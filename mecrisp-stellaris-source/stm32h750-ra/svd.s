@ arm-none-eabi-as equates file for STM32H7x3
@ SVD2GAS Equates Generator, Copyright Terry Porter 2017 "terry@tjporter.com.au" for arm-none-eabi-as 
@ Matthias Koch Complimentary Edition 2017
@ Takes a CMSIS-SVD file plus a hand edited config.xml file as input 
@ Licensed under the GPL, see http://www.gnu.org/licenses/


@=========================== COMP1 ===========================@
.equ COMP1_BASE, 0x58003800 @ (COMP1) 
    .equ COMP1_SR, COMP1_BASE + 0x0 @ (Comparator status register) 
        .equ COMP1_SR_C1VAL, 1 << 0   @ bitWidth 1 (COMP channel 1 output status  bit)  
        .equ COMP1_SR_C2VAL, 1 << 1   @ bitWidth 1 (COMP channel 2 output status  bit)  
        .equ COMP1_SR_C1IF, 1 << 16   @ bitWidth 1 (COMP channel 1 Interrupt  Flag)  
        .equ COMP1_SR_C2IF, 1 << 17   @ bitWidth 1 (COMP channel 2 Interrupt  Flag)  
 
    .equ COMP1_ICFR, COMP1_BASE + 0x4 @ (Comparator interrupt clear flag  register) 
        .equ COMP1_ICFR_CC1IF, 1 << 16   @ bitWidth 1 (Clear COMP channel 1 Interrupt  Flag)  
        .equ COMP1_ICFR_CC2IF, 1 << 17   @ bitWidth 1 (Clear COMP channel 2 Interrupt  Flag)  
 
    .equ COMP1_OR, COMP1_BASE + 0x8 @ (Comparator option register) 
        .equ COMP1_OR_AFOP_Shift, 0   @ bitWidth 11 (Selection of source for alternate  function of output ports)  
        .equ COMP1_OR_OR_Shift, 11   @ bitWidth 21 (Option Register)  
 
    .equ COMP1_CFGR1, COMP1_BASE + 0xC @ (Comparator configuration register  1) 
        .equ COMP1_CFGR1_EN, 1 << 0   @ bitWidth 1 (COMP channel 1 enable bit)  
        .equ COMP1_CFGR1_BRGEN, 1 << 1   @ bitWidth 1 (Scaler bridge enable)  
        .equ COMP1_CFGR1_SCALEN, 1 << 2   @ bitWidth 1 (Voltage scaler enable bit)  
        .equ COMP1_CFGR1_POLARITY, 1 << 3   @ bitWidth 1 (COMP channel 1 polarity selection  bit)  
        .equ COMP1_CFGR1_ITEN, 1 << 6   @ bitWidth 1 (COMP channel 1 interrupt  enable)  
        .equ COMP1_CFGR1_HYST_Shift, 8   @ bitWidth 2 (COMP channel 1 hysteresis selection  bits)  
        .equ COMP1_CFGR1_PWRMODE_Shift, 12   @ bitWidth 2 (Power Mode of the COMP channel  1)  
        .equ COMP1_CFGR1_INMSEL_Shift, 16   @ bitWidth 3 (COMP channel 1 inverting input selection  field)  
        .equ COMP1_CFGR1_INPSEL, 1 << 20   @ bitWidth 1 (COMP channel 1 non-inverting input  selection bit)  
        .equ COMP1_CFGR1_BLANKING_Shift, 24   @ bitWidth 4 (COMP channel 1 blanking source selection  bits)  
        .equ COMP1_CFGR1_LOCK, 1 << 31   @ bitWidth 1 (Lock bit)  
 
    .equ COMP1_CFGR2, COMP1_BASE + 0x10 @ (Comparator configuration register  2) 
        .equ COMP1_CFGR2_EN, 1 << 0   @ bitWidth 1 (COMP channel 1 enable bit)  
        .equ COMP1_CFGR2_BRGEN, 1 << 1   @ bitWidth 1 (Scaler bridge enable)  
        .equ COMP1_CFGR2_SCALEN, 1 << 2   @ bitWidth 1 (Voltage scaler enable bit)  
        .equ COMP1_CFGR2_POLARITY, 1 << 3   @ bitWidth 1 (COMP channel 1 polarity selection  bit)  
        .equ COMP1_CFGR2_WINMODE, 1 << 4   @ bitWidth 1 (Window comparator mode selection  bit)  
        .equ COMP1_CFGR2_ITEN, 1 << 6   @ bitWidth 1 (COMP channel 1 interrupt  enable)  
        .equ COMP1_CFGR2_HYST_Shift, 8   @ bitWidth 2 (COMP channel 1 hysteresis selection  bits)  
        .equ COMP1_CFGR2_PWRMODE_Shift, 12   @ bitWidth 2 (Power Mode of the COMP channel  1)  
        .equ COMP1_CFGR2_INMSEL_Shift, 16   @ bitWidth 3 (COMP channel 1 inverting input selection  field)  
        .equ COMP1_CFGR2_INPSEL, 1 << 20   @ bitWidth 1 (COMP channel 1 non-inverting input  selection bit)  
        .equ COMP1_CFGR2_BLANKING_Shift, 24   @ bitWidth 4 (COMP channel 1 blanking source selection  bits)  
        .equ COMP1_CFGR2_LOCK, 1 << 31   @ bitWidth 1 (Lock bit)  
 

@=========================== CRS ===========================@
.equ CRS_BASE, 0x40008400 @ (CRS) 
    .equ CRS_CR, CRS_BASE + 0x0 @ (CRS control register) 
        .equ CRS_CR_SYNCOKIE, 1 << 0   @ bitWidth 1 (SYNC event OK interrupt  enable)  
        .equ CRS_CR_SYNCWARNIE, 1 << 1   @ bitWidth 1 (SYNC warning interrupt  enable)  
        .equ CRS_CR_ERRIE, 1 << 2   @ bitWidth 1 (Synchronization or trimming error  interrupt enable)  
        .equ CRS_CR_ESYNCIE, 1 << 3   @ bitWidth 1 (Expected SYNC interrupt  enable)  
        .equ CRS_CR_CEN, 1 << 5   @ bitWidth 1 (Frequency error counter enable This bit  enables the oscillator clock for the frequency error  counter. When this bit is set, the CRS_CFGR register  is write-protected and cannot be  modified.)  
        .equ CRS_CR_AUTOTRIMEN, 1 << 6   @ bitWidth 1 (Automatic trimming enable This bit  enables the automatic hardware adjustment of TRIM  bits according to the measured frequency error  between two SYNC events. If this bit is set, the TRIM  bits are read-only. The TRIM value can be adjusted by  hardware by one or two steps at a time, depending on  the measured frequency error value. Refer to  Section7.3.4: Frequency error evaluation and  automatic trimming for more details.)  
        .equ CRS_CR_SWSYNC, 1 << 7   @ bitWidth 1 (Generate software SYNC event This bit is  set by software in order to generate a software SYNC  event. It is automatically cleared by  hardware.)  
        .equ CRS_CR_TRIM_Shift, 8   @ bitWidth 6 (HSI48 oscillator smooth trimming These  bits provide a user-programmable trimming value to  the HSI48 oscillator. They can be programmed to  adjust to variations in voltage and temperature that  influence the frequency of the HSI48. The default  value is 32, which corresponds to the middle of the  trimming interval. The trimming step is around 67 kHz  between two consecutive TRIM steps. A higher TRIM  value corresponds to a higher output frequency. When  the AUTOTRIMEN bit is set, this field is controlled  by hardware and is read-only.)  
 
    .equ CRS_CFGR, CRS_BASE + 0x4 @ (This register can be written only when the  frequency error counter is disabled CEN bit is cleared  in CRS_CR. When the counter is enabled, this register is  write-protected.) 
        .equ CRS_CFGR_RELOAD_Shift, 0   @ bitWidth 16 (Counter reload value RELOAD is the value  to be loaded in the frequency error counter with each  SYNC event. Refer to Section7.3.3: Frequency error  measurement for more details about counter  behavior.)  
        .equ CRS_CFGR_FELIM_Shift, 16   @ bitWidth 8 (Frequency error limit FELIM contains the  value to be used to evaluate the captured frequency  error value latched in the FECAP[15:0] bits of the  CRS_ISR register. Refer to Section7.3.4: Frequency  error evaluation and automatic trimming for more  details about FECAP evaluation.)  
        .equ CRS_CFGR_SYNCDIV_Shift, 24   @ bitWidth 3 (SYNC divider These bits are set and  cleared by software to control the division factor of  the SYNC signal.)  
        .equ CRS_CFGR_SYNCSRC_Shift, 28   @ bitWidth 2 (SYNC signal source selection These bits  are set and cleared by software to select the SYNC  signal source. Note: When using USB LPM Link Power  Management and the device is in Sleep mode, the  periodic USB SOF will not be generated by the host.  No SYNC signal will therefore be provided to the CRS  to calibrate the HSI48 on the run. To guarantee the  required clock precision after waking up from Sleep  mode, the LSE or reference clock on the GPIOs should  be used as SYNC signal.)  
        .equ CRS_CFGR_SYNCPOL, 1 << 31   @ bitWidth 1 (SYNC polarity selection This bit is set  and cleared by software to select the input polarity  for the SYNC signal source.)  
 
    .equ CRS_ISR, CRS_BASE + 0x8 @ (CRS interrupt and status  register) 
        .equ CRS_ISR_SYNCOKF, 1 << 0   @ bitWidth 1 (SYNC event OK flag This flag is set by  hardware when the measured frequency error is smaller  than FELIM * 3. This means that either no adjustment  of the TRIM value is needed or that an adjustment by  one trimming step is enough to compensate the  frequency error. An interrupt is generated if the  SYNCOKIE bit is set in the CRS_CR register. It is  cleared by software by setting the SYNCOKC bit in the  CRS_ICR register.)  
        .equ CRS_ISR_SYNCWARNF, 1 << 1   @ bitWidth 1 (SYNC warning flag This flag is set by  hardware when the measured frequency error is greater  than or equal to FELIM * 3, but smaller than FELIM *  128. This means that to compensate the frequency  error, the TRIM value must be adjusted by two steps  or more. An interrupt is generated if the SYNCWARNIE  bit is set in the CRS_CR register. It is cleared by  software by setting the SYNCWARNC bit in the CRS_ICR  register.)  
        .equ CRS_ISR_ERRF, 1 << 2   @ bitWidth 1 (Error flag This flag is set by hardware  in case of any synchronization or trimming error. It  is the logical OR of the TRIMOVF, SYNCMISS and  SYNCERR bits. An interrupt is generated if the ERRIE  bit is set in the CRS_CR register. It is cleared by  software in reaction to setting the ERRC bit in the  CRS_ICR register, which clears the TRIMOVF, SYNCMISS  and SYNCERR bits.)  
        .equ CRS_ISR_ESYNCF, 1 << 3   @ bitWidth 1 (Expected SYNC flag This flag is set by  hardware when the frequency error counter reached a  zero value. An interrupt is generated if the ESYNCIE  bit is set in the CRS_CR register. It is cleared by  software by setting the ESYNCC bit in the CRS_ICR  register.)  
        .equ CRS_ISR_SYNCERR, 1 << 8   @ bitWidth 1 (SYNC error This flag is set by hardware  when the SYNC pulse arrives before the ESYNC event  and the measured frequency error is greater than or  equal to FELIM * 128. This means that the frequency  error is too big internal frequency too low to be  compensated by adjusting the TRIM value, and that  some other action should be taken. An interrupt is  generated if the ERRIE bit is set in the CRS_CR  register. It is cleared by software by setting the  ERRC bit in the CRS_ICR register.)  
        .equ CRS_ISR_SYNCMISS, 1 << 9   @ bitWidth 1 (SYNC missed This flag is set by hardware  when the frequency error counter reached value FELIM  * 128 and no SYNC was detected, meaning either that a  SYNC pulse was missed or that the frequency error is  too big internal frequency too high to be  compensated by adjusting the TRIM value, and that  some other action should be taken. At this point, the  frequency error counter is stopped waiting for a  next SYNC and an interrupt is generated if the ERRIE  bit is set in the CRS_CR register. It is cleared by  software by setting the ERRC bit in the CRS_ICR  register.)  
        .equ CRS_ISR_TRIMOVF, 1 << 10   @ bitWidth 1 (Trimming overflow or underflow This flag  is set by hardware when the automatic trimming tries  to over- or under-flow the TRIM value. An interrupt  is generated if the ERRIE bit is set in the CRS_CR  register. It is cleared by software by setting the  ERRC bit in the CRS_ICR register.)  
        .equ CRS_ISR_FEDIR, 1 << 15   @ bitWidth 1 (Frequency error direction FEDIR is the  counting direction of the frequency error counter  latched in the time of the last SYNC event. It shows  whether the actual frequency is below or above the  target.)  
        .equ CRS_ISR_FECAP_Shift, 16   @ bitWidth 16 (Frequency error capture FECAP is the  frequency error counter value latched in the time of  the last SYNC event. Refer to Section7.3.4: Frequency  error evaluation and automatic trimming for more  details about FECAP usage.)  
 
    .equ CRS_ICR, CRS_BASE + 0xC @ (CRS interrupt flag clear  register) 
        .equ CRS_ICR_SYNCOKC, 1 << 0   @ bitWidth 1 (SYNC event OK clear flag Writing 1 to  this bit clears the SYNCOKF flag in the CRS_ISR  register.)  
        .equ CRS_ICR_SYNCWARNC, 1 << 1   @ bitWidth 1 (SYNC warning clear flag Writing 1 to  this bit clears the SYNCWARNF flag in the CRS_ISR  register.)  
        .equ CRS_ICR_ERRC, 1 << 2   @ bitWidth 1 (Error clear flag Writing 1 to this bit  clears TRIMOVF, SYNCMISS and SYNCERR bits and  consequently also the ERRF flag in the CRS_ISR  register.)  
        .equ CRS_ICR_ESYNCC, 1 << 3   @ bitWidth 1 (Expected SYNC clear flag Writing 1 to  this bit clears the ESYNCF flag in the CRS_ISR  register.)  
 

@=========================== DAC ===========================@
.equ DAC_BASE, 0x40007400 @ (DAC) 
    .equ DAC_CR, DAC_BASE + 0x0 @ (DAC control register) 
        .equ DAC_CR_EN1, 1 << 0   @ bitWidth 1 (DAC channel1 enable This bit is set and  cleared by software to enable/disable DAC  channel1.)  
        .equ DAC_CR_TEN1, 1 << 1   @ bitWidth 1 (DAC channel1 trigger  enable)  
        .equ DAC_CR_TSEL1_Shift, 2   @ bitWidth 3 (DAC channel1 trigger selection These  bits select the external event used to trigger DAC  channel1. Note: Only used if bit TEN1 = 1 DAC  channel1 trigger enabled.)  
        .equ DAC_CR_WAVE1_Shift, 6   @ bitWidth 2 (DAC channel1 noise/triangle wave  generation enable These bits are set and cleared by  software. Note: Only used if bit TEN1 = 1 DAC  channel1 trigger enabled.)  
        .equ DAC_CR_MAMP1_Shift, 8   @ bitWidth 4 (DAC channel1 mask/amplitude selector  These bits are written by software to select mask in  wave generation mode or amplitude in triangle  generation mode. = 1011: Unmask bits[11:0] of LFSR/  triangle amplitude equal to 4095)  
        .equ DAC_CR_DMAEN1, 1 << 12   @ bitWidth 1 (DAC channel1 DMA enable This bit is set  and cleared by software.)  
        .equ DAC_CR_DMAUDRIE1, 1 << 13   @ bitWidth 1 (DAC channel1 DMA Underrun Interrupt  enable This bit is set and cleared by  software.)  
        .equ DAC_CR_CEN1, 1 << 14   @ bitWidth 1 (DAC Channel 1 calibration enable This  bit is set and cleared by software to enable/disable  DAC channel 1 calibration, it can be written only if  bit EN1=0 into DAC_CR the calibration mode can be  entered/exit only when the DAC channel is disabled  Otherwise, the write operation is  ignored.)  
        .equ DAC_CR_EN2, 1 << 16   @ bitWidth 1 (DAC channel2 enable This bit is set and  cleared by software to enable/disable DAC  channel2.)  
        .equ DAC_CR_TEN2, 1 << 17   @ bitWidth 1 (DAC channel2 trigger  enable)  
        .equ DAC_CR_TSEL2_Shift, 18   @ bitWidth 3 (DAC channel2 trigger selection These  bits select the external event used to trigger DAC  channel2 Note: Only used if bit TEN2 = 1 DAC  channel2 trigger enabled.)  
        .equ DAC_CR_WAVE2_Shift, 22   @ bitWidth 2 (DAC channel2 noise/triangle wave  generation enable These bits are set/reset by  software. 1x: Triangle wave generation enabled Note:  Only used if bit TEN2 = 1 DAC channel2 trigger  enabled)  
        .equ DAC_CR_MAMP2_Shift, 24   @ bitWidth 4 (DAC channel2 mask/amplitude selector  These bits are written by software to select mask in  wave generation mode or amplitude in triangle  generation mode. = 1011: Unmask bits[11:0] of LFSR/  triangle amplitude equal to 4095)  
        .equ DAC_CR_DMAEN2, 1 << 28   @ bitWidth 1 (DAC channel2 DMA enable This bit is set  and cleared by software.)  
        .equ DAC_CR_DMAUDRIE2, 1 << 29   @ bitWidth 1 (DAC channel2 DMA underrun interrupt  enable This bit is set and cleared by  software.)  
        .equ DAC_CR_CEN2, 1 << 30   @ bitWidth 1 (DAC Channel 2 calibration enable This  bit is set and cleared by software to enable/disable  DAC channel 2 calibration, it can be written only if  bit EN2=0 into DAC_CR the calibration mode can be  entered/exit only when the DAC channel is disabled  Otherwise, the write operation is  ignored.)  
 
    .equ DAC_SWTRGR, DAC_BASE + 0x4 @ (DAC software trigger register) 
        .equ DAC_SWTRGR_SWTRIG1, 1 << 0   @ bitWidth 1 (DAC channel1 software trigger This bit  is set by software to trigger the DAC in software  trigger mode. Note: This bit is cleared by hardware  one APB1 clock cycle later once the DAC_DHR1  register value has been loaded into the DAC_DOR1  register.)  
        .equ DAC_SWTRGR_SWTRIG2, 1 << 1   @ bitWidth 1 (DAC channel2 software trigger This bit  is set by software to trigger the DAC in software  trigger mode. Note: This bit is cleared by hardware  one APB1 clock cycle later once the DAC_DHR2  register value has been loaded into the DAC_DOR2  register.)  
 
    .equ DAC_DHR12R1, DAC_BASE + 0x8 @ (DAC channel1 12-bit right-aligned data  holding register) 
        .equ DAC_DHR12R1_DACC1DHR_Shift, 0   @ bitWidth 12 (DAC channel1 12-bit right-aligned data  These bits are written by software which specifies  12-bit data for DAC channel1.)  
 
    .equ DAC_DHR12L1, DAC_BASE + 0xC @ (DAC channel1 12-bit left aligned data  holding register) 
        .equ DAC_DHR12L1_DACC1DHR_Shift, 4   @ bitWidth 12 (DAC channel1 12-bit left-aligned data  These bits are written by software which specifies  12-bit data for DAC channel1.)  
 
    .equ DAC_DHR8R1, DAC_BASE + 0x10 @ (DAC channel1 8-bit right aligned data  holding register) 
        .equ DAC_DHR8R1_DACC1DHR_Shift, 0   @ bitWidth 8 (DAC channel1 8-bit right-aligned data  These bits are written by software which specifies  8-bit data for DAC channel1.)  
 
    .equ DAC_DHR12R2, DAC_BASE + 0x14 @ (DAC channel2 12-bit right aligned data  holding register) 
        .equ DAC_DHR12R2_DACC2DHR_Shift, 0   @ bitWidth 12 (DAC channel2 12-bit right-aligned data  These bits are written by software which specifies  12-bit data for DAC channel2.)  
 
    .equ DAC_DHR12L2, DAC_BASE + 0x18 @ (DAC channel2 12-bit left aligned data  holding register) 
        .equ DAC_DHR12L2_DACC2DHR_Shift, 4   @ bitWidth 12 (DAC channel2 12-bit left-aligned data  These bits are written by software which specify  12-bit data for DAC channel2.)  
 
    .equ DAC_DHR8R2, DAC_BASE + 0x1C @ (DAC channel2 8-bit right-aligned data  holding register) 
        .equ DAC_DHR8R2_DACC2DHR_Shift, 0   @ bitWidth 8 (DAC channel2 8-bit right-aligned data  These bits are written by software which specifies  8-bit data for DAC channel2.)  
 
    .equ DAC_DHR12RD, DAC_BASE + 0x20 @ (Dual DAC 12-bit right-aligned data holding  register) 
        .equ DAC_DHR12RD_DACC1DHR_Shift, 0   @ bitWidth 12 (DAC channel1 12-bit right-aligned data  These bits are written by software which specifies  12-bit data for DAC channel1.)  
        .equ DAC_DHR12RD_DACC2DHR_Shift, 16   @ bitWidth 12 (DAC channel2 12-bit right-aligned data  These bits are written by software which specifies  12-bit data for DAC channel2.)  
 
    .equ DAC_DHR12LD, DAC_BASE + 0x24 @ (DUAL DAC 12-bit left aligned data holding  register) 
        .equ DAC_DHR12LD_DACC1DHR_Shift, 4   @ bitWidth 12 (DAC channel1 12-bit left-aligned data  These bits are written by software which specifies  12-bit data for DAC channel1.)  
        .equ DAC_DHR12LD_DACC2DHR_Shift, 20   @ bitWidth 12 (DAC channel2 12-bit left-aligned data  These bits are written by software which specifies  12-bit data for DAC channel2.)  
 
    .equ DAC_DHR8RD, DAC_BASE + 0x28 @ (DUAL DAC 8-bit right aligned data holding  register) 
        .equ DAC_DHR8RD_DACC1DHR_Shift, 0   @ bitWidth 8 (DAC channel1 8-bit right-aligned data  These bits are written by software which specifies  8-bit data for DAC channel1.)  
        .equ DAC_DHR8RD_DACC2DHR_Shift, 8   @ bitWidth 8 (DAC channel2 8-bit right-aligned data  These bits are written by software which specifies  8-bit data for DAC channel2.)  
 
    .equ DAC_DOR1, DAC_BASE + 0x2C @ (DAC channel1 data output  register) 
        .equ DAC_DOR1_DACC1DOR_Shift, 0   @ bitWidth 12 (DAC channel1 data output These bits are  read-only, they contain data output for DAC  channel1.)  
 
    .equ DAC_DOR2, DAC_BASE + 0x30 @ (DAC channel2 data output  register) 
        .equ DAC_DOR2_DACC2DOR_Shift, 0   @ bitWidth 12 (DAC channel2 data output These bits are  read-only, they contain data output for DAC  channel2.)  
 
    .equ DAC_SR, DAC_BASE + 0x34 @ (DAC status register) 
        .equ DAC_SR_DMAUDR1, 1 << 13   @ bitWidth 1 (DAC channel1 DMA underrun flag This bit  is set by hardware and cleared by software by  writing it to 1.)  
        .equ DAC_SR_CAL_FLAG1, 1 << 14   @ bitWidth 1 (DAC Channel 1 calibration offset status  This bit is set and cleared by hardware)  
        .equ DAC_SR_BWST1, 1 << 15   @ bitWidth 1 (DAC Channel 1 busy writing sample time  flag This bit is systematically set just after Sample  & Hold mode enable and is set each time the  software writes the register DAC_SHSR1, It is cleared  by hardware when the write operation of DAC_SHSR1 is  complete. It takes about 3LSI periods of  synchronization.)  
        .equ DAC_SR_DMAUDR2, 1 << 29   @ bitWidth 1 (DAC channel2 DMA underrun flag This bit  is set by hardware and cleared by software by  writing it to 1.)  
        .equ DAC_SR_CAL_FLAG2, 1 << 30   @ bitWidth 1 (DAC Channel 2 calibration offset status  This bit is set and cleared by hardware)  
        .equ DAC_SR_BWST2, 1 << 31   @ bitWidth 1 (DAC Channel 2 busy writing sample time  flag This bit is systematically set just after Sample  & Hold mode enable and is set each time the  software writes the register DAC_SHSR2, It is cleared  by hardware when the write operation of DAC_SHSR2 is  complete. It takes about 3 LSI periods of  synchronization.)  
 
    .equ DAC_CCR, DAC_BASE + 0x38 @ (DAC calibration control  register) 
        .equ DAC_CCR_OTRIM1_Shift, 0   @ bitWidth 5 (DAC Channel 1 offset trimming  value)  
        .equ DAC_CCR_OTRIM2_Shift, 16   @ bitWidth 5 (DAC Channel 2 offset trimming  value)  
 
    .equ DAC_MCR, DAC_BASE + 0x3C @ (DAC mode control register) 
        .equ DAC_MCR_MODE1_Shift, 0   @ bitWidth 3 (DAC Channel 1 mode These bits can be  written only when the DAC is disabled and not in the  calibration mode when bit EN1=0 and bit CEN1 =0 in  the DAC_CR register. If EN1=1 or CEN1 =1 the write  operation is ignored. They can be set and cleared by  software to select the DAC Channel 1 mode: DAC  Channel 1 in normal Mode DAC Channel 1 in sample  &amp; hold mode)  
        .equ DAC_MCR_MODE2_Shift, 16   @ bitWidth 3 (DAC Channel 2 mode These bits can be  written only when the DAC is disabled and not in the  calibration mode when bit EN2=0 and bit CEN2 =0 in  the DAC_CR register. If EN2=1 or CEN2 =1 the write  operation is ignored. They can be set and cleared by  software to select the DAC Channel 2 mode: DAC  Channel 2 in normal Mode DAC Channel 2 in sample  &amp; hold mode)  
 
    .equ DAC_SHSR1, DAC_BASE + 0x40 @ (DAC Sample and Hold sample time register  1) 
        .equ DAC_SHSR1_TSAMPLE1_Shift, 0   @ bitWidth 10 (DAC Channel 1 sample Time only valid in  sample &amp; hold mode These bits can be written  when the DAC channel1 is disabled or also during  normal operation. in the latter case, the write can  be done only when BWSTx of DAC_SR register is low, If  BWSTx=1, the write operation is  ignored.)  
 
    .equ DAC_SHSR2, DAC_BASE + 0x44 @ (DAC Sample and Hold sample time register  2) 
        .equ DAC_SHSR2_TSAMPLE2_Shift, 0   @ bitWidth 10 (DAC Channel 2 sample Time only valid in  sample &amp; hold mode These bits can be written  when the DAC channel2 is disabled or also during  normal operation. in the latter case, the write can  be done only when BWSTx of DAC_SR register is low, if  BWSTx=1, the write operation is  ignored.)  
 
    .equ DAC_SHHR, DAC_BASE + 0x48 @ (DAC Sample and Hold hold time  register) 
        .equ DAC_SHHR_THOLD1_Shift, 0   @ bitWidth 10 (DAC Channel 1 hold Time only valid in  sample &amp; hold mode Hold time= THOLD[9:0] x  T LSI)  
        .equ DAC_SHHR_THOLD2_Shift, 16   @ bitWidth 10 (DAC Channel 2 hold time only valid in  sample &amp; hold mode. Hold time= THOLD[9:0]  x T LSI)  
 
    .equ DAC_SHRR, DAC_BASE + 0x4C @ (DAC Sample and Hold refresh time  register) 
        .equ DAC_SHRR_TREFRESH1_Shift, 0   @ bitWidth 8 (DAC Channel 1 refresh Time only valid  in sample &amp; hold mode Refresh time=  TREFRESH[7:0] x T LSI)  
        .equ DAC_SHRR_TREFRESH2_Shift, 16   @ bitWidth 8 (DAC Channel 2 refresh Time only valid  in sample &amp; hold mode Refresh time=  TREFRESH[7:0] x T LSI)  
 

@=========================== BDMA ===========================@
.equ BDMA_BASE, 0x58025400 @ (BDMA) 
    .equ BDMA_ISR, BDMA_BASE + 0x0 @ (DMA interrupt status register) 
        .equ BDMA_ISR_GIF1, 1 << 0   @ bitWidth 1 (Channel x global interrupt flag x =  1..8 This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_TCIF1, 1 << 1   @ bitWidth 1 (Channel x transfer complete flag x =  1..8 This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_HTIF1, 1 << 2   @ bitWidth 1 (Channel x half transfer flag x = 1..8  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_TEIF1, 1 << 3   @ bitWidth 1 (Channel x transfer error flag x = 1..8  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_GIF2, 1 << 4   @ bitWidth 1 (Channel x global interrupt flag x =  1..8 This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_TCIF2, 1 << 5   @ bitWidth 1 (Channel x transfer complete flag x =  1..8 This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_HTIF2, 1 << 6   @ bitWidth 1 (Channel x half transfer flag x = 1..8  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_TEIF2, 1 << 7   @ bitWidth 1 (Channel x transfer error flag x = 1..8  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_GIF3, 1 << 8   @ bitWidth 1 (Channel x global interrupt flag x =  1..8 This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_TCIF3, 1 << 9   @ bitWidth 1 (Channel x transfer complete flag x =  1..8 This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_HTIF3, 1 << 10   @ bitWidth 1 (Channel x half transfer flag x = 1..8  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_TEIF3, 1 << 11   @ bitWidth 1 (Channel x transfer error flag x = 1..8  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_GIF4, 1 << 12   @ bitWidth 1 (Channel x global interrupt flag x =  1..8 This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_TCIF4, 1 << 13   @ bitWidth 1 (Channel x transfer complete flag x =  1..8 This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_HTIF4, 1 << 14   @ bitWidth 1 (Channel x half transfer flag x = 1..8  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_TEIF4, 1 << 15   @ bitWidth 1 (Channel x transfer error flag x = 1..8  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_GIF5, 1 << 16   @ bitWidth 1 (Channel x global interrupt flag x =  1..8 This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_TCIF5, 1 << 17   @ bitWidth 1 (Channel x transfer complete flag x =  1..8 This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_HTIF5, 1 << 18   @ bitWidth 1 (Channel x half transfer flag x = 1..8  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_TEIF5, 1 << 19   @ bitWidth 1 (Channel x transfer error flag x = 1..8  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_GIF6, 1 << 20   @ bitWidth 1 (Channel x global interrupt flag x =  1..8 This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_TCIF6, 1 << 21   @ bitWidth 1 (Channel x transfer complete flag x =  1..8 This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_HTIF6, 1 << 22   @ bitWidth 1 (Channel x half transfer flag x = 1..8  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_TEIF6, 1 << 23   @ bitWidth 1 (Channel x transfer error flag x = 1..8  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_GIF7, 1 << 24   @ bitWidth 1 (Channel x global interrupt flag x =  1..8 This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_TCIF7, 1 << 25   @ bitWidth 1 (Channel x transfer complete flag x =  1..8 This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_HTIF7, 1 << 26   @ bitWidth 1 (Channel x half transfer flag x = 1..8  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_TEIF7, 1 << 27   @ bitWidth 1 (Channel x transfer error flag x = 1..8  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_GIF8, 1 << 28   @ bitWidth 1 (Channel x global interrupt flag x =  1..8 This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_TCIF8, 1 << 29   @ bitWidth 1 (Channel x transfer complete flag x =  1..8 This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_HTIF8, 1 << 30   @ bitWidth 1 (Channel x half transfer flag x = 1..8  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
        .equ BDMA_ISR_TEIF8, 1 << 31   @ bitWidth 1 (Channel x transfer error flag x = 1..8  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCR register.)  
 
    .equ BDMA_IFCR, BDMA_BASE + 0x4 @ (DMA interrupt flag clear  register) 
        .equ BDMA_IFCR_CGIF1, 1 << 0   @ bitWidth 1 (Channel x global interrupt clear This  bit is set and cleared by software.)  
        .equ BDMA_IFCR_CTCIF1, 1 << 1   @ bitWidth 1 (Channel x transfer complete clear This  bit is set and cleared by software.)  
        .equ BDMA_IFCR_CHTIF1, 1 << 2   @ bitWidth 1 (Channel x half transfer clear This bit  is set and cleared by software.)  
        .equ BDMA_IFCR_CTEIF1, 1 << 3   @ bitWidth 1 (Channel x transfer error clear This bit  is set and cleared by software.)  
        .equ BDMA_IFCR_CGIF2, 1 << 4   @ bitWidth 1 (Channel x global interrupt clear This  bit is set and cleared by software.)  
        .equ BDMA_IFCR_CTCIF2, 1 << 5   @ bitWidth 1 (Channel x transfer complete clear This  bit is set and cleared by software.)  
        .equ BDMA_IFCR_CHTIF2, 1 << 6   @ bitWidth 1 (Channel x half transfer clear This bit  is set and cleared by software.)  
        .equ BDMA_IFCR_CTEIF2, 1 << 7   @ bitWidth 1 (Channel x transfer error clear This bit  is set and cleared by software.)  
        .equ BDMA_IFCR_CGIF3, 1 << 8   @ bitWidth 1 (Channel x global interrupt clear This  bit is set and cleared by software.)  
        .equ BDMA_IFCR_CTCIF3, 1 << 9   @ bitWidth 1 (Channel x transfer complete clear This  bit is set and cleared by software.)  
        .equ BDMA_IFCR_CHTIF3, 1 << 10   @ bitWidth 1 (Channel x half transfer clear This bit  is set and cleared by software.)  
        .equ BDMA_IFCR_CTEIF3, 1 << 11   @ bitWidth 1 (Channel x transfer error clear This bit  is set and cleared by software.)  
        .equ BDMA_IFCR_CGIF4, 1 << 12   @ bitWidth 1 (Channel x global interrupt clear This  bit is set and cleared by software.)  
        .equ BDMA_IFCR_CTCIF4, 1 << 13   @ bitWidth 1 (Channel x transfer complete clear This  bit is set and cleared by software.)  
        .equ BDMA_IFCR_CHTIF4, 1 << 14   @ bitWidth 1 (Channel x half transfer clear This bit  is set and cleared by software.)  
        .equ BDMA_IFCR_CTEIF4, 1 << 15   @ bitWidth 1 (Channel x transfer error clear This bit  is set and cleared by software.)  
        .equ BDMA_IFCR_CGIF5, 1 << 16   @ bitWidth 1 (Channel x global interrupt clear This  bit is set and cleared by software.)  
        .equ BDMA_IFCR_CTCIF5, 1 << 17   @ bitWidth 1 (Channel x transfer complete clear This  bit is set and cleared by software.)  
        .equ BDMA_IFCR_CHTIF5, 1 << 18   @ bitWidth 1 (Channel x half transfer clear This bit  is set and cleared by software.)  
        .equ BDMA_IFCR_CTEIF5, 1 << 19   @ bitWidth 1 (Channel x transfer error clear This bit  is set and cleared by software.)  
        .equ BDMA_IFCR_CGIF6, 1 << 20   @ bitWidth 1 (Channel x global interrupt clear This  bit is set and cleared by software.)  
        .equ BDMA_IFCR_CTCIF6, 1 << 21   @ bitWidth 1 (Channel x transfer complete clear This  bit is set and cleared by software.)  
        .equ BDMA_IFCR_CHTIF6, 1 << 22   @ bitWidth 1 (Channel x half transfer clear This bit  is set and cleared by software.)  
        .equ BDMA_IFCR_CTEIF6, 1 << 23   @ bitWidth 1 (Channel x transfer error clear This bit  is set and cleared by software.)  
        .equ BDMA_IFCR_CGIF7, 1 << 24   @ bitWidth 1 (Channel x global interrupt clear This  bit is set and cleared by software.)  
        .equ BDMA_IFCR_CTCIF7, 1 << 25   @ bitWidth 1 (Channel x transfer complete clear This  bit is set and cleared by software.)  
        .equ BDMA_IFCR_CHTIF7, 1 << 26   @ bitWidth 1 (Channel x half transfer clear This bit  is set and cleared by software.)  
        .equ BDMA_IFCR_CTEIF7, 1 << 27   @ bitWidth 1 (Channel x transfer error clear This bit  is set and cleared by software.)  
        .equ BDMA_IFCR_CGIF8, 1 << 28   @ bitWidth 1 (Channel x global interrupt clear This  bit is set and cleared by software.)  
        .equ BDMA_IFCR_CTCIF8, 1 << 29   @ bitWidth 1 (Channel x transfer complete clear This  bit is set and cleared by software.)  
        .equ BDMA_IFCR_CHTIF8, 1 << 30   @ bitWidth 1 (Channel x half transfer clear This bit  is set and cleared by software.)  
        .equ BDMA_IFCR_CTEIF8, 1 << 31   @ bitWidth 1 (Channel x transfer error clear This bit  is set and cleared by software.)  
 
    .equ BDMA_CCR1, BDMA_BASE + 0x8 @ (DMA channel x configuration  register) 
        .equ BDMA_CCR1_EN, 1 << 0   @ bitWidth 1 (Channel enable This bit is set and  cleared by software.)  
        .equ BDMA_CCR1_TCIE, 1 << 1   @ bitWidth 1 (Transfer complete interrupt enable This  bit is set and cleared by software.)  
        .equ BDMA_CCR1_HTIE, 1 << 2   @ bitWidth 1 (Half transfer interrupt enable This bit  is set and cleared by software.)  
        .equ BDMA_CCR1_TEIE, 1 << 3   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ BDMA_CCR1_DIR, 1 << 4   @ bitWidth 1 (Data transfer direction This bit is set  and cleared by software.)  
        .equ BDMA_CCR1_CIRC, 1 << 5   @ bitWidth 1 (Circular mode This bit is set and  cleared by software.)  
        .equ BDMA_CCR1_PINC, 1 << 6   @ bitWidth 1 (Peripheral increment mode This bit is  set and cleared by software.)  
        .equ BDMA_CCR1_MINC, 1 << 7   @ bitWidth 1 (Memory increment mode This bit is set  and cleared by software.)  
        .equ BDMA_CCR1_PSIZE_Shift, 8   @ bitWidth 2 (Peripheral size These bits are set and  cleared by software.)  
        .equ BDMA_CCR1_MSIZE_Shift, 10   @ bitWidth 2 (Memory size These bits are set and  cleared by software.)  
        .equ BDMA_CCR1_PL_Shift, 12   @ bitWidth 2 (Channel priority level These bits are  set and cleared by software.)  
        .equ BDMA_CCR1_MEM2MEM, 1 << 14   @ bitWidth 1 (Memory to memory mode This bit is set  and cleared by software.)  
 
    .equ BDMA_CNDTR1, BDMA_BASE + 0xC @ (DMA channel x number of data  register) 
        .equ BDMA_CNDTR1_NDT_Shift, 0   @ bitWidth 16 (Number of data to transfer Number of  data to be transferred 0 up to 65535. This register  can only be written when the channel is disabled.  Once the channel is enabled, this register is  read-only, indicating the remaining bytes to be  transmitted. This register decrements after each DMA  transfer. Once the transfer is completed, this  register can either stay at zero or be reloaded  automatically by the value previously programmed if  the channel is configured in auto-reload mode. If  this register is zero, no transaction can be served  whether the channel is enabled or not.)  
 
    .equ BDMA_CPAR1, BDMA_BASE + 0x10 @ (This register must not be written when the  channel is enabled.) 
        .equ BDMA_CPAR1_PA_Shift, 0   @ bitWidth 32 (Peripheral address Base address of the  peripheral data register from/to which the data will  be read/written. When PSIZE is 01 16-bit, the PA[0]  bit is ignored. Access is automatically aligned to a  half-word address. When PSIZE is 10 32-bit, PA[1:0]  are ignored. Access is automatically aligned to a  word address.)  
 
    .equ BDMA_CMAR1, BDMA_BASE + 0x14 @ (This register must not be written when the  channel is enabled.) 
        .equ BDMA_CMAR1_MA_Shift, 0   @ bitWidth 32 (Memory address Base address of the  memory area from/to which the data will be  read/written. When MSIZE is 01 16-bit, the MA[0]  bit is ignored. Access is automatically aligned to a  half-word address. When MSIZE is 10 32-bit, MA[1:0]  are ignored. Access is automatically aligned to a  word address.)  
 
    .equ BDMA_CCR2, BDMA_BASE + 0x1C @ (DMA channel x configuration  register) 
        .equ BDMA_CCR2_EN, 1 << 0   @ bitWidth 1 (Channel enable This bit is set and  cleared by software.)  
        .equ BDMA_CCR2_TCIE, 1 << 1   @ bitWidth 1 (Transfer complete interrupt enable This  bit is set and cleared by software.)  
        .equ BDMA_CCR2_HTIE, 1 << 2   @ bitWidth 1 (Half transfer interrupt enable This bit  is set and cleared by software.)  
        .equ BDMA_CCR2_TEIE, 1 << 3   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ BDMA_CCR2_DIR, 1 << 4   @ bitWidth 1 (Data transfer direction This bit is set  and cleared by software.)  
        .equ BDMA_CCR2_CIRC, 1 << 5   @ bitWidth 1 (Circular mode This bit is set and  cleared by software.)  
        .equ BDMA_CCR2_PINC, 1 << 6   @ bitWidth 1 (Peripheral increment mode This bit is  set and cleared by software.)  
        .equ BDMA_CCR2_MINC, 1 << 7   @ bitWidth 1 (Memory increment mode This bit is set  and cleared by software.)  
        .equ BDMA_CCR2_PSIZE_Shift, 8   @ bitWidth 2 (Peripheral size These bits are set and  cleared by software.)  
        .equ BDMA_CCR2_MSIZE_Shift, 10   @ bitWidth 2 (Memory size These bits are set and  cleared by software.)  
        .equ BDMA_CCR2_PL_Shift, 12   @ bitWidth 2 (Channel priority level These bits are  set and cleared by software.)  
        .equ BDMA_CCR2_MEM2MEM, 1 << 14   @ bitWidth 1 (Memory to memory mode This bit is set  and cleared by software.)  
 
    .equ BDMA_CNDTR2, BDMA_BASE + 0x20 @ (DMA channel x number of data  register) 
        .equ BDMA_CNDTR2_NDT_Shift, 0   @ bitWidth 16 (Number of data to transfer Number of  data to be transferred 0 up to 65535. This register  can only be written when the channel is disabled.  Once the channel is enabled, this register is  read-only, indicating the remaining bytes to be  transmitted. This register decrements after each DMA  transfer. Once the transfer is completed, this  register can either stay at zero or be reloaded  automatically by the value previously programmed if  the channel is configured in auto-reload mode. If  this register is zero, no transaction can be served  whether the channel is enabled or not.)  
 
    .equ BDMA_CPAR2, BDMA_BASE + 0x24 @ (This register must not be written when the  channel is enabled.) 
        .equ BDMA_CPAR2_PA_Shift, 0   @ bitWidth 32 (Peripheral address Base address of the  peripheral data register from/to which the data will  be read/written. When PSIZE is 01 16-bit, the PA[0]  bit is ignored. Access is automatically aligned to a  half-word address. When PSIZE is 10 32-bit, PA[1:0]  are ignored. Access is automatically aligned to a  word address.)  
 
    .equ BDMA_CMAR2, BDMA_BASE + 0x28 @ (This register must not be written when the  channel is enabled.) 
        .equ BDMA_CMAR2_MA_Shift, 0   @ bitWidth 32 (Memory address Base address of the  memory area from/to which the data will be  read/written. When MSIZE is 01 16-bit, the MA[0]  bit is ignored. Access is automatically aligned to a  half-word address. When MSIZE is 10 32-bit, MA[1:0]  are ignored. Access is automatically aligned to a  word address.)  
 
    .equ BDMA_CCR3, BDMA_BASE + 0x30 @ (DMA channel x configuration  register) 
        .equ BDMA_CCR3_EN, 1 << 0   @ bitWidth 1 (Channel enable This bit is set and  cleared by software.)  
        .equ BDMA_CCR3_TCIE, 1 << 1   @ bitWidth 1 (Transfer complete interrupt enable This  bit is set and cleared by software.)  
        .equ BDMA_CCR3_HTIE, 1 << 2   @ bitWidth 1 (Half transfer interrupt enable This bit  is set and cleared by software.)  
        .equ BDMA_CCR3_TEIE, 1 << 3   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ BDMA_CCR3_DIR, 1 << 4   @ bitWidth 1 (Data transfer direction This bit is set  and cleared by software.)  
        .equ BDMA_CCR3_CIRC, 1 << 5   @ bitWidth 1 (Circular mode This bit is set and  cleared by software.)  
        .equ BDMA_CCR3_PINC, 1 << 6   @ bitWidth 1 (Peripheral increment mode This bit is  set and cleared by software.)  
        .equ BDMA_CCR3_MINC, 1 << 7   @ bitWidth 1 (Memory increment mode This bit is set  and cleared by software.)  
        .equ BDMA_CCR3_PSIZE_Shift, 8   @ bitWidth 2 (Peripheral size These bits are set and  cleared by software.)  
        .equ BDMA_CCR3_MSIZE_Shift, 10   @ bitWidth 2 (Memory size These bits are set and  cleared by software.)  
        .equ BDMA_CCR3_PL_Shift, 12   @ bitWidth 2 (Channel priority level These bits are  set and cleared by software.)  
        .equ BDMA_CCR3_MEM2MEM, 1 << 14   @ bitWidth 1 (Memory to memory mode This bit is set  and cleared by software.)  
 
    .equ BDMA_CNDTR3, BDMA_BASE + 0x34 @ (DMA channel x number of data  register) 
        .equ BDMA_CNDTR3_NDT_Shift, 0   @ bitWidth 16 (Number of data to transfer Number of  data to be transferred 0 up to 65535. This register  can only be written when the channel is disabled.  Once the channel is enabled, this register is  read-only, indicating the remaining bytes to be  transmitted. This register decrements after each DMA  transfer. Once the transfer is completed, this  register can either stay at zero or be reloaded  automatically by the value previously programmed if  the channel is configured in auto-reload mode. If  this register is zero, no transaction can be served  whether the channel is enabled or not.)  
 
    .equ BDMA_CPAR3, BDMA_BASE + 0x38 @ (This register must not be written when the  channel is enabled.) 
        .equ BDMA_CPAR3_PA_Shift, 0   @ bitWidth 32 (Peripheral address Base address of the  peripheral data register from/to which the data will  be read/written. When PSIZE is 01 16-bit, the PA[0]  bit is ignored. Access is automatically aligned to a  half-word address. When PSIZE is 10 32-bit, PA[1:0]  are ignored. Access is automatically aligned to a  word address.)  
 
    .equ BDMA_CMAR3, BDMA_BASE + 0x3C @ (This register must not be written when the  channel is enabled.) 
        .equ BDMA_CMAR3_MA_Shift, 0   @ bitWidth 32 (Memory address Base address of the  memory area from/to which the data will be  read/written. When MSIZE is 01 16-bit, the MA[0]  bit is ignored. Access is automatically aligned to a  half-word address. When MSIZE is 10 32-bit, MA[1:0]  are ignored. Access is automatically aligned to a  word address.)  
 
    .equ BDMA_CCR4, BDMA_BASE + 0x44 @ (DMA channel x configuration  register) 
        .equ BDMA_CCR4_EN, 1 << 0   @ bitWidth 1 (Channel enable This bit is set and  cleared by software.)  
        .equ BDMA_CCR4_TCIE, 1 << 1   @ bitWidth 1 (Transfer complete interrupt enable This  bit is set and cleared by software.)  
        .equ BDMA_CCR4_HTIE, 1 << 2   @ bitWidth 1 (Half transfer interrupt enable This bit  is set and cleared by software.)  
        .equ BDMA_CCR4_TEIE, 1 << 3   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ BDMA_CCR4_DIR, 1 << 4   @ bitWidth 1 (Data transfer direction This bit is set  and cleared by software.)  
        .equ BDMA_CCR4_CIRC, 1 << 5   @ bitWidth 1 (Circular mode This bit is set and  cleared by software.)  
        .equ BDMA_CCR4_PINC, 1 << 6   @ bitWidth 1 (Peripheral increment mode This bit is  set and cleared by software.)  
        .equ BDMA_CCR4_MINC, 1 << 7   @ bitWidth 1 (Memory increment mode This bit is set  and cleared by software.)  
        .equ BDMA_CCR4_PSIZE_Shift, 8   @ bitWidth 2 (Peripheral size These bits are set and  cleared by software.)  
        .equ BDMA_CCR4_MSIZE_Shift, 10   @ bitWidth 2 (Memory size These bits are set and  cleared by software.)  
        .equ BDMA_CCR4_PL_Shift, 12   @ bitWidth 2 (Channel priority level These bits are  set and cleared by software.)  
        .equ BDMA_CCR4_MEM2MEM, 1 << 14   @ bitWidth 1 (Memory to memory mode This bit is set  and cleared by software.)  
 
    .equ BDMA_CNDTR4, BDMA_BASE + 0x48 @ (DMA channel x number of data  register) 
        .equ BDMA_CNDTR4_NDT_Shift, 0   @ bitWidth 16 (Number of data to transfer Number of  data to be transferred 0 up to 65535. This register  can only be written when the channel is disabled.  Once the channel is enabled, this register is  read-only, indicating the remaining bytes to be  transmitted. This register decrements after each DMA  transfer. Once the transfer is completed, this  register can either stay at zero or be reloaded  automatically by the value previously programmed if  the channel is configured in auto-reload mode. If  this register is zero, no transaction can be served  whether the channel is enabled or not.)  
 
    .equ BDMA_CPAR4, BDMA_BASE + 0x4C @ (This register must not be written when the  channel is enabled.) 
        .equ BDMA_CPAR4_PA_Shift, 0   @ bitWidth 32 (Peripheral address Base address of the  peripheral data register from/to which the data will  be read/written. When PSIZE is 01 16-bit, the PA[0]  bit is ignored. Access is automatically aligned to a  half-word address. When PSIZE is 10 32-bit, PA[1:0]  are ignored. Access is automatically aligned to a  word address.)  
 
    .equ BDMA_CMAR4, BDMA_BASE + 0x50 @ (This register must not be written when the  channel is enabled.) 
        .equ BDMA_CMAR4_MA_Shift, 0   @ bitWidth 32 (Memory address Base address of the  memory area from/to which the data will be  read/written. When MSIZE is 01 16-bit, the MA[0]  bit is ignored. Access is automatically aligned to a  half-word address. When MSIZE is 10 32-bit, MA[1:0]  are ignored. Access is automatically aligned to a  word address.)  
 
    .equ BDMA_CCR5, BDMA_BASE + 0x58 @ (DMA channel x configuration  register) 
        .equ BDMA_CCR5_EN, 1 << 0   @ bitWidth 1 (Channel enable This bit is set and  cleared by software.)  
        .equ BDMA_CCR5_TCIE, 1 << 1   @ bitWidth 1 (Transfer complete interrupt enable This  bit is set and cleared by software.)  
        .equ BDMA_CCR5_HTIE, 1 << 2   @ bitWidth 1 (Half transfer interrupt enable This bit  is set and cleared by software.)  
        .equ BDMA_CCR5_TEIE, 1 << 3   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ BDMA_CCR5_DIR, 1 << 4   @ bitWidth 1 (Data transfer direction This bit is set  and cleared by software.)  
        .equ BDMA_CCR5_CIRC, 1 << 5   @ bitWidth 1 (Circular mode This bit is set and  cleared by software.)  
        .equ BDMA_CCR5_PINC, 1 << 6   @ bitWidth 1 (Peripheral increment mode This bit is  set and cleared by software.)  
        .equ BDMA_CCR5_MINC, 1 << 7   @ bitWidth 1 (Memory increment mode This bit is set  and cleared by software.)  
        .equ BDMA_CCR5_PSIZE_Shift, 8   @ bitWidth 2 (Peripheral size These bits are set and  cleared by software.)  
        .equ BDMA_CCR5_MSIZE_Shift, 10   @ bitWidth 2 (Memory size These bits are set and  cleared by software.)  
        .equ BDMA_CCR5_PL_Shift, 12   @ bitWidth 2 (Channel priority level These bits are  set and cleared by software.)  
        .equ BDMA_CCR5_MEM2MEM, 1 << 14   @ bitWidth 1 (Memory to memory mode This bit is set  and cleared by software.)  
 
    .equ BDMA_CNDTR5, BDMA_BASE + 0x5C @ (DMA channel x number of data  register) 
        .equ BDMA_CNDTR5_NDT_Shift, 0   @ bitWidth 16 (Number of data to transfer Number of  data to be transferred 0 up to 65535. This register  can only be written when the channel is disabled.  Once the channel is enabled, this register is  read-only, indicating the remaining bytes to be  transmitted. This register decrements after each DMA  transfer. Once the transfer is completed, this  register can either stay at zero or be reloaded  automatically by the value previously programmed if  the channel is configured in auto-reload mode. If  this register is zero, no transaction can be served  whether the channel is enabled or not.)  
 
    .equ BDMA_CPAR5, BDMA_BASE + 0x60 @ (This register must not be written when the  channel is enabled.) 
        .equ BDMA_CPAR5_PA_Shift, 0   @ bitWidth 32 (Peripheral address Base address of the  peripheral data register from/to which the data will  be read/written. When PSIZE is 01 16-bit, the PA[0]  bit is ignored. Access is automatically aligned to a  half-word address. When PSIZE is 10 32-bit, PA[1:0]  are ignored. Access is automatically aligned to a  word address.)  
 
    .equ BDMA_CMAR5, BDMA_BASE + 0x64 @ (This register must not be written when the  channel is enabled.) 
        .equ BDMA_CMAR5_MA_Shift, 0   @ bitWidth 32 (Memory address Base address of the  memory area from/to which the data will be  read/written. When MSIZE is 01 16-bit, the MA[0]  bit is ignored. Access is automatically aligned to a  half-word address. When MSIZE is 10 32-bit, MA[1:0]  are ignored. Access is automatically aligned to a  word address.)  
 
    .equ BDMA_CCR6, BDMA_BASE + 0x6C @ (DMA channel x configuration  register) 
        .equ BDMA_CCR6_EN, 1 << 0   @ bitWidth 1 (Channel enable This bit is set and  cleared by software.)  
        .equ BDMA_CCR6_TCIE, 1 << 1   @ bitWidth 1 (Transfer complete interrupt enable This  bit is set and cleared by software.)  
        .equ BDMA_CCR6_HTIE, 1 << 2   @ bitWidth 1 (Half transfer interrupt enable This bit  is set and cleared by software.)  
        .equ BDMA_CCR6_TEIE, 1 << 3   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ BDMA_CCR6_DIR, 1 << 4   @ bitWidth 1 (Data transfer direction This bit is set  and cleared by software.)  
        .equ BDMA_CCR6_CIRC, 1 << 5   @ bitWidth 1 (Circular mode This bit is set and  cleared by software.)  
        .equ BDMA_CCR6_PINC, 1 << 6   @ bitWidth 1 (Peripheral increment mode This bit is  set and cleared by software.)  
        .equ BDMA_CCR6_MINC, 1 << 7   @ bitWidth 1 (Memory increment mode This bit is set  and cleared by software.)  
        .equ BDMA_CCR6_PSIZE_Shift, 8   @ bitWidth 2 (Peripheral size These bits are set and  cleared by software.)  
        .equ BDMA_CCR6_MSIZE_Shift, 10   @ bitWidth 2 (Memory size These bits are set and  cleared by software.)  
        .equ BDMA_CCR6_PL_Shift, 12   @ bitWidth 2 (Channel priority level These bits are  set and cleared by software.)  
        .equ BDMA_CCR6_MEM2MEM, 1 << 14   @ bitWidth 1 (Memory to memory mode This bit is set  and cleared by software.)  
 
    .equ BDMA_CNDTR6, BDMA_BASE + 0x70 @ (DMA channel x number of data  register) 
        .equ BDMA_CNDTR6_NDT_Shift, 0   @ bitWidth 16 (Number of data to transfer Number of  data to be transferred 0 up to 65535. This register  can only be written when the channel is disabled.  Once the channel is enabled, this register is  read-only, indicating the remaining bytes to be  transmitted. This register decrements after each DMA  transfer. Once the transfer is completed, this  register can either stay at zero or be reloaded  automatically by the value previously programmed if  the channel is configured in auto-reload mode. If  this register is zero, no transaction can be served  whether the channel is enabled or not.)  
 
    .equ BDMA_CPAR6, BDMA_BASE + 0x74 @ (This register must not be written when the  channel is enabled.) 
        .equ BDMA_CPAR6_PA_Shift, 0   @ bitWidth 32 (Peripheral address Base address of the  peripheral data register from/to which the data will  be read/written. When PSIZE is 01 16-bit, the PA[0]  bit is ignored. Access is automatically aligned to a  half-word address. When PSIZE is 10 32-bit, PA[1:0]  are ignored. Access is automatically aligned to a  word address.)  
 
    .equ BDMA_CMAR6, BDMA_BASE + 0x78 @ (This register must not be written when the  channel is enabled.) 
        .equ BDMA_CMAR6_MA_Shift, 0   @ bitWidth 32 (Memory address Base address of the  memory area from/to which the data will be  read/written. When MSIZE is 01 16-bit, the MA[0]  bit is ignored. Access is automatically aligned to a  half-word address. When MSIZE is 10 32-bit, MA[1:0]  are ignored. Access is automatically aligned to a  word address.)  
 
    .equ BDMA_CCR7, BDMA_BASE + 0x80 @ (DMA channel x configuration  register) 
        .equ BDMA_CCR7_EN, 1 << 0   @ bitWidth 1 (Channel enable This bit is set and  cleared by software.)  
        .equ BDMA_CCR7_TCIE, 1 << 1   @ bitWidth 1 (Transfer complete interrupt enable This  bit is set and cleared by software.)  
        .equ BDMA_CCR7_HTIE, 1 << 2   @ bitWidth 1 (Half transfer interrupt enable This bit  is set and cleared by software.)  
        .equ BDMA_CCR7_TEIE, 1 << 3   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ BDMA_CCR7_DIR, 1 << 4   @ bitWidth 1 (Data transfer direction This bit is set  and cleared by software.)  
        .equ BDMA_CCR7_CIRC, 1 << 5   @ bitWidth 1 (Circular mode This bit is set and  cleared by software.)  
        .equ BDMA_CCR7_PINC, 1 << 6   @ bitWidth 1 (Peripheral increment mode This bit is  set and cleared by software.)  
        .equ BDMA_CCR7_MINC, 1 << 7   @ bitWidth 1 (Memory increment mode This bit is set  and cleared by software.)  
        .equ BDMA_CCR7_PSIZE_Shift, 8   @ bitWidth 2 (Peripheral size These bits are set and  cleared by software.)  
        .equ BDMA_CCR7_MSIZE_Shift, 10   @ bitWidth 2 (Memory size These bits are set and  cleared by software.)  
        .equ BDMA_CCR7_PL_Shift, 12   @ bitWidth 2 (Channel priority level These bits are  set and cleared by software.)  
        .equ BDMA_CCR7_MEM2MEM, 1 << 14   @ bitWidth 1 (Memory to memory mode This bit is set  and cleared by software.)  
 
    .equ BDMA_CNDTR7, BDMA_BASE + 0x84 @ (DMA channel x number of data  register) 
        .equ BDMA_CNDTR7_NDT_Shift, 0   @ bitWidth 16 (Number of data to transfer Number of  data to be transferred 0 up to 65535. This register  can only be written when the channel is disabled.  Once the channel is enabled, this register is  read-only, indicating the remaining bytes to be  transmitted. This register decrements after each DMA  transfer. Once the transfer is completed, this  register can either stay at zero or be reloaded  automatically by the value previously programmed if  the channel is configured in auto-reload mode. If  this register is zero, no transaction can be served  whether the channel is enabled or not.)  
 
    .equ BDMA_CPAR7, BDMA_BASE + 0x88 @ (This register must not be written when the  channel is enabled.) 
        .equ BDMA_CPAR7_PA_Shift, 0   @ bitWidth 32 (Peripheral address Base address of the  peripheral data register from/to which the data will  be read/written. When PSIZE is 01 16-bit, the PA[0]  bit is ignored. Access is automatically aligned to a  half-word address. When PSIZE is 10 32-bit, PA[1:0]  are ignored. Access is automatically aligned to a  word address.)  
 
    .equ BDMA_CMAR7, BDMA_BASE + 0x8C @ (This register must not be written when the  channel is enabled.) 
        .equ BDMA_CMAR7_MA_Shift, 0   @ bitWidth 32 (Memory address Base address of the  memory area from/to which the data will be  read/written. When MSIZE is 01 16-bit, the MA[0]  bit is ignored. Access is automatically aligned to a  half-word address. When MSIZE is 10 32-bit, MA[1:0]  are ignored. Access is automatically aligned to a  word address.)  
 
    .equ BDMA_CCR8, BDMA_BASE + 0x94 @ (DMA channel x configuration  register) 
        .equ BDMA_CCR8_EN, 1 << 0   @ bitWidth 1 (Channel enable This bit is set and  cleared by software.)  
        .equ BDMA_CCR8_TCIE, 1 << 1   @ bitWidth 1 (Transfer complete interrupt enable This  bit is set and cleared by software.)  
        .equ BDMA_CCR8_HTIE, 1 << 2   @ bitWidth 1 (Half transfer interrupt enable This bit  is set and cleared by software.)  
        .equ BDMA_CCR8_TEIE, 1 << 3   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ BDMA_CCR8_DIR, 1 << 4   @ bitWidth 1 (Data transfer direction This bit is set  and cleared by software.)  
        .equ BDMA_CCR8_CIRC, 1 << 5   @ bitWidth 1 (Circular mode This bit is set and  cleared by software.)  
        .equ BDMA_CCR8_PINC, 1 << 6   @ bitWidth 1 (Peripheral increment mode This bit is  set and cleared by software.)  
        .equ BDMA_CCR8_MINC, 1 << 7   @ bitWidth 1 (Memory increment mode This bit is set  and cleared by software.)  
        .equ BDMA_CCR8_PSIZE_Shift, 8   @ bitWidth 2 (Peripheral size These bits are set and  cleared by software.)  
        .equ BDMA_CCR8_MSIZE_Shift, 10   @ bitWidth 2 (Memory size These bits are set and  cleared by software.)  
        .equ BDMA_CCR8_PL_Shift, 12   @ bitWidth 2 (Channel priority level These bits are  set and cleared by software.)  
        .equ BDMA_CCR8_MEM2MEM, 1 << 14   @ bitWidth 1 (Memory to memory mode This bit is set  and cleared by software.)  
 
    .equ BDMA_CNDTR8, BDMA_BASE + 0x98 @ (DMA channel x number of data  register) 
        .equ BDMA_CNDTR8_NDT_Shift, 0   @ bitWidth 16 (Number of data to transfer Number of  data to be transferred 0 up to 65535. This register  can only be written when the channel is disabled.  Once the channel is enabled, this register is  read-only, indicating the remaining bytes to be  transmitted. This register decrements after each DMA  transfer. Once the transfer is completed, this  register can either stay at zero or be reloaded  automatically by the value previously programmed if  the channel is configured in auto-reload mode. If  this register is zero, no transaction can be served  whether the channel is enabled or not.)  
 
    .equ BDMA_CPAR8, BDMA_BASE + 0x9C @ (This register must not be written when the  channel is enabled.) 
        .equ BDMA_CPAR8_PA_Shift, 0   @ bitWidth 32 (Peripheral address Base address of the  peripheral data register from/to which the data will  be read/written. When PSIZE is 01 16-bit, the PA[0]  bit is ignored. Access is automatically aligned to a  half-word address. When PSIZE is 10 32-bit, PA[1:0]  are ignored. Access is automatically aligned to a  word address.)  
 
    .equ BDMA_CMAR8, BDMA_BASE + 0xA0 @ (This register must not be written when the  channel is enabled.) 
        .equ BDMA_CMAR8_MA_Shift, 0   @ bitWidth 32 (Memory address Base address of the  memory area from/to which the data will be  read/written. When MSIZE is 01 16-bit, the MA[0]  bit is ignored. Access is automatically aligned to a  half-word address. When MSIZE is 10 32-bit, MA[1:0]  are ignored. Access is automatically aligned to a  word address.)  
 

@=========================== DMA2D ===========================@
.equ DMA2D_BASE, 0x52001000 @ (DMA2D) 
    .equ DMA2D_CR, DMA2D_BASE + 0x0 @ (DMA2D control register) 
        .equ DMA2D_CR_START, 1 << 0   @ bitWidth 1 (Start This bit can be used to launch the  DMA2D according to the parameters loaded in the  various configuration registers)  
        .equ DMA2D_CR_SUSP, 1 << 1   @ bitWidth 1 (Suspend This bit can be used to suspend  the current transfer. This bit is set and reset by  software. It is automatically reset by hardware when  the START bit is reset.)  
        .equ DMA2D_CR_ABORT, 1 << 2   @ bitWidth 1 (Abort This bit can be used to abort the  current transfer. This bit is set by software and is  automatically reset by hardware when the START bit is  reset.)  
        .equ DMA2D_CR_TEIE, 1 << 8   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ DMA2D_CR_TCIE, 1 << 9   @ bitWidth 1 (Transfer complete interrupt enable This  bit is set and cleared by software.)  
        .equ DMA2D_CR_TWIE, 1 << 10   @ bitWidth 1 (Transfer watermark interrupt enable This  bit is set and cleared by software.)  
        .equ DMA2D_CR_CAEIE, 1 << 11   @ bitWidth 1 (CLUT access error interrupt enable This  bit is set and cleared by software.)  
        .equ DMA2D_CR_CTCIE, 1 << 12   @ bitWidth 1 (CLUT transfer complete interrupt enable  This bit is set and cleared by  software.)  
        .equ DMA2D_CR_CEIE, 1 << 13   @ bitWidth 1 (Configuration Error Interrupt Enable  This bit is set and cleared by  software.)  
        .equ DMA2D_CR_MODE_Shift, 16   @ bitWidth 2 (DMA2D mode This bit is set and cleared  by software. It cannot be modified while a transfer  is ongoing.)  
 
    .equ DMA2D_ISR, DMA2D_BASE + 0x4 @ (DMA2D Interrupt Status  Register) 
        .equ DMA2D_ISR_TEIF, 1 << 0   @ bitWidth 1 (Transfer error interrupt flag This bit  is set when an error occurs during a DMA transfer  data transfer or automatic CLUT  loading.)  
        .equ DMA2D_ISR_TCIF, 1 << 1   @ bitWidth 1 (Transfer complete interrupt flag This  bit is set when a DMA2D transfer operation is  complete data transfer only.)  
        .equ DMA2D_ISR_TWIF, 1 << 2   @ bitWidth 1 (Transfer watermark interrupt flag This  bit is set when the last pixel of the watermarked  line has been transferred.)  
        .equ DMA2D_ISR_CAEIF, 1 << 3   @ bitWidth 1 (CLUT access error interrupt flag This  bit is set when the CPU accesses the CLUT while the  CLUT is being automatically copied from a system  memory to the internal DMA2D.)  
        .equ DMA2D_ISR_CTCIF, 1 << 4   @ bitWidth 1 (CLUT transfer complete interrupt flag  This bit is set when the CLUT copy from a system  memory area to the internal DMA2D memory is  complete.)  
        .equ DMA2D_ISR_CEIF, 1 << 5   @ bitWidth 1 (Configuration error interrupt flag This  bit is set when the START bit of DMA2D_CR,  DMA2DFGPFCCR or DMA2D_BGPFCCR is set and a wrong  configuration has been programmed.)  
 
    .equ DMA2D_IFCR, DMA2D_BASE + 0x8 @ (DMA2D interrupt flag clear  register) 
        .equ DMA2D_IFCR_CTEIF, 1 << 0   @ bitWidth 1 (Clear Transfer error interrupt flag  Programming this bit to 1 clears the TEIF flag in the  DMA2D_ISR register)  
        .equ DMA2D_IFCR_CTCIF, 1 << 1   @ bitWidth 1 (Clear transfer complete interrupt flag  Programming this bit to 1 clears the TCIF flag in the  DMA2D_ISR register)  
        .equ DMA2D_IFCR_CTWIF, 1 << 2   @ bitWidth 1 (Clear transfer watermark interrupt flag  Programming this bit to 1 clears the TWIF flag in the  DMA2D_ISR register)  
        .equ DMA2D_IFCR_CAECIF, 1 << 3   @ bitWidth 1 (Clear CLUT access error interrupt flag  Programming this bit to 1 clears the CAEIF flag in  the DMA2D_ISR register)  
        .equ DMA2D_IFCR_CCTCIF, 1 << 4   @ bitWidth 1 (Clear CLUT transfer complete interrupt  flag Programming this bit to 1 clears the CTCIF flag  in the DMA2D_ISR register)  
        .equ DMA2D_IFCR_CCEIF, 1 << 5   @ bitWidth 1 (Clear configuration error interrupt flag  Programming this bit to 1 clears the CEIF flag in the  DMA2D_ISR register)  
 
    .equ DMA2D_FGMAR, DMA2D_BASE + 0xC @ (DMA2D foreground memory address  register) 
        .equ DMA2D_FGMAR_MA_Shift, 0   @ bitWidth 32 (Memory address Address of the data used  for the foreground image. This register can only be  written when data transfers are disabled. Once the  data transfer has started, this register is  read-only. The address alignment must match the image  format selected e.g. a 32-bit per pixel format must  be 32-bit aligned, a 16-bit per pixel format must be  16-bit aligned and a 4-bit per pixel format must be  8-bit aligned.)  
 
    .equ DMA2D_FGOR, DMA2D_BASE + 0x10 @ (DMA2D foreground offset  register) 
        .equ DMA2D_FGOR_LO_Shift, 0   @ bitWidth 14 (Line offset Line offset used for the  foreground expressed in pixel. This value is used to  generate the address. It is added at the end of each  line to determine the starting address of the next  line. These bits can only be written when data  transfers are disabled. Once a data transfer has  started, they become read-only. If the image format  is 4-bit per pixel, the line offset must be  even.)  
 
    .equ DMA2D_BGMAR, DMA2D_BASE + 0x14 @ (DMA2D background memory address  register) 
        .equ DMA2D_BGMAR_MA_Shift, 0   @ bitWidth 32 (Memory address Address of the data used  for the background image. This register can only be  written when data transfers are disabled. Once a data  transfer has started, this register is read-only. The  address alignment must match the image format  selected e.g. a 32-bit per pixel format must be  32-bit aligned, a 16-bit per pixel format must be  16-bit aligned and a 4-bit per pixel format must be  8-bit aligned.)  
 
    .equ DMA2D_BGOR, DMA2D_BASE + 0x18 @ (DMA2D background offset  register) 
        .equ DMA2D_BGOR_LO_Shift, 0   @ bitWidth 14 (Line offset Line offset used for the  background image expressed in pixel. This value is  used for the address generation. It is added at the  end of each line to determine the starting address of  the next line. These bits can only be written when  data transfers are disabled. Once data transfer has  started, they become read-only. If the image format  is 4-bit per pixel, the line offset must be  even.)  
 
    .equ DMA2D_FGPFCCR, DMA2D_BASE + 0x1C @ (DMA2D foreground PFC control  register) 
        .equ DMA2D_FGPFCCR_CM_Shift, 0   @ bitWidth 4 (Color mode These bits defines the color  format of the foreground image. They can only be  written when data transfers are disabled. Once the  transfer has started, they are read-only. others:  meaningless)  
        .equ DMA2D_FGPFCCR_CCM, 1 << 4   @ bitWidth 1 (CLUT color mode This bit defines the  color format of the CLUT. It can only be written when  the transfer is disabled. Once the CLUT transfer has  started, this bit is read-only.)  
        .equ DMA2D_FGPFCCR_START, 1 << 5   @ bitWidth 1 (Start This bit can be set to start the  automatic loading of the CLUT. It is automatically  reset: ** at the end of the transfer ** when the  transfer is aborted by the user application by  setting the ABORT bit in DMA2D_CR ** when a transfer  error occurs ** when the transfer has not started due  to a configuration error or another transfer  operation already ongoing data transfer or automatic  background CLUT transfer.)  
        .equ DMA2D_FGPFCCR_CS_Shift, 8   @ bitWidth 8 (CLUT size These bits define the size of  the CLUT used for the foreground image. Once the CLUT  transfer has started, this field is read-only. The  number of CLUT entries is equal to CS[7:0] +  1.)  
        .equ DMA2D_FGPFCCR_AM_Shift, 16   @ bitWidth 2 (Alpha mode These bits select the alpha  channel value to be used for the foreground image.  They can only be written data the transfer are  disabled. Once the transfer has started, they become  read-only. other configurations are  meaningless)  
        .equ DMA2D_FGPFCCR_CSS_Shift, 18   @ bitWidth 2 (Chroma Sub-Sampling These bits define  the chroma sub-sampling mode for YCbCr color mode.  Once the transfer has started, these bits are  read-only. others: meaningless)  
        .equ DMA2D_FGPFCCR_AI, 1 << 20   @ bitWidth 1 (Alpha Inverted This bit inverts the  alpha value. Once the transfer has started, this bit  is read-only.)  
        .equ DMA2D_FGPFCCR_RBS, 1 << 21   @ bitWidth 1 (Red Blue Swap This bit allows to swap  the R &amp; B to support BGR or ABGR color  formats. Once the transfer has started, this bit is  read-only.)  
        .equ DMA2D_FGPFCCR_ALPHA_Shift, 24   @ bitWidth 8 (Alpha value These bits define a fixed  alpha channel value which can replace the original  alpha value or be multiplied by the original alpha  value according to the alpha mode selected through  the AM[1:0] bits. These bits can only be written when  data transfers are disabled. Once a transfer has  started, they become read-only.)  
 
    .equ DMA2D_FGCOLR, DMA2D_BASE + 0x20 @ (DMA2D foreground color  register) 
        .equ DMA2D_FGCOLR_BLUE_Shift, 0   @ bitWidth 8 (Blue Value These bits defines the blue  value for the A4 or A8 mode of the foreground image.  They can only be written when data transfers are  disabled. Once the transfer has started, They are  read-only.)  
        .equ DMA2D_FGCOLR_GREEN_Shift, 8   @ bitWidth 8 (Green Value These bits defines the green  value for the A4 or A8 mode of the foreground image.  They can only be written when data transfers are  disabled. Once the transfer has started, They are  read-only.)  
        .equ DMA2D_FGCOLR_RED_Shift, 16   @ bitWidth 8 (Red Value These bits defines the red  value for the A4 or A8 mode of the foreground image.  They can only be written when data transfers are  disabled. Once the transfer has started, they are  read-only.)  
 
    .equ DMA2D_BGPFCCR, DMA2D_BASE + 0x24 @ (DMA2D background PFC control  register) 
        .equ DMA2D_BGPFCCR_CM_Shift, 0   @ bitWidth 4 (Color mode These bits define the color  format of the foreground image. These bits can only  be written when data transfers are disabled. Once the  transfer has started, they are read-only. others:  meaningless)  
        .equ DMA2D_BGPFCCR_CCM, 1 << 4   @ bitWidth 1 (CLUT Color mode These bits define the  color format of the CLUT. This register can only be  written when the transfer is disabled. Once the CLUT  transfer has started, this bit is  read-only.)  
        .equ DMA2D_BGPFCCR_START, 1 << 5   @ bitWidth 1 (Start This bit is set to start the  automatic loading of the CLUT. This bit is  automatically reset: ** at the end of the transfer **  when the transfer is aborted by the user application  by setting the ABORT bit in the DMA2D_CR ** when a  transfer error occurs ** when the transfer has not  started due to a configuration error or another  transfer operation already on going data transfer or  automatic BackGround CLUT transfer.)  
        .equ DMA2D_BGPFCCR_CS_Shift, 8   @ bitWidth 8 (CLUT size These bits define the size of  the CLUT used for the BG. Once the CLUT transfer has  started, this field is read-only. The number of CLUT  entries is equal to CS[7:0] + 1.)  
        .equ DMA2D_BGPFCCR_AM_Shift, 16   @ bitWidth 2 (Alpha mode These bits define which alpha  channel value to be used for the background image.  These bits can only be written when data transfers  are disabled. Once the transfer has started, they are  read-only. others: meaningless)  
        .equ DMA2D_BGPFCCR_AI, 1 << 20   @ bitWidth 1 (Alpha Inverted This bit inverts the  alpha value. Once the transfer has started, this bit  is read-only.)  
        .equ DMA2D_BGPFCCR_RBS, 1 << 21   @ bitWidth 1 (Red Blue Swap This bit allows to swap  the R &amp; B to support BGR or ABGR color  formats. Once the transfer has started, this bit is  read-only.)  
        .equ DMA2D_BGPFCCR_ALPHA_Shift, 24   @ bitWidth 8 (Alpha value These bits define a fixed  alpha channel value which can replace the original  alpha value or be multiplied with the original alpha  value according to the alpha mode selected with bits  AM[1: 0]. These bits can only be written when data  transfers are disabled. Once the transfer has  started, they are read-only.)  
 
    .equ DMA2D_BGCOLR, DMA2D_BASE + 0x28 @ (DMA2D background color  register) 
        .equ DMA2D_BGCOLR_BLUE_Shift, 0   @ bitWidth 8 (Blue Value These bits define the blue  value for the A4 or A8 mode of the background. These  bits can only be written when data transfers are  disabled. Once the transfer has started, they are  read-only.)  
        .equ DMA2D_BGCOLR_GREEN_Shift, 8   @ bitWidth 8 (Green Value These bits define the green  value for the A4 or A8 mode of the background. These  bits can only be written when data transfers are  disabled. Once the transfer has started, they are  read-only.)  
        .equ DMA2D_BGCOLR_RED_Shift, 16   @ bitWidth 8 (Red Value These bits define the red  value for the A4 or A8 mode of the background. These  bits can only be written when data transfers are  disabled. Once the transfer has started, they are  read-only.)  
 
    .equ DMA2D_FGCMAR, DMA2D_BASE + 0x2C @ (DMA2D foreground CLUT memory address  register) 
        .equ DMA2D_FGCMAR_MA_Shift, 0   @ bitWidth 32 (Memory Address Address of the data used  for the CLUT address dedicated to the foreground  image. This register can only be written when no  transfer is ongoing. Once the CLUT transfer has  started, this register is read-only. If the  foreground CLUT format is 32-bit, the address must be  32-bit aligned.)  
 
    .equ DMA2D_BGCMAR, DMA2D_BASE + 0x30 @ (DMA2D background CLUT memory address  register) 
        .equ DMA2D_BGCMAR_MA_Shift, 0   @ bitWidth 32 (Memory address Address of the data used  for the CLUT address dedicated to the background  image. This register can only be written when no  transfer is on going. Once the CLUT transfer has  started, this register is read-only. If the  background CLUT format is 32-bit, the address must be  32-bit aligned.)  
 
    .equ DMA2D_OPFCCR, DMA2D_BASE + 0x34 @ (DMA2D output PFC control  register) 
        .equ DMA2D_OPFCCR_CM_Shift, 0   @ bitWidth 3 (Color mode These bits define the color  format of the output image. These bits can only be  written when data transfers are disabled. Once the  transfer has started, they are read-only. others:  meaningless)  
        .equ DMA2D_OPFCCR_AI, 1 << 20   @ bitWidth 1 (Alpha Inverted This bit inverts the  alpha value. Once the transfer has started, this bit  is read-only.)  
        .equ DMA2D_OPFCCR_RBS, 1 << 21   @ bitWidth 1 (Red Blue Swap This bit allows to swap  the R &amp; B to support BGR or ABGR color  formats. Once the transfer has started, this bit is  read-only.)  
 
    .equ DMA2D_OCOLR, DMA2D_BASE + 0x38 @ (DMA2D output color register) 
        .equ DMA2D_OCOLR_BLUE_Shift, 0   @ bitWidth 8 (Blue Value These bits define the blue  value of the output image. These bits can only be  written when data transfers are disabled. Once the  transfer has started, they are  read-only.)  
        .equ DMA2D_OCOLR_GREEN_Shift, 8   @ bitWidth 8 (Green Value These bits define the green  value of the output image. These bits can only be  written when data transfers are disabled. Once the  transfer has started, they are  read-only.)  
        .equ DMA2D_OCOLR_RED_Shift, 16   @ bitWidth 8 (Red Value These bits define the red  value of the output image. These bits can only be  written when data transfers are disabled. Once the  transfer has started, they are  read-only.)  
        .equ DMA2D_OCOLR_ALPHA_Shift, 24   @ bitWidth 8 (Alpha Channel Value These bits define  the alpha channel of the output color. These bits can  only be written when data transfers are disabled.  Once the transfer has started, they are  read-only.)  
 
    .equ DMA2D_OMAR, DMA2D_BASE + 0x3C @ (DMA2D output memory address  register) 
        .equ DMA2D_OMAR_MA_Shift, 0   @ bitWidth 32 (Memory Address Address of the data used  for the output FIFO. These bits can only be written  when data transfers are disabled. Once the transfer  has started, they are read-only. The address  alignment must match the image format selected e.g. a  32-bit per pixel format must be 32-bit aligned and a  16-bit per pixel format must be 16-bit  aligned.)  
 
    .equ DMA2D_OOR, DMA2D_BASE + 0x40 @ (DMA2D output offset register) 
        .equ DMA2D_OOR_LO_Shift, 0   @ bitWidth 14 (Line Offset Line offset used for the  output expressed in pixels. This value is used for  the address generation. It is added at the end of  each line to determine the starting address of the  next line. These bits can only be written when data  transfers are disabled. Once the transfer has  started, they are read-only.)  
 
    .equ DMA2D_NLR, DMA2D_BASE + 0x44 @ (DMA2D number of line register) 
        .equ DMA2D_NLR_NL_Shift, 0   @ bitWidth 16 (Number of lines Number of lines of the  area to be transferred. These bits can only be  written when data transfers are disabled. Once the  transfer has started, they are  read-only.)  
        .equ DMA2D_NLR_PL_Shift, 16   @ bitWidth 14 (Pixel per lines Number of pixels per  lines of the area to be transferred. These bits can  only be written when data transfers are disabled.  Once the transfer has started, they are read-only. If  any of the input image format is 4-bit per pixel,  pixel per lines must be even.)  
 
    .equ DMA2D_LWR, DMA2D_BASE + 0x48 @ (DMA2D line watermark register) 
        .equ DMA2D_LWR_LW_Shift, 0   @ bitWidth 16 (Line watermark These bits allow to  configure the line watermark for interrupt  generation. An interrupt is raised when the last  pixel of the watermarked line has been transferred.  These bits can only be written when data transfers  are disabled. Once the transfer has started, they are  read-only.)  
 
    .equ DMA2D_AMTCR, DMA2D_BASE + 0x4C @ (DMA2D AXI master timer configuration  register) 
        .equ DMA2D_AMTCR_EN, 1 << 0   @ bitWidth 1 (Enable Enables the dead time  functionality.)  
        .equ DMA2D_AMTCR_DT_Shift, 8   @ bitWidth 8 (Dead Time Dead time value in the AXI  clock cycle inserted between two consecutive accesses  on the AXI master port. These bits represent the  minimum guaranteed number of cycles between two  consecutive AXI accesses.)  
 

@=========================== DMAMUX2 ===========================@
.equ DMAMUX2_BASE, 0x58025800 @ (DMAMUX) 
    .equ DMAMUX2_C0CR, DMAMUX2_BASE + 0x0 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX2_C0CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX2_C0CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX2_C0CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX2_C0CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX2_C0CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX2_C0CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX2_C0CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX2_C1CR, DMAMUX2_BASE + 0x4 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX2_C1CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX2_C1CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX2_C1CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX2_C1CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX2_C1CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX2_C1CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX2_C1CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX2_C2CR, DMAMUX2_BASE + 0x8 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX2_C2CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX2_C2CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX2_C2CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX2_C2CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX2_C2CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX2_C2CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX2_C2CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX2_C3CR, DMAMUX2_BASE + 0xC @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX2_C3CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX2_C3CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX2_C3CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX2_C3CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX2_C3CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX2_C3CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX2_C3CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX2_C4CR, DMAMUX2_BASE + 0x10 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX2_C4CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX2_C4CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX2_C4CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX2_C4CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX2_C4CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX2_C4CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX2_C4CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX2_C5CR, DMAMUX2_BASE + 0x14 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX2_C5CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX2_C5CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX2_C5CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX2_C5CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX2_C5CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX2_C5CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX2_C5CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX2_C6CR, DMAMUX2_BASE + 0x18 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX2_C6CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX2_C6CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX2_C6CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX2_C6CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX2_C6CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX2_C6CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX2_C6CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX2_C7CR, DMAMUX2_BASE + 0x1C @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX2_C7CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX2_C7CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX2_C7CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX2_C7CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX2_C7CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX2_C7CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX2_C7CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX2_RG0CR, DMAMUX2_BASE + 0x100 @ (DMAMux - DMA request generator channel x  control register) 
        .equ DMAMUX2_RG0CR_SIG_ID_Shift, 0   @ bitWidth 5 (DMA request trigger input  selected)  
        .equ DMAMUX2_RG0CR_OIE, 1 << 8   @ bitWidth 1 (Interrupt enable at trigger event  overrun)  
        .equ DMAMUX2_RG0CR_GE, 1 << 16   @ bitWidth 1 (DMA request generator channel  enable/disable)  
        .equ DMAMUX2_RG0CR_GPOL_Shift, 17   @ bitWidth 2 (DMA request generator trigger event type  selection Defines the trigger event on the selected  DMA request trigger input)  
        .equ DMAMUX2_RG0CR_GNBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to generate  Defines the number of DMA requests generated after a  trigger event, then stop generating. The actual  number of generated DMA requests is GNBREQ+1. Note:  This field can only be written when GE bit is  reset.)  
 
    .equ DMAMUX2_RG1CR, DMAMUX2_BASE + 0x104 @ (DMAMux - DMA request generator channel x  control register) 
        .equ DMAMUX2_RG1CR_SIG_ID_Shift, 0   @ bitWidth 5 (DMA request trigger input  selected)  
        .equ DMAMUX2_RG1CR_OIE, 1 << 8   @ bitWidth 1 (Interrupt enable at trigger event  overrun)  
        .equ DMAMUX2_RG1CR_GE, 1 << 16   @ bitWidth 1 (DMA request generator channel  enable/disable)  
        .equ DMAMUX2_RG1CR_GPOL_Shift, 17   @ bitWidth 2 (DMA request generator trigger event type  selection Defines the trigger event on the selected  DMA request trigger input)  
        .equ DMAMUX2_RG1CR_GNBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to generate  Defines the number of DMA requests generated after a  trigger event, then stop generating. The actual  number of generated DMA requests is GNBREQ+1. Note:  This field can only be written when GE bit is  reset.)  
 
    .equ DMAMUX2_RG2CR, DMAMUX2_BASE + 0x108 @ (DMAMux - DMA request generator channel x  control register) 
        .equ DMAMUX2_RG2CR_SIG_ID_Shift, 0   @ bitWidth 5 (DMA request trigger input  selected)  
        .equ DMAMUX2_RG2CR_OIE, 1 << 8   @ bitWidth 1 (Interrupt enable at trigger event  overrun)  
        .equ DMAMUX2_RG2CR_GE, 1 << 16   @ bitWidth 1 (DMA request generator channel  enable/disable)  
        .equ DMAMUX2_RG2CR_GPOL_Shift, 17   @ bitWidth 2 (DMA request generator trigger event type  selection Defines the trigger event on the selected  DMA request trigger input)  
        .equ DMAMUX2_RG2CR_GNBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to generate  Defines the number of DMA requests generated after a  trigger event, then stop generating. The actual  number of generated DMA requests is GNBREQ+1. Note:  This field can only be written when GE bit is  reset.)  
 
    .equ DMAMUX2_RG3CR, DMAMUX2_BASE + 0x10C @ (DMAMux - DMA request generator channel x  control register) 
        .equ DMAMUX2_RG3CR_SIG_ID_Shift, 0   @ bitWidth 5 (DMA request trigger input  selected)  
        .equ DMAMUX2_RG3CR_OIE, 1 << 8   @ bitWidth 1 (Interrupt enable at trigger event  overrun)  
        .equ DMAMUX2_RG3CR_GE, 1 << 16   @ bitWidth 1 (DMA request generator channel  enable/disable)  
        .equ DMAMUX2_RG3CR_GPOL_Shift, 17   @ bitWidth 2 (DMA request generator trigger event type  selection Defines the trigger event on the selected  DMA request trigger input)  
        .equ DMAMUX2_RG3CR_GNBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to generate  Defines the number of DMA requests generated after a  trigger event, then stop generating. The actual  number of generated DMA requests is GNBREQ+1. Note:  This field can only be written when GE bit is  reset.)  
 
    .equ DMAMUX2_RG4CR, DMAMUX2_BASE + 0x110 @ (DMAMux - DMA request generator channel x  control register) 
        .equ DMAMUX2_RG4CR_SIG_ID_Shift, 0   @ bitWidth 5 (DMA request trigger input  selected)  
        .equ DMAMUX2_RG4CR_OIE, 1 << 8   @ bitWidth 1 (Interrupt enable at trigger event  overrun)  
        .equ DMAMUX2_RG4CR_GE, 1 << 16   @ bitWidth 1 (DMA request generator channel  enable/disable)  
        .equ DMAMUX2_RG4CR_GPOL_Shift, 17   @ bitWidth 2 (DMA request generator trigger event type  selection Defines the trigger event on the selected  DMA request trigger input)  
        .equ DMAMUX2_RG4CR_GNBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to generate  Defines the number of DMA requests generated after a  trigger event, then stop generating. The actual  number of generated DMA requests is GNBREQ+1. Note:  This field can only be written when GE bit is  reset.)  
 
    .equ DMAMUX2_RG5CR, DMAMUX2_BASE + 0x114 @ (DMAMux - DMA request generator channel x  control register) 
        .equ DMAMUX2_RG5CR_SIG_ID_Shift, 0   @ bitWidth 5 (DMA request trigger input  selected)  
        .equ DMAMUX2_RG5CR_OIE, 1 << 8   @ bitWidth 1 (Interrupt enable at trigger event  overrun)  
        .equ DMAMUX2_RG5CR_GE, 1 << 16   @ bitWidth 1 (DMA request generator channel  enable/disable)  
        .equ DMAMUX2_RG5CR_GPOL_Shift, 17   @ bitWidth 2 (DMA request generator trigger event type  selection Defines the trigger event on the selected  DMA request trigger input)  
        .equ DMAMUX2_RG5CR_GNBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to generate  Defines the number of DMA requests generated after a  trigger event, then stop generating. The actual  number of generated DMA requests is GNBREQ+1. Note:  This field can only be written when GE bit is  reset.)  
 
    .equ DMAMUX2_RG6CR, DMAMUX2_BASE + 0x118 @ (DMAMux - DMA request generator channel x  control register) 
        .equ DMAMUX2_RG6CR_SIG_ID_Shift, 0   @ bitWidth 5 (DMA request trigger input  selected)  
        .equ DMAMUX2_RG6CR_OIE, 1 << 8   @ bitWidth 1 (Interrupt enable at trigger event  overrun)  
        .equ DMAMUX2_RG6CR_GE, 1 << 16   @ bitWidth 1 (DMA request generator channel  enable/disable)  
        .equ DMAMUX2_RG6CR_GPOL_Shift, 17   @ bitWidth 2 (DMA request generator trigger event type  selection Defines the trigger event on the selected  DMA request trigger input)  
        .equ DMAMUX2_RG6CR_GNBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to generate  Defines the number of DMA requests generated after a  trigger event, then stop generating. The actual  number of generated DMA requests is GNBREQ+1. Note:  This field can only be written when GE bit is  reset.)  
 
    .equ DMAMUX2_RG7CR, DMAMUX2_BASE + 0x11C @ (DMAMux - DMA request generator channel x  control register) 
        .equ DMAMUX2_RG7CR_SIG_ID_Shift, 0   @ bitWidth 5 (DMA request trigger input  selected)  
        .equ DMAMUX2_RG7CR_OIE, 1 << 8   @ bitWidth 1 (Interrupt enable at trigger event  overrun)  
        .equ DMAMUX2_RG7CR_GE, 1 << 16   @ bitWidth 1 (DMA request generator channel  enable/disable)  
        .equ DMAMUX2_RG7CR_GPOL_Shift, 17   @ bitWidth 2 (DMA request generator trigger event type  selection Defines the trigger event on the selected  DMA request trigger input)  
        .equ DMAMUX2_RG7CR_GNBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to generate  Defines the number of DMA requests generated after a  trigger event, then stop generating. The actual  number of generated DMA requests is GNBREQ+1. Note:  This field can only be written when GE bit is  reset.)  
 
    .equ DMAMUX2_RGSR, DMAMUX2_BASE + 0x140 @ (DMAMux - DMA request generator status  register) 
        .equ DMAMUX2_RGSR_OF_Shift, 0   @ bitWidth 8 (Trigger event overrun flag The flag is  set when a trigger event occurs on DMA request  generator channel x, while the DMA request generator  counter value is lower than GNBREQ. The flag is  cleared by writing 1 to the corresponding COFx bit in  DMAMUX_RGCFR register.)  
 
    .equ DMAMUX2_RGCFR, DMAMUX2_BASE + 0x144 @ (DMAMux - DMA request generator clear flag  register) 
        .equ DMAMUX2_RGCFR_COF_Shift, 0   @ bitWidth 8 (Clear trigger event overrun flag Upon  setting, this bit clears the corresponding overrun  flag OFx in the DMAMUX_RGCSR register.)  
 
    .equ DMAMUX2_CSR, DMAMUX2_BASE + 0x80 @ (DMAMUX request line multiplexer interrupt  channel status register) 
        .equ DMAMUX2_CSR_SOF_Shift, 0   @ bitWidth 16 (Synchronization overrun event  flag)  
 
    .equ DMAMUX2_CFR, DMAMUX2_BASE + 0x84 @ (DMAMUX request line multiplexer interrupt  clear flag register) 
        .equ DMAMUX2_CFR_CSOF_Shift, 0   @ bitWidth 16 (Clear synchronization overrun event  flag)  
 

@=========================== FMC ===========================@
.equ FMC_BASE, 0x52004000 @ (FMC) 
    .equ FMC_BCR1, FMC_BASE + 0x0 @ (This register contains the control  information of each memory bank, used for SRAMs, PSRAM  and NOR Flash memories.) 
        .equ FMC_BCR1_MBKEN, 1 << 0   @ bitWidth 1 (Memory bank enable bit This bit enables  the memory bank. After reset Bank1 is enabled, all  others are disabled. Accessing a disabled bank causes  an ERROR on AXI bus.)  
        .equ FMC_BCR1_MUXEN, 1 << 1   @ bitWidth 1 (Address/data multiplexing enable bit  When this bit is set, the address and data values are  multiplexed on the data bus, valid only with NOR and  PSRAM memories:)  
        .equ FMC_BCR1_MTYP_Shift, 2   @ bitWidth 2 (Memory type These bits define the type  of external memory attached to the corresponding  memory bank:)  
        .equ FMC_BCR1_MWID_Shift, 4   @ bitWidth 2 (Memory data bus width Defines the  external memory device width, valid for all type of  memories.)  
        .equ FMC_BCR1_FACCEN, 1 << 6   @ bitWidth 1 (Flash access enable This bit enables NOR  Flash memory access operations.)  
        .equ FMC_BCR1_BURSTEN, 1 << 8   @ bitWidth 1 (Burst enable bit This bit  enables/disables synchronous accesses during read  operations. It is valid only for synchronous memories  operating in Burst mode:)  
        .equ FMC_BCR1_WAITPOL, 1 << 9   @ bitWidth 1 (Wait signal polarity bit This bit  defines the polarity of the wait signal from memory  used for either in synchronous or asynchronous  mode:)  
        .equ FMC_BCR1_WAITCFG, 1 << 11   @ bitWidth 1 (Wait timing configuration The NWAIT  signal indicates whether the data from the memory are  valid or if a wait state must be inserted when  accessing the memory in synchronous mode. This  configuration bit determines if NWAIT is asserted by  the memory one clock cycle before the wait state or  during the wait state:)  
        .equ FMC_BCR1_WREN, 1 << 12   @ bitWidth 1 (Write enable bit This bit indicates  whether write operations are enabled/disabled in the  bank by the FMC:)  
        .equ FMC_BCR1_WAITEN, 1 << 13   @ bitWidth 1 (Wait enable bit This bit  enables/disables wait-state insertion via the NWAIT  signal when accessing the memory in synchronous  mode.)  
        .equ FMC_BCR1_EXTMOD, 1 << 14   @ bitWidth 1 (Extended mode enable. This bit enables  the FMC to program the write timings for asynchronous  accesses inside the FMC_BWTR register, thus resulting  in different timings for read and write operations.  Note: When the extended mode is disabled, the FMC can  operate in Mode1 or Mode2 as follows: ** Mode 1 is  the default mode when the SRAM/PSRAM memory type is  selected MTYP =0x0 or 0x01 ** Mode 2 is the default  mode when the NOR memory type is selected MTYP =  0x10.)  
        .equ FMC_BCR1_ASYNCWAIT, 1 << 15   @ bitWidth 1 (Wait signal during asynchronous  transfers This bit enables/disables the FMC to use  the wait signal even during an asynchronous  protocol.)  
        .equ FMC_BCR1_CPSIZE_Shift, 16   @ bitWidth 3 (CRAM Page Size These are used for  Cellular RAM 1.5 which does not allow burst access to  cross the address boundaries between pages. When  these bits are configured, the FMC controller splits  automatically the burst access when the memory page  size is reached refer to memory datasheet for page  size. Other configuration: reserved.)  
        .equ FMC_BCR1_CBURSTRW, 1 << 19   @ bitWidth 1 (Write burst enable For PSRAM CRAM  operating in Burst mode, the bit enables synchronous  accesses during write operations. The enable bit for  synchronous read accesses is the BURSTEN bit in the  FMC_BCRx register.)  
        .equ FMC_BCR1_CCLKEN, 1 << 20   @ bitWidth 1 (Continuous Clock Enable This bit enables  the FMC_CLK clock output to external memory devices.  Note: The CCLKEN bit of the FMC_BCR2..4 registers is  dont care. It is only enabled through the FMC_BCR1  register. Bank 1 must be configured in synchronous  mode to generate the FMC_CLK continuous clock. If  CCLKEN bit is set, the FMC_CLK clock ratio is  specified by CLKDIV value in the FMC_BTR1 register.  CLKDIV in FMC_BWTR1 is dont care. If the synchronous  mode is used and CCLKEN bit is set, the synchronous  memories connected to other banks than Bank 1 are  clocked by the same clock the CLKDIV value in the  FMC_BTR2..4 and FMC_BWTR2..4 registers for other  banks has no effect.)  
        .equ FMC_BCR1_WFDIS, 1 << 21   @ bitWidth 1 (Write FIFO Disable This bit disables the  Write FIFO used by the FMC controller. Note: The  WFDIS bit of the FMC_BCR2..4 registers is dont care.  It is only enabled through the FMC_BCR1  register.)  
        .equ FMC_BCR1_BMAP_Shift, 24   @ bitWidth 2 (FMC bank mapping These bits allows  different to remap SDRAM bank2 or swap the FMC  NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note:  The BMAP bits of the FMC_BCR2..4 registers are dont  care. It is only enabled through the FMC_BCR1  register.)  
        .equ FMC_BCR1_FMCEN, 1 << 31   @ bitWidth 1 (FMC controller Enable This bit  enables/disables the FMC controller. Note: The FMCEN  bit of the FMC_BCR2..4 registers is dont care. It is  only enabled through the FMC_BCR1  register.)  
 
    .equ FMC_BTR1, FMC_BASE + 0x4 @ (This register contains the control  information of each memory bank, used for SRAMs, PSRAM  and NOR Flash memories.If the EXTMOD bit is set in the  FMC_BCRx register, then this register is partitioned for  write and read access, that is, 2 registers are  available: one to configure read accesses this register  and one to configure write accesses FMC_BWTRx  registers.) 
        .equ FMC_BTR1_ADDSET_Shift, 0   @ bitWidth 4 (Address setup phase duration These bits  are written by software to define the duration of the  address setup phase refer to Figure81 to Figure93,  used in SRAMs, ROMs and asynchronous NOR Flash: For  each access mode address setup phase duration, please  refer to the respective figure refer to Figure81 to  Figure93. Note: In synchronous accesses, this value  is dont care. In Muxed mode or Mode D, the minimum  value for ADDSET is 1.)  
        .equ FMC_BTR1_ADDHLD_Shift, 4   @ bitWidth 4 (Address-hold phase duration These bits  are written by software to define the duration of the  address hold phase refer to Figure81 to Figure93,  used in mode D or multiplexed accesses: For each  access mode address-hold phase duration, please refer  to the respective figure Figure81 to Figure93.  Note: In synchronous accesses, this value is not  used, the address hold phase is always 1 memory clock  period duration.)  
        .equ FMC_BTR1_DATAST_Shift, 8   @ bitWidth 8 (Data-phase duration These bits are  written by software to define the duration of the  data phase refer to Figure81 to Figure93, used in  asynchronous accesses: For each memory type and  access mode data-phase duration, please refer to the  respective figure Figure81 to Figure93. Example:  Mode1, write access, DATAST=1: Data-phase duration=  DATAST+1 = 2 KCK_FMC clock cycles. Note: In  synchronous accesses, this value is dont  care.)  
        .equ FMC_BTR1_BUSTURN_Shift, 16   @ bitWidth 4 (Bus turnaround phase duration These bits  are written by software to add a delay at the end of  a write-to-read or read-to write transaction. The  programmed bus turnaround delay is inserted between  an asynchronous read in muxed or mode D or write  transaction and any other asynchronous /synchronous  read/write from/to a static bank. If a read operation  is performed, the bank can be the same or a different  one, whereas it must be different in case of write  operation to the bank, except in muxed mode or mode  D. In some cases, whatever the programmed BUSTRUN  values, the bus turnaround delay is fixed as follows:  The bus turnaround delay is not inserted between two  consecutive asynchronous write transfers to the same  static memory bank except in muxed mode and mode D.  There is a bus turnaround delay of 1 FMC clock cycle  between: Two consecutive asynchronous read transfers  to the same static memory bank except for modes muxed  and D. An asynchronous read to an asynchronous or  synchronous write to any static bank or dynamic bank  except in modes muxed and D mode. There is a bus  turnaround delay of 2 FMC clock cycle between: Two  consecutive synchronous write operations in Burst or  Single mode to the same bank. A synchronous write  burst or single access and an asynchronous write or  read transfer to or from static memory bank the bank  can be the same or a different one in case of a read  operation. Two consecutive synchronous read  operations in Burst or Single mode followed by any  synchronous/asynchronous read or write from/to  another static memory bank. There is a bus turnaround  delay of 3 FMC clock cycle between: Two consecutive  synchronous write operations in Burst or Single  mode to different static banks. A synchronous write  access in Burst or Single mode and a synchronous  read from the same or a different bank. The bus  turnaround delay allows to match the minimum time  between consecutive transactions tEHEL from NEx high  to NEx low and the maximum time required by the  memory to free the data bus after a read access  tEHQZ: BUSTRUN + 1 KCK_FMC period &#8805;  tEHELmin and BUSTRUN + 2KCK_FMC period &#8805;  tEHQZmax if EXTMOD = 0 BUSTRUN + 2KCK_FMC period  &#8805; max tEHELmin, tEHQZmax if EXTMOD = 126.  ...)  
        .equ FMC_BTR1_CLKDIV_Shift, 20   @ bitWidth 4 (Clock divide ratio for FMC_CLK signal  These bits define the period of FMC_CLK clock output  signal, expressed in number of KCK_FMC cycles: In  asynchronous NOR Flash, SRAM or PSRAM accesses, this  value is dont care. Note: Refer to Section20.6.5:  Synchronous transactions for FMC_CLK divider ratio  formula)  
        .equ FMC_BTR1_DATLAT_Shift, 24   @ bitWidth 4 (Data latency for synchronous memory For  synchronous access with read write burst mode enabled  these bits define the number of memory clock  cycles)  
        .equ FMC_BTR1_ACCMOD_Shift, 28   @ bitWidth 2 (Access mode These bits specify the  asynchronous access modes as shown in the timing  diagrams. They are taken into account only when the  EXTMOD bit in the FMC_BCRx register is  1.)  
 
    .equ FMC_BCR2, FMC_BASE + 0x8 @ (This register contains the control  information of each memory bank, used for SRAMs, PSRAM  and NOR Flash memories.) 
        .equ FMC_BCR2_MBKEN, 1 << 0   @ bitWidth 1 (Memory bank enable bit This bit enables  the memory bank. After reset Bank1 is enabled, all  others are disabled. Accessing a disabled bank causes  an ERROR on AXI bus.)  
        .equ FMC_BCR2_MUXEN, 1 << 1   @ bitWidth 1 (Address/data multiplexing enable bit  When this bit is set, the address and data values are  multiplexed on the data bus, valid only with NOR and  PSRAM memories:)  
        .equ FMC_BCR2_MTYP_Shift, 2   @ bitWidth 2 (Memory type These bits define the type  of external memory attached to the corresponding  memory bank:)  
        .equ FMC_BCR2_MWID_Shift, 4   @ bitWidth 2 (Memory data bus width Defines the  external memory device width, valid for all type of  memories.)  
        .equ FMC_BCR2_FACCEN, 1 << 6   @ bitWidth 1 (Flash access enable This bit enables NOR  Flash memory access operations.)  
        .equ FMC_BCR2_BURSTEN, 1 << 8   @ bitWidth 1 (Burst enable bit This bit  enables/disables synchronous accesses during read  operations. It is valid only for synchronous memories  operating in Burst mode:)  
        .equ FMC_BCR2_WAITPOL, 1 << 9   @ bitWidth 1 (Wait signal polarity bit This bit  defines the polarity of the wait signal from memory  used for either in synchronous or asynchronous  mode:)  
        .equ FMC_BCR2_WAITCFG, 1 << 11   @ bitWidth 1 (Wait timing configuration The NWAIT  signal indicates whether the data from the memory are  valid or if a wait state must be inserted when  accessing the memory in synchronous mode. This  configuration bit determines if NWAIT is asserted by  the memory one clock cycle before the wait state or  during the wait state:)  
        .equ FMC_BCR2_WREN, 1 << 12   @ bitWidth 1 (Write enable bit This bit indicates  whether write operations are enabled/disabled in the  bank by the FMC:)  
        .equ FMC_BCR2_WAITEN, 1 << 13   @ bitWidth 1 (Wait enable bit This bit  enables/disables wait-state insertion via the NWAIT  signal when accessing the memory in synchronous  mode.)  
        .equ FMC_BCR2_EXTMOD, 1 << 14   @ bitWidth 1 (Extended mode enable. This bit enables  the FMC to program the write timings for asynchronous  accesses inside the FMC_BWTR register, thus resulting  in different timings for read and write operations.  Note: When the extended mode is disabled, the FMC can  operate in Mode1 or Mode2 as follows: ** Mode 1 is  the default mode when the SRAM/PSRAM memory type is  selected MTYP =0x0 or 0x01 ** Mode 2 is the default  mode when the NOR memory type is selected MTYP =  0x10.)  
        .equ FMC_BCR2_ASYNCWAIT, 1 << 15   @ bitWidth 1 (Wait signal during asynchronous  transfers This bit enables/disables the FMC to use  the wait signal even during an asynchronous  protocol.)  
        .equ FMC_BCR2_CPSIZE_Shift, 16   @ bitWidth 3 (CRAM Page Size These are used for  Cellular RAM 1.5 which does not allow burst access to  cross the address boundaries between pages. When  these bits are configured, the FMC controller splits  automatically the burst access when the memory page  size is reached refer to memory datasheet for page  size. Other configuration: reserved.)  
        .equ FMC_BCR2_CBURSTRW, 1 << 19   @ bitWidth 1 (Write burst enable For PSRAM CRAM  operating in Burst mode, the bit enables synchronous  accesses during write operations. The enable bit for  synchronous read accesses is the BURSTEN bit in the  FMC_BCRx register.)  
        .equ FMC_BCR2_CCLKEN, 1 << 20   @ bitWidth 1 (Continuous Clock Enable This bit enables  the FMC_CLK clock output to external memory devices.  Note: The CCLKEN bit of the FMC_BCR2..4 registers is  dont care. It is only enabled through the FMC_BCR1  register. Bank 1 must be configured in synchronous  mode to generate the FMC_CLK continuous clock. If  CCLKEN bit is set, the FMC_CLK clock ratio is  specified by CLKDIV value in the FMC_BTR1 register.  CLKDIV in FMC_BWTR1 is dont care. If the synchronous  mode is used and CCLKEN bit is set, the synchronous  memories connected to other banks than Bank 1 are  clocked by the same clock the CLKDIV value in the  FMC_BTR2..4 and FMC_BWTR2..4 registers for other  banks has no effect.)  
        .equ FMC_BCR2_WFDIS, 1 << 21   @ bitWidth 1 (Write FIFO Disable This bit disables the  Write FIFO used by the FMC controller. Note: The  WFDIS bit of the FMC_BCR2..4 registers is dont care.  It is only enabled through the FMC_BCR1  register.)  
        .equ FMC_BCR2_BMAP_Shift, 24   @ bitWidth 2 (FMC bank mapping These bits allows  different to remap SDRAM bank2 or swap the FMC  NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note:  The BMAP bits of the FMC_BCR2..4 registers are dont  care. It is only enabled through the FMC_BCR1  register.)  
        .equ FMC_BCR2_FMCEN, 1 << 31   @ bitWidth 1 (FMC controller Enable This bit  enables/disables the FMC controller. Note: The FMCEN  bit of the FMC_BCR2..4 registers is dont care. It is  only enabled through the FMC_BCR1  register.)  
 
    .equ FMC_BTR2, FMC_BASE + 0xC @ (This register contains the control  information of each memory bank, used for SRAMs, PSRAM  and NOR Flash memories.If the EXTMOD bit is set in the  FMC_BCRx register, then this register is partitioned for  write and read access, that is, 2 registers are  available: one to configure read accesses this register  and one to configure write accesses FMC_BWTRx  registers.) 
        .equ FMC_BTR2_ADDSET_Shift, 0   @ bitWidth 4 (Address setup phase duration These bits  are written by software to define the duration of the  address setup phase refer to Figure81 to Figure93,  used in SRAMs, ROMs and asynchronous NOR Flash: For  each access mode address setup phase duration, please  refer to the respective figure refer to Figure81 to  Figure93. Note: In synchronous accesses, this value  is dont care. In Muxed mode or Mode D, the minimum  value for ADDSET is 1.)  
        .equ FMC_BTR2_ADDHLD_Shift, 4   @ bitWidth 4 (Address-hold phase duration These bits  are written by software to define the duration of the  address hold phase refer to Figure81 to Figure93,  used in mode D or multiplexed accesses: For each  access mode address-hold phase duration, please refer  to the respective figure Figure81 to Figure93.  Note: In synchronous accesses, this value is not  used, the address hold phase is always 1 memory clock  period duration.)  
        .equ FMC_BTR2_DATAST_Shift, 8   @ bitWidth 8 (Data-phase duration These bits are  written by software to define the duration of the  data phase refer to Figure81 to Figure93, used in  asynchronous accesses: For each memory type and  access mode data-phase duration, please refer to the  respective figure Figure81 to Figure93. Example:  Mode1, write access, DATAST=1: Data-phase duration=  DATAST+1 = 2 KCK_FMC clock cycles. Note: In  synchronous accesses, this value is dont  care.)  
        .equ FMC_BTR2_BUSTURN_Shift, 16   @ bitWidth 4 (Bus turnaround phase duration These bits  are written by software to add a delay at the end of  a write-to-read or read-to write transaction. The  programmed bus turnaround delay is inserted between  an asynchronous read in muxed or mode D or write  transaction and any other asynchronous /synchronous  read/write from/to a static bank. If a read operation  is performed, the bank can be the same or a different  one, whereas it must be different in case of write  operation to the bank, except in muxed mode or mode  D. In some cases, whatever the programmed BUSTRUN  values, the bus turnaround delay is fixed as follows:  The bus turnaround delay is not inserted between two  consecutive asynchronous write transfers to the same  static memory bank except in muxed mode and mode D.  There is a bus turnaround delay of 1 FMC clock cycle  between: Two consecutive asynchronous read transfers  to the same static memory bank except for modes muxed  and D. An asynchronous read to an asynchronous or  synchronous write to any static bank or dynamic bank  except in modes muxed and D mode. There is a bus  turnaround delay of 2 FMC clock cycle between: Two  consecutive synchronous write operations in Burst or  Single mode to the same bank. A synchronous write  burst or single access and an asynchronous write or  read transfer to or from static memory bank the bank  can be the same or a different one in case of a read  operation. Two consecutive synchronous read  operations in Burst or Single mode followed by any  synchronous/asynchronous read or write from/to  another static memory bank. There is a bus turnaround  delay of 3 FMC clock cycle between: Two consecutive  synchronous write operations in Burst or Single  mode to different static banks. A synchronous write  access in Burst or Single mode and a synchronous  read from the same or a different bank. The bus  turnaround delay allows to match the minimum time  between consecutive transactions tEHEL from NEx high  to NEx low and the maximum time required by the  memory to free the data bus after a read access  tEHQZ: BUSTRUN + 1 KCK_FMC period &#8805;  tEHELmin and BUSTRUN + 2KCK_FMC period &#8805;  tEHQZmax if EXTMOD = 0 BUSTRUN + 2KCK_FMC period  &#8805; max tEHELmin, tEHQZmax if EXTMOD = 1.  ...)  
        .equ FMC_BTR2_CLKDIV_Shift, 20   @ bitWidth 4 (Clock divide ratio for FMC_CLK signal  These bits define the period of FMC_CLK clock output  signal, expressed in number of KCK_FMC cycles: In  asynchronous NOR Flash, SRAM or PSRAM accesses, this  value is dont care. Note: Refer to Section20.6.5:  Synchronous transactions for FMC_CLK divider ratio  formula)  
        .equ FMC_BTR2_DATLAT_Shift, 24   @ bitWidth 4 (Data latency for synchronous memory For  synchronous access with read write burst mode enabled  these bits define the number of memory clock  cycles)  
        .equ FMC_BTR2_ACCMOD_Shift, 28   @ bitWidth 2 (Access mode These bits specify the  asynchronous access modes as shown in the timing  diagrams. They are taken into account only when the  EXTMOD bit in the FMC_BCRx register is  1.)  
 
    .equ FMC_BCR3, FMC_BASE + 0x10 @ (This register contains the control  information of each memory bank, used for SRAMs, PSRAM  and NOR Flash memories.) 
        .equ FMC_BCR3_MBKEN, 1 << 0   @ bitWidth 1 (Memory bank enable bit This bit enables  the memory bank. After reset Bank1 is enabled, all  others are disabled. Accessing a disabled bank causes  an ERROR on AXI bus.)  
        .equ FMC_BCR3_MUXEN, 1 << 1   @ bitWidth 1 (Address/data multiplexing enable bit  When this bit is set, the address and data values are  multiplexed on the data bus, valid only with NOR and  PSRAM memories:)  
        .equ FMC_BCR3_MTYP_Shift, 2   @ bitWidth 2 (Memory type These bits define the type  of external memory attached to the corresponding  memory bank:)  
        .equ FMC_BCR3_MWID_Shift, 4   @ bitWidth 2 (Memory data bus width Defines the  external memory device width, valid for all type of  memories.)  
        .equ FMC_BCR3_FACCEN, 1 << 6   @ bitWidth 1 (Flash access enable This bit enables NOR  Flash memory access operations.)  
        .equ FMC_BCR3_BURSTEN, 1 << 8   @ bitWidth 1 (Burst enable bit This bit  enables/disables synchronous accesses during read  operations. It is valid only for synchronous memories  operating in Burst mode:)  
        .equ FMC_BCR3_WAITPOL, 1 << 9   @ bitWidth 1 (Wait signal polarity bit This bit  defines the polarity of the wait signal from memory  used for either in synchronous or asynchronous  mode:)  
        .equ FMC_BCR3_WAITCFG, 1 << 11   @ bitWidth 1 (Wait timing configuration The NWAIT  signal indicates whether the data from the memory are  valid or if a wait state must be inserted when  accessing the memory in synchronous mode. This  configuration bit determines if NWAIT is asserted by  the memory one clock cycle before the wait state or  during the wait state:)  
        .equ FMC_BCR3_WREN, 1 << 12   @ bitWidth 1 (Write enable bit This bit indicates  whether write operations are enabled/disabled in the  bank by the FMC:)  
        .equ FMC_BCR3_WAITEN, 1 << 13   @ bitWidth 1 (Wait enable bit This bit  enables/disables wait-state insertion via the NWAIT  signal when accessing the memory in synchronous  mode.)  
        .equ FMC_BCR3_EXTMOD, 1 << 14   @ bitWidth 1 (Extended mode enable. This bit enables  the FMC to program the write timings for asynchronous  accesses inside the FMC_BWTR register, thus resulting  in different timings for read and write operations.  Note: When the extended mode is disabled, the FMC can  operate in Mode1 or Mode2 as follows: ** Mode 1 is  the default mode when the SRAM/PSRAM memory type is  selected MTYP =0x0 or 0x01 ** Mode 2 is the default  mode when the NOR memory type is selected MTYP =  0x10.)  
        .equ FMC_BCR3_ASYNCWAIT, 1 << 15   @ bitWidth 1 (Wait signal during asynchronous  transfers This bit enables/disables the FMC to use  the wait signal even during an asynchronous  protocol.)  
        .equ FMC_BCR3_CPSIZE_Shift, 16   @ bitWidth 3 (CRAM Page Size These are used for  Cellular RAM 1.5 which does not allow burst access to  cross the address boundaries between pages. When  these bits are configured, the FMC controller splits  automatically the burst access when the memory page  size is reached refer to memory datasheet for page  size. Other configuration: reserved.)  
        .equ FMC_BCR3_CBURSTRW, 1 << 19   @ bitWidth 1 (Write burst enable For PSRAM CRAM  operating in Burst mode, the bit enables synchronous  accesses during write operations. The enable bit for  synchronous read accesses is the BURSTEN bit in the  FMC_BCRx register.)  
        .equ FMC_BCR3_CCLKEN, 1 << 20   @ bitWidth 1 (Continuous Clock Enable This bit enables  the FMC_CLK clock output to external memory devices.  Note: The CCLKEN bit of the FMC_BCR2..4 registers is  dont care. It is only enabled through the FMC_BCR1  register. Bank 1 must be configured in synchronous  mode to generate the FMC_CLK continuous clock. If  CCLKEN bit is set, the FMC_CLK clock ratio is  specified by CLKDIV value in the FMC_BTR1 register.  CLKDIV in FMC_BWTR1 is dont care. If the synchronous  mode is used and CCLKEN bit is set, the synchronous  memories connected to other banks than Bank 1 are  clocked by the same clock the CLKDIV value in the  FMC_BTR2..4 and FMC_BWTR2..4 registers for other  banks has no effect.)  
        .equ FMC_BCR3_WFDIS, 1 << 21   @ bitWidth 1 (Write FIFO Disable This bit disables the  Write FIFO used by the FMC controller. Note: The  WFDIS bit of the FMC_BCR2..4 registers is dont care.  It is only enabled through the FMC_BCR1  register.)  
        .equ FMC_BCR3_BMAP_Shift, 24   @ bitWidth 2 (FMC bank mapping These bits allows  different to remap SDRAM bank2 or swap the FMC  NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note:  The BMAP bits of the FMC_BCR2..4 registers are dont  care. It is only enabled through the FMC_BCR1  register.)  
        .equ FMC_BCR3_FMCEN, 1 << 31   @ bitWidth 1 (FMC controller Enable This bit  enables/disables the FMC controller. Note: The FMCEN  bit of the FMC_BCR2..4 registers is dont care. It is  only enabled through the FMC_BCR1  register.)  
 
    .equ FMC_BTR3, FMC_BASE + 0x14 @ (This register contains the control  information of each memory bank, used for SRAMs, PSRAM  and NOR Flash memories.If the EXTMOD bit is set in the  FMC_BCRx register, then this register is partitioned for  write and read access, that is, 2 registers are  available: one to configure read accesses this register  and one to configure write accesses FMC_BWTRx  registers.) 
        .equ FMC_BTR3_ADDSET_Shift, 0   @ bitWidth 4 (Address setup phase duration These bits  are written by software to define the duration of the  address setup phase refer to Figure81 to Figure93,  used in SRAMs, ROMs and asynchronous NOR Flash: For  each access mode address setup phase duration, please  refer to the respective figure refer to Figure81 to  Figure93. Note: In synchronous accesses, this value  is dont care. In Muxed mode or Mode D, the minimum  value for ADDSET is 1.)  
        .equ FMC_BTR3_ADDHLD_Shift, 4   @ bitWidth 4 (Address-hold phase duration These bits  are written by software to define the duration of the  address hold phase refer to Figure81 to Figure93,  used in mode D or multiplexed accesses: For each  access mode address-hold phase duration, please refer  to the respective figure Figure81 to Figure93.  Note: In synchronous accesses, this value is not  used, the address hold phase is always 1 memory clock  period duration.)  
        .equ FMC_BTR3_DATAST_Shift, 8   @ bitWidth 8 (Data-phase duration These bits are  written by software to define the duration of the  data phase refer to Figure81 to Figure93, used in  asynchronous accesses: For each memory type and  access mode data-phase duration, please refer to the  respective figure Figure81 to Figure93. Example:  Mode1, write access, DATAST=1: Data-phase duration=  DATAST+1 = 2 KCK_FMC clock cycles. Note: In  synchronous accesses, this value is dont  care.)  
        .equ FMC_BTR3_BUSTURN_Shift, 16   @ bitWidth 4 (Bus turnaround phase duration These bits  are written by software to add a delay at the end of  a write-to-read or read-to write transaction. The  programmed bus turnaround delay is inserted between  an asynchronous read in muxed or mode D or write  transaction and any other asynchronous /synchronous  read/write from/to a static bank. If a read operation  is performed, the bank can be the same or a different  one, whereas it must be different in case of write  operation to the bank, except in muxed mode or mode  D. In some cases, whatever the programmed BUSTRUN  values, the bus turnaround delay is fixed as follows:  The bus turnaround delay is not inserted between two  consecutive asynchronous write transfers to the same  static memory bank except in muxed mode and mode D.  There is a bus turnaround delay of 1 FMC clock cycle  between: Two consecutive asynchronous read transfers  to the same static memory bank except for modes muxed  and D. An asynchronous read to an asynchronous or  synchronous write to any static bank or dynamic bank  except in modes muxed and D mode. There is a bus  turnaround delay of 2 FMC clock cycle between: Two  consecutive synchronous write operations in Burst or  Single mode to the same bank. A synchronous write  burst or single access and an asynchronous write or  read transfer to or from static memory bank the bank  can be the same or a different one in case of a read  operation. Two consecutive synchronous read  operations in Burst or Single mode followed by any  synchronous/asynchronous read or write from/to  another static memory bank. There is a bus turnaround  delay of 3 FMC clock cycle between: Two consecutive  synchronous write operations in Burst or Single  mode to different static banks. A synchronous write  access in Burst or Single mode and a synchronous  read from the same or a different bank. The bus  turnaround delay allows to match the minimum time  between consecutive transactions tEHEL from NEx high  to NEx low and the maximum time required by the  memory to free the data bus after a read access  tEHQZ: BUSTRUN + 1 KCK_FMC period &#8805;  tEHELmin and BUSTRUN + 2KCK_FMC period &#8805;  tEHQZmax if EXTMOD = 0 BUSTRUN + 2KCK_FMC period  &#8805; max tEHELmin, tEHQZmax if EXTMOD =1.  ...)  
        .equ FMC_BTR3_CLKDIV_Shift, 20   @ bitWidth 4 (Clock divide ratio for FMC_CLK signal  These bits define the period of FMC_CLK clock output  signal, expressed in number of KCK_FMC cycles: In  asynchronous NOR Flash, SRAM or PSRAM accesses, this  value is dont care. Note: Refer to Section20.6.5:  Synchronous transactions for FMC_CLK divider ratio  formula)  
        .equ FMC_BTR3_DATLAT_Shift, 24   @ bitWidth 4 (Data latency for synchronous memory For  synchronous access with read write burst mode enabled  these bits define the number of memory clock  cycles)  
        .equ FMC_BTR3_ACCMOD_Shift, 28   @ bitWidth 2 (Access mode These bits specify the  asynchronous access modes as shown in the timing  diagrams. They are taken into account only when the  EXTMOD bit in the FMC_BCRx register is  1.)  
 
    .equ FMC_BCR4, FMC_BASE + 0x18 @ (This register contains the control  information of each memory bank, used for SRAMs, PSRAM  and NOR Flash memories.) 
        .equ FMC_BCR4_MBKEN, 1 << 0   @ bitWidth 1 (Memory bank enable bit This bit enables  the memory bank. After reset Bank1 is enabled, all  others are disabled. Accessing a disabled bank causes  an ERROR on AXI bus.)  
        .equ FMC_BCR4_MUXEN, 1 << 1   @ bitWidth 1 (Address/data multiplexing enable bit  When this bit is set, the address and data values are  multiplexed on the data bus, valid only with NOR and  PSRAM memories:)  
        .equ FMC_BCR4_MTYP_Shift, 2   @ bitWidth 2 (Memory type These bits define the type  of external memory attached to the corresponding  memory bank:)  
        .equ FMC_BCR4_MWID_Shift, 4   @ bitWidth 2 (Memory data bus width Defines the  external memory device width, valid for all type of  memories.)  
        .equ FMC_BCR4_FACCEN, 1 << 6   @ bitWidth 1 (Flash access enable This bit enables NOR  Flash memory access operations.)  
        .equ FMC_BCR4_BURSTEN, 1 << 8   @ bitWidth 1 (Burst enable bit This bit  enables/disables synchronous accesses during read  operations. It is valid only for synchronous memories  operating in Burst mode:)  
        .equ FMC_BCR4_WAITPOL, 1 << 9   @ bitWidth 1 (Wait signal polarity bit This bit  defines the polarity of the wait signal from memory  used for either in synchronous or asynchronous  mode:)  
        .equ FMC_BCR4_WAITCFG, 1 << 11   @ bitWidth 1 (Wait timing configuration The NWAIT  signal indicates whether the data from the memory are  valid or if a wait state must be inserted when  accessing the memory in synchronous mode. This  configuration bit determines if NWAIT is asserted by  the memory one clock cycle before the wait state or  during the wait state:)  
        .equ FMC_BCR4_WREN, 1 << 12   @ bitWidth 1 (Write enable bit This bit indicates  whether write operations are enabled/disabled in the  bank by the FMC:)  
        .equ FMC_BCR4_WAITEN, 1 << 13   @ bitWidth 1 (Wait enable bit This bit  enables/disables wait-state insertion via the NWAIT  signal when accessing the memory in synchronous  mode.)  
        .equ FMC_BCR4_EXTMOD, 1 << 14   @ bitWidth 1 (Extended mode enable. This bit enables  the FMC to program the write timings for asynchronous  accesses inside the FMC_BWTR register, thus resulting  in different timings for read and write operations.  Note: When the extended mode is disabled, the FMC can  operate in Mode1 or Mode2 as follows: ** Mode 1 is  the default mode when the SRAM/PSRAM memory type is  selected MTYP =0x0 or 0x01 ** Mode 2 is the default  mode when the NOR memory type is selected MTYP =  0x10.)  
        .equ FMC_BCR4_ASYNCWAIT, 1 << 15   @ bitWidth 1 (Wait signal during asynchronous  transfers This bit enables/disables the FMC to use  the wait signal even during an asynchronous  protocol.)  
        .equ FMC_BCR4_CPSIZE_Shift, 16   @ bitWidth 3 (CRAM Page Size These are used for  Cellular RAM 1.5 which does not allow burst access to  cross the address boundaries between pages. When  these bits are configured, the FMC controller splits  automatically the burst access when the memory page  size is reached refer to memory datasheet for page  size. Other configuration: reserved.)  
        .equ FMC_BCR4_CBURSTRW, 1 << 19   @ bitWidth 1 (Write burst enable For PSRAM CRAM  operating in Burst mode, the bit enables synchronous  accesses during write operations. The enable bit for  synchronous read accesses is the BURSTEN bit in the  FMC_BCRx register.)  
        .equ FMC_BCR4_CCLKEN, 1 << 20   @ bitWidth 1 (Continuous Clock Enable This bit enables  the FMC_CLK clock output to external memory devices.  Note: The CCLKEN bit of the FMC_BCR2..4 registers is  dont care. It is only enabled through the FMC_BCR1  register. Bank 1 must be configured in synchronous  mode to generate the FMC_CLK continuous clock. If  CCLKEN bit is set, the FMC_CLK clock ratio is  specified by CLKDIV value in the FMC_BTR1 register.  CLKDIV in FMC_BWTR1 is dont care. If the synchronous  mode is used and CCLKEN bit is set, the synchronous  memories connected to other banks than Bank 1 are  clocked by the same clock the CLKDIV value in the  FMC_BTR2..4 and FMC_BWTR2..4 registers for other  banks has no effect.)  
        .equ FMC_BCR4_WFDIS, 1 << 21   @ bitWidth 1 (Write FIFO Disable This bit disables the  Write FIFO used by the FMC controller. Note: The  WFDIS bit of the FMC_BCR2..4 registers is dont care.  It is only enabled through the FMC_BCR1  register.)  
        .equ FMC_BCR4_BMAP_Shift, 24   @ bitWidth 2 (FMC bank mapping These bits allows  different to remap SDRAM bank2 or swap the FMC  NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note:  The BMAP bits of the FMC_BCR2..4 registers are dont  care. It is only enabled through the FMC_BCR1  register.)  
        .equ FMC_BCR4_FMCEN, 1 << 31   @ bitWidth 1 (FMC controller Enable This bit  enables/disables the FMC controller. Note: The FMCEN  bit of the FMC_BCR2..4 registers is dont care. It is  only enabled through the FMC_BCR1  register.)  
 
    .equ FMC_BTR4, FMC_BASE + 0x1C @ (This register contains the control  information of each memory bank, used for SRAMs, PSRAM  and NOR Flash memories.If the EXTMOD bit is set in the  FMC_BCRx register, then this register is partitioned for  write and read access, that is, 2 registers are  available: one to configure read accesses this register  and one to configure write accesses FMC_BWTRx  registers.) 
        .equ FMC_BTR4_ADDSET_Shift, 0   @ bitWidth 4 (Address setup phase duration These bits  are written by software to define the duration of the  address setup phase refer to Figure81 to Figure93,  used in SRAMs, ROMs and asynchronous NOR Flash: For  each access mode address setup phase duration, please  refer to the respective figure refer to Figure81 to  Figure93. Note: In synchronous accesses, this value  is dont care. In Muxed mode or Mode D, the minimum  value for ADDSET is 1.)  
        .equ FMC_BTR4_ADDHLD_Shift, 4   @ bitWidth 4 (Address-hold phase duration These bits  are written by software to define the duration of the  address hold phase refer to Figure81 to Figure93,  used in mode D or multiplexed accesses: For each  access mode address-hold phase duration, please refer  to the respective figure Figure81 to Figure93.  Note: In synchronous accesses, this value is not  used, the address hold phase is always 1 memory clock  period duration.)  
        .equ FMC_BTR4_DATAST_Shift, 8   @ bitWidth 8 (Data-phase duration These bits are  written by software to define the duration of the  data phase refer to Figure81 to Figure93, used in  asynchronous accesses: For each memory type and  access mode data-phase duration, please refer to the  respective figure Figure81 to Figure93. Example:  Mode1, write access, DATAST=1: Data-phase duration=  DATAST+1 = 2 KCK_FMC clock cycles. Note: In  synchronous accesses, this value is dont  care.)  
        .equ FMC_BTR4_BUSTURN_Shift, 16   @ bitWidth 4 (Bus turnaround phase duration These bits  are written by software to add a delay at the end of  a write-to-read or read-to write transaction. The  programmed bus turnaround delay is inserted between  an asynchronous read in muxed or mode D or write  transaction and any other asynchronous /synchronous  read/write from/to a static bank. If a read operation  is performed, the bank can be the same or a different  one, whereas it must be different in case of write  operation to the bank, except in muxed mode or mode  D. In some cases, whatever the programmed BUSTRUN  values, the bus turnaround delay is fixed as follows:  The bus turnaround delay is not inserted between two  consecutive asynchronous write transfers to the same  static memory bank except in muxed mode and mode D.  There is a bus turnaround delay of 1 FMC clock cycle  between: Two consecutive asynchronous read transfers  to the same static memory bank except for modes muxed  and D. An asynchronous read to an asynchronous or  synchronous write to any static bank or dynamic bank  except in modes muxed and D mode. There is a bus  turnaround delay of 2 FMC clock cycle between: Two  consecutive synchronous write operations in Burst or  Single mode to the same bank. A synchronous write  burst or single access and an asynchronous write or  read transfer to or from static memory bank the bank  can be the same or a different one in case of a read  operation. Two consecutive synchronous read  operations in Burst or Single mode followed by any  synchronous/asynchronous read or write from/to  another static memory bank. There is a bus turnaround  delay of 3 FMC clock cycle between: Two consecutive  synchronous write operations in Burst or Single  mode to different static banks. A synchronous write  access in Burst or Single mode and a synchronous  read from the same or a different bank. The bus  turnaround delay allows to match the minimum time  between consecutive transactions tEHEL from NEx high  to NEx low and the maximum time required by the  memory to free the data bus after a read access  tEHQZ: BUSTRUN + 1 KCK_FMC period &#8805;  tEHELmin and BUSTRUN + 2KCK_FMC period &#8805;  tEHQZmax if EXTMOD = 0 BUSTRUN + 2KCK_FMC period  &#8805; max tEHELmin, tEHQZmax if EXTMOD =1.  ...)  
        .equ FMC_BTR4_CLKDIV_Shift, 20   @ bitWidth 4 (Clock divide ratio for FMC_CLK signal  These bits define the period of FMC_CLK clock output  signal, expressed in number of KCK_FMC cycles: In  asynchronous NOR Flash, SRAM or PSRAM accesses, this  value is dont care. Note: Refer to Section20.6.5:  Synchronous transactions for FMC_CLK divider ratio  formula)  
        .equ FMC_BTR4_DATLAT_Shift, 24   @ bitWidth 4 (Data latency for synchronous memory For  synchronous access with read write burst mode enabled  these bits define the number of memory clock  cycles)  
        .equ FMC_BTR4_ACCMOD_Shift, 28   @ bitWidth 2 (Access mode These bits specify the  asynchronous access modes as shown in the timing  diagrams. They are taken into account only when the  EXTMOD bit in the FMC_BCRx register is  1.)  
 
    .equ FMC_PCR, FMC_BASE + 0x80 @ (NAND Flash control registers) 
        .equ FMC_PCR_PWAITEN, 1 << 1   @ bitWidth 1 (Wait feature enable bit. This bit  enables the Wait feature for the NAND Flash memory  bank:)  
        .equ FMC_PCR_PBKEN, 1 << 2   @ bitWidth 1 (NAND Flash memory bank enable bit. This  bit enables the memory bank. Accessing a disabled  memory bank causes an ERROR on AXI bus)  
        .equ FMC_PCR_PWID_Shift, 4   @ bitWidth 2 (Data bus width. These bits define the  external memory device width.)  
        .equ FMC_PCR_ECCEN, 1 << 6   @ bitWidth 1 (ECC computation logic enable  bit)  
        .equ FMC_PCR_TCLR_Shift, 9   @ bitWidth 4 (CLE to RE delay. These bits set time  from CLE low to RE low in number of KCK_FMC clock  cycles. The time is give by the following formula:  t_clr = TCLR + SET + 2 TKCK_FMC where TKCK_FMC is  the KCK_FMC clock period Note: Set is MEMSET or  ATTSET according to the addressed  space.)  
        .equ FMC_PCR_TAR_Shift, 13   @ bitWidth 4 (ALE to RE delay. These bits set time  from ALE low to RE low in number of KCK_FMC clock  cycles. Time is: t_ar = TAR + SET + 2 TKCK_FMC  where TKCK_FMC is the FMC clock period Note: Set is  MEMSET or ATTSET according to the addressed  space.)  
        .equ FMC_PCR_ECCPS_Shift, 17   @ bitWidth 3 (ECC page size. These bits define the  page size for the extended ECC:)  
 
    .equ FMC_SR, FMC_BASE + 0x84 @ (This register contains information about the  FIFO status and interrupt. The FMC features a FIFO that  is used when writing to memories to transfer up to 16  words of data.This is used to quickly write to the FIFO  and free the AXI bus for transactions to peripherals  other than the FMC, while the FMC is draining its FIFO  into the memory. One of these register bits indicates the  status of the FIFO, for ECC purposes.The ECC is  calculated while the data are written to the memory. To  read the correct ECC, the software must consequently wait  until the FIFO is empty.) 
        .equ FMC_SR_IRS, 1 << 0   @ bitWidth 1 (Interrupt rising edge status The flag is  set by hardware and reset by software. Note: If this  bit is written by software to 1 it will be  set.)  
        .equ FMC_SR_ILS, 1 << 1   @ bitWidth 1 (Interrupt high-level status The flag is  set by hardware and reset by software.)  
        .equ FMC_SR_IFS, 1 << 2   @ bitWidth 1 (Interrupt falling edge status The flag  is set by hardware and reset by software. Note: If  this bit is written by software to 1 it will be  set.)  
        .equ FMC_SR_IREN, 1 << 3   @ bitWidth 1 (Interrupt rising edge detection enable  bit)  
        .equ FMC_SR_ILEN, 1 << 4   @ bitWidth 1 (Interrupt high-level detection enable  bit)  
        .equ FMC_SR_IFEN, 1 << 5   @ bitWidth 1 (Interrupt falling edge detection enable  bit)  
        .equ FMC_SR_FEMPT, 1 << 6   @ bitWidth 1 (FIFO empty. Read-only bit that provides  the status of the FIFO)  
 
    .equ FMC_PMEM, FMC_BASE + 0x88 @ (The FMC_PMEM read/write register contains  the timing information for NAND Flash memory bank. This  information is used to access either the common memory  space of the NAND Flash for command, address write access  and data read/write access.) 
        .equ FMC_PMEM_MEMSET_Shift, 0   @ bitWidth 8 (Common memory x setup time These bits  define the number of KCK_FMC +1 clock cycles to set  up the address before the command assertion NWE,  NOE, for NAND Flash read or write access to common  memory space:)  
        .equ FMC_PMEM_MEMWAIT_Shift, 8   @ bitWidth 8 (Common memory wait time These bits  define the minimum number of KCK_FMC +1 clock  cycles to assert the command NWE, NOE, for NAND  Flash read or write access to common memory space.  The duration of command assertion is extended if the  wait signal NWAIT is active low at the end of the  programmed value of KCK_FMC:)  
        .equ FMC_PMEM_MEMHOLD_Shift, 16   @ bitWidth 8 (Common memory hold time These bits  define the number of KCK_FMC clock cycles for write  accesses and KCK_FMC+1 clock cycles for read accesses  during which the address is held and data for write  accesses after the command is de-asserted NWE,  NOE, for NAND Flash read or write access to common  memory space:)  
        .equ FMC_PMEM_MEMHIZ_Shift, 24   @ bitWidth 8 (Common memory x data bus Hi-Z time These  bits define the number of KCK_FMC clock cycles during  which the data bus is kept Hi-Z after the start of a  NAND Flash write access to common memory space. This  is only valid for write transactions:)  
 
    .equ FMC_PATT, FMC_BASE + 0x8C @ (The FMC_PATT read/write register contains  the timing information for NAND Flash memory bank. It is  used for 8-bit accesses to the attribute memory space of  the NAND Flash for the last address write access if the  timing must differ from that of previous accesses for  Ready/Busy management, refer to Section20.8.5: NAND Flash  prewait feature.) 
        .equ FMC_PATT_ATTSET_Shift, 0   @ bitWidth 8 (Attribute memory setup time These bits  define the number of KCK_FMC +1 clock cycles to set  up address before the command assertion NWE, NOE,  for NAND Flash read or write access to attribute  memory space:)  
        .equ FMC_PATT_ATTWAIT_Shift, 8   @ bitWidth 8 (Attribute memory wait time These bits  define the minimum number of x KCK_FMC +1 clock  cycles to assert the command NWE, NOE, for NAND  Flash read or write access to attribute memory space.  The duration for command assertion is extended if the  wait signal NWAIT is active low at the end of the  programmed value of KCK_FMC:)  
        .equ FMC_PATT_ATTHOLD_Shift, 16   @ bitWidth 8 (Attribute memory hold time These bits  define the number of KCK_FMC clock cycles during  which the address is held and data for write access  after the command de-assertion NWE, NOE, for NAND  Flash read or write access to attribute memory  space:)  
        .equ FMC_PATT_ATTHIZ_Shift, 24   @ bitWidth 8 (Attribute memory data bus Hi-Z time  These bits define the number of KCK_FMC clock cycles  during which the data bus is kept in Hi-Z after the  start of a NAND Flash write access to attribute  memory space on socket. Only valid for writ  transaction:)  
 
    .equ FMC_ECCR, FMC_BASE + 0x94 @ (This register contain the current error  correction code value computed by the ECC computation  modules of the FMC NAND controller. When the CPU  reads/writes the data from a NAND Flash memory page at  the correct address refer to Section20.8.6: Computation  of the error correction code ECC in NAND Flash memory,  the data read/written from/to the NAND Flash memory are  processed automatically by the ECC computation module.  When X bytes have been read according to the ECCPS field  in the FMC_PCR registers, the CPU must read the computed  ECC value from the FMC_ECC registers. It then verifies if  these computed parity data are the same as the parity  value recorded in the spare area, to determine whether a  page is valid, and, to correct it otherwise. The FMC_ECCR  register should be cleared after being read by setting  the ECCEN bit to 0. To compute a new data block, the  ECCEN bit must be set to 1.) 
        .equ FMC_ECCR_ECC_Shift, 0   @ bitWidth 32 (ECC result This field contains the value  computed by the ECC computation logic. Table167  describes the contents of these bit  fields.)  
 
    .equ FMC_BWTR1, FMC_BASE + 0x104 @ (This register contains the control  information of each memory bank. It is used for SRAMs,  PSRAMs and NOR Flash memories. When the EXTMOD bit is set  in the FMC_BCRx register, then this register is active  for write access.) 
        .equ FMC_BWTR1_ADDSET_Shift, 0   @ bitWidth 4 (Address setup phase duration. These bits  are written by software to define the duration of the  address setup phase in KCK_FMC cycles refer to  Figure81 to Figure93, used in asynchronous accesses:  ... Note: In synchronous accesses, this value is not  used, the address setup phase is always 1 Flash clock  period duration. In muxed mode, the minimum ADDSET  value is 1.)  
        .equ FMC_BWTR1_ADDHLD_Shift, 4   @ bitWidth 4 (Address-hold phase duration. These bits  are written by software to define the duration of the  address hold phase refer to Figure81 to Figure93,  used in asynchronous multiplexed accesses: ... Note:  In synchronous NOR Flash accesses, this value is not  used, the address hold phase is always 1 Flash clock  period duration.)  
        .equ FMC_BWTR1_DATAST_Shift, 8   @ bitWidth 8 (Data-phase duration. These bits are  written by software to define the duration of the  data phase refer to Figure81 to Figure93, used in  asynchronous SRAM, PSRAM and NOR Flash memory  accesses:)  
        .equ FMC_BWTR1_BUSTURN_Shift, 16   @ bitWidth 4 (Bus turnaround phase duration These bits  are written by software to add a delay at the end of  a write transaction to match the minimum time between  consecutive transactions tEHEL from ENx high to ENx  low: BUSTRUN + 1 KCK_FMC period &#8805;  tEHELmin. The programmed bus turnaround delay is  inserted between a an asynchronous write transfer and  any other asynchronous /synchronous read or write  transfer to or from a static bank. If a read  operation is performed, the bank can be the same or a  different one, whereas it must be different in case  of write operation to the bank, except in muxed mode  or mode D. In some cases, whatever the programmed  BUSTRUN values, the bus turnaround delay is fixed as  follows: The bus turnaround delay is not inserted  between two consecutive asynchronous write transfers  to the same static memory bank except for muxed mode  and mode D. There is a bus turnaround delay of 2 FMC  clock cycle between: Two consecutive synchronous  write operations in Burst or Single mode to the  same bank A synchronous write transfer in Burst or  Single mode and an asynchronous write or read  transfer to or from static memory bank. There is a  bus turnaround delay of 3 FMC clock cycle between:  Two consecutive synchronous write operations in  Burst or Single mode to different static banks. A  synchronous write transfer in Burst or Single mode  and a synchronous read from the same or a different  bank. ...)  
        .equ FMC_BWTR1_ACCMOD_Shift, 28   @ bitWidth 2 (Access mode. These bits specify the  asynchronous access modes as shown in the next timing  diagrams.These bits are taken into account only when  the EXTMOD bit in the FMC_BCRx register is  1.)  
 
    .equ FMC_BWTR2, FMC_BASE + 0x10C @ (This register contains the control  information of each memory bank. It is used for SRAMs,  PSRAMs and NOR Flash memories. When the EXTMOD bit is set  in the FMC_BCRx register, then this register is active  for write access.) 
        .equ FMC_BWTR2_ADDSET_Shift, 0   @ bitWidth 4 (Address setup phase duration. These bits  are written by software to define the duration of the  address setup phase in KCK_FMC cycles refer to  Figure81 to Figure93, used in asynchronous accesses:  ... Note: In synchronous accesses, this value is not  used, the address setup phase is always 1 Flash clock  period duration. In muxed mode, the minimum ADDSET  value is 1.)  
        .equ FMC_BWTR2_ADDHLD_Shift, 4   @ bitWidth 4 (Address-hold phase duration. These bits  are written by software to define the duration of the  address hold phase refer to Figure81 to Figure93,  used in asynchronous multiplexed accesses: ... Note:  In synchronous NOR Flash accesses, this value is not  used, the address hold phase is always 1 Flash clock  period duration.)  
        .equ FMC_BWTR2_DATAST_Shift, 8   @ bitWidth 8 (Data-phase duration. These bits are  written by software to define the duration of the  data phase refer to Figure81 to Figure93, used in  asynchronous SRAM, PSRAM and NOR Flash memory  accesses:)  
        .equ FMC_BWTR2_BUSTURN_Shift, 16   @ bitWidth 4 (Bus turnaround phase duration These bits  are written by software to add a delay at the end of  a write transaction to match the minimum time between  consecutive transactions tEHEL from ENx high to ENx  low: BUSTRUN + 1 KCK_FMC period &#8805;  tEHELmin. The programmed bus turnaround delay is  inserted between a an asynchronous write transfer and  any other asynchronous /synchronous read or write  transfer to or from a static bank. If a read  operation is performed, the bank can be the same or a  different one, whereas it must be different in case  of write operation to the bank, except in muxed mode  or mode D. In some cases, whatever the programmed  BUSTRUN values, the bus turnaround delay is fixed as  follows: The bus turnaround delay is not inserted  between two consecutive asynchronous write transfers  to the same static memory bank except for muxed mode  and mode D. There is a bus turnaround delay of 2 FMC  clock cycle between: Two consecutive synchronous  write operations in Burst or Single mode to the  same bank A synchronous write transfer in Burst or  Single mode and an asynchronous write or read  transfer to or from static memory bank. There is a  bus turnaround delay of 3 FMC clock cycle between:  Two consecutive synchronous write operations in  Burst or Single mode to different static banks. A  synchronous write transfer in Burst or Single mode  and a synchronous read from the same or a different  bank. ...)  
        .equ FMC_BWTR2_ACCMOD_Shift, 28   @ bitWidth 2 (Access mode. These bits specify the  asynchronous access modes as shown in the next timing  diagrams.These bits are taken into account only when  the EXTMOD bit in the FMC_BCRx register is  1.)  
 
    .equ FMC_BWTR3, FMC_BASE + 0x114 @ (This register contains the control  information of each memory bank. It is used for SRAMs,  PSRAMs and NOR Flash memories. When the EXTMOD bit is set  in the FMC_BCRx register, then this register is active  for write access.) 
        .equ FMC_BWTR3_ADDSET_Shift, 0   @ bitWidth 4 (Address setup phase duration. These bits  are written by software to define the duration of the  address setup phase in KCK_FMC cycles refer to  Figure81 to Figure93, used in asynchronous accesses:  ... Note: In synchronous accesses, this value is not  used, the address setup phase is always 1 Flash clock  period duration. In muxed mode, the minimum ADDSET  value is 1.)  
        .equ FMC_BWTR3_ADDHLD_Shift, 4   @ bitWidth 4 (Address-hold phase duration. These bits  are written by software to define the duration of the  address hold phase refer to Figure81 to Figure93,  used in asynchronous multiplexed accesses: ... Note:  In synchronous NOR Flash accesses, this value is not  used, the address hold phase is always 1 Flash clock  period duration.)  
        .equ FMC_BWTR3_DATAST_Shift, 8   @ bitWidth 8 (Data-phase duration. These bits are  written by software to define the duration of the  data phase refer to Figure81 to Figure93, used in  asynchronous SRAM, PSRAM and NOR Flash memory  accesses:)  
        .equ FMC_BWTR3_BUSTURN_Shift, 16   @ bitWidth 4 (Bus turnaround phase duration These bits  are written by software to add a delay at the end of  a write transaction to match the minimum time between  consecutive transactions tEHEL from ENx high to ENx  low: BUSTRUN + 1 KCK_FMC period &#8805;  tEHELmin. The programmed bus turnaround delay is  inserted between a an asynchronous write transfer and  any other asynchronous /synchronous read or write  transfer to or from a static bank. If a read  operation is performed, the bank can be the same or a  different one, whereas it must be different in case  of write operation to the bank, except in muxed mode  or mode D. In some cases, whatever the programmed  BUSTRUN values, the bus turnaround delay is fixed as  follows: The bus turnaround delay is not inserted  between two consecutive asynchronous write transfers  to the same static memory bank except for muxed mode  and mode D. There is a bus turnaround delay of 2 FMC  clock cycle between: Two consecutive synchronous  write operations in Burst or Single mode to the  same bank A synchronous write transfer in Burst or  Single mode and an asynchronous write or read  transfer to or from static memory bank. There is a  bus turnaround delay of 3 FMC clock cycle between:  Two consecutive synchronous write operations in  Burst or Single mode to different static banks. A  synchronous write transfer in Burst or Single mode  and a synchronous read from the same or a different  bank. ...)  
        .equ FMC_BWTR3_ACCMOD_Shift, 28   @ bitWidth 2 (Access mode. These bits specify the  asynchronous access modes as shown in the next timing  diagrams.These bits are taken into account only when  the EXTMOD bit in the FMC_BCRx register is  1.)  
 
    .equ FMC_BWTR4, FMC_BASE + 0x11C @ (This register contains the control  information of each memory bank. It is used for SRAMs,  PSRAMs and NOR Flash memories. When the EXTMOD bit is set  in the FMC_BCRx register, then this register is active  for write access.) 
        .equ FMC_BWTR4_ADDSET_Shift, 0   @ bitWidth 4 (Address setup phase duration. These bits  are written by software to define the duration of the  address setup phase in KCK_FMC cycles refer to  Figure81 to Figure93, used in asynchronous accesses:  ... Note: In synchronous accesses, this value is not  used, the address setup phase is always 1 Flash clock  period duration. In muxed mode, the minimum ADDSET  value is 1.)  
        .equ FMC_BWTR4_ADDHLD_Shift, 4   @ bitWidth 4 (Address-hold phase duration. These bits  are written by software to define the duration of the  address hold phase refer to Figure81 to Figure93,  used in asynchronous multiplexed accesses: ... Note:  In synchronous NOR Flash accesses, this value is not  used, the address hold phase is always 1 Flash clock  period duration.)  
        .equ FMC_BWTR4_DATAST_Shift, 8   @ bitWidth 8 (Data-phase duration. These bits are  written by software to define the duration of the  data phase refer to Figure81 to Figure93, used in  asynchronous SRAM, PSRAM and NOR Flash memory  accesses:)  
        .equ FMC_BWTR4_BUSTURN_Shift, 16   @ bitWidth 4 (Bus turnaround phase duration These bits  are written by software to add a delay at the end of  a write transaction to match the minimum time between  consecutive transactions tEHEL from ENx high to ENx  low: BUSTRUN + 1 KCK_FMC period &#8805;  tEHELmin. The programmed bus turnaround delay is  inserted between a an asynchronous write transfer and  any other asynchronous /synchronous read or write  transfer to or from a static bank. If a read  operation is performed, the bank can be the same or a  different one, whereas it must be different in case  of write operation to the bank, except in muxed mode  or mode D. In some cases, whatever the programmed  BUSTRUN values, the bus turnaround delay is fixed as  follows: The bus turnaround delay is not inserted  between two consecutive asynchronous write transfers  to the same static memory bank except for muxed mode  and mode D. There is a bus turnaround delay of 2 FMC  clock cycle between: Two consecutive synchronous  write operations in Burst or Single mode to the  same bank A synchronous write transfer in Burst or  Single mode and an asynchronous write or read  transfer to or from static memory bank. There is a  bus turnaround delay of 3 FMC clock cycle between:  Two consecutive synchronous write operations in  Burst or Single mode to different static banks. A  synchronous write transfer in Burst or Single mode  and a synchronous read from the same or a different  bank. ...)  
        .equ FMC_BWTR4_ACCMOD_Shift, 28   @ bitWidth 2 (Access mode. These bits specify the  asynchronous access modes as shown in the next timing  diagrams.These bits are taken into account only when  the EXTMOD bit in the FMC_BCRx register is  1.)  
 
    .equ FMC_SDCR1, FMC_BASE + 0x140 @ (This register contains the control  parameters for each SDRAM memory bank) 
        .equ FMC_SDCR1_NC_Shift, 0   @ bitWidth 2 (Number of column address bits These bits  define the number of bits of a column  address.)  
        .equ FMC_SDCR1_NR_Shift, 2   @ bitWidth 2 (Number of row address bits These bits  define the number of bits of a row  address.)  
        .equ FMC_SDCR1_MWID_Shift, 4   @ bitWidth 2 (Memory data bus width. These bits define  the memory device width.)  
        .equ FMC_SDCR1_NB, 1 << 6   @ bitWidth 1 (Number of internal banks This bit sets  the number of internal banks.)  
        .equ FMC_SDCR1_CAS_Shift, 7   @ bitWidth 2 (CAS Latency This bits sets the SDRAM CAS  latency in number of memory clock  cycles)  
        .equ FMC_SDCR1_WP, 1 << 9   @ bitWidth 1 (Write protection This bit enables write  mode access to the SDRAM bank.)  
        .equ FMC_SDCR1_SDCLK_Shift, 10   @ bitWidth 2 (SDRAM clock configuration These bits  define the SDRAM clock period for both SDRAM banks  and allow disabling the clock before changing the  frequency. In this case the SDRAM must be  re-initialized. Note: The corresponding bits in the  FMC_SDCR2 register is read only.)  
        .equ FMC_SDCR1_RBURST, 1 << 12   @ bitWidth 1 (Burst read This bit enables burst read  mode. The SDRAM controller anticipates the next read  commands during the CAS latency and stores data in  the Read FIFO. Note: The corresponding bit in the  FMC_SDCR2 register is read only.)  
        .equ FMC_SDCR1_RPIPE_Shift, 13   @ bitWidth 2 (Read pipe These bits define the delay,  in KCK_FMC clock cycles, for reading data after CAS  latency. Note: The corresponding bits in the  FMC_SDCR2 register is read only.)  
 
    .equ FMC_SDCR2, FMC_BASE + 0x144 @ (This register contains the control  parameters for each SDRAM memory bank) 
        .equ FMC_SDCR2_NC_Shift, 0   @ bitWidth 2 (Number of column address bits These bits  define the number of bits of a column  address.)  
        .equ FMC_SDCR2_NR_Shift, 2   @ bitWidth 2 (Number of row address bits These bits  define the number of bits of a row  address.)  
        .equ FMC_SDCR2_MWID_Shift, 4   @ bitWidth 2 (Memory data bus width. These bits define  the memory device width.)  
        .equ FMC_SDCR2_NB, 1 << 6   @ bitWidth 1 (Number of internal banks This bit sets  the number of internal banks.)  
        .equ FMC_SDCR2_CAS_Shift, 7   @ bitWidth 2 (CAS Latency This bits sets the SDRAM CAS  latency in number of memory clock  cycles)  
        .equ FMC_SDCR2_WP, 1 << 9   @ bitWidth 1 (Write protection This bit enables write  mode access to the SDRAM bank.)  
        .equ FMC_SDCR2_SDCLK_Shift, 10   @ bitWidth 2 (SDRAM clock configuration These bits  define the SDRAM clock period for both SDRAM banks  and allow disabling the clock before changing the  frequency. In this case the SDRAM must be  re-initialized. Note: The corresponding bits in the  FMC_SDCR2 register is read only.)  
        .equ FMC_SDCR2_RBURST, 1 << 12   @ bitWidth 1 (Burst read This bit enables burst read  mode. The SDRAM controller anticipates the next read  commands during the CAS latency and stores data in  the Read FIFO. Note: The corresponding bit in the  FMC_SDCR2 register is read only.)  
        .equ FMC_SDCR2_RPIPE_Shift, 13   @ bitWidth 2 (Read pipe These bits define the delay,  in KCK_FMC clock cycles, for reading data after CAS  latency. Note: The corresponding bits in the  FMC_SDCR2 register is read only.)  
 
    .equ FMC_SDTR1, FMC_BASE + 0x148 @ (This register contains the timing parameters  of each SDRAM bank) 
        .equ FMC_SDTR1_TMRD_Shift, 0   @ bitWidth 4 (Load Mode Register to Active These bits  define the delay between a Load Mode Register command  and an Active or Refresh command in number of memory  clock cycles. ....)  
        .equ FMC_SDTR1_TXSR_Shift, 4   @ bitWidth 4 (Exit Self-refresh delay These bits  define the delay from releasing the Self-refresh  command to issuing the Activate command in number of  memory clock cycles. .... Note: If two SDRAM devices  are used, the FMC_SDTR1 and FMC_SDTR2 must be  programmed with the same TXSR timing corresponding to  the slowest SDRAM device.)  
        .equ FMC_SDTR1_TRAS_Shift, 8   @ bitWidth 4 (Self refresh time These bits define the  minimum Self-refresh period in number of memory clock  cycles. ....)  
        .equ FMC_SDTR1_TRC_Shift, 12   @ bitWidth 4 (Row cycle delay These bits define the  delay between the Refresh command and the Activate  command, as well as the delay between two consecutive  Refresh commands. It is expressed in number of memory  clock cycles. The TRC timing is only configured in  the FMC_SDTR1 register. If two SDRAM devices are  used, the TRC must be programmed with the timings of  the slowest device. .... Note: TRC must match the TRC  and TRFC Auto Refresh period timings defined in the  SDRAM device datasheet. Note: The corresponding bits  in the FMC_SDTR2 register are dont  care.)  
        .equ FMC_SDTR1_TWR_Shift, 16   @ bitWidth 4 (Recovery delay These bits define the  delay between a Write and a Precharge command in  number of memory clock cycles. .... Note: TWR must be  programmed to match the write recovery time tWR  defined in the SDRAM datasheet, and to guarantee  that: TWR &#8805; TRAS - TRCD and TWR  &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles,  TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must  be programmed to 0x1. If two SDRAM devices are used,  the FMC_SDTR1 and FMC_SDTR2 must be programmed with  the same TWR timing corresponding to the slowest  SDRAM device.)  
        .equ FMC_SDTR1_TRP_Shift, 20   @ bitWidth 4 (Row precharge delay These bits define  the delay between a Precharge command and another  command in number of memory clock cycles. The TRP  timing is only configured in the FMC_SDTR1 register.  If two SDRAM devices are used, the TRP must be  programmed with the timing of the slowest device.  .... Note: The corresponding bits in the FMC_SDTR2  register are dont care.)  
        .equ FMC_SDTR1_TRCD_Shift, 24   @ bitWidth 4 (Row to column delay These bits define  the delay between the Activate command and a  Read/Write command in number of memory clock cycles.  ....)  
 
    .equ FMC_SDTR2, FMC_BASE + 0x14C @ (This register contains the timing parameters  of each SDRAM bank) 
        .equ FMC_SDTR2_TMRD_Shift, 0   @ bitWidth 4 (Load Mode Register to Active These bits  define the delay between a Load Mode Register command  and an Active or Refresh command in number of memory  clock cycles. ....)  
        .equ FMC_SDTR2_TXSR_Shift, 4   @ bitWidth 4 (Exit Self-refresh delay These bits  define the delay from releasing the Self-refresh  command to issuing the Activate command in number of  memory clock cycles. .... Note: If two SDRAM devices  are used, the FMC_SDTR1 and FMC_SDTR2 must be  programmed with the same TXSR timing corresponding to  the slowest SDRAM device.)  
        .equ FMC_SDTR2_TRAS_Shift, 8   @ bitWidth 4 (Self refresh time These bits define the  minimum Self-refresh period in number of memory clock  cycles. ....)  
        .equ FMC_SDTR2_TRC_Shift, 12   @ bitWidth 4 (Row cycle delay These bits define the  delay between the Refresh command and the Activate  command, as well as the delay between two consecutive  Refresh commands. It is expressed in number of memory  clock cycles. The TRC timing is only configured in  the FMC_SDTR1 register. If two SDRAM devices are  used, the TRC must be programmed with the timings of  the slowest device. .... Note: TRC must match the TRC  and TRFC Auto Refresh period timings defined in the  SDRAM device datasheet. Note: The corresponding bits  in the FMC_SDTR2 register are dont  care.)  
        .equ FMC_SDTR2_TWR_Shift, 16   @ bitWidth 4 (Recovery delay These bits define the  delay between a Write and a Precharge command in  number of memory clock cycles. .... Note: TWR must be  programmed to match the write recovery time tWR  defined in the SDRAM datasheet, and to guarantee  that: TWR &#8805; TRAS - TRCD and TWR  &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles,  TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must  be programmed to 0x1. If two SDRAM devices are used,  the FMC_SDTR1 and FMC_SDTR2 must be programmed with  the same TWR timing corresponding to the slowest  SDRAM device.)  
        .equ FMC_SDTR2_TRP_Shift, 20   @ bitWidth 4 (Row precharge delay These bits define  the delay between a Precharge command and another  command in number of memory clock cycles. The TRP  timing is only configured in the FMC_SDTR1 register.  If two SDRAM devices are used, the TRP must be  programmed with the timing of the slowest device.  .... Note: The corresponding bits in the FMC_SDTR2  register are dont care.)  
        .equ FMC_SDTR2_TRCD_Shift, 24   @ bitWidth 4 (Row to column delay These bits define  the delay between the Activate command and a  Read/Write command in number of memory clock cycles.  ....)  
 
    .equ FMC_SDCMR, FMC_BASE + 0x150 @ (This register contains the command issued  when the SDRAM device is accessed. This register is used  to initialize the SDRAM device, and to activate the  Self-refresh and the Power-down modes. As soon as the  MODE field is written, the command will be issued only to  one or to both SDRAM banks according to CTB1 and CTB2  command bits. This register is the same for both SDRAM  banks.) 
        .equ FMC_SDCMR_MODE_Shift, 0   @ bitWidth 3 (Command mode These bits define the  command issued to the SDRAM device. Note: When a  command is issued, at least one Command Target Bank  bit  CTB1 or CTB2 must be set otherwise the command  will be ignored. Note: If two SDRAM banks are used,  the Auto-refresh and PALL command must be issued  simultaneously to the two devices with CTB1 and CTB2  bits set otherwise the command will be ignored. Note:  If only one SDRAM bank is used and a command is  issued with its associated CTB bit set, the other CTB  bit of the unused bank must be kept to  0.)  
        .equ FMC_SDCMR_CTB2, 1 << 3   @ bitWidth 1 (Command Target Bank 2 This bit indicates  whether the command will be issued to SDRAM Bank 2 or  not.)  
        .equ FMC_SDCMR_CTB1, 1 << 4   @ bitWidth 1 (Command Target Bank 1 This bit indicates  whether the command will be issued to SDRAM Bank 1 or  not.)  
        .equ FMC_SDCMR_NRFS_Shift, 5   @ bitWidth 4 (Number of Auto-refresh These bits define  the number of consecutive Auto-refresh commands  issued when MODE = 011. ....)  
        .equ FMC_SDCMR_MRD_Shift, 9   @ bitWidth 14 (Mode Register definition This 14-bit  field defines the SDRAM Mode Register content. The  Mode Register is programmed using the Load Mode  Register command. The MRD[13:0] bits are also used to  program the extended mode register for mobile  SDRAM.)  
 
    .equ FMC_SDRTR, FMC_BASE + 0x154 @ (This register sets the refresh rate in  number of SDCLK clock cycles between the refresh cycles  by configuring the Refresh Timer Count value.Examplewhere  64 ms is the SDRAM refresh period.The refresh rate must  be increased by 20 SDRAM clock cycles as in the above  example to obtain a safe margin if an internal refresh  request occurs when a read request has been accepted. It  corresponds to a COUNT value of 0000111000000 448. This  13-bit field is loaded into a timer which is decremented  using the SDRAM clock. This timer generates a refresh  pulse when zero is reached. The COUNT value must be set  at least to 41 SDRAM clock cycles.As soon as the  FMC_SDRTR register is programmed, the timer starts  counting. If the value programmed in the register is 0,  no refresh is carried out. This register must not be  reprogrammed after the initialization procedure to avoid  modifying the refresh rate.Each time a refresh pulse is  generated, this 13-bit COUNT field is reloaded into the  counter.If a memory access is in progress, the  Auto-refresh request is delayed. However, if the memory  access and Auto-refresh requests are generated  simultaneously, the Auto-refresh takes precedence. If the  memory access occurs during a refresh operation, the  request is buffered to be processed when the refresh is  complete.This register is common to SDRAM bank 1 and bank  2.) 
        .equ FMC_SDRTR_CRE, 1 << 0   @ bitWidth 1 (Clear Refresh error flag This bit is  used to clear the Refresh Error Flag RE in the  Status Register.)  
        .equ FMC_SDRTR_COUNT_Shift, 1   @ bitWidth 13 (Refresh Timer Count This 13-bit field  defines the refresh rate of the SDRAM device. It is  expressed in number of memory clock cycles. It must  be set at least to 41 SDRAM clock cycles 0x29.  Refresh rate = COUNT + 1 x SDRAM frequency clock  COUNT = SDRAM refresh period / Number of rows -  20)  
        .equ FMC_SDRTR_REIE, 1 << 14   @ bitWidth 1 (RES Interrupt Enable)  
 
    .equ FMC_SDSR, FMC_BASE + 0x158 @ (SDRAM Status register) 
        .equ FMC_SDSR_RE, 1 << 0   @ bitWidth 1 (Refresh error flag An interrupt is  generated if REIE = 1 and RE = 1)  
        .equ FMC_SDSR_MODES1_Shift, 1   @ bitWidth 2 (Status Mode for Bank 1 These bits define  the Status Mode of SDRAM Bank 1.)  
        .equ FMC_SDSR_MODES2_Shift, 3   @ bitWidth 2 (Status Mode for Bank 2 These bits define  the Status Mode of SDRAM Bank 2.)  
 

@=========================== CEC ===========================@
.equ CEC_BASE, 0x40006C00 @ (CEC) 
    .equ CEC_CR, CEC_BASE + 0x0 @ (CEC control register) 
        .equ CEC_CR_CECEN, 1 << 0   @ bitWidth 1 (CEC Enable The CECEN bit is set and  cleared by software. CECEN=1 starts message reception  and enables the TXSOM control. CECEN=0 disables the  CEC peripheral, clears all bits of CEC_CR register  and aborts any on-going reception or  transmission.)  
        .equ CEC_CR_TXSOM, 1 << 1   @ bitWidth 1 (Tx Start Of Message TXSOM is set by  software to command transmission of the first byte of  a CEC message. If the CEC message consists of only  one byte, TXEOM must be set before of TXSOM.  Start-Bit is effectively started on the CEC line  after SFT is counted. If TXSOM is set while a message  reception is ongoing, transmission will start after  the end of reception. TXSOM is cleared by hardware  after the last byte of the message is sent with a  positive acknowledge TXEND=1, in case of  transmission underrun TXUDR=1, negative acknowledge  TXACKE=1, and transmission error TXERR=1. It is  also cleared by CECEN=0. It is not cleared and  transmission is automatically retried in case of  arbitration lost ARBLST=1. TXSOM can be also used  as a status bit informing application whether any  transmission request is pending or under execution.  The application can abort a transmission request at  any time by clearing the CECEN bit. Note: TXSOM must  be set when CECEN=1 TXSOM must be set when  transmission data is available into TXDR HEADERs  first four bits containing own peripheral address are  taken from TXDR[7:4], not from CEC_CFGR.OAR which is  used only for reception)  
        .equ CEC_CR_TXEOM, 1 << 2   @ bitWidth 1 (Tx End Of Message The TXEOM bit is set  by software to command transmission of the last byte  of a CEC message. TXEOM is cleared by hardware at the  same time and under the same conditions as for TXSOM.  Note: TXEOM must be set when CECEN=1 TXEOM must be  set before writing transmission data to TXDR If TXEOM  is set when TXSOM=0, transmitted message will consist  of 1 byte HEADER only PING message)  
 
    .equ CEC_CFGR, CEC_BASE + 0x4 @ (This register is used to configure the  HDMI-CEC controller. It is mandatory to write CEC_CFGR  only when CECEN=0.) 
        .equ CEC_CFGR_SFT_Shift, 0   @ bitWidth 3 (Signal Free Time SFT bits are set by  software. In the SFT=0x0 configuration the number of  nominal data bit periods waited before transmission  is ruled by hardware according to the transmission  history. In all the other configurations the SFT  number is determined by software. * 0x0 ** 2.5  Data-Bit periods if CEC is the last bus initiator  with unsuccessful transmission ARBLST=1, TXERR=1,  TXUDR=1 or TXACKE= 1 ** 4 Data-Bit periods if CEC is  the new bus initiator ** 6 Data-Bit periods if CEC is  the last bus initiator with successful transmission  TXEOM=1 * 0x1: 0.5 nominal data bit periods * 0x2:  1.5 nominal data bit periods * 0x3: 2.5 nominal data  bit periods * 0x4: 3.5 nominal data bit periods *  0x5: 4.5 nominal data bit periods * 0x6: 5.5 nominal  data bit periods * 0x7: 6.5 nominal data bit  periods)  
        .equ CEC_CFGR_RXTOL, 1 << 3   @ bitWidth 1 (Rx-Tolerance The RXTOL bit is set and  cleared by software. ** Start-Bit, +/- 200 s rise,  +/- 200 s fall. ** Data-Bit: +/- 200 s rise. +/- 350  s fall. ** Start-Bit: +/- 400 s rise, +/- 400 s fall  ** Data-Bit: +/-300 s rise, +/- 500 s  fall)  
        .equ CEC_CFGR_BRESTP, 1 << 4   @ bitWidth 1 (Rx-Stop on Bit Rising Error The BRESTP  bit is set and cleared by software.)  
        .equ CEC_CFGR_BREGEN, 1 << 5   @ bitWidth 1 (Generate Error-Bit on Bit Rising Error  The BREGEN bit is set and cleared by software. Note:  If BRDNOGEN=0, an Error-bit is generated upon BRE  detection with BRESTP=1 in broadcast even if  BREGEN=0)  
        .equ CEC_CFGR_LBPEGEN, 1 << 6   @ bitWidth 1 (Generate Error-Bit on Long Bit Period  Error The LBPEGEN bit is set and cleared by software.  Note: If BRDNOGEN=0, an Error-bit is generated upon  LBPE detection in broadcast even if  LBPEGEN=0)  
        .equ CEC_CFGR_BRDNOGEN, 1 << 7   @ bitWidth 1 (Avoid Error-Bit Generation in Broadcast  The BRDNOGEN bit is set and cleared by  software.)  
        .equ CEC_CFGR_SFTOPT, 1 << 8   @ bitWidth 1 (SFT Option Bit The SFTOPT bit is set and  cleared by software.)  
        .equ CEC_CFGR_OAR_Shift, 16   @ bitWidth 15 (Own addresses configuration The OAR bits  are set by software to select which destination  logical addresses has to be considered in receive  mode. Each bit, when set, enables the CEC logical  address identified by the given bit position. At the  end of HEADER reception, the received destination  address is compared with the enabled addresses. In  case of matching address, the incoming message is  acknowledged and received. In case of non-matching  address, the incoming message is received only in  listen mode LSTN=1, but without acknowledge sent.  Broadcast messages are always received. Example: OAR  = 0b000 0000 0010 0001 means that CEC acknowledges  addresses 0x0 and 0x5. Consequently, each message  directed to one of these addresses is  received.)  
        .equ CEC_CFGR_LSTN, 1 << 31   @ bitWidth 1 (Listen mode LSTN bit is set and cleared  by software.)  
 
    .equ CEC_TXDR, CEC_BASE + 0x8 @ (CEC Tx data register) 
        .equ CEC_TXDR_TXD_Shift, 0   @ bitWidth 8 (Tx Data register. TXD is a write-only  register containing the data byte to be transmitted.  Note: TXD must be written when  TXSTART=1)  
 
    .equ CEC_RXDR, CEC_BASE + 0xC @ (CEC Rx Data Register) 
        .equ CEC_RXDR_RXD_Shift, 0   @ bitWidth 8 (Rx Data register. RXD is read-only and  contains the last data byte which has been received  from the CEC line.)  
 
    .equ CEC_ISR, CEC_BASE + 0x10 @ (CEC Interrupt and Status  Register) 
        .equ CEC_ISR_RXBR, 1 << 0   @ bitWidth 1 (Rx-Byte Received The RXBR bit is set by  hardware to inform application that a new byte has  been received from the CEC line and stored into the  RXD buffer. RXBR is cleared by software write at  1.)  
        .equ CEC_ISR_RXEND, 1 << 1   @ bitWidth 1 (End Of Reception RXEND is set by  hardware to inform application that the last byte of  a CEC message is received from the CEC line and  stored into the RXD buffer. RXEND is set at the same  time of RXBR. RXEND is cleared by software write at  1.)  
        .equ CEC_ISR_RXOVR, 1 << 2   @ bitWidth 1 (Rx-Overrun RXOVR is set by hardware if  RXBR is not yet cleared at the time a new byte is  received on the CEC line and stored into RXD. RXOVR  assertion stops message reception so that no  acknowledge is sent. In case of broadcast, a negative  acknowledge is sent. RXOVR is cleared by software  write at 1.)  
        .equ CEC_ISR_BRE, 1 << 3   @ bitWidth 1 (Rx-Bit Rising Error BRE is set by  hardware in case a Data-Bit waveform is detected with  Bit Rising Error. BRE is set either at the time the  misplaced rising edge occurs, or at the end of the  maximum BRE tolerance allowed by RXTOL, in case  rising edge is still longing. BRE stops message  reception if BRESTP=1. BRE generates an Error-Bit on  the CEC line if BREGEN=1. BRE is cleared by software  write at 1.)  
        .equ CEC_ISR_SBPE, 1 << 4   @ bitWidth 1 (Rx-Short Bit Period Error SBPE is set by  hardware in case a Data-Bit waveform is detected with  Short Bit Period Error. SBPE is set at the time the  anticipated falling edge occurs. SBPE generates an  Error-Bit on the CEC line. SBPE is cleared by  software write at 1.)  
        .equ CEC_ISR_LBPE, 1 << 5   @ bitWidth 1 (Rx-Long Bit Period Error LBPE is set by  hardware in case a Data-Bit waveform is detected with  Long Bit Period Error. LBPE is set at the end of the  maximum bit-extension tolerance allowed by RXTOL, in  case falling edge is still longing. LBPE always stops  reception of the CEC message. LBPE generates an  Error-Bit on the CEC line if LBPEGEN=1. In case of  broadcast, Error-Bit is generated even in case of  LBPEGEN=0. LBPE is cleared by software write at  1.)  
        .equ CEC_ISR_RXACKE, 1 << 6   @ bitWidth 1 (Rx-Missing Acknowledge In receive mode,  RXACKE is set by hardware to inform application that  no acknowledge was seen on the CEC line. RXACKE  applies only for broadcast messages and in listen  mode also for not directly addressed messages  destination address not enabled in OAR. RXACKE  aborts message reception. RXACKE is cleared by  software write at 1.)  
        .equ CEC_ISR_ARBLST, 1 << 7   @ bitWidth 1 (Arbitration Lost ARBLST is set by  hardware to inform application that CEC device is  switching to reception due to arbitration lost event  following the TXSOM command. ARBLST can be due either  to a contending CEC device starting earlier or  starting at the same time but with higher HEADER  priority. After ARBLST assertion TXSOM bit keeps  pending for next transmission attempt. ARBLST is  cleared by software write at 1.)  
        .equ CEC_ISR_TXBR, 1 << 8   @ bitWidth 1 (Tx-Byte Request TXBR is set by hardware  to inform application that the next transmission data  has to be written to TXDR. TXBR is set when the 4th  bit of currently transmitted byte is sent.  Application must write the next byte to TXDR within 6  nominal data-bit periods before transmission underrun  error occurs TXUDR. TXBR is cleared by software  write at 1.)  
        .equ CEC_ISR_TXEND, 1 << 9   @ bitWidth 1 (End of Transmission TXEND is set by  hardware to inform application that the last byte of  the CEC message has been successfully transmitted.  TXEND clears the TXSOM and TXEOM control bits. TXEND  is cleared by software write at 1.)  
        .equ CEC_ISR_TXUDR, 1 << 10   @ bitWidth 1 (Tx-Buffer Underrun In transmission mode,  TXUDR is set by hardware if application was not in  time to load TXDR before of next byte transmission.  TXUDR aborts message transmission and clears TXSOM  and TXEOM control bits. TXUDR is cleared by software  write at 1)  
        .equ CEC_ISR_TXERR, 1 << 11   @ bitWidth 1 (Tx-Error In transmission mode, TXERR is  set by hardware if the CEC initiator detects low  impedance on the CEC line while it is released. TXERR  aborts message transmission and clears TXSOM and  TXEOM controls. TXERR is cleared by software write at  1.)  
        .equ CEC_ISR_TXACKE, 1 << 12   @ bitWidth 1 (Tx-Missing Acknowledge Error In  transmission mode, TXACKE is set by hardware to  inform application that no acknowledge was received.  In case of broadcast transmission, TXACKE informs  application that a negative acknowledge was received.  TXACKE aborts message transmission and clears TXSOM  and TXEOM controls. TXACKE is cleared by software  write at 1.)  
 
    .equ CEC_IER, CEC_BASE + 0x14 @ (CEC interrupt enable register) 
        .equ CEC_IER_RXBRIE, 1 << 0   @ bitWidth 1 (Rx-Byte Received Interrupt Enable The  RXBRIE bit is set and cleared by  software.)  
        .equ CEC_IER_RXENDIE, 1 << 1   @ bitWidth 1 (End Of Reception Interrupt Enable The  RXENDIE bit is set and cleared by  software.)  
        .equ CEC_IER_RXOVRIE, 1 << 2   @ bitWidth 1 (Rx-Buffer Overrun Interrupt Enable The  RXOVRIE bit is set and cleared by  software.)  
        .equ CEC_IER_BREIE, 1 << 3   @ bitWidth 1 (Bit Rising Error Interrupt Enable The  BREIE bit is set and cleared by  software.)  
        .equ CEC_IER_SBPEIE, 1 << 4   @ bitWidth 1 (Short Bit Period Error Interrupt Enable  The SBPEIE bit is set and cleared by  software.)  
        .equ CEC_IER_LBPEIE, 1 << 5   @ bitWidth 1 (Long Bit Period Error Interrupt Enable  The LBPEIE bit is set and cleared by  software.)  
        .equ CEC_IER_RXACKIE, 1 << 6   @ bitWidth 1 (Rx-Missing Acknowledge Error Interrupt  Enable The RXACKIE bit is set and cleared by  software.)  
        .equ CEC_IER_ARBLSTIE, 1 << 7   @ bitWidth 1 (Arbitration Lost Interrupt Enable The  ARBLSTIE bit is set and cleared by  software.)  
        .equ CEC_IER_TXBRIE, 1 << 8   @ bitWidth 1 (Tx-Byte Request Interrupt Enable The  TXBRIE bit is set and cleared by  software.)  
        .equ CEC_IER_TXENDIE, 1 << 9   @ bitWidth 1 (Tx-End Of Message Interrupt Enable The  TXENDIE bit is set and cleared by  software.)  
        .equ CEC_IER_TXUDRIE, 1 << 10   @ bitWidth 1 (Tx-Underrun Interrupt Enable The TXUDRIE  bit is set and cleared by software.)  
        .equ CEC_IER_TXERRIE, 1 << 11   @ bitWidth 1 (Tx-Error Interrupt Enable The TXERRIE  bit is set and cleared by software.)  
        .equ CEC_IER_TXACKIE, 1 << 12   @ bitWidth 1 (Tx-Missing Acknowledge Error Interrupt  Enable The TXACKEIE bit is set and cleared by  software.)  
 

@=========================== HSEM ===========================@
.equ HSEM_BASE, 0x58026400 @ (HSEM) 
    .equ HSEM_HSEM_R0, HSEM_BASE + 0x0 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R0_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R0_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R0_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R1, HSEM_BASE + 0x4 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R1_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R1_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R1_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R2, HSEM_BASE + 0x8 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R2_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R2_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R2_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R3, HSEM_BASE + 0xC @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R3_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R3_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R3_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R4, HSEM_BASE + 0x10 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R4_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R4_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R4_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R5, HSEM_BASE + 0x14 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R5_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R5_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R5_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R6, HSEM_BASE + 0x18 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R6_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R6_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R6_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R7, HSEM_BASE + 0x1C @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R7_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R7_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R7_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R8, HSEM_BASE + 0x20 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R8_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R8_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R8_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R9, HSEM_BASE + 0x24 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R9_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R9_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R9_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R10, HSEM_BASE + 0x28 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R10_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R10_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R10_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R11, HSEM_BASE + 0x2C @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R11_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R11_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R11_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R12, HSEM_BASE + 0x30 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R12_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R12_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R12_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R13, HSEM_BASE + 0x34 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R13_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R13_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R13_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R14, HSEM_BASE + 0x38 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R14_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R14_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R14_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R15, HSEM_BASE + 0x3C @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R15_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R15_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R15_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R16, HSEM_BASE + 0x40 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R16_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R16_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R16_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R17, HSEM_BASE + 0x44 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R17_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R17_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R17_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R18, HSEM_BASE + 0x48 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R18_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R18_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R18_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R19, HSEM_BASE + 0x4C @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R19_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R19_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R19_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R20, HSEM_BASE + 0x50 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R20_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R20_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R20_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R21, HSEM_BASE + 0x54 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R21_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R21_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R21_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R22, HSEM_BASE + 0x58 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R22_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R22_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R22_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R23, HSEM_BASE + 0x5C @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R23_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R23_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R23_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R24, HSEM_BASE + 0x60 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R24_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R24_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R24_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R25, HSEM_BASE + 0x64 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R25_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R25_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R25_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R26, HSEM_BASE + 0x68 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R26_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R26_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R26_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R27, HSEM_BASE + 0x6C @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R27_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R27_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R27_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R28, HSEM_BASE + 0x70 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R28_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R28_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R28_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R29, HSEM_BASE + 0x74 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R29_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R29_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R29_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R30, HSEM_BASE + 0x78 @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R30_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R30_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R30_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_R31, HSEM_BASE + 0x7C @ (HSEM register HSEM_R0 HSEM_R31) 
        .equ HSEM_HSEM_R31_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_R31_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_R31_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR0, HSEM_BASE + 0x80 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR0_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR0_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR0_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR1, HSEM_BASE + 0x84 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR1_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR1_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR1_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR2, HSEM_BASE + 0x88 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR2_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR2_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR2_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR3, HSEM_BASE + 0x8C @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR3_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR3_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR3_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR4, HSEM_BASE + 0x90 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR4_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR4_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR4_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR5, HSEM_BASE + 0x94 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR5_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR5_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR5_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR6, HSEM_BASE + 0x98 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR6_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR6_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR6_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR7, HSEM_BASE + 0x9C @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR7_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR7_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR7_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR8, HSEM_BASE + 0xA0 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR8_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR8_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR8_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR9, HSEM_BASE + 0xA4 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR9_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR9_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR9_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR10, HSEM_BASE + 0xA8 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR10_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR10_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR10_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR11, HSEM_BASE + 0xAC @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR11_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR11_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR11_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR12, HSEM_BASE + 0xB0 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR12_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR12_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR12_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR13, HSEM_BASE + 0xB4 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR13_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR13_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR13_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR14, HSEM_BASE + 0xB8 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR14_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR14_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR14_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR15, HSEM_BASE + 0xBC @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR15_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR15_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR15_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR16, HSEM_BASE + 0xC0 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR16_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR16_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR16_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR17, HSEM_BASE + 0xC4 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR17_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR17_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR17_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR18, HSEM_BASE + 0xC8 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR18_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR18_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR18_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR19, HSEM_BASE + 0xCC @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR19_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR19_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR19_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR20, HSEM_BASE + 0xD0 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR20_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR20_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR20_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR21, HSEM_BASE + 0xD4 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR21_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR21_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR21_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR22, HSEM_BASE + 0xD8 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR22_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR22_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR22_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR23, HSEM_BASE + 0xDC @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR23_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR23_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR23_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR24, HSEM_BASE + 0xE0 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR24_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR24_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR24_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR25, HSEM_BASE + 0xE4 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR25_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR25_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR25_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR26, HSEM_BASE + 0xE8 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR26_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR26_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR26_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR27, HSEM_BASE + 0xEC @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR27_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR27_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR27_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR28, HSEM_BASE + 0xF0 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR28_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR28_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR28_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR29, HSEM_BASE + 0xF4 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR29_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR29_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR29_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR30, HSEM_BASE + 0xF8 @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR30_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR30_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR30_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_RLR31, HSEM_BASE + 0xFC @ (HSEM Read lock register) 
        .equ HSEM_HSEM_RLR31_PROCID_Shift, 0   @ bitWidth 8 (Semaphore ProcessID)  
        .equ HSEM_HSEM_RLR31_MASTERID_Shift, 8   @ bitWidth 8 (Semaphore MasterID)  
        .equ HSEM_HSEM_RLR31_LOCK, 1 << 31   @ bitWidth 1 (Lock indication)  
 
    .equ HSEM_HSEM_IER, HSEM_BASE + 0x100 @ (HSEM Interrupt enable register) 
        .equ HSEM_HSEM_IER_ISEM0, 1 << 0   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM1, 1 << 1   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM2, 1 << 2   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM3, 1 << 3   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM4, 1 << 4   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM5, 1 << 5   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM6, 1 << 6   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM7, 1 << 7   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM8, 1 << 8   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM9, 1 << 9   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM10, 1 << 10   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM11, 1 << 11   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM12, 1 << 12   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM13, 1 << 13   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM14, 1 << 14   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM15, 1 << 15   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM16, 1 << 16   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM17, 1 << 17   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM18, 1 << 18   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM19, 1 << 19   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM20, 1 << 20   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM21, 1 << 21   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM22, 1 << 22   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM23, 1 << 23   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM24, 1 << 24   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM25, 1 << 25   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM26, 1 << 26   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM27, 1 << 27   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM28, 1 << 28   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM29, 1 << 29   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM30, 1 << 30   @ bitWidth 1 (Interrupt semaphore n enable  bit)  
        .equ HSEM_HSEM_IER_ISEM31, 1 << 31   @ bitWidth 1 (InterruptN semaphore n enable  bit.)  
 
    .equ HSEM_HSEM_ICR, HSEM_BASE + 0x104 @ (HSEM Interrupt clear register) 
        .equ HSEM_HSEM_ICR_ISEM0, 1 << 0   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM1, 1 << 1   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM2, 1 << 2   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM3, 1 << 3   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM4, 1 << 4   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM5, 1 << 5   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM6, 1 << 6   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM7, 1 << 7   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM8, 1 << 8   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM9, 1 << 9   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM10, 1 << 10   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM11, 1 << 11   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM12, 1 << 12   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM13, 1 << 13   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM14, 1 << 14   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM15, 1 << 15   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM16, 1 << 16   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM17, 1 << 17   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM18, 1 << 18   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM19, 1 << 19   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM20, 1 << 20   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM21, 1 << 21   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM22, 1 << 22   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM23, 1 << 23   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM24, 1 << 24   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM25, 1 << 25   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM26, 1 << 26   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM27, 1 << 27   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM28, 1 << 28   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM29, 1 << 29   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM30, 1 << 30   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
        .equ HSEM_HSEM_ICR_ISEM31, 1 << 31   @ bitWidth 1 (InterruptN semaphore n clear  bit)  
 
    .equ HSEM_HSEM_ISR, HSEM_BASE + 0x108 @ (HSEM Interrupt status register) 
        .equ HSEM_HSEM_ISR_ISEM0, 1 << 0   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM1, 1 << 1   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM2, 1 << 2   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM3, 1 << 3   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM4, 1 << 4   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM5, 1 << 5   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM6, 1 << 6   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM7, 1 << 7   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM8, 1 << 8   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM9, 1 << 9   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM10, 1 << 10   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM11, 1 << 11   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM12, 1 << 12   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM13, 1 << 13   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM14, 1 << 14   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM15, 1 << 15   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM16, 1 << 16   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM17, 1 << 17   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM18, 1 << 18   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM19, 1 << 19   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM20, 1 << 20   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM21, 1 << 21   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM22, 1 << 22   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM23, 1 << 23   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM24, 1 << 24   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM25, 1 << 25   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM26, 1 << 26   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM27, 1 << 27   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM28, 1 << 28   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM29, 1 << 29   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM30, 1 << 30   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
        .equ HSEM_HSEM_ISR_ISEM31, 1 << 31   @ bitWidth 1 (InterruptN semaphore n status bit  before enable mask)  
 
    .equ HSEM_HSEM_MISR, HSEM_BASE + 0x10C @ (HSEM Masked interrupt status  register) 
        .equ HSEM_HSEM_MISR_ISEM0, 1 << 0   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM1, 1 << 1   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM2, 1 << 2   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM3, 1 << 3   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM4, 1 << 4   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM5, 1 << 5   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM6, 1 << 6   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM7, 1 << 7   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM8, 1 << 8   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM9, 1 << 9   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM10, 1 << 10   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM11, 1 << 11   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM12, 1 << 12   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM13, 1 << 13   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM14, 1 << 14   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM15, 1 << 15   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM16, 1 << 16   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM17, 1 << 17   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM18, 1 << 18   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM19, 1 << 19   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM20, 1 << 20   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM21, 1 << 21   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM22, 1 << 22   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM23, 1 << 23   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM24, 1 << 24   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM25, 1 << 25   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM26, 1 << 26   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM27, 1 << 27   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM28, 1 << 28   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM29, 1 << 29   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM30, 1 << 30   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
        .equ HSEM_HSEM_MISR_ISEM31, 1 << 31   @ bitWidth 1 (masked interruptN semaphore n status  bit after enable mask)  
 
    .equ HSEM_HSEM_CR, HSEM_BASE + 0x140 @ (HSEM Clear register) 
        .equ HSEM_HSEM_CR_MASTERID_Shift, 8   @ bitWidth 8 (MasterID of semaphores to be  cleared)  
        .equ HSEM_HSEM_CR_KEY_Shift, 16   @ bitWidth 16 (Semaphore clear Key)  
 
    .equ HSEM_HSEM_KEYR, HSEM_BASE + 0x144 @ (HSEM Interrupt clear register) 
        .equ HSEM_HSEM_KEYR_KEY_Shift, 16   @ bitWidth 16 (Semaphore Clear Key)  
 

@=========================== I2C1 ===========================@
.equ I2C1_BASE, 0x40005400 @ (I2C) 
    .equ I2C1_CR1, I2C1_BASE + 0x0 @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C1_CR1_PE, 1 << 0   @ bitWidth 1 (Peripheral enable Note: When PE=0, the  I2C SCL and SDA lines are released. Internal state  machines and status bits are put back to their reset  value. When cleared, PE must be kept low for at least  3 APB clock cycles.)  
        .equ I2C1_CR1_TXIE, 1 << 1   @ bitWidth 1 (TX Interrupt enable)  
        .equ I2C1_CR1_RXIE, 1 << 2   @ bitWidth 1 (RX Interrupt enable)  
        .equ I2C1_CR1_ADDRIE, 1 << 3   @ bitWidth 1 (Address match Interrupt enable slave  only)  
        .equ I2C1_CR1_NACKIE, 1 << 4   @ bitWidth 1 (Not acknowledge received Interrupt  enable)  
        .equ I2C1_CR1_STOPIE, 1 << 5   @ bitWidth 1 (STOP detection Interrupt  enable)  
        .equ I2C1_CR1_TCIE, 1 << 6   @ bitWidth 1 (Transfer Complete interrupt enable Note:  Any of these events will generate an interrupt:  Transfer Complete TC Transfer Complete Reload  TCR)  
        .equ I2C1_CR1_ERRIE, 1 << 7   @ bitWidth 1 (Error interrupts enable Note: Any of  these errors generate an interrupt: Arbitration Loss  ARLO Bus Error detection BERR Overrun/Underrun  OVR Timeout detection TIMEOUT PEC error detection  PECERR Alert pin event detection  ALERT)  
        .equ I2C1_CR1_DNF_Shift, 8   @ bitWidth 4 (Digital noise filter These bits are used  to configure the digital noise filter on SDA and SCL  input. The digital filter will filter spikes with a  length of up to DNF[3:0] * tI2CCLK ... Note: If the  analog filter is also enabled, the digital filter is  added to the analog filter. This filter can only be  programmed when the I2C is disabled PE =  0.)  
        .equ I2C1_CR1_ANFOFF, 1 << 12   @ bitWidth 1 (Analog noise filter OFF Note: This bit  can only be programmed when the I2C is disabled PE =  0.)  
        .equ I2C1_CR1_TXDMAEN, 1 << 14   @ bitWidth 1 (DMA transmission requests  enable)  
        .equ I2C1_CR1_RXDMAEN, 1 << 15   @ bitWidth 1 (DMA reception requests  enable)  
        .equ I2C1_CR1_SBC, 1 << 16   @ bitWidth 1 (Slave byte control This bit is used to  enable hardware byte control in slave  mode.)  
        .equ I2C1_CR1_NOSTRETCH, 1 << 17   @ bitWidth 1 (Clock stretching disable This bit is  used to disable clock stretching in slave mode. It  must be kept cleared in master mode. Note: This bit  can only be programmed when the I2C is disabled PE =  0.)  
        .equ I2C1_CR1_WUPEN, 1 << 18   @ bitWidth 1 (Wakeup from Stop mode enable Note: If  the Wakeup from Stop mode feature is not supported,  this bit is reserved and forced by hardware to 0.  Please refer to Section25.3: I2C implementation.  Note: WUPEN can be set only when DNF =  0000)  
        .equ I2C1_CR1_GCEN, 1 << 19   @ bitWidth 1 (General call enable)  
        .equ I2C1_CR1_SMBHEN, 1 << 20   @ bitWidth 1 (SMBus Host address enable Note: If the  SMBus feature is not supported, this bit is reserved  and forced by hardware to 0. Please refer to  Section25.3: I2C implementation.)  
        .equ I2C1_CR1_SMBDEN, 1 << 21   @ bitWidth 1 (SMBus Device Default address enable  Note: If the SMBus feature is not supported, this bit  is reserved and forced by hardware to 0. Please refer  to Section25.3: I2C implementation.)  
        .equ I2C1_CR1_ALERTEN, 1 << 22   @ bitWidth 1 (SMBus alert enable Device mode  SMBHEN=0: Host mode SMBHEN=1: Note: When  ALERTEN=0, the SMBA pin can be used as a standard  GPIO. If the SMBus feature is not supported, this bit  is reserved and forced by hardware to 0. Please refer  to Section25.3: I2C implementation.)  
        .equ I2C1_CR1_PECEN, 1 << 23   @ bitWidth 1 (PEC enable Note: If the SMBus feature is  not supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
 
    .equ I2C1_CR2, I2C1_BASE + 0x4 @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C1_CR2_SADD0, 1 << 0   @ bitWidth 1 (Slave address bit 0 master mode In  7-bit addressing mode ADD10 = 0: This bit is dont  care In 10-bit addressing mode ADD10 = 1: This bit  should be written with bit 0 of the slave address to  be sent Note: Changing these bits when the START bit  is set is not allowed.)  
        .equ I2C1_CR2_SADD1, 1 << 1   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C1_CR2_SADD2, 1 << 2   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C1_CR2_SADD3, 1 << 3   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C1_CR2_SADD4, 1 << 4   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C1_CR2_SADD5, 1 << 5   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C1_CR2_SADD6, 1 << 6   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C1_CR2_SADD7, 1 << 7   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C1_CR2_SADD8, 1 << 8   @ bitWidth 1 (Slave address bit 9:8 master mode In  7-bit addressing mode ADD10 = 0: These bits are  dont care In 10-bit addressing mode ADD10 = 1:  These bits should be written with bits 9:8 of the  slave address to be sent Note: Changing these bits  when the START bit is set is not  allowed.)  
        .equ I2C1_CR2_SADD9, 1 << 9   @ bitWidth 1 (Slave address bit 9:8 master mode In  7-bit addressing mode ADD10 = 0: These bits are  dont care In 10-bit addressing mode ADD10 = 1:  These bits should be written with bits 9:8 of the  slave address to be sent Note: Changing these bits  when the START bit is set is not  allowed.)  
        .equ I2C1_CR2_RD_WRN, 1 << 10   @ bitWidth 1 (Transfer direction master mode Note:  Changing this bit when the START bit is set is not  allowed.)  
        .equ I2C1_CR2_ADD10, 1 << 11   @ bitWidth 1 (10-bit addressing mode master mode  Note: Changing this bit when the START bit is set is  not allowed.)  
        .equ I2C1_CR2_HEAD10R, 1 << 12   @ bitWidth 1 (10-bit address header only read  direction master receiver mode Note: Changing this  bit when the START bit is set is not  allowed.)  
        .equ I2C1_CR2_START, 1 << 13   @ bitWidth 1 (Start generation This bit is set by  software, and cleared by hardware after the Start  followed by the address sequence is sent, by an  arbitration loss, by a timeout error detection, or  when PE = 0. It can also be cleared by software by  writing 1 to the ADDRCF bit in the I2C_ICR register.  If the I2C is already in master mode with AUTOEND =  0, setting this bit generates a Repeated Start  condition when RELOAD=0, after the end of the NBYTES  transfer. Otherwise setting this bit will generate a  START condition once the bus is free. Note: Writing 0  to this bit has no effect. The START bit can be set  even if the bus is BUSY or I2C is in slave mode. This  bit has no effect when RELOAD is set.)  
        .equ I2C1_CR2_STOP, 1 << 14   @ bitWidth 1 (Stop generation master mode The bit is  set by software, cleared by hardware when a Stop  condition is detected, or when PE = 0. In Master  Mode: Note: Writing 0 to this bit has no  effect.)  
        .equ I2C1_CR2_NACK, 1 << 15   @ bitWidth 1 (NACK generation slave mode The bit is  set by software, cleared by hardware when the NACK is  sent, or when a STOP condition or an Address matched  is received, or when PE=0. Note: Writing 0 to this  bit has no effect. This bit is used in slave mode  only: in master receiver mode, NACK is automatically  generated after last byte preceding STOP or RESTART  condition, whatever the NACK bit value. When an  overrun occurs in slave receiver NOSTRETCH mode, a  NACK is automatically generated whatever the NACK bit  value. When hardware PEC checking is enabled  PECBYTE=1, the PEC acknowledge value does not  depend on the NACK value.)  
        .equ I2C1_CR2_NBYTES_Shift, 16   @ bitWidth 8 (Number of bytes The number of bytes to  be transmitted/received is programmed there. This  field is dont care in slave mode with SBC=0. Note:  Changing these bits when the START bit is set is not  allowed.)  
        .equ I2C1_CR2_RELOAD, 1 << 24   @ bitWidth 1 (NBYTES reload mode This bit is set and  cleared by software.)  
        .equ I2C1_CR2_AUTOEND, 1 << 25   @ bitWidth 1 (Automatic end mode master mode This  bit is set and cleared by software. Note: This bit  has no effect in slave mode or when the RELOAD bit is  set.)  
        .equ I2C1_CR2_PECBYTE, 1 << 26   @ bitWidth 1 (Packet error checking byte This bit is  set by software, and cleared by hardware when the PEC  is transferred, or when a STOP condition or an  Address matched is received, also when PE=0. Note:  Writing 0 to this bit has no effect. This bit has no  effect when RELOAD is set. This bit has no effect is  slave mode when SBC=0. If the SMBus feature is not  supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
 
    .equ I2C1_OAR1, I2C1_BASE + 0x8 @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C1_OAR1_OA1_Shift, 0   @ bitWidth 10 (Interface address 7-bit addressing mode:  dont care 10-bit addressing mode: bits 9:8 of address  Note: These bits can be written only when OA1EN=0.  OA1[7:1]: Interface address Bits 7:1 of address Note:  These bits can be written only when OA1EN=0. OA1[0]:  Interface address 7-bit addressing mode: dont care  10-bit addressing mode: bit 0 of address Note: This  bit can be written only when OA1EN=0.)  
        .equ I2C1_OAR1_OA1MODE, 1 << 10   @ bitWidth 1 (Own Address 1 10-bit mode Note: This bit  can be written only when OA1EN=0.)  
        .equ I2C1_OAR1_OA1EN, 1 << 15   @ bitWidth 1 (Own Address 1 enable)  
 
    .equ I2C1_OAR2, I2C1_BASE + 0xC @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C1_OAR2_OA2_Shift, 1   @ bitWidth 7 (Interface address bits 7:1 of address  Note: These bits can be written only when  OA2EN=0.)  
        .equ I2C1_OAR2_OA2MSK_Shift, 8   @ bitWidth 3 (Own Address 2 masks Note: These bits can  be written only when OA2EN=0. As soon as OA2MSK is  not equal to 0, the reserved I2C addresses 0b0000xxx  and 0b1111xxx are not acknowledged even if the  comparison matches.)  
        .equ I2C1_OAR2_OA2EN, 1 << 15   @ bitWidth 1 (Own Address 2 enable)  
 
    .equ I2C1_TIMINGR, I2C1_BASE + 0x10 @ (Access: No wait states) 
        .equ I2C1_TIMINGR_SCLL_Shift, 0   @ bitWidth 8 (SCL low period master mode This field  is used to generate the SCL low period in master  mode. tSCLL = SCLL+1 x tPRESC Note: SCLL is also  used to generate tBUF and tSU:STA  timings.)  
        .equ I2C1_TIMINGR_SCLH_Shift, 8   @ bitWidth 8 (SCL high period master mode This field  is used to generate the SCL high period in master  mode. tSCLH = SCLH+1 x tPRESC Note: SCLH is also  used to generate tSU:STO and tHD:STA  timing.)  
        .equ I2C1_TIMINGR_SDADEL_Shift, 16   @ bitWidth 4 (Data hold time This field is used to  generate the delay tSDADEL between SCL falling edge  and SDA edge. In master mode and in slave mode with  NOSTRETCH = 0, the SCL line is stretched low during  tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is  used to generate tHD:DAT timing.)  
        .equ I2C1_TIMINGR_SCLDEL_Shift, 20   @ bitWidth 4 (Data setup time This field is used to  generate a delay tSCLDEL between SDA edge and SCL  rising edge. In master mode and in slave mode with  NOSTRETCH = 0, the SCL line is stretched low during  tSCLDEL. tSCLDEL = SCLDEL+1 x tPRESC Note: tSCLDEL  is used to generate tSU:DAT timing.)  
        .equ I2C1_TIMINGR_PRESC_Shift, 28   @ bitWidth 4 (Timing prescaler This field is used to  prescale I2CCLK in order to generate the clock period  tPRESC used for data setup and hold counters refer  to I2C timings on page9 and for SCL high and low  level counters refer to I2C master initialization on  page24. tPRESC = PRESC+1 x tI2CCLK)  
 
    .equ I2C1_TIMEOUTR, I2C1_BASE + 0x14 @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C1_TIMEOUTR_TIMEOUTA_Shift, 0   @ bitWidth 12 (Bus Timeout A This field is used to  configure: The SCL low timeout condition tTIMEOUT  when TIDLE=0 tTIMEOUT= TIMEOUTA+1 x 2048 x tI2CCLK  The bus idle condition both SCL and SDA high when  TIDLE=1 tIDLE= TIMEOUTA+1 x 4 x tI2CCLK Note: These  bits can be written only when  TIMOUTEN=0.)  
        .equ I2C1_TIMEOUTR_TIDLE, 1 << 12   @ bitWidth 1 (Idle clock timeout detection Note: This  bit can be written only when  TIMOUTEN=0.)  
        .equ I2C1_TIMEOUTR_TIMOUTEN, 1 << 15   @ bitWidth 1 (Clock timeout enable)  
        .equ I2C1_TIMEOUTR_TIMEOUTB_Shift, 16   @ bitWidth 12 (Bus timeout B This field is used to  configure the cumulative clock extension timeout: In  master mode, the master cumulative clock low extend  time tLOW:MEXT is detected In slave mode, the slave  cumulative clock low extend time tLOW:SEXT is  detected tLOW:EXT= TIMEOUTB+1 x 2048 x tI2CCLK  Note: These bits can be written only when  TEXTEN=0.)  
        .equ I2C1_TIMEOUTR_TEXTEN, 1 << 31   @ bitWidth 1 (Extended clock timeout  enable)  
 
    .equ I2C1_ISR, I2C1_BASE + 0x18 @ (Access: No wait states) 
        .equ I2C1_ISR_TXE, 1 << 0   @ bitWidth 1 (Transmit data register empty  transmitters This bit is set by hardware when the  I2C_TXDR register is empty. It is cleared when the  next data to be sent is written in the I2C_TXDR  register. This bit can be written to 1 by software in  order to flush the transmit data register I2C_TXDR.  Note: This bit is set by hardware when  PE=0.)  
        .equ I2C1_ISR_TXIS, 1 << 1   @ bitWidth 1 (Transmit interrupt status transmitters  This bit is set by hardware when the I2C_TXDR  register is empty and the data to be transmitted must  be written in the I2C_TXDR register. It is cleared  when the next data to be sent is written in the  I2C_TXDR register. This bit can be written to 1 by  software when NOSTRETCH=1 only, in order to generate  a TXIS event interrupt if TXIE=1 or DMA request if  TXDMAEN=1. Note: This bit is cleared by hardware  when PE=0.)  
        .equ I2C1_ISR_RXNE, 1 << 2   @ bitWidth 1 (Receive data register not empty  receivers This bit is set by hardware when the  received data is copied into the I2C_RXDR register,  and is ready to be read. It is cleared when I2C_RXDR  is read. Note: This bit is cleared by hardware when  PE=0.)  
        .equ I2C1_ISR_ADDR, 1 << 3   @ bitWidth 1 (Address matched slave mode This bit is  set by hardware as soon as the received slave address  matched with one of the enabled slave addresses. It  is cleared by software by setting ADDRCF bit. Note:  This bit is cleared by hardware when  PE=0.)  
        .equ I2C1_ISR_NACKF, 1 << 4   @ bitWidth 1 (Not Acknowledge received flag This flag  is set by hardware when a NACK is received after a  byte transmission. It is cleared by software by  setting the NACKCF bit. Note: This bit is cleared by  hardware when PE=0.)  
        .equ I2C1_ISR_STOPF, 1 << 5   @ bitWidth 1 (Stop detection flag This flag is set by  hardware when a Stop condition is detected on the bus  and the peripheral is involved in this transfer:  either as a master, provided that the STOP condition  is generated by the peripheral. or as a slave,  provided that the peripheral has been addressed  previously during this transfer. It is cleared by  software by setting the STOPCF bit. Note: This bit is  cleared by hardware when PE=0.)  
        .equ I2C1_ISR_TC, 1 << 6   @ bitWidth 1 (Transfer Complete master mode This  flag is set by hardware when RELOAD=0, AUTOEND=0 and  NBYTES data have been transferred. It is cleared by  software when START bit or STOP bit is set. Note:  This bit is cleared by hardware when  PE=0.)  
        .equ I2C1_ISR_TCR, 1 << 7   @ bitWidth 1 (Transfer Complete Reload This flag is  set by hardware when RELOAD=1 and NBYTES data have  been transferred. It is cleared by software when  NBYTES is written to a non-zero value. Note: This bit  is cleared by hardware when PE=0. This flag is only  for master mode, or for slave mode when the SBC bit  is set.)  
        .equ I2C1_ISR_BERR, 1 << 8   @ bitWidth 1 (Bus error This flag is set by hardware  when a misplaced Start or Stop condition is detected  whereas the peripheral is involved in the transfer.  The flag is not set during the address phase in slave  mode. It is cleared by software by setting BERRCF  bit. Note: This bit is cleared by hardware when  PE=0.)  
        .equ I2C1_ISR_ARLO, 1 << 9   @ bitWidth 1 (Arbitration lost This flag is set by  hardware in case of arbitration loss. It is cleared  by software by setting the ARLOCF bit. Note: This bit  is cleared by hardware when PE=0.)  
        .equ I2C1_ISR_OVR, 1 << 10   @ bitWidth 1 (Overrun/Underrun slave mode This flag  is set by hardware in slave mode with NOSTRETCH=1,  when an overrun/underrun error occurs. It is cleared  by software by setting the OVRCF bit. Note: This bit  is cleared by hardware when PE=0.)  
        .equ I2C1_ISR_PECERR, 1 << 11   @ bitWidth 1 (PEC Error in reception This flag is set  by hardware when the received PEC does not match with  the PEC register content. A NACK is automatically  sent after the wrong PEC reception. It is cleared by  software by setting the PECCF bit. Note: This bit is  cleared by hardware when PE=0. If the SMBus feature  is not supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
        .equ I2C1_ISR_TIMEOUT, 1 << 12   @ bitWidth 1 (Timeout or tLOW detection flag This flag  is set by hardware when a timeout or extended clock  timeout occurred. It is cleared by software by  setting the TIMEOUTCF bit. Note: This bit is cleared  by hardware when PE=0. If the SMBus feature is not  supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
        .equ I2C1_ISR_ALERT, 1 << 13   @ bitWidth 1 (SMBus alert This flag is set by hardware  when SMBHEN=1 SMBus host configuration, ALERTEN=1  and a SMBALERT event falling edge is detected on  SMBA pin. It is cleared by software by setting the  ALERTCF bit. Note: This bit is cleared by hardware  when PE=0. If the SMBus feature is not supported,  this bit is reserved and forced by hardware to 0.  Please refer to Section25.3: I2C  implementation.)  
        .equ I2C1_ISR_BUSY, 1 << 15   @ bitWidth 1 (Bus busy This flag indicates that a  communication is in progress on the bus. It is set by  hardware when a START condition is detected. It is  cleared by hardware when a Stop condition is  detected, or when PE=0.)  
        .equ I2C1_ISR_DIR, 1 << 16   @ bitWidth 1 (Transfer direction Slave mode This  flag is updated when an address match event occurs  ADDR=1.)  
        .equ I2C1_ISR_ADDCODE_Shift, 17   @ bitWidth 7 (Address match code Slave mode These  bits are updated with the received address when an  address match event occurs ADDR = 1. In the case of  a 10-bit address, ADDCODE provides the 10-bit header  followed by the 2 MSBs of the address.)  
 
    .equ I2C1_ICR, I2C1_BASE + 0x1C @ (Access: No wait states) 
        .equ I2C1_ICR_ADDRCF, 1 << 3   @ bitWidth 1 (Address matched flag clear Writing 1 to  this bit clears the ADDR flag in the I2C_ISR  register. Writing 1 to this bit also clears the START  bit in the I2C_CR2 register.)  
        .equ I2C1_ICR_NACKCF, 1 << 4   @ bitWidth 1 (Not Acknowledge flag clear Writing 1 to  this bit clears the ACKF flag in I2C_ISR  register.)  
        .equ I2C1_ICR_STOPCF, 1 << 5   @ bitWidth 1 (Stop detection flag clear Writing 1 to  this bit clears the STOPF flag in the I2C_ISR  register.)  
        .equ I2C1_ICR_BERRCF, 1 << 8   @ bitWidth 1 (Bus error flag clear Writing 1 to this  bit clears the BERRF flag in the I2C_ISR  register.)  
        .equ I2C1_ICR_ARLOCF, 1 << 9   @ bitWidth 1 (Arbitration Lost flag clear Writing 1 to  this bit clears the ARLO flag in the I2C_ISR  register.)  
        .equ I2C1_ICR_OVRCF, 1 << 10   @ bitWidth 1 (Overrun/Underrun flag clear Writing 1 to  this bit clears the OVR flag in the I2C_ISR  register.)  
        .equ I2C1_ICR_PECCF, 1 << 11   @ bitWidth 1 (PEC Error flag clear Writing 1 to this  bit clears the PECERR flag in the I2C_ISR register.  Note: If the SMBus feature is not supported, this bit  is reserved and forced by hardware to 0. Please refer  to Section25.3: I2C implementation.)  
        .equ I2C1_ICR_TIMOUTCF, 1 << 12   @ bitWidth 1 (Timeout detection flag clear Writing 1  to this bit clears the TIMEOUT flag in the I2C_ISR  register. Note: If the SMBus feature is not  supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
        .equ I2C1_ICR_ALERTCF, 1 << 13   @ bitWidth 1 (Alert flag clear Writing 1 to this bit  clears the ALERT flag in the I2C_ISR register. Note:  If the SMBus feature is not supported, this bit is  reserved and forced by hardware to 0. Please refer to  Section25.3: I2C implementation.)  
 
    .equ I2C1_PECR, I2C1_BASE + 0x20 @ (Access: No wait states) 
        .equ I2C1_PECR_PEC_Shift, 0   @ bitWidth 8 (Packet error checking register This  field contains the internal PEC when PECEN=1. The PEC  is cleared by hardware when PE=0.)  
 
    .equ I2C1_RXDR, I2C1_BASE + 0x24 @ (Access: No wait states) 
        .equ I2C1_RXDR_RXDATA_Shift, 0   @ bitWidth 8 (8-bit receive data Data byte received  from the I2C bus.)  
 
    .equ I2C1_TXDR, I2C1_BASE + 0x28 @ (Access: No wait states) 
        .equ I2C1_TXDR_TXDATA_Shift, 0   @ bitWidth 8 (8-bit transmit data Data byte to be  transmitted to the I2C bus. Note: These bits can be  written only when TXE=1.)  
 

@=========================== I2C2 ===========================@
.equ I2C2_BASE, 0x40005800 @ (I2C) 
    .equ I2C2_CR1, I2C2_BASE + 0x0 @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C2_CR1_PE, 1 << 0   @ bitWidth 1 (Peripheral enable Note: When PE=0, the  I2C SCL and SDA lines are released. Internal state  machines and status bits are put back to their reset  value. When cleared, PE must be kept low for at least  3 APB clock cycles.)  
        .equ I2C2_CR1_TXIE, 1 << 1   @ bitWidth 1 (TX Interrupt enable)  
        .equ I2C2_CR1_RXIE, 1 << 2   @ bitWidth 1 (RX Interrupt enable)  
        .equ I2C2_CR1_ADDRIE, 1 << 3   @ bitWidth 1 (Address match Interrupt enable slave  only)  
        .equ I2C2_CR1_NACKIE, 1 << 4   @ bitWidth 1 (Not acknowledge received Interrupt  enable)  
        .equ I2C2_CR1_STOPIE, 1 << 5   @ bitWidth 1 (STOP detection Interrupt  enable)  
        .equ I2C2_CR1_TCIE, 1 << 6   @ bitWidth 1 (Transfer Complete interrupt enable Note:  Any of these events will generate an interrupt:  Transfer Complete TC Transfer Complete Reload  TCR)  
        .equ I2C2_CR1_ERRIE, 1 << 7   @ bitWidth 1 (Error interrupts enable Note: Any of  these errors generate an interrupt: Arbitration Loss  ARLO Bus Error detection BERR Overrun/Underrun  OVR Timeout detection TIMEOUT PEC error detection  PECERR Alert pin event detection  ALERT)  
        .equ I2C2_CR1_DNF_Shift, 8   @ bitWidth 4 (Digital noise filter These bits are used  to configure the digital noise filter on SDA and SCL  input. The digital filter will filter spikes with a  length of up to DNF[3:0] * tI2CCLK ... Note: If the  analog filter is also enabled, the digital filter is  added to the analog filter. This filter can only be  programmed when the I2C is disabled PE =  0.)  
        .equ I2C2_CR1_ANFOFF, 1 << 12   @ bitWidth 1 (Analog noise filter OFF Note: This bit  can only be programmed when the I2C is disabled PE =  0.)  
        .equ I2C2_CR1_TXDMAEN, 1 << 14   @ bitWidth 1 (DMA transmission requests  enable)  
        .equ I2C2_CR1_RXDMAEN, 1 << 15   @ bitWidth 1 (DMA reception requests  enable)  
        .equ I2C2_CR1_SBC, 1 << 16   @ bitWidth 1 (Slave byte control This bit is used to  enable hardware byte control in slave  mode.)  
        .equ I2C2_CR1_NOSTRETCH, 1 << 17   @ bitWidth 1 (Clock stretching disable This bit is  used to disable clock stretching in slave mode. It  must be kept cleared in master mode. Note: This bit  can only be programmed when the I2C is disabled PE =  0.)  
        .equ I2C2_CR1_WUPEN, 1 << 18   @ bitWidth 1 (Wakeup from Stop mode enable Note: If  the Wakeup from Stop mode feature is not supported,  this bit is reserved and forced by hardware to 0.  Please refer to Section25.3: I2C implementation.  Note: WUPEN can be set only when DNF =  0000)  
        .equ I2C2_CR1_GCEN, 1 << 19   @ bitWidth 1 (General call enable)  
        .equ I2C2_CR1_SMBHEN, 1 << 20   @ bitWidth 1 (SMBus Host address enable Note: If the  SMBus feature is not supported, this bit is reserved  and forced by hardware to 0. Please refer to  Section25.3: I2C implementation.)  
        .equ I2C2_CR1_SMBDEN, 1 << 21   @ bitWidth 1 (SMBus Device Default address enable  Note: If the SMBus feature is not supported, this bit  is reserved and forced by hardware to 0. Please refer  to Section25.3: I2C implementation.)  
        .equ I2C2_CR1_ALERTEN, 1 << 22   @ bitWidth 1 (SMBus alert enable Device mode  SMBHEN=0: Host mode SMBHEN=1: Note: When  ALERTEN=0, the SMBA pin can be used as a standard  GPIO. If the SMBus feature is not supported, this bit  is reserved and forced by hardware to 0. Please refer  to Section25.3: I2C implementation.)  
        .equ I2C2_CR1_PECEN, 1 << 23   @ bitWidth 1 (PEC enable Note: If the SMBus feature is  not supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
 
    .equ I2C2_CR2, I2C2_BASE + 0x4 @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C2_CR2_SADD0, 1 << 0   @ bitWidth 1 (Slave address bit 0 master mode In  7-bit addressing mode ADD10 = 0: This bit is dont  care In 10-bit addressing mode ADD10 = 1: This bit  should be written with bit 0 of the slave address to  be sent Note: Changing these bits when the START bit  is set is not allowed.)  
        .equ I2C2_CR2_SADD1, 1 << 1   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C2_CR2_SADD2, 1 << 2   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C2_CR2_SADD3, 1 << 3   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C2_CR2_SADD4, 1 << 4   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C2_CR2_SADD5, 1 << 5   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C2_CR2_SADD6, 1 << 6   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C2_CR2_SADD7, 1 << 7   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C2_CR2_SADD8, 1 << 8   @ bitWidth 1 (Slave address bit 9:8 master mode In  7-bit addressing mode ADD10 = 0: These bits are  dont care In 10-bit addressing mode ADD10 = 1:  These bits should be written with bits 9:8 of the  slave address to be sent Note: Changing these bits  when the START bit is set is not  allowed.)  
        .equ I2C2_CR2_SADD9, 1 << 9   @ bitWidth 1 (Slave address bit 9:8 master mode In  7-bit addressing mode ADD10 = 0: These bits are  dont care In 10-bit addressing mode ADD10 = 1:  These bits should be written with bits 9:8 of the  slave address to be sent Note: Changing these bits  when the START bit is set is not  allowed.)  
        .equ I2C2_CR2_RD_WRN, 1 << 10   @ bitWidth 1 (Transfer direction master mode Note:  Changing this bit when the START bit is set is not  allowed.)  
        .equ I2C2_CR2_ADD10, 1 << 11   @ bitWidth 1 (10-bit addressing mode master mode  Note: Changing this bit when the START bit is set is  not allowed.)  
        .equ I2C2_CR2_HEAD10R, 1 << 12   @ bitWidth 1 (10-bit address header only read  direction master receiver mode Note: Changing this  bit when the START bit is set is not  allowed.)  
        .equ I2C2_CR2_START, 1 << 13   @ bitWidth 1 (Start generation This bit is set by  software, and cleared by hardware after the Start  followed by the address sequence is sent, by an  arbitration loss, by a timeout error detection, or  when PE = 0. It can also be cleared by software by  writing 1 to the ADDRCF bit in the I2C_ICR register.  If the I2C is already in master mode with AUTOEND =  0, setting this bit generates a Repeated Start  condition when RELOAD=0, after the end of the NBYTES  transfer. Otherwise setting this bit will generate a  START condition once the bus is free. Note: Writing 0  to this bit has no effect. The START bit can be set  even if the bus is BUSY or I2C is in slave mode. This  bit has no effect when RELOAD is set.)  
        .equ I2C2_CR2_STOP, 1 << 14   @ bitWidth 1 (Stop generation master mode The bit is  set by software, cleared by hardware when a Stop  condition is detected, or when PE = 0. In Master  Mode: Note: Writing 0 to this bit has no  effect.)  
        .equ I2C2_CR2_NACK, 1 << 15   @ bitWidth 1 (NACK generation slave mode The bit is  set by software, cleared by hardware when the NACK is  sent, or when a STOP condition or an Address matched  is received, or when PE=0. Note: Writing 0 to this  bit has no effect. This bit is used in slave mode  only: in master receiver mode, NACK is automatically  generated after last byte preceding STOP or RESTART  condition, whatever the NACK bit value. When an  overrun occurs in slave receiver NOSTRETCH mode, a  NACK is automatically generated whatever the NACK bit  value. When hardware PEC checking is enabled  PECBYTE=1, the PEC acknowledge value does not  depend on the NACK value.)  
        .equ I2C2_CR2_NBYTES_Shift, 16   @ bitWidth 8 (Number of bytes The number of bytes to  be transmitted/received is programmed there. This  field is dont care in slave mode with SBC=0. Note:  Changing these bits when the START bit is set is not  allowed.)  
        .equ I2C2_CR2_RELOAD, 1 << 24   @ bitWidth 1 (NBYTES reload mode This bit is set and  cleared by software.)  
        .equ I2C2_CR2_AUTOEND, 1 << 25   @ bitWidth 1 (Automatic end mode master mode This  bit is set and cleared by software. Note: This bit  has no effect in slave mode or when the RELOAD bit is  set.)  
        .equ I2C2_CR2_PECBYTE, 1 << 26   @ bitWidth 1 (Packet error checking byte This bit is  set by software, and cleared by hardware when the PEC  is transferred, or when a STOP condition or an  Address matched is received, also when PE=0. Note:  Writing 0 to this bit has no effect. This bit has no  effect when RELOAD is set. This bit has no effect is  slave mode when SBC=0. If the SMBus feature is not  supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
 
    .equ I2C2_OAR1, I2C2_BASE + 0x8 @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C2_OAR1_OA1_Shift, 0   @ bitWidth 10 (Interface address 7-bit addressing mode:  dont care 10-bit addressing mode: bits 9:8 of address  Note: These bits can be written only when OA1EN=0.  OA1[7:1]: Interface address Bits 7:1 of address Note:  These bits can be written only when OA1EN=0. OA1[0]:  Interface address 7-bit addressing mode: dont care  10-bit addressing mode: bit 0 of address Note: This  bit can be written only when OA1EN=0.)  
        .equ I2C2_OAR1_OA1MODE, 1 << 10   @ bitWidth 1 (Own Address 1 10-bit mode Note: This bit  can be written only when OA1EN=0.)  
        .equ I2C2_OAR1_OA1EN, 1 << 15   @ bitWidth 1 (Own Address 1 enable)  
 
    .equ I2C2_OAR2, I2C2_BASE + 0xC @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C2_OAR2_OA2_Shift, 1   @ bitWidth 7 (Interface address bits 7:1 of address  Note: These bits can be written only when  OA2EN=0.)  
        .equ I2C2_OAR2_OA2MSK_Shift, 8   @ bitWidth 3 (Own Address 2 masks Note: These bits can  be written only when OA2EN=0. As soon as OA2MSK is  not equal to 0, the reserved I2C addresses 0b0000xxx  and 0b1111xxx are not acknowledged even if the  comparison matches.)  
        .equ I2C2_OAR2_OA2EN, 1 << 15   @ bitWidth 1 (Own Address 2 enable)  
 
    .equ I2C2_TIMINGR, I2C2_BASE + 0x10 @ (Access: No wait states) 
        .equ I2C2_TIMINGR_SCLL_Shift, 0   @ bitWidth 8 (SCL low period master mode This field  is used to generate the SCL low period in master  mode. tSCLL = SCLL+1 x tPRESC Note: SCLL is also  used to generate tBUF and tSU:STA  timings.)  
        .equ I2C2_TIMINGR_SCLH_Shift, 8   @ bitWidth 8 (SCL high period master mode This field  is used to generate the SCL high period in master  mode. tSCLH = SCLH+1 x tPRESC Note: SCLH is also  used to generate tSU:STO and tHD:STA  timing.)  
        .equ I2C2_TIMINGR_SDADEL_Shift, 16   @ bitWidth 4 (Data hold time This field is used to  generate the delay tSDADEL between SCL falling edge  and SDA edge. In master mode and in slave mode with  NOSTRETCH = 0, the SCL line is stretched low during  tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is  used to generate tHD:DAT timing.)  
        .equ I2C2_TIMINGR_SCLDEL_Shift, 20   @ bitWidth 4 (Data setup time This field is used to  generate a delay tSCLDEL between SDA edge and SCL  rising edge. In master mode and in slave mode with  NOSTRETCH = 0, the SCL line is stretched low during  tSCLDEL. tSCLDEL = SCLDEL+1 x tPRESC Note: tSCLDEL  is used to generate tSU:DAT timing.)  
        .equ I2C2_TIMINGR_PRESC_Shift, 28   @ bitWidth 4 (Timing prescaler This field is used to  prescale I2CCLK in order to generate the clock period  tPRESC used for data setup and hold counters refer  to I2C timings on page9 and for SCL high and low  level counters refer to I2C master initialization on  page24. tPRESC = PRESC+1 x tI2CCLK)  
 
    .equ I2C2_TIMEOUTR, I2C2_BASE + 0x14 @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C2_TIMEOUTR_TIMEOUTA_Shift, 0   @ bitWidth 12 (Bus Timeout A This field is used to  configure: The SCL low timeout condition tTIMEOUT  when TIDLE=0 tTIMEOUT= TIMEOUTA+1 x 2048 x tI2CCLK  The bus idle condition both SCL and SDA high when  TIDLE=1 tIDLE= TIMEOUTA+1 x 4 x tI2CCLK Note: These  bits can be written only when  TIMOUTEN=0.)  
        .equ I2C2_TIMEOUTR_TIDLE, 1 << 12   @ bitWidth 1 (Idle clock timeout detection Note: This  bit can be written only when  TIMOUTEN=0.)  
        .equ I2C2_TIMEOUTR_TIMOUTEN, 1 << 15   @ bitWidth 1 (Clock timeout enable)  
        .equ I2C2_TIMEOUTR_TIMEOUTB_Shift, 16   @ bitWidth 12 (Bus timeout B This field is used to  configure the cumulative clock extension timeout: In  master mode, the master cumulative clock low extend  time tLOW:MEXT is detected In slave mode, the slave  cumulative clock low extend time tLOW:SEXT is  detected tLOW:EXT= TIMEOUTB+1 x 2048 x tI2CCLK  Note: These bits can be written only when  TEXTEN=0.)  
        .equ I2C2_TIMEOUTR_TEXTEN, 1 << 31   @ bitWidth 1 (Extended clock timeout  enable)  
 
    .equ I2C2_ISR, I2C2_BASE + 0x18 @ (Access: No wait states) 
        .equ I2C2_ISR_TXE, 1 << 0   @ bitWidth 1 (Transmit data register empty  transmitters This bit is set by hardware when the  I2C_TXDR register is empty. It is cleared when the  next data to be sent is written in the I2C_TXDR  register. This bit can be written to 1 by software in  order to flush the transmit data register I2C_TXDR.  Note: This bit is set by hardware when  PE=0.)  
        .equ I2C2_ISR_TXIS, 1 << 1   @ bitWidth 1 (Transmit interrupt status transmitters  This bit is set by hardware when the I2C_TXDR  register is empty and the data to be transmitted must  be written in the I2C_TXDR register. It is cleared  when the next data to be sent is written in the  I2C_TXDR register. This bit can be written to 1 by  software when NOSTRETCH=1 only, in order to generate  a TXIS event interrupt if TXIE=1 or DMA request if  TXDMAEN=1. Note: This bit is cleared by hardware  when PE=0.)  
        .equ I2C2_ISR_RXNE, 1 << 2   @ bitWidth 1 (Receive data register not empty  receivers This bit is set by hardware when the  received data is copied into the I2C_RXDR register,  and is ready to be read. It is cleared when I2C_RXDR  is read. Note: This bit is cleared by hardware when  PE=0.)  
        .equ I2C2_ISR_ADDR, 1 << 3   @ bitWidth 1 (Address matched slave mode This bit is  set by hardware as soon as the received slave address  matched with one of the enabled slave addresses. It  is cleared by software by setting ADDRCF bit. Note:  This bit is cleared by hardware when  PE=0.)  
        .equ I2C2_ISR_NACKF, 1 << 4   @ bitWidth 1 (Not Acknowledge received flag This flag  is set by hardware when a NACK is received after a  byte transmission. It is cleared by software by  setting the NACKCF bit. Note: This bit is cleared by  hardware when PE=0.)  
        .equ I2C2_ISR_STOPF, 1 << 5   @ bitWidth 1 (Stop detection flag This flag is set by  hardware when a Stop condition is detected on the bus  and the peripheral is involved in this transfer:  either as a master, provided that the STOP condition  is generated by the peripheral. or as a slave,  provided that the peripheral has been addressed  previously during this transfer. It is cleared by  software by setting the STOPCF bit. Note: This bit is  cleared by hardware when PE=0.)  
        .equ I2C2_ISR_TC, 1 << 6   @ bitWidth 1 (Transfer Complete master mode This  flag is set by hardware when RELOAD=0, AUTOEND=0 and  NBYTES data have been transferred. It is cleared by  software when START bit or STOP bit is set. Note:  This bit is cleared by hardware when  PE=0.)  
        .equ I2C2_ISR_TCR, 1 << 7   @ bitWidth 1 (Transfer Complete Reload This flag is  set by hardware when RELOAD=1 and NBYTES data have  been transferred. It is cleared by software when  NBYTES is written to a non-zero value. Note: This bit  is cleared by hardware when PE=0. This flag is only  for master mode, or for slave mode when the SBC bit  is set.)  
        .equ I2C2_ISR_BERR, 1 << 8   @ bitWidth 1 (Bus error This flag is set by hardware  when a misplaced Start or Stop condition is detected  whereas the peripheral is involved in the transfer.  The flag is not set during the address phase in slave  mode. It is cleared by software by setting BERRCF  bit. Note: This bit is cleared by hardware when  PE=0.)  
        .equ I2C2_ISR_ARLO, 1 << 9   @ bitWidth 1 (Arbitration lost This flag is set by  hardware in case of arbitration loss. It is cleared  by software by setting the ARLOCF bit. Note: This bit  is cleared by hardware when PE=0.)  
        .equ I2C2_ISR_OVR, 1 << 10   @ bitWidth 1 (Overrun/Underrun slave mode This flag  is set by hardware in slave mode with NOSTRETCH=1,  when an overrun/underrun error occurs. It is cleared  by software by setting the OVRCF bit. Note: This bit  is cleared by hardware when PE=0.)  
        .equ I2C2_ISR_PECERR, 1 << 11   @ bitWidth 1 (PEC Error in reception This flag is set  by hardware when the received PEC does not match with  the PEC register content. A NACK is automatically  sent after the wrong PEC reception. It is cleared by  software by setting the PECCF bit. Note: This bit is  cleared by hardware when PE=0. If the SMBus feature  is not supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
        .equ I2C2_ISR_TIMEOUT, 1 << 12   @ bitWidth 1 (Timeout or tLOW detection flag This flag  is set by hardware when a timeout or extended clock  timeout occurred. It is cleared by software by  setting the TIMEOUTCF bit. Note: This bit is cleared  by hardware when PE=0. If the SMBus feature is not  supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
        .equ I2C2_ISR_ALERT, 1 << 13   @ bitWidth 1 (SMBus alert This flag is set by hardware  when SMBHEN=1 SMBus host configuration, ALERTEN=1  and a SMBALERT event falling edge is detected on  SMBA pin. It is cleared by software by setting the  ALERTCF bit. Note: This bit is cleared by hardware  when PE=0. If the SMBus feature is not supported,  this bit is reserved and forced by hardware to 0.  Please refer to Section25.3: I2C  implementation.)  
        .equ I2C2_ISR_BUSY, 1 << 15   @ bitWidth 1 (Bus busy This flag indicates that a  communication is in progress on the bus. It is set by  hardware when a START condition is detected. It is  cleared by hardware when a Stop condition is  detected, or when PE=0.)  
        .equ I2C2_ISR_DIR, 1 << 16   @ bitWidth 1 (Transfer direction Slave mode This  flag is updated when an address match event occurs  ADDR=1.)  
        .equ I2C2_ISR_ADDCODE_Shift, 17   @ bitWidth 7 (Address match code Slave mode These  bits are updated with the received address when an  address match event occurs ADDR = 1. In the case of  a 10-bit address, ADDCODE provides the 10-bit header  followed by the 2 MSBs of the address.)  
 
    .equ I2C2_ICR, I2C2_BASE + 0x1C @ (Access: No wait states) 
        .equ I2C2_ICR_ADDRCF, 1 << 3   @ bitWidth 1 (Address matched flag clear Writing 1 to  this bit clears the ADDR flag in the I2C_ISR  register. Writing 1 to this bit also clears the START  bit in the I2C_CR2 register.)  
        .equ I2C2_ICR_NACKCF, 1 << 4   @ bitWidth 1 (Not Acknowledge flag clear Writing 1 to  this bit clears the ACKF flag in I2C_ISR  register.)  
        .equ I2C2_ICR_STOPCF, 1 << 5   @ bitWidth 1 (Stop detection flag clear Writing 1 to  this bit clears the STOPF flag in the I2C_ISR  register.)  
        .equ I2C2_ICR_BERRCF, 1 << 8   @ bitWidth 1 (Bus error flag clear Writing 1 to this  bit clears the BERRF flag in the I2C_ISR  register.)  
        .equ I2C2_ICR_ARLOCF, 1 << 9   @ bitWidth 1 (Arbitration Lost flag clear Writing 1 to  this bit clears the ARLO flag in the I2C_ISR  register.)  
        .equ I2C2_ICR_OVRCF, 1 << 10   @ bitWidth 1 (Overrun/Underrun flag clear Writing 1 to  this bit clears the OVR flag in the I2C_ISR  register.)  
        .equ I2C2_ICR_PECCF, 1 << 11   @ bitWidth 1 (PEC Error flag clear Writing 1 to this  bit clears the PECERR flag in the I2C_ISR register.  Note: If the SMBus feature is not supported, this bit  is reserved and forced by hardware to 0. Please refer  to Section25.3: I2C implementation.)  
        .equ I2C2_ICR_TIMOUTCF, 1 << 12   @ bitWidth 1 (Timeout detection flag clear Writing 1  to this bit clears the TIMEOUT flag in the I2C_ISR  register. Note: If the SMBus feature is not  supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
        .equ I2C2_ICR_ALERTCF, 1 << 13   @ bitWidth 1 (Alert flag clear Writing 1 to this bit  clears the ALERT flag in the I2C_ISR register. Note:  If the SMBus feature is not supported, this bit is  reserved and forced by hardware to 0. Please refer to  Section25.3: I2C implementation.)  
 
    .equ I2C2_PECR, I2C2_BASE + 0x20 @ (Access: No wait states) 
        .equ I2C2_PECR_PEC_Shift, 0   @ bitWidth 8 (Packet error checking register This  field contains the internal PEC when PECEN=1. The PEC  is cleared by hardware when PE=0.)  
 
    .equ I2C2_RXDR, I2C2_BASE + 0x24 @ (Access: No wait states) 
        .equ I2C2_RXDR_RXDATA_Shift, 0   @ bitWidth 8 (8-bit receive data Data byte received  from the I2C bus.)  
 
    .equ I2C2_TXDR, I2C2_BASE + 0x28 @ (Access: No wait states) 
        .equ I2C2_TXDR_TXDATA_Shift, 0   @ bitWidth 8 (8-bit transmit data Data byte to be  transmitted to the I2C bus. Note: These bits can be  written only when TXE=1.)  
 

@=========================== I2C3 ===========================@
.equ I2C3_BASE, 0x40005C00 @ (I2C) 
    .equ I2C3_CR1, I2C3_BASE + 0x0 @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C3_CR1_PE, 1 << 0   @ bitWidth 1 (Peripheral enable Note: When PE=0, the  I2C SCL and SDA lines are released. Internal state  machines and status bits are put back to their reset  value. When cleared, PE must be kept low for at least  3 APB clock cycles.)  
        .equ I2C3_CR1_TXIE, 1 << 1   @ bitWidth 1 (TX Interrupt enable)  
        .equ I2C3_CR1_RXIE, 1 << 2   @ bitWidth 1 (RX Interrupt enable)  
        .equ I2C3_CR1_ADDRIE, 1 << 3   @ bitWidth 1 (Address match Interrupt enable slave  only)  
        .equ I2C3_CR1_NACKIE, 1 << 4   @ bitWidth 1 (Not acknowledge received Interrupt  enable)  
        .equ I2C3_CR1_STOPIE, 1 << 5   @ bitWidth 1 (STOP detection Interrupt  enable)  
        .equ I2C3_CR1_TCIE, 1 << 6   @ bitWidth 1 (Transfer Complete interrupt enable Note:  Any of these events will generate an interrupt:  Transfer Complete TC Transfer Complete Reload  TCR)  
        .equ I2C3_CR1_ERRIE, 1 << 7   @ bitWidth 1 (Error interrupts enable Note: Any of  these errors generate an interrupt: Arbitration Loss  ARLO Bus Error detection BERR Overrun/Underrun  OVR Timeout detection TIMEOUT PEC error detection  PECERR Alert pin event detection  ALERT)  
        .equ I2C3_CR1_DNF_Shift, 8   @ bitWidth 4 (Digital noise filter These bits are used  to configure the digital noise filter on SDA and SCL  input. The digital filter will filter spikes with a  length of up to DNF[3:0] * tI2CCLK ... Note: If the  analog filter is also enabled, the digital filter is  added to the analog filter. This filter can only be  programmed when the I2C is disabled PE =  0.)  
        .equ I2C3_CR1_ANFOFF, 1 << 12   @ bitWidth 1 (Analog noise filter OFF Note: This bit  can only be programmed when the I2C is disabled PE =  0.)  
        .equ I2C3_CR1_TXDMAEN, 1 << 14   @ bitWidth 1 (DMA transmission requests  enable)  
        .equ I2C3_CR1_RXDMAEN, 1 << 15   @ bitWidth 1 (DMA reception requests  enable)  
        .equ I2C3_CR1_SBC, 1 << 16   @ bitWidth 1 (Slave byte control This bit is used to  enable hardware byte control in slave  mode.)  
        .equ I2C3_CR1_NOSTRETCH, 1 << 17   @ bitWidth 1 (Clock stretching disable This bit is  used to disable clock stretching in slave mode. It  must be kept cleared in master mode. Note: This bit  can only be programmed when the I2C is disabled PE =  0.)  
        .equ I2C3_CR1_WUPEN, 1 << 18   @ bitWidth 1 (Wakeup from Stop mode enable Note: If  the Wakeup from Stop mode feature is not supported,  this bit is reserved and forced by hardware to 0.  Please refer to Section25.3: I2C implementation.  Note: WUPEN can be set only when DNF =  0000)  
        .equ I2C3_CR1_GCEN, 1 << 19   @ bitWidth 1 (General call enable)  
        .equ I2C3_CR1_SMBHEN, 1 << 20   @ bitWidth 1 (SMBus Host address enable Note: If the  SMBus feature is not supported, this bit is reserved  and forced by hardware to 0. Please refer to  Section25.3: I2C implementation.)  
        .equ I2C3_CR1_SMBDEN, 1 << 21   @ bitWidth 1 (SMBus Device Default address enable  Note: If the SMBus feature is not supported, this bit  is reserved and forced by hardware to 0. Please refer  to Section25.3: I2C implementation.)  
        .equ I2C3_CR1_ALERTEN, 1 << 22   @ bitWidth 1 (SMBus alert enable Device mode  SMBHEN=0: Host mode SMBHEN=1: Note: When  ALERTEN=0, the SMBA pin can be used as a standard  GPIO. If the SMBus feature is not supported, this bit  is reserved and forced by hardware to 0. Please refer  to Section25.3: I2C implementation.)  
        .equ I2C3_CR1_PECEN, 1 << 23   @ bitWidth 1 (PEC enable Note: If the SMBus feature is  not supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
 
    .equ I2C3_CR2, I2C3_BASE + 0x4 @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C3_CR2_SADD0, 1 << 0   @ bitWidth 1 (Slave address bit 0 master mode In  7-bit addressing mode ADD10 = 0: This bit is dont  care In 10-bit addressing mode ADD10 = 1: This bit  should be written with bit 0 of the slave address to  be sent Note: Changing these bits when the START bit  is set is not allowed.)  
        .equ I2C3_CR2_SADD1, 1 << 1   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C3_CR2_SADD2, 1 << 2   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C3_CR2_SADD3, 1 << 3   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C3_CR2_SADD4, 1 << 4   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C3_CR2_SADD5, 1 << 5   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C3_CR2_SADD6, 1 << 6   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C3_CR2_SADD7, 1 << 7   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C3_CR2_SADD8, 1 << 8   @ bitWidth 1 (Slave address bit 9:8 master mode In  7-bit addressing mode ADD10 = 0: These bits are  dont care In 10-bit addressing mode ADD10 = 1:  These bits should be written with bits 9:8 of the  slave address to be sent Note: Changing these bits  when the START bit is set is not  allowed.)  
        .equ I2C3_CR2_SADD9, 1 << 9   @ bitWidth 1 (Slave address bit 9:8 master mode In  7-bit addressing mode ADD10 = 0: These bits are  dont care In 10-bit addressing mode ADD10 = 1:  These bits should be written with bits 9:8 of the  slave address to be sent Note: Changing these bits  when the START bit is set is not  allowed.)  
        .equ I2C3_CR2_RD_WRN, 1 << 10   @ bitWidth 1 (Transfer direction master mode Note:  Changing this bit when the START bit is set is not  allowed.)  
        .equ I2C3_CR2_ADD10, 1 << 11   @ bitWidth 1 (10-bit addressing mode master mode  Note: Changing this bit when the START bit is set is  not allowed.)  
        .equ I2C3_CR2_HEAD10R, 1 << 12   @ bitWidth 1 (10-bit address header only read  direction master receiver mode Note: Changing this  bit when the START bit is set is not  allowed.)  
        .equ I2C3_CR2_START, 1 << 13   @ bitWidth 1 (Start generation This bit is set by  software, and cleared by hardware after the Start  followed by the address sequence is sent, by an  arbitration loss, by a timeout error detection, or  when PE = 0. It can also be cleared by software by  writing 1 to the ADDRCF bit in the I2C_ICR register.  If the I2C is already in master mode with AUTOEND =  0, setting this bit generates a Repeated Start  condition when RELOAD=0, after the end of the NBYTES  transfer. Otherwise setting this bit will generate a  START condition once the bus is free. Note: Writing 0  to this bit has no effect. The START bit can be set  even if the bus is BUSY or I2C is in slave mode. This  bit has no effect when RELOAD is set.)  
        .equ I2C3_CR2_STOP, 1 << 14   @ bitWidth 1 (Stop generation master mode The bit is  set by software, cleared by hardware when a Stop  condition is detected, or when PE = 0. In Master  Mode: Note: Writing 0 to this bit has no  effect.)  
        .equ I2C3_CR2_NACK, 1 << 15   @ bitWidth 1 (NACK generation slave mode The bit is  set by software, cleared by hardware when the NACK is  sent, or when a STOP condition or an Address matched  is received, or when PE=0. Note: Writing 0 to this  bit has no effect. This bit is used in slave mode  only: in master receiver mode, NACK is automatically  generated after last byte preceding STOP or RESTART  condition, whatever the NACK bit value. When an  overrun occurs in slave receiver NOSTRETCH mode, a  NACK is automatically generated whatever the NACK bit  value. When hardware PEC checking is enabled  PECBYTE=1, the PEC acknowledge value does not  depend on the NACK value.)  
        .equ I2C3_CR2_NBYTES_Shift, 16   @ bitWidth 8 (Number of bytes The number of bytes to  be transmitted/received is programmed there. This  field is dont care in slave mode with SBC=0. Note:  Changing these bits when the START bit is set is not  allowed.)  
        .equ I2C3_CR2_RELOAD, 1 << 24   @ bitWidth 1 (NBYTES reload mode This bit is set and  cleared by software.)  
        .equ I2C3_CR2_AUTOEND, 1 << 25   @ bitWidth 1 (Automatic end mode master mode This  bit is set and cleared by software. Note: This bit  has no effect in slave mode or when the RELOAD bit is  set.)  
        .equ I2C3_CR2_PECBYTE, 1 << 26   @ bitWidth 1 (Packet error checking byte This bit is  set by software, and cleared by hardware when the PEC  is transferred, or when a STOP condition or an  Address matched is received, also when PE=0. Note:  Writing 0 to this bit has no effect. This bit has no  effect when RELOAD is set. This bit has no effect is  slave mode when SBC=0. If the SMBus feature is not  supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
 
    .equ I2C3_OAR1, I2C3_BASE + 0x8 @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C3_OAR1_OA1_Shift, 0   @ bitWidth 10 (Interface address 7-bit addressing mode:  dont care 10-bit addressing mode: bits 9:8 of address  Note: These bits can be written only when OA1EN=0.  OA1[7:1]: Interface address Bits 7:1 of address Note:  These bits can be written only when OA1EN=0. OA1[0]:  Interface address 7-bit addressing mode: dont care  10-bit addressing mode: bit 0 of address Note: This  bit can be written only when OA1EN=0.)  
        .equ I2C3_OAR1_OA1MODE, 1 << 10   @ bitWidth 1 (Own Address 1 10-bit mode Note: This bit  can be written only when OA1EN=0.)  
        .equ I2C3_OAR1_OA1EN, 1 << 15   @ bitWidth 1 (Own Address 1 enable)  
 
    .equ I2C3_OAR2, I2C3_BASE + 0xC @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C3_OAR2_OA2_Shift, 1   @ bitWidth 7 (Interface address bits 7:1 of address  Note: These bits can be written only when  OA2EN=0.)  
        .equ I2C3_OAR2_OA2MSK_Shift, 8   @ bitWidth 3 (Own Address 2 masks Note: These bits can  be written only when OA2EN=0. As soon as OA2MSK is  not equal to 0, the reserved I2C addresses 0b0000xxx  and 0b1111xxx are not acknowledged even if the  comparison matches.)  
        .equ I2C3_OAR2_OA2EN, 1 << 15   @ bitWidth 1 (Own Address 2 enable)  
 
    .equ I2C3_TIMINGR, I2C3_BASE + 0x10 @ (Access: No wait states) 
        .equ I2C3_TIMINGR_SCLL_Shift, 0   @ bitWidth 8 (SCL low period master mode This field  is used to generate the SCL low period in master  mode. tSCLL = SCLL+1 x tPRESC Note: SCLL is also  used to generate tBUF and tSU:STA  timings.)  
        .equ I2C3_TIMINGR_SCLH_Shift, 8   @ bitWidth 8 (SCL high period master mode This field  is used to generate the SCL high period in master  mode. tSCLH = SCLH+1 x tPRESC Note: SCLH is also  used to generate tSU:STO and tHD:STA  timing.)  
        .equ I2C3_TIMINGR_SDADEL_Shift, 16   @ bitWidth 4 (Data hold time This field is used to  generate the delay tSDADEL between SCL falling edge  and SDA edge. In master mode and in slave mode with  NOSTRETCH = 0, the SCL line is stretched low during  tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is  used to generate tHD:DAT timing.)  
        .equ I2C3_TIMINGR_SCLDEL_Shift, 20   @ bitWidth 4 (Data setup time This field is used to  generate a delay tSCLDEL between SDA edge and SCL  rising edge. In master mode and in slave mode with  NOSTRETCH = 0, the SCL line is stretched low during  tSCLDEL. tSCLDEL = SCLDEL+1 x tPRESC Note: tSCLDEL  is used to generate tSU:DAT timing.)  
        .equ I2C3_TIMINGR_PRESC_Shift, 28   @ bitWidth 4 (Timing prescaler This field is used to  prescale I2CCLK in order to generate the clock period  tPRESC used for data setup and hold counters refer  to I2C timings on page9 and for SCL high and low  level counters refer to I2C master initialization on  page24. tPRESC = PRESC+1 x tI2CCLK)  
 
    .equ I2C3_TIMEOUTR, I2C3_BASE + 0x14 @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C3_TIMEOUTR_TIMEOUTA_Shift, 0   @ bitWidth 12 (Bus Timeout A This field is used to  configure: The SCL low timeout condition tTIMEOUT  when TIDLE=0 tTIMEOUT= TIMEOUTA+1 x 2048 x tI2CCLK  The bus idle condition both SCL and SDA high when  TIDLE=1 tIDLE= TIMEOUTA+1 x 4 x tI2CCLK Note: These  bits can be written only when  TIMOUTEN=0.)  
        .equ I2C3_TIMEOUTR_TIDLE, 1 << 12   @ bitWidth 1 (Idle clock timeout detection Note: This  bit can be written only when  TIMOUTEN=0.)  
        .equ I2C3_TIMEOUTR_TIMOUTEN, 1 << 15   @ bitWidth 1 (Clock timeout enable)  
        .equ I2C3_TIMEOUTR_TIMEOUTB_Shift, 16   @ bitWidth 12 (Bus timeout B This field is used to  configure the cumulative clock extension timeout: In  master mode, the master cumulative clock low extend  time tLOW:MEXT is detected In slave mode, the slave  cumulative clock low extend time tLOW:SEXT is  detected tLOW:EXT= TIMEOUTB+1 x 2048 x tI2CCLK  Note: These bits can be written only when  TEXTEN=0.)  
        .equ I2C3_TIMEOUTR_TEXTEN, 1 << 31   @ bitWidth 1 (Extended clock timeout  enable)  
 
    .equ I2C3_ISR, I2C3_BASE + 0x18 @ (Access: No wait states) 
        .equ I2C3_ISR_TXE, 1 << 0   @ bitWidth 1 (Transmit data register empty  transmitters This bit is set by hardware when the  I2C_TXDR register is empty. It is cleared when the  next data to be sent is written in the I2C_TXDR  register. This bit can be written to 1 by software in  order to flush the transmit data register I2C_TXDR.  Note: This bit is set by hardware when  PE=0.)  
        .equ I2C3_ISR_TXIS, 1 << 1   @ bitWidth 1 (Transmit interrupt status transmitters  This bit is set by hardware when the I2C_TXDR  register is empty and the data to be transmitted must  be written in the I2C_TXDR register. It is cleared  when the next data to be sent is written in the  I2C_TXDR register. This bit can be written to 1 by  software when NOSTRETCH=1 only, in order to generate  a TXIS event interrupt if TXIE=1 or DMA request if  TXDMAEN=1. Note: This bit is cleared by hardware  when PE=0.)  
        .equ I2C3_ISR_RXNE, 1 << 2   @ bitWidth 1 (Receive data register not empty  receivers This bit is set by hardware when the  received data is copied into the I2C_RXDR register,  and is ready to be read. It is cleared when I2C_RXDR  is read. Note: This bit is cleared by hardware when  PE=0.)  
        .equ I2C3_ISR_ADDR, 1 << 3   @ bitWidth 1 (Address matched slave mode This bit is  set by hardware as soon as the received slave address  matched with one of the enabled slave addresses. It  is cleared by software by setting ADDRCF bit. Note:  This bit is cleared by hardware when  PE=0.)  
        .equ I2C3_ISR_NACKF, 1 << 4   @ bitWidth 1 (Not Acknowledge received flag This flag  is set by hardware when a NACK is received after a  byte transmission. It is cleared by software by  setting the NACKCF bit. Note: This bit is cleared by  hardware when PE=0.)  
        .equ I2C3_ISR_STOPF, 1 << 5   @ bitWidth 1 (Stop detection flag This flag is set by  hardware when a Stop condition is detected on the bus  and the peripheral is involved in this transfer:  either as a master, provided that the STOP condition  is generated by the peripheral. or as a slave,  provided that the peripheral has been addressed  previously during this transfer. It is cleared by  software by setting the STOPCF bit. Note: This bit is  cleared by hardware when PE=0.)  
        .equ I2C3_ISR_TC, 1 << 6   @ bitWidth 1 (Transfer Complete master mode This  flag is set by hardware when RELOAD=0, AUTOEND=0 and  NBYTES data have been transferred. It is cleared by  software when START bit or STOP bit is set. Note:  This bit is cleared by hardware when  PE=0.)  
        .equ I2C3_ISR_TCR, 1 << 7   @ bitWidth 1 (Transfer Complete Reload This flag is  set by hardware when RELOAD=1 and NBYTES data have  been transferred. It is cleared by software when  NBYTES is written to a non-zero value. Note: This bit  is cleared by hardware when PE=0. This flag is only  for master mode, or for slave mode when the SBC bit  is set.)  
        .equ I2C3_ISR_BERR, 1 << 8   @ bitWidth 1 (Bus error This flag is set by hardware  when a misplaced Start or Stop condition is detected  whereas the peripheral is involved in the transfer.  The flag is not set during the address phase in slave  mode. It is cleared by software by setting BERRCF  bit. Note: This bit is cleared by hardware when  PE=0.)  
        .equ I2C3_ISR_ARLO, 1 << 9   @ bitWidth 1 (Arbitration lost This flag is set by  hardware in case of arbitration loss. It is cleared  by software by setting the ARLOCF bit. Note: This bit  is cleared by hardware when PE=0.)  
        .equ I2C3_ISR_OVR, 1 << 10   @ bitWidth 1 (Overrun/Underrun slave mode This flag  is set by hardware in slave mode with NOSTRETCH=1,  when an overrun/underrun error occurs. It is cleared  by software by setting the OVRCF bit. Note: This bit  is cleared by hardware when PE=0.)  
        .equ I2C3_ISR_PECERR, 1 << 11   @ bitWidth 1 (PEC Error in reception This flag is set  by hardware when the received PEC does not match with  the PEC register content. A NACK is automatically  sent after the wrong PEC reception. It is cleared by  software by setting the PECCF bit. Note: This bit is  cleared by hardware when PE=0. If the SMBus feature  is not supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
        .equ I2C3_ISR_TIMEOUT, 1 << 12   @ bitWidth 1 (Timeout or tLOW detection flag This flag  is set by hardware when a timeout or extended clock  timeout occurred. It is cleared by software by  setting the TIMEOUTCF bit. Note: This bit is cleared  by hardware when PE=0. If the SMBus feature is not  supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
        .equ I2C3_ISR_ALERT, 1 << 13   @ bitWidth 1 (SMBus alert This flag is set by hardware  when SMBHEN=1 SMBus host configuration, ALERTEN=1  and a SMBALERT event falling edge is detected on  SMBA pin. It is cleared by software by setting the  ALERTCF bit. Note: This bit is cleared by hardware  when PE=0. If the SMBus feature is not supported,  this bit is reserved and forced by hardware to 0.  Please refer to Section25.3: I2C  implementation.)  
        .equ I2C3_ISR_BUSY, 1 << 15   @ bitWidth 1 (Bus busy This flag indicates that a  communication is in progress on the bus. It is set by  hardware when a START condition is detected. It is  cleared by hardware when a Stop condition is  detected, or when PE=0.)  
        .equ I2C3_ISR_DIR, 1 << 16   @ bitWidth 1 (Transfer direction Slave mode This  flag is updated when an address match event occurs  ADDR=1.)  
        .equ I2C3_ISR_ADDCODE_Shift, 17   @ bitWidth 7 (Address match code Slave mode These  bits are updated with the received address when an  address match event occurs ADDR = 1. In the case of  a 10-bit address, ADDCODE provides the 10-bit header  followed by the 2 MSBs of the address.)  
 
    .equ I2C3_ICR, I2C3_BASE + 0x1C @ (Access: No wait states) 
        .equ I2C3_ICR_ADDRCF, 1 << 3   @ bitWidth 1 (Address matched flag clear Writing 1 to  this bit clears the ADDR flag in the I2C_ISR  register. Writing 1 to this bit also clears the START  bit in the I2C_CR2 register.)  
        .equ I2C3_ICR_NACKCF, 1 << 4   @ bitWidth 1 (Not Acknowledge flag clear Writing 1 to  this bit clears the ACKF flag in I2C_ISR  register.)  
        .equ I2C3_ICR_STOPCF, 1 << 5   @ bitWidth 1 (Stop detection flag clear Writing 1 to  this bit clears the STOPF flag in the I2C_ISR  register.)  
        .equ I2C3_ICR_BERRCF, 1 << 8   @ bitWidth 1 (Bus error flag clear Writing 1 to this  bit clears the BERRF flag in the I2C_ISR  register.)  
        .equ I2C3_ICR_ARLOCF, 1 << 9   @ bitWidth 1 (Arbitration Lost flag clear Writing 1 to  this bit clears the ARLO flag in the I2C_ISR  register.)  
        .equ I2C3_ICR_OVRCF, 1 << 10   @ bitWidth 1 (Overrun/Underrun flag clear Writing 1 to  this bit clears the OVR flag in the I2C_ISR  register.)  
        .equ I2C3_ICR_PECCF, 1 << 11   @ bitWidth 1 (PEC Error flag clear Writing 1 to this  bit clears the PECERR flag in the I2C_ISR register.  Note: If the SMBus feature is not supported, this bit  is reserved and forced by hardware to 0. Please refer  to Section25.3: I2C implementation.)  
        .equ I2C3_ICR_TIMOUTCF, 1 << 12   @ bitWidth 1 (Timeout detection flag clear Writing 1  to this bit clears the TIMEOUT flag in the I2C_ISR  register. Note: If the SMBus feature is not  supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
        .equ I2C3_ICR_ALERTCF, 1 << 13   @ bitWidth 1 (Alert flag clear Writing 1 to this bit  clears the ALERT flag in the I2C_ISR register. Note:  If the SMBus feature is not supported, this bit is  reserved and forced by hardware to 0. Please refer to  Section25.3: I2C implementation.)  
 
    .equ I2C3_PECR, I2C3_BASE + 0x20 @ (Access: No wait states) 
        .equ I2C3_PECR_PEC_Shift, 0   @ bitWidth 8 (Packet error checking register This  field contains the internal PEC when PECEN=1. The PEC  is cleared by hardware when PE=0.)  
 
    .equ I2C3_RXDR, I2C3_BASE + 0x24 @ (Access: No wait states) 
        .equ I2C3_RXDR_RXDATA_Shift, 0   @ bitWidth 8 (8-bit receive data Data byte received  from the I2C bus.)  
 
    .equ I2C3_TXDR, I2C3_BASE + 0x28 @ (Access: No wait states) 
        .equ I2C3_TXDR_TXDATA_Shift, 0   @ bitWidth 8 (8-bit transmit data Data byte to be  transmitted to the I2C bus. Note: These bits can be  written only when TXE=1.)  
 

@=========================== I2C4 ===========================@
.equ I2C4_BASE, 0x58001C00 @ (I2C) 
    .equ I2C4_CR1, I2C4_BASE + 0x0 @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C4_CR1_PE, 1 << 0   @ bitWidth 1 (Peripheral enable Note: When PE=0, the  I2C SCL and SDA lines are released. Internal state  machines and status bits are put back to their reset  value. When cleared, PE must be kept low for at least  3 APB clock cycles.)  
        .equ I2C4_CR1_TXIE, 1 << 1   @ bitWidth 1 (TX Interrupt enable)  
        .equ I2C4_CR1_RXIE, 1 << 2   @ bitWidth 1 (RX Interrupt enable)  
        .equ I2C4_CR1_ADDRIE, 1 << 3   @ bitWidth 1 (Address match Interrupt enable slave  only)  
        .equ I2C4_CR1_NACKIE, 1 << 4   @ bitWidth 1 (Not acknowledge received Interrupt  enable)  
        .equ I2C4_CR1_STOPIE, 1 << 5   @ bitWidth 1 (STOP detection Interrupt  enable)  
        .equ I2C4_CR1_TCIE, 1 << 6   @ bitWidth 1 (Transfer Complete interrupt enable Note:  Any of these events will generate an interrupt:  Transfer Complete TC Transfer Complete Reload  TCR)  
        .equ I2C4_CR1_ERRIE, 1 << 7   @ bitWidth 1 (Error interrupts enable Note: Any of  these errors generate an interrupt: Arbitration Loss  ARLO Bus Error detection BERR Overrun/Underrun  OVR Timeout detection TIMEOUT PEC error detection  PECERR Alert pin event detection  ALERT)  
        .equ I2C4_CR1_DNF_Shift, 8   @ bitWidth 4 (Digital noise filter These bits are used  to configure the digital noise filter on SDA and SCL  input. The digital filter will filter spikes with a  length of up to DNF[3:0] * tI2CCLK ... Note: If the  analog filter is also enabled, the digital filter is  added to the analog filter. This filter can only be  programmed when the I2C is disabled PE =  0.)  
        .equ I2C4_CR1_ANFOFF, 1 << 12   @ bitWidth 1 (Analog noise filter OFF Note: This bit  can only be programmed when the I2C is disabled PE =  0.)  
        .equ I2C4_CR1_TXDMAEN, 1 << 14   @ bitWidth 1 (DMA transmission requests  enable)  
        .equ I2C4_CR1_RXDMAEN, 1 << 15   @ bitWidth 1 (DMA reception requests  enable)  
        .equ I2C4_CR1_SBC, 1 << 16   @ bitWidth 1 (Slave byte control This bit is used to  enable hardware byte control in slave  mode.)  
        .equ I2C4_CR1_NOSTRETCH, 1 << 17   @ bitWidth 1 (Clock stretching disable This bit is  used to disable clock stretching in slave mode. It  must be kept cleared in master mode. Note: This bit  can only be programmed when the I2C is disabled PE =  0.)  
        .equ I2C4_CR1_WUPEN, 1 << 18   @ bitWidth 1 (Wakeup from Stop mode enable Note: If  the Wakeup from Stop mode feature is not supported,  this bit is reserved and forced by hardware to 0.  Please refer to Section25.3: I2C implementation.  Note: WUPEN can be set only when DNF =  0000)  
        .equ I2C4_CR1_GCEN, 1 << 19   @ bitWidth 1 (General call enable)  
        .equ I2C4_CR1_SMBHEN, 1 << 20   @ bitWidth 1 (SMBus Host address enable Note: If the  SMBus feature is not supported, this bit is reserved  and forced by hardware to 0. Please refer to  Section25.3: I2C implementation.)  
        .equ I2C4_CR1_SMBDEN, 1 << 21   @ bitWidth 1 (SMBus Device Default address enable  Note: If the SMBus feature is not supported, this bit  is reserved and forced by hardware to 0. Please refer  to Section25.3: I2C implementation.)  
        .equ I2C4_CR1_ALERTEN, 1 << 22   @ bitWidth 1 (SMBus alert enable Device mode  SMBHEN=0: Host mode SMBHEN=1: Note: When  ALERTEN=0, the SMBA pin can be used as a standard  GPIO. If the SMBus feature is not supported, this bit  is reserved and forced by hardware to 0. Please refer  to Section25.3: I2C implementation.)  
        .equ I2C4_CR1_PECEN, 1 << 23   @ bitWidth 1 (PEC enable Note: If the SMBus feature is  not supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
 
    .equ I2C4_CR2, I2C4_BASE + 0x4 @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C4_CR2_SADD0, 1 << 0   @ bitWidth 1 (Slave address bit 0 master mode In  7-bit addressing mode ADD10 = 0: This bit is dont  care In 10-bit addressing mode ADD10 = 1: This bit  should be written with bit 0 of the slave address to  be sent Note: Changing these bits when the START bit  is set is not allowed.)  
        .equ I2C4_CR2_SADD1, 1 << 1   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C4_CR2_SADD2, 1 << 2   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C4_CR2_SADD3, 1 << 3   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C4_CR2_SADD4, 1 << 4   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C4_CR2_SADD5, 1 << 5   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C4_CR2_SADD6, 1 << 6   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C4_CR2_SADD7, 1 << 7   @ bitWidth 1 (Slave address bit 7:1 master mode In  7-bit addressing mode ADD10 = 0: These bits should  be written with the 7-bit slave address to be sent In  10-bit addressing mode ADD10 = 1: These bits should  be written with bits 7:1 of the slave address to be  sent. Note: Changing these bits when the START bit is  set is not allowed.)  
        .equ I2C4_CR2_SADD8, 1 << 8   @ bitWidth 1 (Slave address bit 9:8 master mode In  7-bit addressing mode ADD10 = 0: These bits are  dont care In 10-bit addressing mode ADD10 = 1:  These bits should be written with bits 9:8 of the  slave address to be sent Note: Changing these bits  when the START bit is set is not  allowed.)  
        .equ I2C4_CR2_SADD9, 1 << 9   @ bitWidth 1 (Slave address bit 9:8 master mode In  7-bit addressing mode ADD10 = 0: These bits are  dont care In 10-bit addressing mode ADD10 = 1:  These bits should be written with bits 9:8 of the  slave address to be sent Note: Changing these bits  when the START bit is set is not  allowed.)  
        .equ I2C4_CR2_RD_WRN, 1 << 10   @ bitWidth 1 (Transfer direction master mode Note:  Changing this bit when the START bit is set is not  allowed.)  
        .equ I2C4_CR2_ADD10, 1 << 11   @ bitWidth 1 (10-bit addressing mode master mode  Note: Changing this bit when the START bit is set is  not allowed.)  
        .equ I2C4_CR2_HEAD10R, 1 << 12   @ bitWidth 1 (10-bit address header only read  direction master receiver mode Note: Changing this  bit when the START bit is set is not  allowed.)  
        .equ I2C4_CR2_START, 1 << 13   @ bitWidth 1 (Start generation This bit is set by  software, and cleared by hardware after the Start  followed by the address sequence is sent, by an  arbitration loss, by a timeout error detection, or  when PE = 0. It can also be cleared by software by  writing 1 to the ADDRCF bit in the I2C_ICR register.  If the I2C is already in master mode with AUTOEND =  0, setting this bit generates a Repeated Start  condition when RELOAD=0, after the end of the NBYTES  transfer. Otherwise setting this bit will generate a  START condition once the bus is free. Note: Writing 0  to this bit has no effect. The START bit can be set  even if the bus is BUSY or I2C is in slave mode. This  bit has no effect when RELOAD is set.)  
        .equ I2C4_CR2_STOP, 1 << 14   @ bitWidth 1 (Stop generation master mode The bit is  set by software, cleared by hardware when a Stop  condition is detected, or when PE = 0. In Master  Mode: Note: Writing 0 to this bit has no  effect.)  
        .equ I2C4_CR2_NACK, 1 << 15   @ bitWidth 1 (NACK generation slave mode The bit is  set by software, cleared by hardware when the NACK is  sent, or when a STOP condition or an Address matched  is received, or when PE=0. Note: Writing 0 to this  bit has no effect. This bit is used in slave mode  only: in master receiver mode, NACK is automatically  generated after last byte preceding STOP or RESTART  condition, whatever the NACK bit value. When an  overrun occurs in slave receiver NOSTRETCH mode, a  NACK is automatically generated whatever the NACK bit  value. When hardware PEC checking is enabled  PECBYTE=1, the PEC acknowledge value does not  depend on the NACK value.)  
        .equ I2C4_CR2_NBYTES_Shift, 16   @ bitWidth 8 (Number of bytes The number of bytes to  be transmitted/received is programmed there. This  field is dont care in slave mode with SBC=0. Note:  Changing these bits when the START bit is set is not  allowed.)  
        .equ I2C4_CR2_RELOAD, 1 << 24   @ bitWidth 1 (NBYTES reload mode This bit is set and  cleared by software.)  
        .equ I2C4_CR2_AUTOEND, 1 << 25   @ bitWidth 1 (Automatic end mode master mode This  bit is set and cleared by software. Note: This bit  has no effect in slave mode or when the RELOAD bit is  set.)  
        .equ I2C4_CR2_PECBYTE, 1 << 26   @ bitWidth 1 (Packet error checking byte This bit is  set by software, and cleared by hardware when the PEC  is transferred, or when a STOP condition or an  Address matched is received, also when PE=0. Note:  Writing 0 to this bit has no effect. This bit has no  effect when RELOAD is set. This bit has no effect is  slave mode when SBC=0. If the SMBus feature is not  supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
 
    .equ I2C4_OAR1, I2C4_BASE + 0x8 @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C4_OAR1_OA1_Shift, 0   @ bitWidth 10 (Interface address 7-bit addressing mode:  dont care 10-bit addressing mode: bits 9:8 of address  Note: These bits can be written only when OA1EN=0.  OA1[7:1]: Interface address Bits 7:1 of address Note:  These bits can be written only when OA1EN=0. OA1[0]:  Interface address 7-bit addressing mode: dont care  10-bit addressing mode: bit 0 of address Note: This  bit can be written only when OA1EN=0.)  
        .equ I2C4_OAR1_OA1MODE, 1 << 10   @ bitWidth 1 (Own Address 1 10-bit mode Note: This bit  can be written only when OA1EN=0.)  
        .equ I2C4_OAR1_OA1EN, 1 << 15   @ bitWidth 1 (Own Address 1 enable)  
 
    .equ I2C4_OAR2, I2C4_BASE + 0xC @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C4_OAR2_OA2_Shift, 1   @ bitWidth 7 (Interface address bits 7:1 of address  Note: These bits can be written only when  OA2EN=0.)  
        .equ I2C4_OAR2_OA2MSK_Shift, 8   @ bitWidth 3 (Own Address 2 masks Note: These bits can  be written only when OA2EN=0. As soon as OA2MSK is  not equal to 0, the reserved I2C addresses 0b0000xxx  and 0b1111xxx are not acknowledged even if the  comparison matches.)  
        .equ I2C4_OAR2_OA2EN, 1 << 15   @ bitWidth 1 (Own Address 2 enable)  
 
    .equ I2C4_TIMINGR, I2C4_BASE + 0x10 @ (Access: No wait states) 
        .equ I2C4_TIMINGR_SCLL_Shift, 0   @ bitWidth 8 (SCL low period master mode This field  is used to generate the SCL low period in master  mode. tSCLL = SCLL+1 x tPRESC Note: SCLL is also  used to generate tBUF and tSU:STA  timings.)  
        .equ I2C4_TIMINGR_SCLH_Shift, 8   @ bitWidth 8 (SCL high period master mode This field  is used to generate the SCL high period in master  mode. tSCLH = SCLH+1 x tPRESC Note: SCLH is also  used to generate tSU:STO and tHD:STA  timing.)  
        .equ I2C4_TIMINGR_SDADEL_Shift, 16   @ bitWidth 4 (Data hold time This field is used to  generate the delay tSDADEL between SCL falling edge  and SDA edge. In master mode and in slave mode with  NOSTRETCH = 0, the SCL line is stretched low during  tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is  used to generate tHD:DAT timing.)  
        .equ I2C4_TIMINGR_SCLDEL_Shift, 20   @ bitWidth 4 (Data setup time This field is used to  generate a delay tSCLDEL between SDA edge and SCL  rising edge. In master mode and in slave mode with  NOSTRETCH = 0, the SCL line is stretched low during  tSCLDEL. tSCLDEL = SCLDEL+1 x tPRESC Note: tSCLDEL  is used to generate tSU:DAT timing.)  
        .equ I2C4_TIMINGR_PRESC_Shift, 28   @ bitWidth 4 (Timing prescaler This field is used to  prescale I2CCLK in order to generate the clock period  tPRESC used for data setup and hold counters refer  to I2C timings on page9 and for SCL high and low  level counters refer to I2C master initialization on  page24. tPRESC = PRESC+1 x tI2CCLK)  
 
    .equ I2C4_TIMEOUTR, I2C4_BASE + 0x14 @ (Access: No wait states, except if a write  access occurs while a write access to this register is  ongoing. In this case, wait states are inserted in the  second write access until the previous one is completed.  The latency of the second write access can be up to 2 x  PCLK1 + 6 x I2CCLK.) 
        .equ I2C4_TIMEOUTR_TIMEOUTA_Shift, 0   @ bitWidth 12 (Bus Timeout A This field is used to  configure: The SCL low timeout condition tTIMEOUT  when TIDLE=0 tTIMEOUT= TIMEOUTA+1 x 2048 x tI2CCLK  The bus idle condition both SCL and SDA high when  TIDLE=1 tIDLE= TIMEOUTA+1 x 4 x tI2CCLK Note: These  bits can be written only when  TIMOUTEN=0.)  
        .equ I2C4_TIMEOUTR_TIDLE, 1 << 12   @ bitWidth 1 (Idle clock timeout detection Note: This  bit can be written only when  TIMOUTEN=0.)  
        .equ I2C4_TIMEOUTR_TIMOUTEN, 1 << 15   @ bitWidth 1 (Clock timeout enable)  
        .equ I2C4_TIMEOUTR_TIMEOUTB_Shift, 16   @ bitWidth 12 (Bus timeout B This field is used to  configure the cumulative clock extension timeout: In  master mode, the master cumulative clock low extend  time tLOW:MEXT is detected In slave mode, the slave  cumulative clock low extend time tLOW:SEXT is  detected tLOW:EXT= TIMEOUTB+1 x 2048 x tI2CCLK  Note: These bits can be written only when  TEXTEN=0.)  
        .equ I2C4_TIMEOUTR_TEXTEN, 1 << 31   @ bitWidth 1 (Extended clock timeout  enable)  
 
    .equ I2C4_ISR, I2C4_BASE + 0x18 @ (Access: No wait states) 
        .equ I2C4_ISR_TXE, 1 << 0   @ bitWidth 1 (Transmit data register empty  transmitters This bit is set by hardware when the  I2C_TXDR register is empty. It is cleared when the  next data to be sent is written in the I2C_TXDR  register. This bit can be written to 1 by software in  order to flush the transmit data register I2C_TXDR.  Note: This bit is set by hardware when  PE=0.)  
        .equ I2C4_ISR_TXIS, 1 << 1   @ bitWidth 1 (Transmit interrupt status transmitters  This bit is set by hardware when the I2C_TXDR  register is empty and the data to be transmitted must  be written in the I2C_TXDR register. It is cleared  when the next data to be sent is written in the  I2C_TXDR register. This bit can be written to 1 by  software when NOSTRETCH=1 only, in order to generate  a TXIS event interrupt if TXIE=1 or DMA request if  TXDMAEN=1. Note: This bit is cleared by hardware  when PE=0.)  
        .equ I2C4_ISR_RXNE, 1 << 2   @ bitWidth 1 (Receive data register not empty  receivers This bit is set by hardware when the  received data is copied into the I2C_RXDR register,  and is ready to be read. It is cleared when I2C_RXDR  is read. Note: This bit is cleared by hardware when  PE=0.)  
        .equ I2C4_ISR_ADDR, 1 << 3   @ bitWidth 1 (Address matched slave mode This bit is  set by hardware as soon as the received slave address  matched with one of the enabled slave addresses. It  is cleared by software by setting ADDRCF bit. Note:  This bit is cleared by hardware when  PE=0.)  
        .equ I2C4_ISR_NACKF, 1 << 4   @ bitWidth 1 (Not Acknowledge received flag This flag  is set by hardware when a NACK is received after a  byte transmission. It is cleared by software by  setting the NACKCF bit. Note: This bit is cleared by  hardware when PE=0.)  
        .equ I2C4_ISR_STOPF, 1 << 5   @ bitWidth 1 (Stop detection flag This flag is set by  hardware when a Stop condition is detected on the bus  and the peripheral is involved in this transfer:  either as a master, provided that the STOP condition  is generated by the peripheral. or as a slave,  provided that the peripheral has been addressed  previously during this transfer. It is cleared by  software by setting the STOPCF bit. Note: This bit is  cleared by hardware when PE=0.)  
        .equ I2C4_ISR_TC, 1 << 6   @ bitWidth 1 (Transfer Complete master mode This  flag is set by hardware when RELOAD=0, AUTOEND=0 and  NBYTES data have been transferred. It is cleared by  software when START bit or STOP bit is set. Note:  This bit is cleared by hardware when  PE=0.)  
        .equ I2C4_ISR_TCR, 1 << 7   @ bitWidth 1 (Transfer Complete Reload This flag is  set by hardware when RELOAD=1 and NBYTES data have  been transferred. It is cleared by software when  NBYTES is written to a non-zero value. Note: This bit  is cleared by hardware when PE=0. This flag is only  for master mode, or for slave mode when the SBC bit  is set.)  
        .equ I2C4_ISR_BERR, 1 << 8   @ bitWidth 1 (Bus error This flag is set by hardware  when a misplaced Start or Stop condition is detected  whereas the peripheral is involved in the transfer.  The flag is not set during the address phase in slave  mode. It is cleared by software by setting BERRCF  bit. Note: This bit is cleared by hardware when  PE=0.)  
        .equ I2C4_ISR_ARLO, 1 << 9   @ bitWidth 1 (Arbitration lost This flag is set by  hardware in case of arbitration loss. It is cleared  by software by setting the ARLOCF bit. Note: This bit  is cleared by hardware when PE=0.)  
        .equ I2C4_ISR_OVR, 1 << 10   @ bitWidth 1 (Overrun/Underrun slave mode This flag  is set by hardware in slave mode with NOSTRETCH=1,  when an overrun/underrun error occurs. It is cleared  by software by setting the OVRCF bit. Note: This bit  is cleared by hardware when PE=0.)  
        .equ I2C4_ISR_PECERR, 1 << 11   @ bitWidth 1 (PEC Error in reception This flag is set  by hardware when the received PEC does not match with  the PEC register content. A NACK is automatically  sent after the wrong PEC reception. It is cleared by  software by setting the PECCF bit. Note: This bit is  cleared by hardware when PE=0. If the SMBus feature  is not supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
        .equ I2C4_ISR_TIMEOUT, 1 << 12   @ bitWidth 1 (Timeout or tLOW detection flag This flag  is set by hardware when a timeout or extended clock  timeout occurred. It is cleared by software by  setting the TIMEOUTCF bit. Note: This bit is cleared  by hardware when PE=0. If the SMBus feature is not  supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
        .equ I2C4_ISR_ALERT, 1 << 13   @ bitWidth 1 (SMBus alert This flag is set by hardware  when SMBHEN=1 SMBus host configuration, ALERTEN=1  and a SMBALERT event falling edge is detected on  SMBA pin. It is cleared by software by setting the  ALERTCF bit. Note: This bit is cleared by hardware  when PE=0. If the SMBus feature is not supported,  this bit is reserved and forced by hardware to 0.  Please refer to Section25.3: I2C  implementation.)  
        .equ I2C4_ISR_BUSY, 1 << 15   @ bitWidth 1 (Bus busy This flag indicates that a  communication is in progress on the bus. It is set by  hardware when a START condition is detected. It is  cleared by hardware when a Stop condition is  detected, or when PE=0.)  
        .equ I2C4_ISR_DIR, 1 << 16   @ bitWidth 1 (Transfer direction Slave mode This  flag is updated when an address match event occurs  ADDR=1.)  
        .equ I2C4_ISR_ADDCODE_Shift, 17   @ bitWidth 7 (Address match code Slave mode These  bits are updated with the received address when an  address match event occurs ADDR = 1. In the case of  a 10-bit address, ADDCODE provides the 10-bit header  followed by the 2 MSBs of the address.)  
 
    .equ I2C4_ICR, I2C4_BASE + 0x1C @ (Access: No wait states) 
        .equ I2C4_ICR_ADDRCF, 1 << 3   @ bitWidth 1 (Address matched flag clear Writing 1 to  this bit clears the ADDR flag in the I2C_ISR  register. Writing 1 to this bit also clears the START  bit in the I2C_CR2 register.)  
        .equ I2C4_ICR_NACKCF, 1 << 4   @ bitWidth 1 (Not Acknowledge flag clear Writing 1 to  this bit clears the ACKF flag in I2C_ISR  register.)  
        .equ I2C4_ICR_STOPCF, 1 << 5   @ bitWidth 1 (Stop detection flag clear Writing 1 to  this bit clears the STOPF flag in the I2C_ISR  register.)  
        .equ I2C4_ICR_BERRCF, 1 << 8   @ bitWidth 1 (Bus error flag clear Writing 1 to this  bit clears the BERRF flag in the I2C_ISR  register.)  
        .equ I2C4_ICR_ARLOCF, 1 << 9   @ bitWidth 1 (Arbitration Lost flag clear Writing 1 to  this bit clears the ARLO flag in the I2C_ISR  register.)  
        .equ I2C4_ICR_OVRCF, 1 << 10   @ bitWidth 1 (Overrun/Underrun flag clear Writing 1 to  this bit clears the OVR flag in the I2C_ISR  register.)  
        .equ I2C4_ICR_PECCF, 1 << 11   @ bitWidth 1 (PEC Error flag clear Writing 1 to this  bit clears the PECERR flag in the I2C_ISR register.  Note: If the SMBus feature is not supported, this bit  is reserved and forced by hardware to 0. Please refer  to Section25.3: I2C implementation.)  
        .equ I2C4_ICR_TIMOUTCF, 1 << 12   @ bitWidth 1 (Timeout detection flag clear Writing 1  to this bit clears the TIMEOUT flag in the I2C_ISR  register. Note: If the SMBus feature is not  supported, this bit is reserved and forced by  hardware to 0. Please refer to Section25.3: I2C  implementation.)  
        .equ I2C4_ICR_ALERTCF, 1 << 13   @ bitWidth 1 (Alert flag clear Writing 1 to this bit  clears the ALERT flag in the I2C_ISR register. Note:  If the SMBus feature is not supported, this bit is  reserved and forced by hardware to 0. Please refer to  Section25.3: I2C implementation.)  
 
    .equ I2C4_PECR, I2C4_BASE + 0x20 @ (Access: No wait states) 
        .equ I2C4_PECR_PEC_Shift, 0   @ bitWidth 8 (Packet error checking register This  field contains the internal PEC when PECEN=1. The PEC  is cleared by hardware when PE=0.)  
 
    .equ I2C4_RXDR, I2C4_BASE + 0x24 @ (Access: No wait states) 
        .equ I2C4_RXDR_RXDATA_Shift, 0   @ bitWidth 8 (8-bit receive data Data byte received  from the I2C bus.)  
 
    .equ I2C4_TXDR, I2C4_BASE + 0x28 @ (Access: No wait states) 
        .equ I2C4_TXDR_TXDATA_Shift, 0   @ bitWidth 8 (8-bit transmit data Data byte to be  transmitted to the I2C bus. Note: These bits can be  written only when TXE=1.)  
 

@=========================== GPIOA ===========================@
.equ GPIOA_BASE, 0x58020000 @ (GPIO) 
    .equ GPIOA_MODER, GPIOA_BASE + 0x0 @ (GPIO port mode register) 
        .equ GPIOA_MODER_MODE0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOA_MODER_MODE1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOA_MODER_MODE2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOA_MODER_MODE3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOA_MODER_MODE4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOA_MODER_MODE5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOA_MODER_MODE6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOA_MODER_MODE7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOA_MODER_MODE8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOA_MODER_MODE9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOA_MODER_MODE10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOA_MODER_MODE11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOA_MODER_MODE12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOA_MODER_MODE13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOA_MODER_MODE14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOA_MODER_MODE15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
 
    .equ GPIOA_OTYPER, GPIOA_BASE + 0x4 @ (GPIO port output type register) 
        .equ GPIOA_OTYPER_OT0, 1 << 0   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOA_OTYPER_OT1, 1 << 1   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOA_OTYPER_OT2, 1 << 2   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOA_OTYPER_OT3, 1 << 3   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOA_OTYPER_OT4, 1 << 4   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOA_OTYPER_OT5, 1 << 5   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOA_OTYPER_OT6, 1 << 6   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOA_OTYPER_OT7, 1 << 7   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOA_OTYPER_OT8, 1 << 8   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOA_OTYPER_OT9, 1 << 9   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOA_OTYPER_OT10, 1 << 10   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOA_OTYPER_OT11, 1 << 11   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOA_OTYPER_OT12, 1 << 12   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOA_OTYPER_OT13, 1 << 13   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOA_OTYPER_OT14, 1 << 14   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOA_OTYPER_OT15, 1 << 15   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
 
    .equ GPIOA_OSPEEDR, GPIOA_BASE + 0x8 @ (GPIO port output speed  register) 
        .equ GPIOA_OSPEEDR_OSPEED0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOA_OSPEEDR_OSPEED1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOA_OSPEEDR_OSPEED2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOA_OSPEEDR_OSPEED3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOA_OSPEEDR_OSPEED4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOA_OSPEEDR_OSPEED5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOA_OSPEEDR_OSPEED6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOA_OSPEEDR_OSPEED7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOA_OSPEEDR_OSPEED8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOA_OSPEEDR_OSPEED9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOA_OSPEEDR_OSPEED10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOA_OSPEEDR_OSPEED11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOA_OSPEEDR_OSPEED12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOA_OSPEEDR_OSPEED13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOA_OSPEEDR_OSPEED14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOA_OSPEEDR_OSPEED15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
 
    .equ GPIOA_PUPDR, GPIOA_BASE + 0xC @ (GPIO port pull-up/pull-down  register) 
        .equ GPIOA_PUPDR_PUPD0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOA_PUPDR_PUPD1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOA_PUPDR_PUPD2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOA_PUPDR_PUPD3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOA_PUPDR_PUPD4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOA_PUPDR_PUPD5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOA_PUPDR_PUPD6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOA_PUPDR_PUPD7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOA_PUPDR_PUPD8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOA_PUPDR_PUPD9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOA_PUPDR_PUPD10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOA_PUPDR_PUPD11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOA_PUPDR_PUPD12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOA_PUPDR_PUPD13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOA_PUPDR_PUPD14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOA_PUPDR_PUPD15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
 
    .equ GPIOA_IDR, GPIOA_BASE + 0x10 @ (GPIO port input data register) 
        .equ GPIOA_IDR_ID0, 1 << 0   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOA_IDR_ID1, 1 << 1   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOA_IDR_ID2, 1 << 2   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOA_IDR_ID3, 1 << 3   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOA_IDR_ID4, 1 << 4   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOA_IDR_ID5, 1 << 5   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOA_IDR_ID6, 1 << 6   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOA_IDR_ID7, 1 << 7   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOA_IDR_ID8, 1 << 8   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOA_IDR_ID9, 1 << 9   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOA_IDR_ID10, 1 << 10   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOA_IDR_ID11, 1 << 11   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOA_IDR_ID12, 1 << 12   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOA_IDR_ID13, 1 << 13   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOA_IDR_ID14, 1 << 14   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOA_IDR_ID15, 1 << 15   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
 
    .equ GPIOA_ODR, GPIOA_BASE + 0x14 @ (GPIO port output data register) 
        .equ GPIOA_ODR_OD0, 1 << 0   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOA_ODR_OD1, 1 << 1   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOA_ODR_OD2, 1 << 2   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOA_ODR_OD3, 1 << 3   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOA_ODR_OD4, 1 << 4   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOA_ODR_OD5, 1 << 5   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOA_ODR_OD6, 1 << 6   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOA_ODR_OD7, 1 << 7   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOA_ODR_OD8, 1 << 8   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOA_ODR_OD9, 1 << 9   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOA_ODR_OD10, 1 << 10   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOA_ODR_OD11, 1 << 11   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOA_ODR_OD12, 1 << 12   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOA_ODR_OD13, 1 << 13   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOA_ODR_OD14, 1 << 14   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOA_ODR_OD15, 1 << 15   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
 
    .equ GPIOA_BSRR, GPIOA_BASE + 0x18 @ (GPIO port bit set/reset  register) 
        .equ GPIOA_BSRR_BS0, 1 << 0   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOA_BSRR_BS1, 1 << 1   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOA_BSRR_BS2, 1 << 2   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOA_BSRR_BS3, 1 << 3   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOA_BSRR_BS4, 1 << 4   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOA_BSRR_BS5, 1 << 5   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOA_BSRR_BS6, 1 << 6   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOA_BSRR_BS7, 1 << 7   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOA_BSRR_BS8, 1 << 8   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOA_BSRR_BS9, 1 << 9   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOA_BSRR_BS10, 1 << 10   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOA_BSRR_BS11, 1 << 11   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOA_BSRR_BS12, 1 << 12   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOA_BSRR_BS13, 1 << 13   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOA_BSRR_BS14, 1 << 14   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOA_BSRR_BS15, 1 << 15   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOA_BSRR_BR0, 1 << 16   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOA_BSRR_BR1, 1 << 17   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOA_BSRR_BR2, 1 << 18   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOA_BSRR_BR3, 1 << 19   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOA_BSRR_BR4, 1 << 20   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOA_BSRR_BR5, 1 << 21   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOA_BSRR_BR6, 1 << 22   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOA_BSRR_BR7, 1 << 23   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOA_BSRR_BR8, 1 << 24   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOA_BSRR_BR9, 1 << 25   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOA_BSRR_BR10, 1 << 26   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOA_BSRR_BR11, 1 << 27   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOA_BSRR_BR12, 1 << 28   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOA_BSRR_BR13, 1 << 29   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOA_BSRR_BR14, 1 << 30   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOA_BSRR_BR15, 1 << 31   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
 
    .equ GPIOA_LCKR, GPIOA_BASE + 0x1C @ (This register is used to lock the  configuration of the port bits when a correct write  sequence is applied to bit 16 LCKK. The value of bits  [15:0] is used to lock the configuration of the GPIO.  During the write sequence, the value of LCKR[15:0] must  not change. When the LOCK sequence has been applied on a  port bit, the value of this port bit can no longer be  modified until the next MCU reset or peripheral reset.A  specific write sequence is used to write to the  GPIOx_LCKR register. Only word access 32-bit long is  allowed during this locking sequence.Each lock bit  freezes a specific configuration register control and  alternate function registers.) 
        .equ GPIOA_LCKR_LCK0, 1 << 0   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOA_LCKR_LCK1, 1 << 1   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOA_LCKR_LCK2, 1 << 2   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOA_LCKR_LCK3, 1 << 3   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOA_LCKR_LCK4, 1 << 4   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOA_LCKR_LCK5, 1 << 5   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOA_LCKR_LCK6, 1 << 6   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOA_LCKR_LCK7, 1 << 7   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOA_LCKR_LCK8, 1 << 8   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOA_LCKR_LCK9, 1 << 9   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOA_LCKR_LCK10, 1 << 10   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOA_LCKR_LCK11, 1 << 11   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOA_LCKR_LCK12, 1 << 12   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOA_LCKR_LCK13, 1 << 13   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOA_LCKR_LCK14, 1 << 14   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOA_LCKR_LCK15, 1 << 15   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOA_LCKR_LCKK, 1 << 16   @ bitWidth 1 (Lock key This bit can be read any time.  It can only be modified using the lock key write  sequence. LOCK key write sequence: WR LCKR[16] = 1 +  LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] =  1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 this read  operation is optional but it confirms that the lock  is active Note: During the LOCK key write sequence,  the value of LCK[15:0] must not change. Any error in  the lock sequence aborts the lock. After the first  lock sequence on any bit of the port, any read access  on the LCKK bit will return 1 until the next MCU  reset or peripheral reset.)  
 
    .equ GPIOA_AFRL, GPIOA_BASE + 0x20 @ (GPIO alternate function low  register) 
        .equ GPIOA_AFRL_AFSEL0_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOA_AFRL_AFSEL1_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOA_AFRL_AFSEL2_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOA_AFRL_AFSEL3_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOA_AFRL_AFSEL4_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOA_AFRL_AFSEL5_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOA_AFRL_AFSEL6_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOA_AFRL_AFSEL7_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
 
    .equ GPIOA_AFRH, GPIOA_BASE + 0x24 @ (GPIO alternate function high  register) 
        .equ GPIOA_AFRH_AFSEL8_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOA_AFRH_AFSEL9_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOA_AFRH_AFSEL10_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOA_AFRH_AFSEL11_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOA_AFRH_AFSEL12_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOA_AFRH_AFSEL13_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOA_AFRH_AFSEL14_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOA_AFRH_AFSEL15_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
 

@=========================== GPIOB ===========================@
.equ GPIOB_BASE, 0x58020400 @ (GPIO) 
    .equ GPIOB_MODER, GPIOB_BASE + 0x0 @ (GPIO port mode register) 
        .equ GPIOB_MODER_MODE0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOB_MODER_MODE1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOB_MODER_MODE2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOB_MODER_MODE3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOB_MODER_MODE4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOB_MODER_MODE5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOB_MODER_MODE6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOB_MODER_MODE7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOB_MODER_MODE8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOB_MODER_MODE9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOB_MODER_MODE10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOB_MODER_MODE11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOB_MODER_MODE12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOB_MODER_MODE13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOB_MODER_MODE14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOB_MODER_MODE15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
 
    .equ GPIOB_OTYPER, GPIOB_BASE + 0x4 @ (GPIO port output type register) 
        .equ GPIOB_OTYPER_OT0, 1 << 0   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOB_OTYPER_OT1, 1 << 1   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOB_OTYPER_OT2, 1 << 2   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOB_OTYPER_OT3, 1 << 3   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOB_OTYPER_OT4, 1 << 4   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOB_OTYPER_OT5, 1 << 5   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOB_OTYPER_OT6, 1 << 6   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOB_OTYPER_OT7, 1 << 7   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOB_OTYPER_OT8, 1 << 8   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOB_OTYPER_OT9, 1 << 9   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOB_OTYPER_OT10, 1 << 10   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOB_OTYPER_OT11, 1 << 11   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOB_OTYPER_OT12, 1 << 12   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOB_OTYPER_OT13, 1 << 13   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOB_OTYPER_OT14, 1 << 14   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOB_OTYPER_OT15, 1 << 15   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
 
    .equ GPIOB_OSPEEDR, GPIOB_BASE + 0x8 @ (GPIO port output speed  register) 
        .equ GPIOB_OSPEEDR_OSPEED0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOB_OSPEEDR_OSPEED1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOB_OSPEEDR_OSPEED2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOB_OSPEEDR_OSPEED3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOB_OSPEEDR_OSPEED4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOB_OSPEEDR_OSPEED5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOB_OSPEEDR_OSPEED6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOB_OSPEEDR_OSPEED7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOB_OSPEEDR_OSPEED8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOB_OSPEEDR_OSPEED9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOB_OSPEEDR_OSPEED10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOB_OSPEEDR_OSPEED11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOB_OSPEEDR_OSPEED12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOB_OSPEEDR_OSPEED13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOB_OSPEEDR_OSPEED14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOB_OSPEEDR_OSPEED15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
 
    .equ GPIOB_PUPDR, GPIOB_BASE + 0xC @ (GPIO port pull-up/pull-down  register) 
        .equ GPIOB_PUPDR_PUPD0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOB_PUPDR_PUPD1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOB_PUPDR_PUPD2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOB_PUPDR_PUPD3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOB_PUPDR_PUPD4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOB_PUPDR_PUPD5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOB_PUPDR_PUPD6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOB_PUPDR_PUPD7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOB_PUPDR_PUPD8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOB_PUPDR_PUPD9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOB_PUPDR_PUPD10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOB_PUPDR_PUPD11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOB_PUPDR_PUPD12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOB_PUPDR_PUPD13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOB_PUPDR_PUPD14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOB_PUPDR_PUPD15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
 
    .equ GPIOB_IDR, GPIOB_BASE + 0x10 @ (GPIO port input data register) 
        .equ GPIOB_IDR_ID0, 1 << 0   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOB_IDR_ID1, 1 << 1   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOB_IDR_ID2, 1 << 2   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOB_IDR_ID3, 1 << 3   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOB_IDR_ID4, 1 << 4   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOB_IDR_ID5, 1 << 5   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOB_IDR_ID6, 1 << 6   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOB_IDR_ID7, 1 << 7   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOB_IDR_ID8, 1 << 8   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOB_IDR_ID9, 1 << 9   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOB_IDR_ID10, 1 << 10   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOB_IDR_ID11, 1 << 11   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOB_IDR_ID12, 1 << 12   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOB_IDR_ID13, 1 << 13   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOB_IDR_ID14, 1 << 14   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOB_IDR_ID15, 1 << 15   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
 
    .equ GPIOB_ODR, GPIOB_BASE + 0x14 @ (GPIO port output data register) 
        .equ GPIOB_ODR_OD0, 1 << 0   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOB_ODR_OD1, 1 << 1   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOB_ODR_OD2, 1 << 2   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOB_ODR_OD3, 1 << 3   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOB_ODR_OD4, 1 << 4   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOB_ODR_OD5, 1 << 5   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOB_ODR_OD6, 1 << 6   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOB_ODR_OD7, 1 << 7   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOB_ODR_OD8, 1 << 8   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOB_ODR_OD9, 1 << 9   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOB_ODR_OD10, 1 << 10   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOB_ODR_OD11, 1 << 11   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOB_ODR_OD12, 1 << 12   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOB_ODR_OD13, 1 << 13   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOB_ODR_OD14, 1 << 14   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOB_ODR_OD15, 1 << 15   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
 
    .equ GPIOB_BSRR, GPIOB_BASE + 0x18 @ (GPIO port bit set/reset  register) 
        .equ GPIOB_BSRR_BS0, 1 << 0   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOB_BSRR_BS1, 1 << 1   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOB_BSRR_BS2, 1 << 2   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOB_BSRR_BS3, 1 << 3   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOB_BSRR_BS4, 1 << 4   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOB_BSRR_BS5, 1 << 5   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOB_BSRR_BS6, 1 << 6   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOB_BSRR_BS7, 1 << 7   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOB_BSRR_BS8, 1 << 8   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOB_BSRR_BS9, 1 << 9   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOB_BSRR_BS10, 1 << 10   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOB_BSRR_BS11, 1 << 11   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOB_BSRR_BS12, 1 << 12   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOB_BSRR_BS13, 1 << 13   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOB_BSRR_BS14, 1 << 14   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOB_BSRR_BS15, 1 << 15   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOB_BSRR_BR0, 1 << 16   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOB_BSRR_BR1, 1 << 17   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOB_BSRR_BR2, 1 << 18   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOB_BSRR_BR3, 1 << 19   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOB_BSRR_BR4, 1 << 20   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOB_BSRR_BR5, 1 << 21   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOB_BSRR_BR6, 1 << 22   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOB_BSRR_BR7, 1 << 23   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOB_BSRR_BR8, 1 << 24   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOB_BSRR_BR9, 1 << 25   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOB_BSRR_BR10, 1 << 26   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOB_BSRR_BR11, 1 << 27   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOB_BSRR_BR12, 1 << 28   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOB_BSRR_BR13, 1 << 29   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOB_BSRR_BR14, 1 << 30   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOB_BSRR_BR15, 1 << 31   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
 
    .equ GPIOB_LCKR, GPIOB_BASE + 0x1C @ (This register is used to lock the  configuration of the port bits when a correct write  sequence is applied to bit 16 LCKK. The value of bits  [15:0] is used to lock the configuration of the GPIO.  During the write sequence, the value of LCKR[15:0] must  not change. When the LOCK sequence has been applied on a  port bit, the value of this port bit can no longer be  modified until the next MCU reset or peripheral reset.A  specific write sequence is used to write to the  GPIOx_LCKR register. Only word access 32-bit long is  allowed during this locking sequence.Each lock bit  freezes a specific configuration register control and  alternate function registers.) 
        .equ GPIOB_LCKR_LCK0, 1 << 0   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOB_LCKR_LCK1, 1 << 1   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOB_LCKR_LCK2, 1 << 2   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOB_LCKR_LCK3, 1 << 3   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOB_LCKR_LCK4, 1 << 4   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOB_LCKR_LCK5, 1 << 5   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOB_LCKR_LCK6, 1 << 6   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOB_LCKR_LCK7, 1 << 7   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOB_LCKR_LCK8, 1 << 8   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOB_LCKR_LCK9, 1 << 9   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOB_LCKR_LCK10, 1 << 10   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOB_LCKR_LCK11, 1 << 11   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOB_LCKR_LCK12, 1 << 12   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOB_LCKR_LCK13, 1 << 13   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOB_LCKR_LCK14, 1 << 14   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOB_LCKR_LCK15, 1 << 15   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOB_LCKR_LCKK, 1 << 16   @ bitWidth 1 (Lock key This bit can be read any time.  It can only be modified using the lock key write  sequence. LOCK key write sequence: WR LCKR[16] = 1 +  LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] =  1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 this read  operation is optional but it confirms that the lock  is active Note: During the LOCK key write sequence,  the value of LCK[15:0] must not change. Any error in  the lock sequence aborts the lock. After the first  lock sequence on any bit of the port, any read access  on the LCKK bit will return 1 until the next MCU  reset or peripheral reset.)  
 
    .equ GPIOB_AFRL, GPIOB_BASE + 0x20 @ (GPIO alternate function low  register) 
        .equ GPIOB_AFRL_AFSEL0_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOB_AFRL_AFSEL1_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOB_AFRL_AFSEL2_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOB_AFRL_AFSEL3_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOB_AFRL_AFSEL4_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOB_AFRL_AFSEL5_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOB_AFRL_AFSEL6_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOB_AFRL_AFSEL7_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
 
    .equ GPIOB_AFRH, GPIOB_BASE + 0x24 @ (GPIO alternate function high  register) 
        .equ GPIOB_AFRH_AFSEL8_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOB_AFRH_AFSEL9_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOB_AFRH_AFSEL10_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOB_AFRH_AFSEL11_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOB_AFRH_AFSEL12_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOB_AFRH_AFSEL13_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOB_AFRH_AFSEL14_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOB_AFRH_AFSEL15_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
 

@=========================== GPIOC ===========================@
.equ GPIOC_BASE, 0x58020800 @ (GPIO) 
    .equ GPIOC_MODER, GPIOC_BASE + 0x0 @ (GPIO port mode register) 
        .equ GPIOC_MODER_MODE0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOC_MODER_MODE1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOC_MODER_MODE2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOC_MODER_MODE3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOC_MODER_MODE4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOC_MODER_MODE5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOC_MODER_MODE6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOC_MODER_MODE7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOC_MODER_MODE8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOC_MODER_MODE9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOC_MODER_MODE10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOC_MODER_MODE11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOC_MODER_MODE12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOC_MODER_MODE13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOC_MODER_MODE14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOC_MODER_MODE15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
 
    .equ GPIOC_OTYPER, GPIOC_BASE + 0x4 @ (GPIO port output type register) 
        .equ GPIOC_OTYPER_OT0, 1 << 0   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOC_OTYPER_OT1, 1 << 1   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOC_OTYPER_OT2, 1 << 2   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOC_OTYPER_OT3, 1 << 3   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOC_OTYPER_OT4, 1 << 4   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOC_OTYPER_OT5, 1 << 5   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOC_OTYPER_OT6, 1 << 6   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOC_OTYPER_OT7, 1 << 7   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOC_OTYPER_OT8, 1 << 8   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOC_OTYPER_OT9, 1 << 9   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOC_OTYPER_OT10, 1 << 10   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOC_OTYPER_OT11, 1 << 11   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOC_OTYPER_OT12, 1 << 12   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOC_OTYPER_OT13, 1 << 13   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOC_OTYPER_OT14, 1 << 14   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOC_OTYPER_OT15, 1 << 15   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
 
    .equ GPIOC_OSPEEDR, GPIOC_BASE + 0x8 @ (GPIO port output speed  register) 
        .equ GPIOC_OSPEEDR_OSPEED0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOC_OSPEEDR_OSPEED1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOC_OSPEEDR_OSPEED2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOC_OSPEEDR_OSPEED3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOC_OSPEEDR_OSPEED4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOC_OSPEEDR_OSPEED5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOC_OSPEEDR_OSPEED6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOC_OSPEEDR_OSPEED7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOC_OSPEEDR_OSPEED8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOC_OSPEEDR_OSPEED9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOC_OSPEEDR_OSPEED10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOC_OSPEEDR_OSPEED11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOC_OSPEEDR_OSPEED12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOC_OSPEEDR_OSPEED13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOC_OSPEEDR_OSPEED14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOC_OSPEEDR_OSPEED15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
 
    .equ GPIOC_PUPDR, GPIOC_BASE + 0xC @ (GPIO port pull-up/pull-down  register) 
        .equ GPIOC_PUPDR_PUPD0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOC_PUPDR_PUPD1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOC_PUPDR_PUPD2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOC_PUPDR_PUPD3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOC_PUPDR_PUPD4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOC_PUPDR_PUPD5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOC_PUPDR_PUPD6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOC_PUPDR_PUPD7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOC_PUPDR_PUPD8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOC_PUPDR_PUPD9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOC_PUPDR_PUPD10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOC_PUPDR_PUPD11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOC_PUPDR_PUPD12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOC_PUPDR_PUPD13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOC_PUPDR_PUPD14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOC_PUPDR_PUPD15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
 
    .equ GPIOC_IDR, GPIOC_BASE + 0x10 @ (GPIO port input data register) 
        .equ GPIOC_IDR_ID0, 1 << 0   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOC_IDR_ID1, 1 << 1   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOC_IDR_ID2, 1 << 2   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOC_IDR_ID3, 1 << 3   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOC_IDR_ID4, 1 << 4   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOC_IDR_ID5, 1 << 5   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOC_IDR_ID6, 1 << 6   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOC_IDR_ID7, 1 << 7   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOC_IDR_ID8, 1 << 8   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOC_IDR_ID9, 1 << 9   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOC_IDR_ID10, 1 << 10   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOC_IDR_ID11, 1 << 11   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOC_IDR_ID12, 1 << 12   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOC_IDR_ID13, 1 << 13   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOC_IDR_ID14, 1 << 14   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOC_IDR_ID15, 1 << 15   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
 
    .equ GPIOC_ODR, GPIOC_BASE + 0x14 @ (GPIO port output data register) 
        .equ GPIOC_ODR_OD0, 1 << 0   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOC_ODR_OD1, 1 << 1   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOC_ODR_OD2, 1 << 2   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOC_ODR_OD3, 1 << 3   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOC_ODR_OD4, 1 << 4   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOC_ODR_OD5, 1 << 5   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOC_ODR_OD6, 1 << 6   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOC_ODR_OD7, 1 << 7   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOC_ODR_OD8, 1 << 8   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOC_ODR_OD9, 1 << 9   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOC_ODR_OD10, 1 << 10   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOC_ODR_OD11, 1 << 11   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOC_ODR_OD12, 1 << 12   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOC_ODR_OD13, 1 << 13   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOC_ODR_OD14, 1 << 14   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOC_ODR_OD15, 1 << 15   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
 
    .equ GPIOC_BSRR, GPIOC_BASE + 0x18 @ (GPIO port bit set/reset  register) 
        .equ GPIOC_BSRR_BS0, 1 << 0   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOC_BSRR_BS1, 1 << 1   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOC_BSRR_BS2, 1 << 2   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOC_BSRR_BS3, 1 << 3   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOC_BSRR_BS4, 1 << 4   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOC_BSRR_BS5, 1 << 5   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOC_BSRR_BS6, 1 << 6   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOC_BSRR_BS7, 1 << 7   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOC_BSRR_BS8, 1 << 8   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOC_BSRR_BS9, 1 << 9   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOC_BSRR_BS10, 1 << 10   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOC_BSRR_BS11, 1 << 11   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOC_BSRR_BS12, 1 << 12   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOC_BSRR_BS13, 1 << 13   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOC_BSRR_BS14, 1 << 14   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOC_BSRR_BS15, 1 << 15   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOC_BSRR_BR0, 1 << 16   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOC_BSRR_BR1, 1 << 17   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOC_BSRR_BR2, 1 << 18   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOC_BSRR_BR3, 1 << 19   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOC_BSRR_BR4, 1 << 20   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOC_BSRR_BR5, 1 << 21   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOC_BSRR_BR6, 1 << 22   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOC_BSRR_BR7, 1 << 23   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOC_BSRR_BR8, 1 << 24   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOC_BSRR_BR9, 1 << 25   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOC_BSRR_BR10, 1 << 26   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOC_BSRR_BR11, 1 << 27   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOC_BSRR_BR12, 1 << 28   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOC_BSRR_BR13, 1 << 29   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOC_BSRR_BR14, 1 << 30   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOC_BSRR_BR15, 1 << 31   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
 
    .equ GPIOC_LCKR, GPIOC_BASE + 0x1C @ (This register is used to lock the  configuration of the port bits when a correct write  sequence is applied to bit 16 LCKK. The value of bits  [15:0] is used to lock the configuration of the GPIO.  During the write sequence, the value of LCKR[15:0] must  not change. When the LOCK sequence has been applied on a  port bit, the value of this port bit can no longer be  modified until the next MCU reset or peripheral reset.A  specific write sequence is used to write to the  GPIOx_LCKR register. Only word access 32-bit long is  allowed during this locking sequence.Each lock bit  freezes a specific configuration register control and  alternate function registers.) 
        .equ GPIOC_LCKR_LCK0, 1 << 0   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOC_LCKR_LCK1, 1 << 1   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOC_LCKR_LCK2, 1 << 2   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOC_LCKR_LCK3, 1 << 3   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOC_LCKR_LCK4, 1 << 4   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOC_LCKR_LCK5, 1 << 5   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOC_LCKR_LCK6, 1 << 6   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOC_LCKR_LCK7, 1 << 7   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOC_LCKR_LCK8, 1 << 8   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOC_LCKR_LCK9, 1 << 9   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOC_LCKR_LCK10, 1 << 10   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOC_LCKR_LCK11, 1 << 11   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOC_LCKR_LCK12, 1 << 12   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOC_LCKR_LCK13, 1 << 13   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOC_LCKR_LCK14, 1 << 14   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOC_LCKR_LCK15, 1 << 15   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOC_LCKR_LCKK, 1 << 16   @ bitWidth 1 (Lock key This bit can be read any time.  It can only be modified using the lock key write  sequence. LOCK key write sequence: WR LCKR[16] = 1 +  LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] =  1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 this read  operation is optional but it confirms that the lock  is active Note: During the LOCK key write sequence,  the value of LCK[15:0] must not change. Any error in  the lock sequence aborts the lock. After the first  lock sequence on any bit of the port, any read access  on the LCKK bit will return 1 until the next MCU  reset or peripheral reset.)  
 
    .equ GPIOC_AFRL, GPIOC_BASE + 0x20 @ (GPIO alternate function low  register) 
        .equ GPIOC_AFRL_AFSEL0_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOC_AFRL_AFSEL1_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOC_AFRL_AFSEL2_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOC_AFRL_AFSEL3_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOC_AFRL_AFSEL4_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOC_AFRL_AFSEL5_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOC_AFRL_AFSEL6_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOC_AFRL_AFSEL7_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
 
    .equ GPIOC_AFRH, GPIOC_BASE + 0x24 @ (GPIO alternate function high  register) 
        .equ GPIOC_AFRH_AFSEL8_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOC_AFRH_AFSEL9_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOC_AFRH_AFSEL10_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOC_AFRH_AFSEL11_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOC_AFRH_AFSEL12_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOC_AFRH_AFSEL13_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOC_AFRH_AFSEL14_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOC_AFRH_AFSEL15_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
 

@=========================== GPIOD ===========================@
.equ GPIOD_BASE, 0x58020C00 @ (GPIO) 
    .equ GPIOD_MODER, GPIOD_BASE + 0x0 @ (GPIO port mode register) 
        .equ GPIOD_MODER_MODE0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOD_MODER_MODE1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOD_MODER_MODE2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOD_MODER_MODE3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOD_MODER_MODE4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOD_MODER_MODE5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOD_MODER_MODE6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOD_MODER_MODE7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOD_MODER_MODE8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOD_MODER_MODE9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOD_MODER_MODE10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOD_MODER_MODE11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOD_MODER_MODE12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOD_MODER_MODE13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOD_MODER_MODE14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOD_MODER_MODE15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
 
    .equ GPIOD_OTYPER, GPIOD_BASE + 0x4 @ (GPIO port output type register) 
        .equ GPIOD_OTYPER_OT0, 1 << 0   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOD_OTYPER_OT1, 1 << 1   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOD_OTYPER_OT2, 1 << 2   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOD_OTYPER_OT3, 1 << 3   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOD_OTYPER_OT4, 1 << 4   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOD_OTYPER_OT5, 1 << 5   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOD_OTYPER_OT6, 1 << 6   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOD_OTYPER_OT7, 1 << 7   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOD_OTYPER_OT8, 1 << 8   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOD_OTYPER_OT9, 1 << 9   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOD_OTYPER_OT10, 1 << 10   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOD_OTYPER_OT11, 1 << 11   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOD_OTYPER_OT12, 1 << 12   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOD_OTYPER_OT13, 1 << 13   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOD_OTYPER_OT14, 1 << 14   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOD_OTYPER_OT15, 1 << 15   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
 
    .equ GPIOD_OSPEEDR, GPIOD_BASE + 0x8 @ (GPIO port output speed  register) 
        .equ GPIOD_OSPEEDR_OSPEED0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOD_OSPEEDR_OSPEED1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOD_OSPEEDR_OSPEED2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOD_OSPEEDR_OSPEED3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOD_OSPEEDR_OSPEED4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOD_OSPEEDR_OSPEED5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOD_OSPEEDR_OSPEED6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOD_OSPEEDR_OSPEED7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOD_OSPEEDR_OSPEED8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOD_OSPEEDR_OSPEED9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOD_OSPEEDR_OSPEED10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOD_OSPEEDR_OSPEED11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOD_OSPEEDR_OSPEED12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOD_OSPEEDR_OSPEED13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOD_OSPEEDR_OSPEED14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOD_OSPEEDR_OSPEED15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
 
    .equ GPIOD_PUPDR, GPIOD_BASE + 0xC @ (GPIO port pull-up/pull-down  register) 
        .equ GPIOD_PUPDR_PUPD0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOD_PUPDR_PUPD1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOD_PUPDR_PUPD2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOD_PUPDR_PUPD3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOD_PUPDR_PUPD4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOD_PUPDR_PUPD5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOD_PUPDR_PUPD6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOD_PUPDR_PUPD7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOD_PUPDR_PUPD8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOD_PUPDR_PUPD9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOD_PUPDR_PUPD10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOD_PUPDR_PUPD11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOD_PUPDR_PUPD12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOD_PUPDR_PUPD13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOD_PUPDR_PUPD14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOD_PUPDR_PUPD15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
 
    .equ GPIOD_IDR, GPIOD_BASE + 0x10 @ (GPIO port input data register) 
        .equ GPIOD_IDR_ID0, 1 << 0   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOD_IDR_ID1, 1 << 1   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOD_IDR_ID2, 1 << 2   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOD_IDR_ID3, 1 << 3   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOD_IDR_ID4, 1 << 4   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOD_IDR_ID5, 1 << 5   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOD_IDR_ID6, 1 << 6   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOD_IDR_ID7, 1 << 7   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOD_IDR_ID8, 1 << 8   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOD_IDR_ID9, 1 << 9   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOD_IDR_ID10, 1 << 10   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOD_IDR_ID11, 1 << 11   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOD_IDR_ID12, 1 << 12   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOD_IDR_ID13, 1 << 13   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOD_IDR_ID14, 1 << 14   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOD_IDR_ID15, 1 << 15   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
 
    .equ GPIOD_ODR, GPIOD_BASE + 0x14 @ (GPIO port output data register) 
        .equ GPIOD_ODR_OD0, 1 << 0   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOD_ODR_OD1, 1 << 1   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOD_ODR_OD2, 1 << 2   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOD_ODR_OD3, 1 << 3   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOD_ODR_OD4, 1 << 4   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOD_ODR_OD5, 1 << 5   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOD_ODR_OD6, 1 << 6   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOD_ODR_OD7, 1 << 7   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOD_ODR_OD8, 1 << 8   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOD_ODR_OD9, 1 << 9   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOD_ODR_OD10, 1 << 10   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOD_ODR_OD11, 1 << 11   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOD_ODR_OD12, 1 << 12   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOD_ODR_OD13, 1 << 13   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOD_ODR_OD14, 1 << 14   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOD_ODR_OD15, 1 << 15   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
 
    .equ GPIOD_BSRR, GPIOD_BASE + 0x18 @ (GPIO port bit set/reset  register) 
        .equ GPIOD_BSRR_BS0, 1 << 0   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOD_BSRR_BS1, 1 << 1   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOD_BSRR_BS2, 1 << 2   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOD_BSRR_BS3, 1 << 3   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOD_BSRR_BS4, 1 << 4   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOD_BSRR_BS5, 1 << 5   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOD_BSRR_BS6, 1 << 6   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOD_BSRR_BS7, 1 << 7   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOD_BSRR_BS8, 1 << 8   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOD_BSRR_BS9, 1 << 9   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOD_BSRR_BS10, 1 << 10   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOD_BSRR_BS11, 1 << 11   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOD_BSRR_BS12, 1 << 12   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOD_BSRR_BS13, 1 << 13   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOD_BSRR_BS14, 1 << 14   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOD_BSRR_BS15, 1 << 15   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOD_BSRR_BR0, 1 << 16   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOD_BSRR_BR1, 1 << 17   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOD_BSRR_BR2, 1 << 18   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOD_BSRR_BR3, 1 << 19   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOD_BSRR_BR4, 1 << 20   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOD_BSRR_BR5, 1 << 21   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOD_BSRR_BR6, 1 << 22   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOD_BSRR_BR7, 1 << 23   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOD_BSRR_BR8, 1 << 24   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOD_BSRR_BR9, 1 << 25   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOD_BSRR_BR10, 1 << 26   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOD_BSRR_BR11, 1 << 27   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOD_BSRR_BR12, 1 << 28   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOD_BSRR_BR13, 1 << 29   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOD_BSRR_BR14, 1 << 30   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOD_BSRR_BR15, 1 << 31   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
 
    .equ GPIOD_LCKR, GPIOD_BASE + 0x1C @ (This register is used to lock the  configuration of the port bits when a correct write  sequence is applied to bit 16 LCKK. The value of bits  [15:0] is used to lock the configuration of the GPIO.  During the write sequence, the value of LCKR[15:0] must  not change. When the LOCK sequence has been applied on a  port bit, the value of this port bit can no longer be  modified until the next MCU reset or peripheral reset.A  specific write sequence is used to write to the  GPIOx_LCKR register. Only word access 32-bit long is  allowed during this locking sequence.Each lock bit  freezes a specific configuration register control and  alternate function registers.) 
        .equ GPIOD_LCKR_LCK0, 1 << 0   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOD_LCKR_LCK1, 1 << 1   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOD_LCKR_LCK2, 1 << 2   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOD_LCKR_LCK3, 1 << 3   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOD_LCKR_LCK4, 1 << 4   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOD_LCKR_LCK5, 1 << 5   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOD_LCKR_LCK6, 1 << 6   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOD_LCKR_LCK7, 1 << 7   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOD_LCKR_LCK8, 1 << 8   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOD_LCKR_LCK9, 1 << 9   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOD_LCKR_LCK10, 1 << 10   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOD_LCKR_LCK11, 1 << 11   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOD_LCKR_LCK12, 1 << 12   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOD_LCKR_LCK13, 1 << 13   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOD_LCKR_LCK14, 1 << 14   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOD_LCKR_LCK15, 1 << 15   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOD_LCKR_LCKK, 1 << 16   @ bitWidth 1 (Lock key This bit can be read any time.  It can only be modified using the lock key write  sequence. LOCK key write sequence: WR LCKR[16] = 1 +  LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] =  1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 this read  operation is optional but it confirms that the lock  is active Note: During the LOCK key write sequence,  the value of LCK[15:0] must not change. Any error in  the lock sequence aborts the lock. After the first  lock sequence on any bit of the port, any read access  on the LCKK bit will return 1 until the next MCU  reset or peripheral reset.)  
 
    .equ GPIOD_AFRL, GPIOD_BASE + 0x20 @ (GPIO alternate function low  register) 
        .equ GPIOD_AFRL_AFSEL0_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOD_AFRL_AFSEL1_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOD_AFRL_AFSEL2_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOD_AFRL_AFSEL3_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOD_AFRL_AFSEL4_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOD_AFRL_AFSEL5_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOD_AFRL_AFSEL6_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOD_AFRL_AFSEL7_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
 
    .equ GPIOD_AFRH, GPIOD_BASE + 0x24 @ (GPIO alternate function high  register) 
        .equ GPIOD_AFRH_AFSEL8_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOD_AFRH_AFSEL9_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOD_AFRH_AFSEL10_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOD_AFRH_AFSEL11_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOD_AFRH_AFSEL12_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOD_AFRH_AFSEL13_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOD_AFRH_AFSEL14_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOD_AFRH_AFSEL15_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
 

@=========================== GPIOE ===========================@
.equ GPIOE_BASE, 0x58021000 @ (GPIO) 
    .equ GPIOE_MODER, GPIOE_BASE + 0x0 @ (GPIO port mode register) 
        .equ GPIOE_MODER_MODE0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOE_MODER_MODE1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOE_MODER_MODE2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOE_MODER_MODE3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOE_MODER_MODE4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOE_MODER_MODE5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOE_MODER_MODE6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOE_MODER_MODE7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOE_MODER_MODE8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOE_MODER_MODE9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOE_MODER_MODE10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOE_MODER_MODE11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOE_MODER_MODE12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOE_MODER_MODE13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOE_MODER_MODE14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOE_MODER_MODE15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
 
    .equ GPIOE_OTYPER, GPIOE_BASE + 0x4 @ (GPIO port output type register) 
        .equ GPIOE_OTYPER_OT0, 1 << 0   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOE_OTYPER_OT1, 1 << 1   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOE_OTYPER_OT2, 1 << 2   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOE_OTYPER_OT3, 1 << 3   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOE_OTYPER_OT4, 1 << 4   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOE_OTYPER_OT5, 1 << 5   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOE_OTYPER_OT6, 1 << 6   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOE_OTYPER_OT7, 1 << 7   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOE_OTYPER_OT8, 1 << 8   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOE_OTYPER_OT9, 1 << 9   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOE_OTYPER_OT10, 1 << 10   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOE_OTYPER_OT11, 1 << 11   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOE_OTYPER_OT12, 1 << 12   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOE_OTYPER_OT13, 1 << 13   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOE_OTYPER_OT14, 1 << 14   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOE_OTYPER_OT15, 1 << 15   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
 
    .equ GPIOE_OSPEEDR, GPIOE_BASE + 0x8 @ (GPIO port output speed  register) 
        .equ GPIOE_OSPEEDR_OSPEED0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOE_OSPEEDR_OSPEED1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOE_OSPEEDR_OSPEED2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOE_OSPEEDR_OSPEED3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOE_OSPEEDR_OSPEED4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOE_OSPEEDR_OSPEED5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOE_OSPEEDR_OSPEED6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOE_OSPEEDR_OSPEED7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOE_OSPEEDR_OSPEED8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOE_OSPEEDR_OSPEED9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOE_OSPEEDR_OSPEED10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOE_OSPEEDR_OSPEED11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOE_OSPEEDR_OSPEED12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOE_OSPEEDR_OSPEED13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOE_OSPEEDR_OSPEED14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOE_OSPEEDR_OSPEED15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
 
    .equ GPIOE_PUPDR, GPIOE_BASE + 0xC @ (GPIO port pull-up/pull-down  register) 
        .equ GPIOE_PUPDR_PUPD0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOE_PUPDR_PUPD1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOE_PUPDR_PUPD2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOE_PUPDR_PUPD3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOE_PUPDR_PUPD4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOE_PUPDR_PUPD5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOE_PUPDR_PUPD6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOE_PUPDR_PUPD7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOE_PUPDR_PUPD8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOE_PUPDR_PUPD9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOE_PUPDR_PUPD10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOE_PUPDR_PUPD11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOE_PUPDR_PUPD12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOE_PUPDR_PUPD13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOE_PUPDR_PUPD14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOE_PUPDR_PUPD15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
 
    .equ GPIOE_IDR, GPIOE_BASE + 0x10 @ (GPIO port input data register) 
        .equ GPIOE_IDR_ID0, 1 << 0   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOE_IDR_ID1, 1 << 1   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOE_IDR_ID2, 1 << 2   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOE_IDR_ID3, 1 << 3   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOE_IDR_ID4, 1 << 4   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOE_IDR_ID5, 1 << 5   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOE_IDR_ID6, 1 << 6   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOE_IDR_ID7, 1 << 7   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOE_IDR_ID8, 1 << 8   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOE_IDR_ID9, 1 << 9   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOE_IDR_ID10, 1 << 10   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOE_IDR_ID11, 1 << 11   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOE_IDR_ID12, 1 << 12   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOE_IDR_ID13, 1 << 13   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOE_IDR_ID14, 1 << 14   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOE_IDR_ID15, 1 << 15   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
 
    .equ GPIOE_ODR, GPIOE_BASE + 0x14 @ (GPIO port output data register) 
        .equ GPIOE_ODR_OD0, 1 << 0   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOE_ODR_OD1, 1 << 1   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOE_ODR_OD2, 1 << 2   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOE_ODR_OD3, 1 << 3   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOE_ODR_OD4, 1 << 4   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOE_ODR_OD5, 1 << 5   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOE_ODR_OD6, 1 << 6   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOE_ODR_OD7, 1 << 7   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOE_ODR_OD8, 1 << 8   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOE_ODR_OD9, 1 << 9   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOE_ODR_OD10, 1 << 10   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOE_ODR_OD11, 1 << 11   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOE_ODR_OD12, 1 << 12   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOE_ODR_OD13, 1 << 13   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOE_ODR_OD14, 1 << 14   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOE_ODR_OD15, 1 << 15   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
 
    .equ GPIOE_BSRR, GPIOE_BASE + 0x18 @ (GPIO port bit set/reset  register) 
        .equ GPIOE_BSRR_BS0, 1 << 0   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOE_BSRR_BS1, 1 << 1   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOE_BSRR_BS2, 1 << 2   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOE_BSRR_BS3, 1 << 3   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOE_BSRR_BS4, 1 << 4   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOE_BSRR_BS5, 1 << 5   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOE_BSRR_BS6, 1 << 6   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOE_BSRR_BS7, 1 << 7   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOE_BSRR_BS8, 1 << 8   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOE_BSRR_BS9, 1 << 9   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOE_BSRR_BS10, 1 << 10   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOE_BSRR_BS11, 1 << 11   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOE_BSRR_BS12, 1 << 12   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOE_BSRR_BS13, 1 << 13   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOE_BSRR_BS14, 1 << 14   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOE_BSRR_BS15, 1 << 15   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOE_BSRR_BR0, 1 << 16   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOE_BSRR_BR1, 1 << 17   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOE_BSRR_BR2, 1 << 18   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOE_BSRR_BR3, 1 << 19   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOE_BSRR_BR4, 1 << 20   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOE_BSRR_BR5, 1 << 21   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOE_BSRR_BR6, 1 << 22   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOE_BSRR_BR7, 1 << 23   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOE_BSRR_BR8, 1 << 24   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOE_BSRR_BR9, 1 << 25   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOE_BSRR_BR10, 1 << 26   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOE_BSRR_BR11, 1 << 27   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOE_BSRR_BR12, 1 << 28   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOE_BSRR_BR13, 1 << 29   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOE_BSRR_BR14, 1 << 30   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOE_BSRR_BR15, 1 << 31   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
 
    .equ GPIOE_LCKR, GPIOE_BASE + 0x1C @ (This register is used to lock the  configuration of the port bits when a correct write  sequence is applied to bit 16 LCKK. The value of bits  [15:0] is used to lock the configuration of the GPIO.  During the write sequence, the value of LCKR[15:0] must  not change. When the LOCK sequence has been applied on a  port bit, the value of this port bit can no longer be  modified until the next MCU reset or peripheral reset.A  specific write sequence is used to write to the  GPIOx_LCKR register. Only word access 32-bit long is  allowed during this locking sequence.Each lock bit  freezes a specific configuration register control and  alternate function registers.) 
        .equ GPIOE_LCKR_LCK0, 1 << 0   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOE_LCKR_LCK1, 1 << 1   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOE_LCKR_LCK2, 1 << 2   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOE_LCKR_LCK3, 1 << 3   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOE_LCKR_LCK4, 1 << 4   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOE_LCKR_LCK5, 1 << 5   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOE_LCKR_LCK6, 1 << 6   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOE_LCKR_LCK7, 1 << 7   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOE_LCKR_LCK8, 1 << 8   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOE_LCKR_LCK9, 1 << 9   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOE_LCKR_LCK10, 1 << 10   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOE_LCKR_LCK11, 1 << 11   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOE_LCKR_LCK12, 1 << 12   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOE_LCKR_LCK13, 1 << 13   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOE_LCKR_LCK14, 1 << 14   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOE_LCKR_LCK15, 1 << 15   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOE_LCKR_LCKK, 1 << 16   @ bitWidth 1 (Lock key This bit can be read any time.  It can only be modified using the lock key write  sequence. LOCK key write sequence: WR LCKR[16] = 1 +  LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] =  1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 this read  operation is optional but it confirms that the lock  is active Note: During the LOCK key write sequence,  the value of LCK[15:0] must not change. Any error in  the lock sequence aborts the lock. After the first  lock sequence on any bit of the port, any read access  on the LCKK bit will return 1 until the next MCU  reset or peripheral reset.)  
 
    .equ GPIOE_AFRL, GPIOE_BASE + 0x20 @ (GPIO alternate function low  register) 
        .equ GPIOE_AFRL_AFSEL0_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOE_AFRL_AFSEL1_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOE_AFRL_AFSEL2_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOE_AFRL_AFSEL3_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOE_AFRL_AFSEL4_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOE_AFRL_AFSEL5_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOE_AFRL_AFSEL6_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOE_AFRL_AFSEL7_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
 
    .equ GPIOE_AFRH, GPIOE_BASE + 0x24 @ (GPIO alternate function high  register) 
        .equ GPIOE_AFRH_AFSEL8_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOE_AFRH_AFSEL9_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOE_AFRH_AFSEL10_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOE_AFRH_AFSEL11_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOE_AFRH_AFSEL12_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOE_AFRH_AFSEL13_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOE_AFRH_AFSEL14_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOE_AFRH_AFSEL15_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
 

@=========================== GPIOF ===========================@
.equ GPIOF_BASE, 0x58021400 @ (GPIO) 
    .equ GPIOF_MODER, GPIOF_BASE + 0x0 @ (GPIO port mode register) 
        .equ GPIOF_MODER_MODE0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOF_MODER_MODE1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOF_MODER_MODE2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOF_MODER_MODE3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOF_MODER_MODE4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOF_MODER_MODE5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOF_MODER_MODE6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOF_MODER_MODE7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOF_MODER_MODE8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOF_MODER_MODE9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOF_MODER_MODE10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOF_MODER_MODE11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOF_MODER_MODE12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOF_MODER_MODE13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOF_MODER_MODE14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOF_MODER_MODE15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
 
    .equ GPIOF_OTYPER, GPIOF_BASE + 0x4 @ (GPIO port output type register) 
        .equ GPIOF_OTYPER_OT0, 1 << 0   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOF_OTYPER_OT1, 1 << 1   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOF_OTYPER_OT2, 1 << 2   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOF_OTYPER_OT3, 1 << 3   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOF_OTYPER_OT4, 1 << 4   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOF_OTYPER_OT5, 1 << 5   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOF_OTYPER_OT6, 1 << 6   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOF_OTYPER_OT7, 1 << 7   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOF_OTYPER_OT8, 1 << 8   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOF_OTYPER_OT9, 1 << 9   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOF_OTYPER_OT10, 1 << 10   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOF_OTYPER_OT11, 1 << 11   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOF_OTYPER_OT12, 1 << 12   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOF_OTYPER_OT13, 1 << 13   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOF_OTYPER_OT14, 1 << 14   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOF_OTYPER_OT15, 1 << 15   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
 
    .equ GPIOF_OSPEEDR, GPIOF_BASE + 0x8 @ (GPIO port output speed  register) 
        .equ GPIOF_OSPEEDR_OSPEED0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOF_OSPEEDR_OSPEED1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOF_OSPEEDR_OSPEED2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOF_OSPEEDR_OSPEED3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOF_OSPEEDR_OSPEED4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOF_OSPEEDR_OSPEED5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOF_OSPEEDR_OSPEED6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOF_OSPEEDR_OSPEED7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOF_OSPEEDR_OSPEED8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOF_OSPEEDR_OSPEED9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOF_OSPEEDR_OSPEED10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOF_OSPEEDR_OSPEED11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOF_OSPEEDR_OSPEED12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOF_OSPEEDR_OSPEED13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOF_OSPEEDR_OSPEED14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOF_OSPEEDR_OSPEED15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
 
    .equ GPIOF_PUPDR, GPIOF_BASE + 0xC @ (GPIO port pull-up/pull-down  register) 
        .equ GPIOF_PUPDR_PUPD0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOF_PUPDR_PUPD1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOF_PUPDR_PUPD2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOF_PUPDR_PUPD3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOF_PUPDR_PUPD4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOF_PUPDR_PUPD5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOF_PUPDR_PUPD6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOF_PUPDR_PUPD7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOF_PUPDR_PUPD8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOF_PUPDR_PUPD9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOF_PUPDR_PUPD10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOF_PUPDR_PUPD11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOF_PUPDR_PUPD12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOF_PUPDR_PUPD13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOF_PUPDR_PUPD14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOF_PUPDR_PUPD15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
 
    .equ GPIOF_IDR, GPIOF_BASE + 0x10 @ (GPIO port input data register) 
        .equ GPIOF_IDR_ID0, 1 << 0   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOF_IDR_ID1, 1 << 1   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOF_IDR_ID2, 1 << 2   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOF_IDR_ID3, 1 << 3   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOF_IDR_ID4, 1 << 4   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOF_IDR_ID5, 1 << 5   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOF_IDR_ID6, 1 << 6   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOF_IDR_ID7, 1 << 7   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOF_IDR_ID8, 1 << 8   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOF_IDR_ID9, 1 << 9   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOF_IDR_ID10, 1 << 10   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOF_IDR_ID11, 1 << 11   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOF_IDR_ID12, 1 << 12   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOF_IDR_ID13, 1 << 13   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOF_IDR_ID14, 1 << 14   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOF_IDR_ID15, 1 << 15   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
 
    .equ GPIOF_ODR, GPIOF_BASE + 0x14 @ (GPIO port output data register) 
        .equ GPIOF_ODR_OD0, 1 << 0   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOF_ODR_OD1, 1 << 1   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOF_ODR_OD2, 1 << 2   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOF_ODR_OD3, 1 << 3   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOF_ODR_OD4, 1 << 4   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOF_ODR_OD5, 1 << 5   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOF_ODR_OD6, 1 << 6   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOF_ODR_OD7, 1 << 7   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOF_ODR_OD8, 1 << 8   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOF_ODR_OD9, 1 << 9   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOF_ODR_OD10, 1 << 10   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOF_ODR_OD11, 1 << 11   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOF_ODR_OD12, 1 << 12   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOF_ODR_OD13, 1 << 13   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOF_ODR_OD14, 1 << 14   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOF_ODR_OD15, 1 << 15   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
 
    .equ GPIOF_BSRR, GPIOF_BASE + 0x18 @ (GPIO port bit set/reset  register) 
        .equ GPIOF_BSRR_BS0, 1 << 0   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOF_BSRR_BS1, 1 << 1   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOF_BSRR_BS2, 1 << 2   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOF_BSRR_BS3, 1 << 3   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOF_BSRR_BS4, 1 << 4   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOF_BSRR_BS5, 1 << 5   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOF_BSRR_BS6, 1 << 6   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOF_BSRR_BS7, 1 << 7   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOF_BSRR_BS8, 1 << 8   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOF_BSRR_BS9, 1 << 9   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOF_BSRR_BS10, 1 << 10   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOF_BSRR_BS11, 1 << 11   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOF_BSRR_BS12, 1 << 12   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOF_BSRR_BS13, 1 << 13   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOF_BSRR_BS14, 1 << 14   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOF_BSRR_BS15, 1 << 15   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOF_BSRR_BR0, 1 << 16   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOF_BSRR_BR1, 1 << 17   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOF_BSRR_BR2, 1 << 18   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOF_BSRR_BR3, 1 << 19   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOF_BSRR_BR4, 1 << 20   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOF_BSRR_BR5, 1 << 21   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOF_BSRR_BR6, 1 << 22   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOF_BSRR_BR7, 1 << 23   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOF_BSRR_BR8, 1 << 24   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOF_BSRR_BR9, 1 << 25   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOF_BSRR_BR10, 1 << 26   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOF_BSRR_BR11, 1 << 27   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOF_BSRR_BR12, 1 << 28   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOF_BSRR_BR13, 1 << 29   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOF_BSRR_BR14, 1 << 30   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOF_BSRR_BR15, 1 << 31   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
 
    .equ GPIOF_LCKR, GPIOF_BASE + 0x1C @ (This register is used to lock the  configuration of the port bits when a correct write  sequence is applied to bit 16 LCKK. The value of bits  [15:0] is used to lock the configuration of the GPIO.  During the write sequence, the value of LCKR[15:0] must  not change. When the LOCK sequence has been applied on a  port bit, the value of this port bit can no longer be  modified until the next MCU reset or peripheral reset.A  specific write sequence is used to write to the  GPIOx_LCKR register. Only word access 32-bit long is  allowed during this locking sequence.Each lock bit  freezes a specific configuration register control and  alternate function registers.) 
        .equ GPIOF_LCKR_LCK0, 1 << 0   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOF_LCKR_LCK1, 1 << 1   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOF_LCKR_LCK2, 1 << 2   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOF_LCKR_LCK3, 1 << 3   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOF_LCKR_LCK4, 1 << 4   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOF_LCKR_LCK5, 1 << 5   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOF_LCKR_LCK6, 1 << 6   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOF_LCKR_LCK7, 1 << 7   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOF_LCKR_LCK8, 1 << 8   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOF_LCKR_LCK9, 1 << 9   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOF_LCKR_LCK10, 1 << 10   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOF_LCKR_LCK11, 1 << 11   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOF_LCKR_LCK12, 1 << 12   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOF_LCKR_LCK13, 1 << 13   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOF_LCKR_LCK14, 1 << 14   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOF_LCKR_LCK15, 1 << 15   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOF_LCKR_LCKK, 1 << 16   @ bitWidth 1 (Lock key This bit can be read any time.  It can only be modified using the lock key write  sequence. LOCK key write sequence: WR LCKR[16] = 1 +  LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] =  1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 this read  operation is optional but it confirms that the lock  is active Note: During the LOCK key write sequence,  the value of LCK[15:0] must not change. Any error in  the lock sequence aborts the lock. After the first  lock sequence on any bit of the port, any read access  on the LCKK bit will return 1 until the next MCU  reset or peripheral reset.)  
 
    .equ GPIOF_AFRL, GPIOF_BASE + 0x20 @ (GPIO alternate function low  register) 
        .equ GPIOF_AFRL_AFSEL0_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOF_AFRL_AFSEL1_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOF_AFRL_AFSEL2_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOF_AFRL_AFSEL3_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOF_AFRL_AFSEL4_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOF_AFRL_AFSEL5_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOF_AFRL_AFSEL6_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOF_AFRL_AFSEL7_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
 
    .equ GPIOF_AFRH, GPIOF_BASE + 0x24 @ (GPIO alternate function high  register) 
        .equ GPIOF_AFRH_AFSEL8_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOF_AFRH_AFSEL9_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOF_AFRH_AFSEL10_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOF_AFRH_AFSEL11_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOF_AFRH_AFSEL12_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOF_AFRH_AFSEL13_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOF_AFRH_AFSEL14_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOF_AFRH_AFSEL15_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
 

@=========================== GPIOG ===========================@
.equ GPIOG_BASE, 0x58021800 @ (GPIO) 
    .equ GPIOG_MODER, GPIOG_BASE + 0x0 @ (GPIO port mode register) 
        .equ GPIOG_MODER_MODE0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOG_MODER_MODE1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOG_MODER_MODE2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOG_MODER_MODE3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOG_MODER_MODE4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOG_MODER_MODE5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOG_MODER_MODE6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOG_MODER_MODE7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOG_MODER_MODE8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOG_MODER_MODE9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOG_MODER_MODE10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOG_MODER_MODE11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOG_MODER_MODE12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOG_MODER_MODE13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOG_MODER_MODE14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOG_MODER_MODE15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
 
    .equ GPIOG_OTYPER, GPIOG_BASE + 0x4 @ (GPIO port output type register) 
        .equ GPIOG_OTYPER_OT0, 1 << 0   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOG_OTYPER_OT1, 1 << 1   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOG_OTYPER_OT2, 1 << 2   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOG_OTYPER_OT3, 1 << 3   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOG_OTYPER_OT4, 1 << 4   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOG_OTYPER_OT5, 1 << 5   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOG_OTYPER_OT6, 1 << 6   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOG_OTYPER_OT7, 1 << 7   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOG_OTYPER_OT8, 1 << 8   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOG_OTYPER_OT9, 1 << 9   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOG_OTYPER_OT10, 1 << 10   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOG_OTYPER_OT11, 1 << 11   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOG_OTYPER_OT12, 1 << 12   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOG_OTYPER_OT13, 1 << 13   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOG_OTYPER_OT14, 1 << 14   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOG_OTYPER_OT15, 1 << 15   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
 
    .equ GPIOG_OSPEEDR, GPIOG_BASE + 0x8 @ (GPIO port output speed  register) 
        .equ GPIOG_OSPEEDR_OSPEED0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOG_OSPEEDR_OSPEED1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOG_OSPEEDR_OSPEED2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOG_OSPEEDR_OSPEED3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOG_OSPEEDR_OSPEED4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOG_OSPEEDR_OSPEED5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOG_OSPEEDR_OSPEED6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOG_OSPEEDR_OSPEED7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOG_OSPEEDR_OSPEED8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOG_OSPEEDR_OSPEED9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOG_OSPEEDR_OSPEED10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOG_OSPEEDR_OSPEED11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOG_OSPEEDR_OSPEED12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOG_OSPEEDR_OSPEED13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOG_OSPEEDR_OSPEED14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOG_OSPEEDR_OSPEED15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
 
    .equ GPIOG_PUPDR, GPIOG_BASE + 0xC @ (GPIO port pull-up/pull-down  register) 
        .equ GPIOG_PUPDR_PUPD0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOG_PUPDR_PUPD1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOG_PUPDR_PUPD2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOG_PUPDR_PUPD3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOG_PUPDR_PUPD4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOG_PUPDR_PUPD5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOG_PUPDR_PUPD6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOG_PUPDR_PUPD7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOG_PUPDR_PUPD8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOG_PUPDR_PUPD9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOG_PUPDR_PUPD10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOG_PUPDR_PUPD11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOG_PUPDR_PUPD12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOG_PUPDR_PUPD13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOG_PUPDR_PUPD14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOG_PUPDR_PUPD15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
 
    .equ GPIOG_IDR, GPIOG_BASE + 0x10 @ (GPIO port input data register) 
        .equ GPIOG_IDR_ID0, 1 << 0   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOG_IDR_ID1, 1 << 1   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOG_IDR_ID2, 1 << 2   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOG_IDR_ID3, 1 << 3   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOG_IDR_ID4, 1 << 4   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOG_IDR_ID5, 1 << 5   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOG_IDR_ID6, 1 << 6   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOG_IDR_ID7, 1 << 7   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOG_IDR_ID8, 1 << 8   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOG_IDR_ID9, 1 << 9   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOG_IDR_ID10, 1 << 10   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOG_IDR_ID11, 1 << 11   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOG_IDR_ID12, 1 << 12   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOG_IDR_ID13, 1 << 13   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOG_IDR_ID14, 1 << 14   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOG_IDR_ID15, 1 << 15   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
 
    .equ GPIOG_ODR, GPIOG_BASE + 0x14 @ (GPIO port output data register) 
        .equ GPIOG_ODR_OD0, 1 << 0   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOG_ODR_OD1, 1 << 1   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOG_ODR_OD2, 1 << 2   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOG_ODR_OD3, 1 << 3   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOG_ODR_OD4, 1 << 4   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOG_ODR_OD5, 1 << 5   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOG_ODR_OD6, 1 << 6   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOG_ODR_OD7, 1 << 7   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOG_ODR_OD8, 1 << 8   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOG_ODR_OD9, 1 << 9   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOG_ODR_OD10, 1 << 10   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOG_ODR_OD11, 1 << 11   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOG_ODR_OD12, 1 << 12   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOG_ODR_OD13, 1 << 13   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOG_ODR_OD14, 1 << 14   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOG_ODR_OD15, 1 << 15   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
 
    .equ GPIOG_BSRR, GPIOG_BASE + 0x18 @ (GPIO port bit set/reset  register) 
        .equ GPIOG_BSRR_BS0, 1 << 0   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOG_BSRR_BS1, 1 << 1   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOG_BSRR_BS2, 1 << 2   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOG_BSRR_BS3, 1 << 3   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOG_BSRR_BS4, 1 << 4   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOG_BSRR_BS5, 1 << 5   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOG_BSRR_BS6, 1 << 6   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOG_BSRR_BS7, 1 << 7   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOG_BSRR_BS8, 1 << 8   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOG_BSRR_BS9, 1 << 9   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOG_BSRR_BS10, 1 << 10   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOG_BSRR_BS11, 1 << 11   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOG_BSRR_BS12, 1 << 12   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOG_BSRR_BS13, 1 << 13   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOG_BSRR_BS14, 1 << 14   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOG_BSRR_BS15, 1 << 15   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOG_BSRR_BR0, 1 << 16   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOG_BSRR_BR1, 1 << 17   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOG_BSRR_BR2, 1 << 18   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOG_BSRR_BR3, 1 << 19   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOG_BSRR_BR4, 1 << 20   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOG_BSRR_BR5, 1 << 21   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOG_BSRR_BR6, 1 << 22   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOG_BSRR_BR7, 1 << 23   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOG_BSRR_BR8, 1 << 24   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOG_BSRR_BR9, 1 << 25   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOG_BSRR_BR10, 1 << 26   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOG_BSRR_BR11, 1 << 27   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOG_BSRR_BR12, 1 << 28   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOG_BSRR_BR13, 1 << 29   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOG_BSRR_BR14, 1 << 30   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOG_BSRR_BR15, 1 << 31   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
 
    .equ GPIOG_LCKR, GPIOG_BASE + 0x1C @ (This register is used to lock the  configuration of the port bits when a correct write  sequence is applied to bit 16 LCKK. The value of bits  [15:0] is used to lock the configuration of the GPIO.  During the write sequence, the value of LCKR[15:0] must  not change. When the LOCK sequence has been applied on a  port bit, the value of this port bit can no longer be  modified until the next MCU reset or peripheral reset.A  specific write sequence is used to write to the  GPIOx_LCKR register. Only word access 32-bit long is  allowed during this locking sequence.Each lock bit  freezes a specific configuration register control and  alternate function registers.) 
        .equ GPIOG_LCKR_LCK0, 1 << 0   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOG_LCKR_LCK1, 1 << 1   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOG_LCKR_LCK2, 1 << 2   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOG_LCKR_LCK3, 1 << 3   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOG_LCKR_LCK4, 1 << 4   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOG_LCKR_LCK5, 1 << 5   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOG_LCKR_LCK6, 1 << 6   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOG_LCKR_LCK7, 1 << 7   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOG_LCKR_LCK8, 1 << 8   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOG_LCKR_LCK9, 1 << 9   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOG_LCKR_LCK10, 1 << 10   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOG_LCKR_LCK11, 1 << 11   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOG_LCKR_LCK12, 1 << 12   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOG_LCKR_LCK13, 1 << 13   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOG_LCKR_LCK14, 1 << 14   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOG_LCKR_LCK15, 1 << 15   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOG_LCKR_LCKK, 1 << 16   @ bitWidth 1 (Lock key This bit can be read any time.  It can only be modified using the lock key write  sequence. LOCK key write sequence: WR LCKR[16] = 1 +  LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] =  1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 this read  operation is optional but it confirms that the lock  is active Note: During the LOCK key write sequence,  the value of LCK[15:0] must not change. Any error in  the lock sequence aborts the lock. After the first  lock sequence on any bit of the port, any read access  on the LCKK bit will return 1 until the next MCU  reset or peripheral reset.)  
 
    .equ GPIOG_AFRL, GPIOG_BASE + 0x20 @ (GPIO alternate function low  register) 
        .equ GPIOG_AFRL_AFSEL0_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOG_AFRL_AFSEL1_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOG_AFRL_AFSEL2_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOG_AFRL_AFSEL3_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOG_AFRL_AFSEL4_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOG_AFRL_AFSEL5_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOG_AFRL_AFSEL6_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOG_AFRL_AFSEL7_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
 
    .equ GPIOG_AFRH, GPIOG_BASE + 0x24 @ (GPIO alternate function high  register) 
        .equ GPIOG_AFRH_AFSEL8_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOG_AFRH_AFSEL9_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOG_AFRH_AFSEL10_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOG_AFRH_AFSEL11_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOG_AFRH_AFSEL12_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOG_AFRH_AFSEL13_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOG_AFRH_AFSEL14_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOG_AFRH_AFSEL15_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
 

@=========================== GPIOH ===========================@
.equ GPIOH_BASE, 0x58021C00 @ (GPIO) 
    .equ GPIOH_MODER, GPIOH_BASE + 0x0 @ (GPIO port mode register) 
        .equ GPIOH_MODER_MODE0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOH_MODER_MODE1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOH_MODER_MODE2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOH_MODER_MODE3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOH_MODER_MODE4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOH_MODER_MODE5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOH_MODER_MODE6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOH_MODER_MODE7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOH_MODER_MODE8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOH_MODER_MODE9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOH_MODER_MODE10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOH_MODER_MODE11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOH_MODER_MODE12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOH_MODER_MODE13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOH_MODER_MODE14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOH_MODER_MODE15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
 
    .equ GPIOH_OTYPER, GPIOH_BASE + 0x4 @ (GPIO port output type register) 
        .equ GPIOH_OTYPER_OT0, 1 << 0   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOH_OTYPER_OT1, 1 << 1   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOH_OTYPER_OT2, 1 << 2   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOH_OTYPER_OT3, 1 << 3   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOH_OTYPER_OT4, 1 << 4   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOH_OTYPER_OT5, 1 << 5   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOH_OTYPER_OT6, 1 << 6   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOH_OTYPER_OT7, 1 << 7   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOH_OTYPER_OT8, 1 << 8   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOH_OTYPER_OT9, 1 << 9   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOH_OTYPER_OT10, 1 << 10   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOH_OTYPER_OT11, 1 << 11   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOH_OTYPER_OT12, 1 << 12   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOH_OTYPER_OT13, 1 << 13   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOH_OTYPER_OT14, 1 << 14   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOH_OTYPER_OT15, 1 << 15   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
 
    .equ GPIOH_OSPEEDR, GPIOH_BASE + 0x8 @ (GPIO port output speed  register) 
        .equ GPIOH_OSPEEDR_OSPEED0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOH_OSPEEDR_OSPEED1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOH_OSPEEDR_OSPEED2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOH_OSPEEDR_OSPEED3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOH_OSPEEDR_OSPEED4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOH_OSPEEDR_OSPEED5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOH_OSPEEDR_OSPEED6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOH_OSPEEDR_OSPEED7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOH_OSPEEDR_OSPEED8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOH_OSPEEDR_OSPEED9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOH_OSPEEDR_OSPEED10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOH_OSPEEDR_OSPEED11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOH_OSPEEDR_OSPEED12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOH_OSPEEDR_OSPEED13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOH_OSPEEDR_OSPEED14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOH_OSPEEDR_OSPEED15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
 
    .equ GPIOH_PUPDR, GPIOH_BASE + 0xC @ (GPIO port pull-up/pull-down  register) 
        .equ GPIOH_PUPDR_PUPD0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOH_PUPDR_PUPD1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOH_PUPDR_PUPD2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOH_PUPDR_PUPD3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOH_PUPDR_PUPD4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOH_PUPDR_PUPD5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOH_PUPDR_PUPD6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOH_PUPDR_PUPD7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOH_PUPDR_PUPD8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOH_PUPDR_PUPD9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOH_PUPDR_PUPD10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOH_PUPDR_PUPD11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOH_PUPDR_PUPD12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOH_PUPDR_PUPD13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOH_PUPDR_PUPD14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOH_PUPDR_PUPD15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
 
    .equ GPIOH_IDR, GPIOH_BASE + 0x10 @ (GPIO port input data register) 
        .equ GPIOH_IDR_ID0, 1 << 0   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOH_IDR_ID1, 1 << 1   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOH_IDR_ID2, 1 << 2   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOH_IDR_ID3, 1 << 3   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOH_IDR_ID4, 1 << 4   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOH_IDR_ID5, 1 << 5   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOH_IDR_ID6, 1 << 6   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOH_IDR_ID7, 1 << 7   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOH_IDR_ID8, 1 << 8   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOH_IDR_ID9, 1 << 9   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOH_IDR_ID10, 1 << 10   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOH_IDR_ID11, 1 << 11   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOH_IDR_ID12, 1 << 12   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOH_IDR_ID13, 1 << 13   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOH_IDR_ID14, 1 << 14   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOH_IDR_ID15, 1 << 15   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
 
    .equ GPIOH_ODR, GPIOH_BASE + 0x14 @ (GPIO port output data register) 
        .equ GPIOH_ODR_OD0, 1 << 0   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOH_ODR_OD1, 1 << 1   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOH_ODR_OD2, 1 << 2   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOH_ODR_OD3, 1 << 3   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOH_ODR_OD4, 1 << 4   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOH_ODR_OD5, 1 << 5   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOH_ODR_OD6, 1 << 6   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOH_ODR_OD7, 1 << 7   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOH_ODR_OD8, 1 << 8   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOH_ODR_OD9, 1 << 9   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOH_ODR_OD10, 1 << 10   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOH_ODR_OD11, 1 << 11   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOH_ODR_OD12, 1 << 12   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOH_ODR_OD13, 1 << 13   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOH_ODR_OD14, 1 << 14   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOH_ODR_OD15, 1 << 15   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
 
    .equ GPIOH_BSRR, GPIOH_BASE + 0x18 @ (GPIO port bit set/reset  register) 
        .equ GPIOH_BSRR_BS0, 1 << 0   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOH_BSRR_BS1, 1 << 1   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOH_BSRR_BS2, 1 << 2   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOH_BSRR_BS3, 1 << 3   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOH_BSRR_BS4, 1 << 4   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOH_BSRR_BS5, 1 << 5   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOH_BSRR_BS6, 1 << 6   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOH_BSRR_BS7, 1 << 7   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOH_BSRR_BS8, 1 << 8   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOH_BSRR_BS9, 1 << 9   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOH_BSRR_BS10, 1 << 10   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOH_BSRR_BS11, 1 << 11   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOH_BSRR_BS12, 1 << 12   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOH_BSRR_BS13, 1 << 13   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOH_BSRR_BS14, 1 << 14   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOH_BSRR_BS15, 1 << 15   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOH_BSRR_BR0, 1 << 16   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOH_BSRR_BR1, 1 << 17   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOH_BSRR_BR2, 1 << 18   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOH_BSRR_BR3, 1 << 19   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOH_BSRR_BR4, 1 << 20   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOH_BSRR_BR5, 1 << 21   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOH_BSRR_BR6, 1 << 22   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOH_BSRR_BR7, 1 << 23   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOH_BSRR_BR8, 1 << 24   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOH_BSRR_BR9, 1 << 25   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOH_BSRR_BR10, 1 << 26   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOH_BSRR_BR11, 1 << 27   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOH_BSRR_BR12, 1 << 28   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOH_BSRR_BR13, 1 << 29   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOH_BSRR_BR14, 1 << 30   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOH_BSRR_BR15, 1 << 31   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
 
    .equ GPIOH_LCKR, GPIOH_BASE + 0x1C @ (This register is used to lock the  configuration of the port bits when a correct write  sequence is applied to bit 16 LCKK. The value of bits  [15:0] is used to lock the configuration of the GPIO.  During the write sequence, the value of LCKR[15:0] must  not change. When the LOCK sequence has been applied on a  port bit, the value of this port bit can no longer be  modified until the next MCU reset or peripheral reset.A  specific write sequence is used to write to the  GPIOx_LCKR register. Only word access 32-bit long is  allowed during this locking sequence.Each lock bit  freezes a specific configuration register control and  alternate function registers.) 
        .equ GPIOH_LCKR_LCK0, 1 << 0   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOH_LCKR_LCK1, 1 << 1   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOH_LCKR_LCK2, 1 << 2   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOH_LCKR_LCK3, 1 << 3   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOH_LCKR_LCK4, 1 << 4   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOH_LCKR_LCK5, 1 << 5   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOH_LCKR_LCK6, 1 << 6   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOH_LCKR_LCK7, 1 << 7   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOH_LCKR_LCK8, 1 << 8   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOH_LCKR_LCK9, 1 << 9   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOH_LCKR_LCK10, 1 << 10   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOH_LCKR_LCK11, 1 << 11   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOH_LCKR_LCK12, 1 << 12   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOH_LCKR_LCK13, 1 << 13   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOH_LCKR_LCK14, 1 << 14   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOH_LCKR_LCK15, 1 << 15   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOH_LCKR_LCKK, 1 << 16   @ bitWidth 1 (Lock key This bit can be read any time.  It can only be modified using the lock key write  sequence. LOCK key write sequence: WR LCKR[16] = 1 +  LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] =  1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 this read  operation is optional but it confirms that the lock  is active Note: During the LOCK key write sequence,  the value of LCK[15:0] must not change. Any error in  the lock sequence aborts the lock. After the first  lock sequence on any bit of the port, any read access  on the LCKK bit will return 1 until the next MCU  reset or peripheral reset.)  
 
    .equ GPIOH_AFRL, GPIOH_BASE + 0x20 @ (GPIO alternate function low  register) 
        .equ GPIOH_AFRL_AFSEL0_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOH_AFRL_AFSEL1_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOH_AFRL_AFSEL2_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOH_AFRL_AFSEL3_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOH_AFRL_AFSEL4_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOH_AFRL_AFSEL5_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOH_AFRL_AFSEL6_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOH_AFRL_AFSEL7_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
 
    .equ GPIOH_AFRH, GPIOH_BASE + 0x24 @ (GPIO alternate function high  register) 
        .equ GPIOH_AFRH_AFSEL8_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOH_AFRH_AFSEL9_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOH_AFRH_AFSEL10_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOH_AFRH_AFSEL11_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOH_AFRH_AFSEL12_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOH_AFRH_AFSEL13_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOH_AFRH_AFSEL14_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOH_AFRH_AFSEL15_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
 

@=========================== GPIOI ===========================@
.equ GPIOI_BASE, 0x58022000 @ (GPIO) 
    .equ GPIOI_MODER, GPIOI_BASE + 0x0 @ (GPIO port mode register) 
        .equ GPIOI_MODER_MODE0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOI_MODER_MODE1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOI_MODER_MODE2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOI_MODER_MODE3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOI_MODER_MODE4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOI_MODER_MODE5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOI_MODER_MODE6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOI_MODER_MODE7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOI_MODER_MODE8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOI_MODER_MODE9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOI_MODER_MODE10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOI_MODER_MODE11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOI_MODER_MODE12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOI_MODER_MODE13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOI_MODER_MODE14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOI_MODER_MODE15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
 
    .equ GPIOI_OTYPER, GPIOI_BASE + 0x4 @ (GPIO port output type register) 
        .equ GPIOI_OTYPER_OT0, 1 << 0   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOI_OTYPER_OT1, 1 << 1   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOI_OTYPER_OT2, 1 << 2   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOI_OTYPER_OT3, 1 << 3   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOI_OTYPER_OT4, 1 << 4   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOI_OTYPER_OT5, 1 << 5   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOI_OTYPER_OT6, 1 << 6   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOI_OTYPER_OT7, 1 << 7   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOI_OTYPER_OT8, 1 << 8   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOI_OTYPER_OT9, 1 << 9   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOI_OTYPER_OT10, 1 << 10   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOI_OTYPER_OT11, 1 << 11   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOI_OTYPER_OT12, 1 << 12   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOI_OTYPER_OT13, 1 << 13   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOI_OTYPER_OT14, 1 << 14   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOI_OTYPER_OT15, 1 << 15   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
 
    .equ GPIOI_OSPEEDR, GPIOI_BASE + 0x8 @ (GPIO port output speed  register) 
        .equ GPIOI_OSPEEDR_OSPEED0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOI_OSPEEDR_OSPEED1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOI_OSPEEDR_OSPEED2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOI_OSPEEDR_OSPEED3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOI_OSPEEDR_OSPEED4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOI_OSPEEDR_OSPEED5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOI_OSPEEDR_OSPEED6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOI_OSPEEDR_OSPEED7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOI_OSPEEDR_OSPEED8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOI_OSPEEDR_OSPEED9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOI_OSPEEDR_OSPEED10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOI_OSPEEDR_OSPEED11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOI_OSPEEDR_OSPEED12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOI_OSPEEDR_OSPEED13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOI_OSPEEDR_OSPEED14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOI_OSPEEDR_OSPEED15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
 
    .equ GPIOI_PUPDR, GPIOI_BASE + 0xC @ (GPIO port pull-up/pull-down  register) 
        .equ GPIOI_PUPDR_PUPD0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOI_PUPDR_PUPD1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOI_PUPDR_PUPD2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOI_PUPDR_PUPD3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOI_PUPDR_PUPD4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOI_PUPDR_PUPD5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOI_PUPDR_PUPD6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOI_PUPDR_PUPD7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOI_PUPDR_PUPD8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOI_PUPDR_PUPD9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOI_PUPDR_PUPD10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOI_PUPDR_PUPD11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOI_PUPDR_PUPD12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOI_PUPDR_PUPD13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOI_PUPDR_PUPD14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOI_PUPDR_PUPD15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
 
    .equ GPIOI_IDR, GPIOI_BASE + 0x10 @ (GPIO port input data register) 
        .equ GPIOI_IDR_ID0, 1 << 0   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOI_IDR_ID1, 1 << 1   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOI_IDR_ID2, 1 << 2   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOI_IDR_ID3, 1 << 3   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOI_IDR_ID4, 1 << 4   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOI_IDR_ID5, 1 << 5   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOI_IDR_ID6, 1 << 6   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOI_IDR_ID7, 1 << 7   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOI_IDR_ID8, 1 << 8   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOI_IDR_ID9, 1 << 9   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOI_IDR_ID10, 1 << 10   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOI_IDR_ID11, 1 << 11   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOI_IDR_ID12, 1 << 12   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOI_IDR_ID13, 1 << 13   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOI_IDR_ID14, 1 << 14   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOI_IDR_ID15, 1 << 15   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
 
    .equ GPIOI_ODR, GPIOI_BASE + 0x14 @ (GPIO port output data register) 
        .equ GPIOI_ODR_OD0, 1 << 0   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOI_ODR_OD1, 1 << 1   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOI_ODR_OD2, 1 << 2   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOI_ODR_OD3, 1 << 3   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOI_ODR_OD4, 1 << 4   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOI_ODR_OD5, 1 << 5   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOI_ODR_OD6, 1 << 6   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOI_ODR_OD7, 1 << 7   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOI_ODR_OD8, 1 << 8   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOI_ODR_OD9, 1 << 9   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOI_ODR_OD10, 1 << 10   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOI_ODR_OD11, 1 << 11   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOI_ODR_OD12, 1 << 12   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOI_ODR_OD13, 1 << 13   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOI_ODR_OD14, 1 << 14   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOI_ODR_OD15, 1 << 15   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
 
    .equ GPIOI_BSRR, GPIOI_BASE + 0x18 @ (GPIO port bit set/reset  register) 
        .equ GPIOI_BSRR_BS0, 1 << 0   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOI_BSRR_BS1, 1 << 1   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOI_BSRR_BS2, 1 << 2   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOI_BSRR_BS3, 1 << 3   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOI_BSRR_BS4, 1 << 4   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOI_BSRR_BS5, 1 << 5   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOI_BSRR_BS6, 1 << 6   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOI_BSRR_BS7, 1 << 7   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOI_BSRR_BS8, 1 << 8   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOI_BSRR_BS9, 1 << 9   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOI_BSRR_BS10, 1 << 10   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOI_BSRR_BS11, 1 << 11   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOI_BSRR_BS12, 1 << 12   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOI_BSRR_BS13, 1 << 13   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOI_BSRR_BS14, 1 << 14   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOI_BSRR_BS15, 1 << 15   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOI_BSRR_BR0, 1 << 16   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOI_BSRR_BR1, 1 << 17   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOI_BSRR_BR2, 1 << 18   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOI_BSRR_BR3, 1 << 19   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOI_BSRR_BR4, 1 << 20   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOI_BSRR_BR5, 1 << 21   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOI_BSRR_BR6, 1 << 22   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOI_BSRR_BR7, 1 << 23   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOI_BSRR_BR8, 1 << 24   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOI_BSRR_BR9, 1 << 25   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOI_BSRR_BR10, 1 << 26   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOI_BSRR_BR11, 1 << 27   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOI_BSRR_BR12, 1 << 28   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOI_BSRR_BR13, 1 << 29   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOI_BSRR_BR14, 1 << 30   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOI_BSRR_BR15, 1 << 31   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
 
    .equ GPIOI_LCKR, GPIOI_BASE + 0x1C @ (This register is used to lock the  configuration of the port bits when a correct write  sequence is applied to bit 16 LCKK. The value of bits  [15:0] is used to lock the configuration of the GPIO.  During the write sequence, the value of LCKR[15:0] must  not change. When the LOCK sequence has been applied on a  port bit, the value of this port bit can no longer be  modified until the next MCU reset or peripheral reset.A  specific write sequence is used to write to the  GPIOx_LCKR register. Only word access 32-bit long is  allowed during this locking sequence.Each lock bit  freezes a specific configuration register control and  alternate function registers.) 
        .equ GPIOI_LCKR_LCK0, 1 << 0   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOI_LCKR_LCK1, 1 << 1   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOI_LCKR_LCK2, 1 << 2   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOI_LCKR_LCK3, 1 << 3   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOI_LCKR_LCK4, 1 << 4   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOI_LCKR_LCK5, 1 << 5   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOI_LCKR_LCK6, 1 << 6   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOI_LCKR_LCK7, 1 << 7   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOI_LCKR_LCK8, 1 << 8   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOI_LCKR_LCK9, 1 << 9   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOI_LCKR_LCK10, 1 << 10   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOI_LCKR_LCK11, 1 << 11   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOI_LCKR_LCK12, 1 << 12   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOI_LCKR_LCK13, 1 << 13   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOI_LCKR_LCK14, 1 << 14   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOI_LCKR_LCK15, 1 << 15   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOI_LCKR_LCKK, 1 << 16   @ bitWidth 1 (Lock key This bit can be read any time.  It can only be modified using the lock key write  sequence. LOCK key write sequence: WR LCKR[16] = 1 +  LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] =  1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 this read  operation is optional but it confirms that the lock  is active Note: During the LOCK key write sequence,  the value of LCK[15:0] must not change. Any error in  the lock sequence aborts the lock. After the first  lock sequence on any bit of the port, any read access  on the LCKK bit will return 1 until the next MCU  reset or peripheral reset.)  
 
    .equ GPIOI_AFRL, GPIOI_BASE + 0x20 @ (GPIO alternate function low  register) 
        .equ GPIOI_AFRL_AFSEL0_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOI_AFRL_AFSEL1_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOI_AFRL_AFSEL2_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOI_AFRL_AFSEL3_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOI_AFRL_AFSEL4_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOI_AFRL_AFSEL5_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOI_AFRL_AFSEL6_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOI_AFRL_AFSEL7_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
 
    .equ GPIOI_AFRH, GPIOI_BASE + 0x24 @ (GPIO alternate function high  register) 
        .equ GPIOI_AFRH_AFSEL8_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOI_AFRH_AFSEL9_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOI_AFRH_AFSEL10_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOI_AFRH_AFSEL11_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOI_AFRH_AFSEL12_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOI_AFRH_AFSEL13_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOI_AFRH_AFSEL14_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOI_AFRH_AFSEL15_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
 

@=========================== GPIOJ ===========================@
.equ GPIOJ_BASE, 0x58022400 @ (GPIO) 
    .equ GPIOJ_MODER, GPIOJ_BASE + 0x0 @ (GPIO port mode register) 
        .equ GPIOJ_MODER_MODE0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOJ_MODER_MODE1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOJ_MODER_MODE2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOJ_MODER_MODE3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOJ_MODER_MODE4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOJ_MODER_MODE5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOJ_MODER_MODE6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOJ_MODER_MODE7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOJ_MODER_MODE8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOJ_MODER_MODE9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOJ_MODER_MODE10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOJ_MODER_MODE11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOJ_MODER_MODE12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOJ_MODER_MODE13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOJ_MODER_MODE14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOJ_MODER_MODE15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
 
    .equ GPIOJ_OTYPER, GPIOJ_BASE + 0x4 @ (GPIO port output type register) 
        .equ GPIOJ_OTYPER_OT0, 1 << 0   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOJ_OTYPER_OT1, 1 << 1   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOJ_OTYPER_OT2, 1 << 2   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOJ_OTYPER_OT3, 1 << 3   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOJ_OTYPER_OT4, 1 << 4   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOJ_OTYPER_OT5, 1 << 5   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOJ_OTYPER_OT6, 1 << 6   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOJ_OTYPER_OT7, 1 << 7   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOJ_OTYPER_OT8, 1 << 8   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOJ_OTYPER_OT9, 1 << 9   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOJ_OTYPER_OT10, 1 << 10   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOJ_OTYPER_OT11, 1 << 11   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOJ_OTYPER_OT12, 1 << 12   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOJ_OTYPER_OT13, 1 << 13   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOJ_OTYPER_OT14, 1 << 14   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOJ_OTYPER_OT15, 1 << 15   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
 
    .equ GPIOJ_OSPEEDR, GPIOJ_BASE + 0x8 @ (GPIO port output speed  register) 
        .equ GPIOJ_OSPEEDR_OSPEED0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOJ_OSPEEDR_OSPEED1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOJ_OSPEEDR_OSPEED2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOJ_OSPEEDR_OSPEED3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOJ_OSPEEDR_OSPEED4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOJ_OSPEEDR_OSPEED5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOJ_OSPEEDR_OSPEED6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOJ_OSPEEDR_OSPEED7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOJ_OSPEEDR_OSPEED8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOJ_OSPEEDR_OSPEED9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOJ_OSPEEDR_OSPEED10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOJ_OSPEEDR_OSPEED11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOJ_OSPEEDR_OSPEED12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOJ_OSPEEDR_OSPEED13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOJ_OSPEEDR_OSPEED14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOJ_OSPEEDR_OSPEED15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
 
    .equ GPIOJ_PUPDR, GPIOJ_BASE + 0xC @ (GPIO port pull-up/pull-down  register) 
        .equ GPIOJ_PUPDR_PUPD0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOJ_PUPDR_PUPD1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOJ_PUPDR_PUPD2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOJ_PUPDR_PUPD3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOJ_PUPDR_PUPD4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOJ_PUPDR_PUPD5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOJ_PUPDR_PUPD6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOJ_PUPDR_PUPD7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOJ_PUPDR_PUPD8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOJ_PUPDR_PUPD9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOJ_PUPDR_PUPD10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOJ_PUPDR_PUPD11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOJ_PUPDR_PUPD12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOJ_PUPDR_PUPD13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOJ_PUPDR_PUPD14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOJ_PUPDR_PUPD15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
 
    .equ GPIOJ_IDR, GPIOJ_BASE + 0x10 @ (GPIO port input data register) 
        .equ GPIOJ_IDR_ID0, 1 << 0   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOJ_IDR_ID1, 1 << 1   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOJ_IDR_ID2, 1 << 2   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOJ_IDR_ID3, 1 << 3   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOJ_IDR_ID4, 1 << 4   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOJ_IDR_ID5, 1 << 5   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOJ_IDR_ID6, 1 << 6   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOJ_IDR_ID7, 1 << 7   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOJ_IDR_ID8, 1 << 8   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOJ_IDR_ID9, 1 << 9   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOJ_IDR_ID10, 1 << 10   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOJ_IDR_ID11, 1 << 11   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOJ_IDR_ID12, 1 << 12   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOJ_IDR_ID13, 1 << 13   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOJ_IDR_ID14, 1 << 14   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOJ_IDR_ID15, 1 << 15   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
 
    .equ GPIOJ_ODR, GPIOJ_BASE + 0x14 @ (GPIO port output data register) 
        .equ GPIOJ_ODR_OD0, 1 << 0   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOJ_ODR_OD1, 1 << 1   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOJ_ODR_OD2, 1 << 2   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOJ_ODR_OD3, 1 << 3   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOJ_ODR_OD4, 1 << 4   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOJ_ODR_OD5, 1 << 5   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOJ_ODR_OD6, 1 << 6   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOJ_ODR_OD7, 1 << 7   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOJ_ODR_OD8, 1 << 8   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOJ_ODR_OD9, 1 << 9   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOJ_ODR_OD10, 1 << 10   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOJ_ODR_OD11, 1 << 11   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOJ_ODR_OD12, 1 << 12   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOJ_ODR_OD13, 1 << 13   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOJ_ODR_OD14, 1 << 14   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOJ_ODR_OD15, 1 << 15   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
 
    .equ GPIOJ_BSRR, GPIOJ_BASE + 0x18 @ (GPIO port bit set/reset  register) 
        .equ GPIOJ_BSRR_BS0, 1 << 0   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOJ_BSRR_BS1, 1 << 1   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOJ_BSRR_BS2, 1 << 2   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOJ_BSRR_BS3, 1 << 3   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOJ_BSRR_BS4, 1 << 4   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOJ_BSRR_BS5, 1 << 5   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOJ_BSRR_BS6, 1 << 6   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOJ_BSRR_BS7, 1 << 7   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOJ_BSRR_BS8, 1 << 8   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOJ_BSRR_BS9, 1 << 9   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOJ_BSRR_BS10, 1 << 10   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOJ_BSRR_BS11, 1 << 11   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOJ_BSRR_BS12, 1 << 12   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOJ_BSRR_BS13, 1 << 13   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOJ_BSRR_BS14, 1 << 14   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOJ_BSRR_BS15, 1 << 15   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOJ_BSRR_BR0, 1 << 16   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOJ_BSRR_BR1, 1 << 17   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOJ_BSRR_BR2, 1 << 18   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOJ_BSRR_BR3, 1 << 19   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOJ_BSRR_BR4, 1 << 20   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOJ_BSRR_BR5, 1 << 21   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOJ_BSRR_BR6, 1 << 22   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOJ_BSRR_BR7, 1 << 23   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOJ_BSRR_BR8, 1 << 24   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOJ_BSRR_BR9, 1 << 25   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOJ_BSRR_BR10, 1 << 26   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOJ_BSRR_BR11, 1 << 27   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOJ_BSRR_BR12, 1 << 28   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOJ_BSRR_BR13, 1 << 29   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOJ_BSRR_BR14, 1 << 30   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOJ_BSRR_BR15, 1 << 31   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
 
    .equ GPIOJ_LCKR, GPIOJ_BASE + 0x1C @ (This register is used to lock the  configuration of the port bits when a correct write  sequence is applied to bit 16 LCKK. The value of bits  [15:0] is used to lock the configuration of the GPIO.  During the write sequence, the value of LCKR[15:0] must  not change. When the LOCK sequence has been applied on a  port bit, the value of this port bit can no longer be  modified until the next MCU reset or peripheral reset.A  specific write sequence is used to write to the  GPIOx_LCKR register. Only word access 32-bit long is  allowed during this locking sequence.Each lock bit  freezes a specific configuration register control and  alternate function registers.) 
        .equ GPIOJ_LCKR_LCK0, 1 << 0   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOJ_LCKR_LCK1, 1 << 1   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOJ_LCKR_LCK2, 1 << 2   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOJ_LCKR_LCK3, 1 << 3   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOJ_LCKR_LCK4, 1 << 4   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOJ_LCKR_LCK5, 1 << 5   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOJ_LCKR_LCK6, 1 << 6   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOJ_LCKR_LCK7, 1 << 7   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOJ_LCKR_LCK8, 1 << 8   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOJ_LCKR_LCK9, 1 << 9   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOJ_LCKR_LCK10, 1 << 10   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOJ_LCKR_LCK11, 1 << 11   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOJ_LCKR_LCK12, 1 << 12   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOJ_LCKR_LCK13, 1 << 13   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOJ_LCKR_LCK14, 1 << 14   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOJ_LCKR_LCK15, 1 << 15   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOJ_LCKR_LCKK, 1 << 16   @ bitWidth 1 (Lock key This bit can be read any time.  It can only be modified using the lock key write  sequence. LOCK key write sequence: WR LCKR[16] = 1 +  LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] =  1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 this read  operation is optional but it confirms that the lock  is active Note: During the LOCK key write sequence,  the value of LCK[15:0] must not change. Any error in  the lock sequence aborts the lock. After the first  lock sequence on any bit of the port, any read access  on the LCKK bit will return 1 until the next MCU  reset or peripheral reset.)  
 
    .equ GPIOJ_AFRL, GPIOJ_BASE + 0x20 @ (GPIO alternate function low  register) 
        .equ GPIOJ_AFRL_AFSEL0_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOJ_AFRL_AFSEL1_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOJ_AFRL_AFSEL2_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOJ_AFRL_AFSEL3_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOJ_AFRL_AFSEL4_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOJ_AFRL_AFSEL5_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOJ_AFRL_AFSEL6_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOJ_AFRL_AFSEL7_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
 
    .equ GPIOJ_AFRH, GPIOJ_BASE + 0x24 @ (GPIO alternate function high  register) 
        .equ GPIOJ_AFRH_AFSEL8_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOJ_AFRH_AFSEL9_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOJ_AFRH_AFSEL10_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOJ_AFRH_AFSEL11_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOJ_AFRH_AFSEL12_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOJ_AFRH_AFSEL13_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOJ_AFRH_AFSEL14_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOJ_AFRH_AFSEL15_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
 

@=========================== GPIOK ===========================@
.equ GPIOK_BASE, 0x58022800 @ (GPIO) 
    .equ GPIOK_MODER, GPIOK_BASE + 0x0 @ (GPIO port mode register) 
        .equ GPIOK_MODER_MODE0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOK_MODER_MODE1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOK_MODER_MODE2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOK_MODER_MODE3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOK_MODER_MODE4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOK_MODER_MODE5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOK_MODER_MODE6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOK_MODER_MODE7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOK_MODER_MODE8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOK_MODER_MODE9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOK_MODER_MODE10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOK_MODER_MODE11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOK_MODER_MODE12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOK_MODER_MODE13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOK_MODER_MODE14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
        .equ GPIOK_MODER_MODE15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O mode.)  
 
    .equ GPIOK_OTYPER, GPIOK_BASE + 0x4 @ (GPIO port output type register) 
        .equ GPIOK_OTYPER_OT0, 1 << 0   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOK_OTYPER_OT1, 1 << 1   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOK_OTYPER_OT2, 1 << 2   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOK_OTYPER_OT3, 1 << 3   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOK_OTYPER_OT4, 1 << 4   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOK_OTYPER_OT5, 1 << 5   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOK_OTYPER_OT6, 1 << 6   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOK_OTYPER_OT7, 1 << 7   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOK_OTYPER_OT8, 1 << 8   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOK_OTYPER_OT9, 1 << 9   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOK_OTYPER_OT10, 1 << 10   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOK_OTYPER_OT11, 1 << 11   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOK_OTYPER_OT12, 1 << 12   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOK_OTYPER_OT13, 1 << 13   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOK_OTYPER_OT14, 1 << 14   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
        .equ GPIOK_OTYPER_OT15, 1 << 15   @ bitWidth 1 (Port x configuration bits y = 0..15  These bits are written by software to configure the  I/O output type.)  
 
    .equ GPIOK_OSPEEDR, GPIOK_BASE + 0x8 @ (GPIO port output speed  register) 
        .equ GPIOK_OSPEEDR_OSPEED0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOK_OSPEEDR_OSPEED1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOK_OSPEEDR_OSPEED2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOK_OSPEEDR_OSPEED3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOK_OSPEEDR_OSPEED4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOK_OSPEEDR_OSPEED5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOK_OSPEEDR_OSPEED6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOK_OSPEEDR_OSPEED7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOK_OSPEEDR_OSPEED8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOK_OSPEEDR_OSPEED9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOK_OSPEEDR_OSPEED10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOK_OSPEEDR_OSPEED11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOK_OSPEEDR_OSPEED12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOK_OSPEEDR_OSPEED13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOK_OSPEEDR_OSPEED14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
        .equ GPIOK_OSPEEDR_OSPEED15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O output speed. Note: Refer to the  device datasheet for the frequency specifications and  the power supply and load conditions for each  speed.)  
 
    .equ GPIOK_PUPDR, GPIOK_BASE + 0xC @ (GPIO port pull-up/pull-down  register) 
        .equ GPIOK_PUPDR_PUPD0_Shift, 0   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOK_PUPDR_PUPD1_Shift, 2   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOK_PUPDR_PUPD2_Shift, 4   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOK_PUPDR_PUPD3_Shift, 6   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOK_PUPDR_PUPD4_Shift, 8   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOK_PUPDR_PUPD5_Shift, 10   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOK_PUPDR_PUPD6_Shift, 12   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOK_PUPDR_PUPD7_Shift, 14   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOK_PUPDR_PUPD8_Shift, 16   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOK_PUPDR_PUPD9_Shift, 18   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOK_PUPDR_PUPD10_Shift, 20   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOK_PUPDR_PUPD11_Shift, 22   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOK_PUPDR_PUPD12_Shift, 24   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOK_PUPDR_PUPD13_Shift, 26   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOK_PUPDR_PUPD14_Shift, 28   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
        .equ GPIOK_PUPDR_PUPD15_Shift, 30   @ bitWidth 2 ([1:0]: Port x configuration bits y =  0..15 These bits are written by software to  configure the I/O pull-up or pull-down)  
 
    .equ GPIOK_IDR, GPIOK_BASE + 0x10 @ (GPIO port input data register) 
        .equ GPIOK_IDR_ID0, 1 << 0   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOK_IDR_ID1, 1 << 1   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOK_IDR_ID2, 1 << 2   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOK_IDR_ID3, 1 << 3   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOK_IDR_ID4, 1 << 4   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOK_IDR_ID5, 1 << 5   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOK_IDR_ID6, 1 << 6   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOK_IDR_ID7, 1 << 7   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOK_IDR_ID8, 1 << 8   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOK_IDR_ID9, 1 << 9   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOK_IDR_ID10, 1 << 10   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOK_IDR_ID11, 1 << 11   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOK_IDR_ID12, 1 << 12   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOK_IDR_ID13, 1 << 13   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOK_IDR_ID14, 1 << 14   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
        .equ GPIOK_IDR_ID15, 1 << 15   @ bitWidth 1 (Port input data bit y = 0..15 These  bits are read-only. They contain the input value of  the corresponding I/O port.)  
 
    .equ GPIOK_ODR, GPIOK_BASE + 0x14 @ (GPIO port output data register) 
        .equ GPIOK_ODR_OD0, 1 << 0   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOK_ODR_OD1, 1 << 1   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOK_ODR_OD2, 1 << 2   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOK_ODR_OD3, 1 << 3   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOK_ODR_OD4, 1 << 4   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOK_ODR_OD5, 1 << 5   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOK_ODR_OD6, 1 << 6   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOK_ODR_OD7, 1 << 7   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOK_ODR_OD8, 1 << 8   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOK_ODR_OD9, 1 << 9   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOK_ODR_OD10, 1 << 10   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOK_ODR_OD11, 1 << 11   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOK_ODR_OD12, 1 << 12   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOK_ODR_OD13, 1 << 13   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOK_ODR_OD14, 1 << 14   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
        .equ GPIOK_ODR_OD15, 1 << 15   @ bitWidth 1 (Port output data bit These bits can be  read and written by software. Note: For atomic bit  set/reset, the OD bits can be individually set and/or  reset by writing to the GPIOx_BSRR or GPIOx_BRR  registers x = A..F.)  
 
    .equ GPIOK_BSRR, GPIOK_BASE + 0x18 @ (GPIO port bit set/reset  register) 
        .equ GPIOK_BSRR_BS0, 1 << 0   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOK_BSRR_BS1, 1 << 1   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOK_BSRR_BS2, 1 << 2   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOK_BSRR_BS3, 1 << 3   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOK_BSRR_BS4, 1 << 4   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOK_BSRR_BS5, 1 << 5   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOK_BSRR_BS6, 1 << 6   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOK_BSRR_BS7, 1 << 7   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOK_BSRR_BS8, 1 << 8   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOK_BSRR_BS9, 1 << 9   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOK_BSRR_BS10, 1 << 10   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOK_BSRR_BS11, 1 << 11   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOK_BSRR_BS12, 1 << 12   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOK_BSRR_BS13, 1 << 13   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOK_BSRR_BS14, 1 << 14   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOK_BSRR_BS15, 1 << 15   @ bitWidth 1 (Port x set bit y y= 0..15 These bits  are write-only. A read to these bits returns the  value 0x0000.)  
        .equ GPIOK_BSRR_BR0, 1 << 16   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOK_BSRR_BR1, 1 << 17   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOK_BSRR_BR2, 1 << 18   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOK_BSRR_BR3, 1 << 19   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOK_BSRR_BR4, 1 << 20   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOK_BSRR_BR5, 1 << 21   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOK_BSRR_BR6, 1 << 22   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOK_BSRR_BR7, 1 << 23   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOK_BSRR_BR8, 1 << 24   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOK_BSRR_BR9, 1 << 25   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOK_BSRR_BR10, 1 << 26   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOK_BSRR_BR11, 1 << 27   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOK_BSRR_BR12, 1 << 28   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOK_BSRR_BR13, 1 << 29   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOK_BSRR_BR14, 1 << 30   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
        .equ GPIOK_BSRR_BR15, 1 << 31   @ bitWidth 1 (Port x reset bit y y = 0..15 These  bits are write-only. A read to these bits returns the  value 0x0000. Note: If both BSx and BRx are set, BSx  has priority.)  
 
    .equ GPIOK_LCKR, GPIOK_BASE + 0x1C @ (This register is used to lock the  configuration of the port bits when a correct write  sequence is applied to bit 16 LCKK. The value of bits  [15:0] is used to lock the configuration of the GPIO.  During the write sequence, the value of LCKR[15:0] must  not change. When the LOCK sequence has been applied on a  port bit, the value of this port bit can no longer be  modified until the next MCU reset or peripheral reset.A  specific write sequence is used to write to the  GPIOx_LCKR register. Only word access 32-bit long is  allowed during this locking sequence.Each lock bit  freezes a specific configuration register control and  alternate function registers.) 
        .equ GPIOK_LCKR_LCK0, 1 << 0   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOK_LCKR_LCK1, 1 << 1   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOK_LCKR_LCK2, 1 << 2   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOK_LCKR_LCK3, 1 << 3   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOK_LCKR_LCK4, 1 << 4   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOK_LCKR_LCK5, 1 << 5   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOK_LCKR_LCK6, 1 << 6   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOK_LCKR_LCK7, 1 << 7   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOK_LCKR_LCK8, 1 << 8   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOK_LCKR_LCK9, 1 << 9   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOK_LCKR_LCK10, 1 << 10   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOK_LCKR_LCK11, 1 << 11   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOK_LCKR_LCK12, 1 << 12   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOK_LCKR_LCK13, 1 << 13   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOK_LCKR_LCK14, 1 << 14   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOK_LCKR_LCK15, 1 << 15   @ bitWidth 1 (Port x lock bit y y= 0..15 These bits  are read/write but can only be written when the LCKK  bit is 0.)  
        .equ GPIOK_LCKR_LCKK, 1 << 16   @ bitWidth 1 (Lock key This bit can be read any time.  It can only be modified using the lock key write  sequence. LOCK key write sequence: WR LCKR[16] = 1 +  LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] =  1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 this read  operation is optional but it confirms that the lock  is active Note: During the LOCK key write sequence,  the value of LCK[15:0] must not change. Any error in  the lock sequence aborts the lock. After the first  lock sequence on any bit of the port, any read access  on the LCKK bit will return 1 until the next MCU  reset or peripheral reset.)  
 
    .equ GPIOK_AFRL, GPIOK_BASE + 0x20 @ (GPIO alternate function low  register) 
        .equ GPIOK_AFRL_AFSEL0_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOK_AFRL_AFSEL1_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOK_AFRL_AFSEL2_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOK_AFRL_AFSEL3_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOK_AFRL_AFSEL4_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOK_AFRL_AFSEL5_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOK_AFRL_AFSEL6_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
        .equ GPIOK_AFRL_AFSEL7_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 0..7 These bits are written by  software to configure alternate function I/Os AFSELy  selection:)  
 
    .equ GPIOK_AFRH, GPIOK_BASE + 0x24 @ (GPIO alternate function high  register) 
        .equ GPIOK_AFRH_AFSEL8_Shift, 0   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOK_AFRH_AFSEL9_Shift, 4   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOK_AFRH_AFSEL10_Shift, 8   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOK_AFRH_AFSEL11_Shift, 12   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOK_AFRH_AFSEL12_Shift, 16   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOK_AFRH_AFSEL13_Shift, 20   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOK_AFRH_AFSEL14_Shift, 24   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
        .equ GPIOK_AFRH_AFSEL15_Shift, 28   @ bitWidth 4 ([3:0]: Alternate function selection for  port x pin y y = 8..15 These bits are written by  software to configure alternate function  I/Os)  
 

@=========================== JPEG ===========================@
.equ JPEG_BASE, 0x52003000 @ (JPEG) 
    .equ JPEG_CONFR0, JPEG_BASE + 0x0 @ (JPEG codec control register) 
        .equ JPEG_CONFR0_START, 1 << 0   @ bitWidth 1 (Start This bit start or stop the  encoding or decoding process. Read this register  always return 0.)  
 
    .equ JPEG_CONFR1, JPEG_BASE + 0x4 @ (JPEG codec configuration register  1) 
        .equ JPEG_CONFR1_NF_Shift, 0   @ bitWidth 2 (Number of color components This field  defines the number of color components minus  1.)  
        .equ JPEG_CONFR1_DE, 1 << 3   @ bitWidth 1 (Decoding Enable This bit selects the  coding or decoding process)  
        .equ JPEG_CONFR1_COLORSPACE_Shift, 4   @ bitWidth 2 (Color Space This filed defines the  number of quantization tables minus 1 to insert in  the output stream.)  
        .equ JPEG_CONFR1_NS_Shift, 6   @ bitWidth 2 (Number of components for Scan This field  defines the number of components minus 1 for scan  header marker segment.)  
        .equ JPEG_CONFR1_HDR, 1 << 8   @ bitWidth 1 (Header Processing This bit enable the  header processing generation/parsing.)  
        .equ JPEG_CONFR1_YSIZE_Shift, 16   @ bitWidth 16 (Y Size This field defines the number of  lines in source image.)  
 
    .equ JPEG_CONFR2, JPEG_BASE + 0x8 @ (JPEG codec configuration register  2) 
        .equ JPEG_CONFR2_NMCU_Shift, 0   @ bitWidth 26 (Number of MCU For encoding: this field  defines the number of MCU units minus 1 to encode.  For decoding: this field indicates the number of  complete MCU units minus 1 to be decoded this field  is updated after the JPEG header parsing. If the  decoded image size has not a X or Y size multiple of  8 or 16 depending on the sub-sampling process, the  resulting incomplete or empty MCU must be added to  this value to get the total number of MCU  generated.)  
 
    .equ JPEG_CONFR3, JPEG_BASE + 0xC @ (JPEG codec configuration register  3) 
        .equ JPEG_CONFR3_XSIZE_Shift, 16   @ bitWidth 16 (X size This field defines the number of  pixels per line.)  
 
    .equ JPEG_CONFRN1, JPEG_BASE + 0x10 @ (JPEG codec configuration register  4-7) 
        .equ JPEG_CONFRN1_HD, 1 << 0   @ bitWidth 1 (Huffman DC Selects the Huffman table for  encoding the DC coefficients.)  
        .equ JPEG_CONFRN1_HA, 1 << 1   @ bitWidth 1 (Huffman AC Selects the Huffman table for  encoding the AC coefficients.)  
        .equ JPEG_CONFRN1_QT_Shift, 2   @ bitWidth 2 (Quantization Table Selects quantization  table associated with a color  component.)  
        .equ JPEG_CONFRN1_NB_Shift, 4   @ bitWidth 4 (Number of Block Number of data units  minus 1 that belong to a particular color in the  MCU.)  
        .equ JPEG_CONFRN1_VSF_Shift, 8   @ bitWidth 4 (Vertical Sampling Factor Vertical  sampling factor for component i.)  
        .equ JPEG_CONFRN1_HSF_Shift, 12   @ bitWidth 4 (Horizontal Sampling Factor Horizontal  sampling factor for component i.)  
 
    .equ JPEG_CONFRN2, JPEG_BASE + 0x14 @ (JPEG codec configuration register  4-7) 
        .equ JPEG_CONFRN2_HD, 1 << 0   @ bitWidth 1 (Huffman DC Selects the Huffman table for  encoding the DC coefficients.)  
        .equ JPEG_CONFRN2_HA, 1 << 1   @ bitWidth 1 (Huffman AC Selects the Huffman table for  encoding the AC coefficients.)  
        .equ JPEG_CONFRN2_QT_Shift, 2   @ bitWidth 2 (Quantization Table Selects quantization  table associated with a color  component.)  
        .equ JPEG_CONFRN2_NB_Shift, 4   @ bitWidth 4 (Number of Block Number of data units  minus 1 that belong to a particular color in the  MCU.)  
        .equ JPEG_CONFRN2_VSF_Shift, 8   @ bitWidth 4 (Vertical Sampling Factor Vertical  sampling factor for component i.)  
        .equ JPEG_CONFRN2_HSF_Shift, 12   @ bitWidth 4 (Horizontal Sampling Factor Horizontal  sampling factor for component i.)  
 
    .equ JPEG_CONFRN3, JPEG_BASE + 0x18 @ (JPEG codec configuration register  4-7) 
        .equ JPEG_CONFRN3_HD, 1 << 0   @ bitWidth 1 (Huffman DC Selects the Huffman table for  encoding the DC coefficients.)  
        .equ JPEG_CONFRN3_HA, 1 << 1   @ bitWidth 1 (Huffman AC Selects the Huffman table for  encoding the AC coefficients.)  
        .equ JPEG_CONFRN3_QT_Shift, 2   @ bitWidth 2 (Quantization Table Selects quantization  table associated with a color  component.)  
        .equ JPEG_CONFRN3_NB_Shift, 4   @ bitWidth 4 (Number of Block Number of data units  minus 1 that belong to a particular color in the  MCU.)  
        .equ JPEG_CONFRN3_VSF_Shift, 8   @ bitWidth 4 (Vertical Sampling Factor Vertical  sampling factor for component i.)  
        .equ JPEG_CONFRN3_HSF_Shift, 12   @ bitWidth 4 (Horizontal Sampling Factor Horizontal  sampling factor for component i.)  
 
    .equ JPEG_CONFRN4, JPEG_BASE + 0x1C @ (JPEG codec configuration register  4-7) 
        .equ JPEG_CONFRN4_HD, 1 << 0   @ bitWidth 1 (Huffman DC Selects the Huffman table for  encoding the DC coefficients.)  
        .equ JPEG_CONFRN4_HA, 1 << 1   @ bitWidth 1 (Huffman AC Selects the Huffman table for  encoding the AC coefficients.)  
        .equ JPEG_CONFRN4_QT_Shift, 2   @ bitWidth 2 (Quantization Table Selects quantization  table associated with a color  component.)  
        .equ JPEG_CONFRN4_NB_Shift, 4   @ bitWidth 4 (Number of Block Number of data units  minus 1 that belong to a particular color in the  MCU.)  
        .equ JPEG_CONFRN4_VSF_Shift, 8   @ bitWidth 4 (Vertical Sampling Factor Vertical  sampling factor for component i.)  
        .equ JPEG_CONFRN4_HSF_Shift, 12   @ bitWidth 4 (Horizontal Sampling Factor Horizontal  sampling factor for component i.)  
 
    .equ JPEG_CR, JPEG_BASE + 0x30 @ (JPEG control register) 
        .equ JPEG_CR_JCEN, 1 << 0   @ bitWidth 1 (JPEG Core Enable Enable the JPEG codec  Core.)  
        .equ JPEG_CR_IFTIE, 1 << 1   @ bitWidth 1 (Input FIFO Threshold Interrupt Enable  This bit enables the interrupt generation when input  FIFO reach the threshold.)  
        .equ JPEG_CR_IFNFIE, 1 << 2   @ bitWidth 1 (Input FIFO Not Full Interrupt Enable  This bit enables the interrupt generation when input  FIFO is not empty.)  
        .equ JPEG_CR_OFTIE, 1 << 3   @ bitWidth 1 (Output FIFO Threshold Interrupt Enable  This bit enables the interrupt generation when output  FIFO reach the threshold.)  
        .equ JPEG_CR_OFNEIE, 1 << 4   @ bitWidth 1 (Output FIFO Not Empty Interrupt Enable  This bit enables the interrupt generation when output  FIFO is not empty.)  
        .equ JPEG_CR_EOCIE, 1 << 5   @ bitWidth 1 (End of Conversion Interrupt Enable This  bit enables the interrupt generation on the end of  conversion.)  
        .equ JPEG_CR_HPDIE, 1 << 6   @ bitWidth 1 (Header Parsing Done Interrupt Enable  This bit enables the interrupt generation on the  Header Parsing Operation.)  
        .equ JPEG_CR_IDMAEN, 1 << 11   @ bitWidth 1 (Input DMA Enable Enable the DMA request  generation for the input FIFO.)  
        .equ JPEG_CR_ODMAEN, 1 << 12   @ bitWidth 1 (Output DMA Enable Enable the DMA request  generation for the output FIFO.)  
        .equ JPEG_CR_IFF, 1 << 13   @ bitWidth 1 (Input FIFO Flush This bit flush the  input FIFO. This bit is always read as  0.)  
        .equ JPEG_CR_OFF, 1 << 14   @ bitWidth 1 (Output FIFO Flush This bit flush the  output FIFO. This bit is always read as  0.)  
 
    .equ JPEG_SR, JPEG_BASE + 0x34 @ (JPEG status register) 
        .equ JPEG_SR_IFTF, 1 << 1   @ bitWidth 1 (Input FIFO Threshold Flag This bit is  set when the input FIFO is not full and is bellow its  threshold.)  
        .equ JPEG_SR_IFNFF, 1 << 2   @ bitWidth 1 (Input FIFO Not Full Flag This bit is set  when the input FIFO is not full a data can be  written.)  
        .equ JPEG_SR_OFTF, 1 << 3   @ bitWidth 1 (Output FIFO Threshold Flag This bit is  set when the output FIFO is not empty and has reach  its threshold.)  
        .equ JPEG_SR_OFNEF, 1 << 4   @ bitWidth 1 (Output FIFO Not Empty Flag This bit is  set when the output FIFO is not empty a data is  available.)  
        .equ JPEG_SR_EOCF, 1 << 5   @ bitWidth 1 (End of Conversion Flag This bit is set  when the JPEG codec core has finished the encoding or  the decoding process and than last data has been sent  to the output FIFO.)  
        .equ JPEG_SR_HPDF, 1 << 6   @ bitWidth 1 (Header Parsing Done Flag This bit is set  in decode mode when the JPEG codec has finished the  parsing of the headers and the internal registers  have been updated.)  
        .equ JPEG_SR_COF, 1 << 7   @ bitWidth 1 (Codec Operation Flag This bit is set  when when a JPEG codec operation is on going  encoding or decoding.)  
 
    .equ JPEG_CFR, JPEG_BASE + 0x38 @ (JPEG clear flag register) 
        .equ JPEG_CFR_CEOCF, 1 << 5   @ bitWidth 1 (Clear End of Conversion Flag Writing 1  clears the End of Conversion Flag of the JPEG Status  Register.)  
        .equ JPEG_CFR_CHPDF, 1 << 6   @ bitWidth 1 (Clear Header Parsing Done Flag Writing 1  clears the Header Parsing Done Flag of the JPEG  Status Register.)  
 
    .equ JPEG_DIR, JPEG_BASE + 0x40 @ (JPEG data input register) 
        .equ JPEG_DIR_DATAIN_Shift, 0   @ bitWidth 32 (Data Input FIFO Input FIFO data  register.)  
 
    .equ JPEG_DOR, JPEG_BASE + 0x44 @ (JPEG data output register) 
        .equ JPEG_DOR_DATAOUT_Shift, 0   @ bitWidth 32 (Data Output FIFO Output FIFO data  register.)  
 

@=========================== MDMA ===========================@
.equ MDMA_BASE, 0x52000000 @ (MDMA) 
    .equ MDMA_MDMA_GISR0, MDMA_BASE + 0x0 @ (MDMA Global Interrupt/Status  Register) 
        .equ MDMA_MDMA_GISR0_GIF0, 1 << 0   @ bitWidth 1 (Channel x global interrupt flag x=...  This bit is set and reset by hardware. It is a  logical OR of all the Channel x interrupt flags  CTCIFx, BTIFx, BRTIFx, TEIFx which are enabled in  the interrupt mask register CTCIEx, BTIEx, BRTIEx,  TEIEx)  
        .equ MDMA_MDMA_GISR0_GIF1, 1 << 1   @ bitWidth 1 (Channel x global interrupt flag x=...  This bit is set and reset by hardware. It is a  logical OR of all the Channel x interrupt flags  CTCIFx, BTIFx, BRTIFx, TEIFx which are enabled in  the interrupt mask register CTCIEx, BTIEx, BRTIEx,  TEIEx)  
        .equ MDMA_MDMA_GISR0_GIF2, 1 << 2   @ bitWidth 1 (Channel x global interrupt flag x=...  This bit is set and reset by hardware. It is a  logical OR of all the Channel x interrupt flags  CTCIFx, BTIFx, BRTIFx, TEIFx which are enabled in  the interrupt mask register CTCIEx, BTIEx, BRTIEx,  TEIEx)  
        .equ MDMA_MDMA_GISR0_GIF3, 1 << 3   @ bitWidth 1 (Channel x global interrupt flag x=...  This bit is set and reset by hardware. It is a  logical OR of all the Channel x interrupt flags  CTCIFx, BTIFx, BRTIFx, TEIFx which are enabled in  the interrupt mask register CTCIEx, BTIEx, BRTIEx,  TEIEx)  
        .equ MDMA_MDMA_GISR0_GIF4, 1 << 4   @ bitWidth 1 (Channel x global interrupt flag x=...  This bit is set and reset by hardware. It is a  logical OR of all the Channel x interrupt flags  CTCIFx, BTIFx, BRTIFx, TEIFx which are enabled in  the interrupt mask register CTCIEx, BTIEx, BRTIEx,  TEIEx)  
        .equ MDMA_MDMA_GISR0_GIF5, 1 << 5   @ bitWidth 1 (Channel x global interrupt flag x=...  This bit is set and reset by hardware. It is a  logical OR of all the Channel x interrupt flags  CTCIFx, BTIFx, BRTIFx, TEIFx which are enabled in  the interrupt mask register CTCIEx, BTIEx, BRTIEx,  TEIEx)  
        .equ MDMA_MDMA_GISR0_GIF6, 1 << 6   @ bitWidth 1 (Channel x global interrupt flag x=...  This bit is set and reset by hardware. It is a  logical OR of all the Channel x interrupt flags  CTCIFx, BTIFx, BRTIFx, TEIFx which are enabled in  the interrupt mask register CTCIEx, BTIEx, BRTIEx,  TEIEx)  
        .equ MDMA_MDMA_GISR0_GIF7, 1 << 7   @ bitWidth 1 (Channel x global interrupt flag x=...  This bit is set and reset by hardware. It is a  logical OR of all the Channel x interrupt flags  CTCIFx, BTIFx, BRTIFx, TEIFx which are enabled in  the interrupt mask register CTCIEx, BTIEx, BRTIEx,  TEIEx)  
        .equ MDMA_MDMA_GISR0_GIF8, 1 << 8   @ bitWidth 1 (Channel x global interrupt flag x=...  This bit is set and reset by hardware. It is a  logical OR of all the Channel x interrupt flags  CTCIFx, BTIFx, BRTIFx, TEIFx which are enabled in  the interrupt mask register CTCIEx, BTIEx, BRTIEx,  TEIEx)  
        .equ MDMA_MDMA_GISR0_GIF9, 1 << 9   @ bitWidth 1 (Channel x global interrupt flag x=...  This bit is set and reset by hardware. It is a  logical OR of all the Channel x interrupt flags  CTCIFx, BTIFx, BRTIFx, TEIFx which are enabled in  the interrupt mask register CTCIEx, BTIEx, BRTIEx,  TEIEx)  
        .equ MDMA_MDMA_GISR0_GIF10, 1 << 10   @ bitWidth 1 (Channel x global interrupt flag x=...  This bit is set and reset by hardware. It is a  logical OR of all the Channel x interrupt flags  CTCIFx, BTIFx, BRTIFx, TEIFx which are enabled in  the interrupt mask register CTCIEx, BTIEx, BRTIEx,  TEIEx)  
        .equ MDMA_MDMA_GISR0_GIF11, 1 << 11   @ bitWidth 1 (Channel x global interrupt flag x=...  This bit is set and reset by hardware. It is a  logical OR of all the Channel x interrupt flags  CTCIFx, BTIFx, BRTIFx, TEIFx which are enabled in  the interrupt mask register CTCIEx, BTIEx, BRTIEx,  TEIEx)  
        .equ MDMA_MDMA_GISR0_GIF12, 1 << 12   @ bitWidth 1 (Channel x global interrupt flag x=...  This bit is set and reset by hardware. It is a  logical OR of all the Channel x interrupt flags  CTCIFx, BTIFx, BRTIFx, TEIFx which are enabled in  the interrupt mask register CTCIEx, BTIEx, BRTIEx,  TEIEx)  
        .equ MDMA_MDMA_GISR0_GIF13, 1 << 13   @ bitWidth 1 (Channel x global interrupt flag x=...  This bit is set and reset by hardware. It is a  logical OR of all the Channel x interrupt flags  CTCIFx, BTIFx, BRTIFx, TEIFx which are enabled in  the interrupt mask register CTCIEx, BTIEx, BRTIEx,  TEIEx)  
        .equ MDMA_MDMA_GISR0_GIF14, 1 << 14   @ bitWidth 1 (Channel x global interrupt flag x=...  This bit is set and reset by hardware. It is a  logical OR of all the Channel x interrupt flags  CTCIFx, BTIFx, BRTIFx, TEIFx which are enabled in  the interrupt mask register CTCIEx, BTIEx, BRTIEx,  TEIEx)  
        .equ MDMA_MDMA_GISR0_GIF15, 1 << 15   @ bitWidth 1 (Channel x global interrupt flag x=...  This bit is set and reset by hardware. It is a  logical OR of all the Channel x interrupt flags  CTCIFx, BTIFx, BRTIFx, TEIFx which are enabled in  the interrupt mask register CTCIEx, BTIEx, BRTIEx,  TEIEx)  
 
    .equ MDMA_MDMA_C0ISR, MDMA_BASE + 0x40 @ (MDMA channel x interrupt/status  register) 
        .equ MDMA_MDMA_C0ISR_TEIF0, 1 << 0   @ bitWidth 1 (Channel x transfer error interrupt flag  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCRy register.)  
        .equ MDMA_MDMA_C0ISR_CTCIF0, 1 << 1   @ bitWidth 1 (Channel x Channel Transfer Complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register. CTC is set when the  last block was transferred and the channel has been  automatically disabled. CTC is also set when the  channel is suspended, as a result of writing EN bit  to 0.)  
        .equ MDMA_MDMA_C0ISR_BRTIF0, 1 << 2   @ bitWidth 1 (Channel x block repeat transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C0ISR_BTIF0, 1 << 3   @ bitWidth 1 (Channel x block transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C0ISR_TCIF0, 1 << 4   @ bitWidth 1 (channel x buffer transfer  complete)  
        .equ MDMA_MDMA_C0ISR_CRQA0, 1 << 16   @ bitWidth 1 (channel x request active  flag)  
 
    .equ MDMA_MDMA_C0IFCR, MDMA_BASE + 0x44 @ (MDMA channel x interrupt flag clear  register) 
        .equ MDMA_MDMA_C0IFCR_CTEIF0, 1 << 0   @ bitWidth 1 (Channel x clear transfer error interrupt  flag Writing a 1 into this bit clears TEIFx in the  MDMA_ISRy register)  
        .equ MDMA_MDMA_C0IFCR_CCTCIF0, 1 << 1   @ bitWidth 1 (Clear Channel transfer complete  interrupt flag for channel x Writing a 1 into this  bit clears CTCIFx in the MDMA_ISRy  register)  
        .equ MDMA_MDMA_C0IFCR_CBRTIF0, 1 << 2   @ bitWidth 1 (Channel x clear block repeat transfer  complete interrupt flag Writing a 1 into this bit  clears BRTIFx in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C0IFCR_CBTIF0, 1 << 3   @ bitWidth 1 (Channel x Clear block transfer complete  interrupt flag Writing a 1 into this bit clears BTIFx  in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C0IFCR_CLTCIF0, 1 << 4   @ bitWidth 1 (CLear buffer Transfer Complete Interrupt  Flag for channel x Writing a 1 into this bit clears  TCIFx in the MDMA_ISRy register)  
 
    .equ MDMA_MDMA_C0ESR, MDMA_BASE + 0x48 @ (MDMA Channel x error status  register) 
        .equ MDMA_MDMA_C0ESR_TEA_Shift, 0   @ bitWidth 7 (Transfer Error Address These bits are  set and cleared by HW, in case of an MDMA data  transfer error. It is used in conjunction with TED.  This field indicates the 7 LSBits of the address  which generated a transfer/access error. It may be  used by SW to retrieve the failing address, by adding  this value truncated to the buffer transfer length  size to the current SAR/DAR value. Note: The SAR/DAR  current value doesnt reflect this last address due to  the FIFO management system. The SAR/DAR are only  updated at the end of a buffer transfer of TLEN+1  bytes. Note: It is not set in case of a link data  error.)  
        .equ MDMA_MDMA_C0ESR_TED, 1 << 7   @ bitWidth 1 (Transfer Error Direction These bit is  set and cleared by HW, in case of an MDMA data  transfer error.)  
        .equ MDMA_MDMA_C0ESR_TELD, 1 << 8   @ bitWidth 1 (Transfer Error Link Data These bit is  set by HW, in case of a transfer error while reading  the block link data structure. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C0ESR_TEMD, 1 << 9   @ bitWidth 1 (Transfer Error Mask Data These bit is  set by HW, in case of a transfer error while writing  the Mask Data. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C0ESR_ASE, 1 << 10   @ bitWidth 1 (Address/Size Error These bit is set by  HW, when the programmed address is not aligned with  the data size. TED will indicate whether the problem  is on the source or destination. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C0ESR_BSE, 1 << 11   @ bitWidth 1 (Block Size Error These bit is set by HW,  when the block size is not an integer multiple of the  data size either for source or destination. TED will  indicate whether the problem is on the source or  destination. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
 
    .equ MDMA_MDMA_C0CR, MDMA_BASE + 0x4C @ (This register is used to control the  concerned channel.) 
        .equ MDMA_MDMA_C0CR_EN, 1 << 0   @ bitWidth 1 (channel enable)  
        .equ MDMA_MDMA_C0CR_TEIE, 1 << 1   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C0CR_CTCIE, 1 << 2   @ bitWidth 1 (Channel Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C0CR_BRTIE, 1 << 3   @ bitWidth 1 (Block Repeat transfer interrupt enable  This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C0CR_BTIE, 1 << 4   @ bitWidth 1 (Block Transfer interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C0CR_TCIE, 1 << 5   @ bitWidth 1 (buffer Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C0CR_PL_Shift, 6   @ bitWidth 2 (Priority level These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0.)  
        .equ MDMA_MDMA_C0CR_BEX, 1 << 12   @ bitWidth 1 (byte Endianness exchange)  
        .equ MDMA_MDMA_C0CR_HEX, 1 << 13   @ bitWidth 1 (Half word Endianes  exchange)  
        .equ MDMA_MDMA_C0CR_WEX, 1 << 14   @ bitWidth 1 (Word Endianness exchange)  
        .equ MDMA_MDMA_C0CR_SWRQ, 1 << 16   @ bitWidth 1 (SW ReQuest Writing a 1 into this bit  sets the CRQAx in MDMA_ISRy register, activating the  request on Channel x Note: Either the whole CxCR  register or the 8-bit/16-bit register @ Address  offset: 0x4E + 0x40 chn may be used for SWRQ  activation. In case of a SW request, acknowledge is  not generated neither HW signal, nor CxMAR write  access.)  
 
    .equ MDMA_MDMA_C0TCR, MDMA_BASE + 0x50 @ (This register is used to configure the  concerned channel.) 
        .equ MDMA_MDMA_C0TCR_SINC_Shift, 0   @ bitWidth 2 (Source increment mode These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0 Note: When source is  AHB SBUS=1, SINC = 00 is forbidden. In Linked List  Mode, at the end of a block single or last block in  repeated block transfer mode, this register will be  loaded from memory from address given by current  LAR[31:0] + 0x00.)  
        .equ MDMA_MDMA_C0TCR_DINC_Shift, 2   @ bitWidth 2 (Destination increment mode These bits  are set and cleared by software. These bits are  protected and can be written only if EN is 0 Note:  When destination is AHB DBUS=1, DINC = 00 is  forbidden.)  
        .equ MDMA_MDMA_C0TCR_SSIZE_Shift, 4   @ bitWidth 2 (Source data size These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0 Note: If a value of 11 is  programmed for the TCM access/AHB port, a transfer  error will occur TEIF bit set If SINCOS &lt;  SSIZE and SINC &#8800; 00, the result will be  unpredictable. Note: SSIZE = 11 double-word is  forbidden when source is TCM/AHB bus  SBUS=1.)  
        .equ MDMA_MDMA_C0TCR_DSIZE_Shift, 6   @ bitWidth 2 (Destination data size These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0. Note: If a value of  11 is programmed for the TCM access/AHB port, a  transfer error will occur TEIF bit set If DINCOS  &lt; DSIZE and DINC &#8800; 00, the result  will be unpredictable. Note: DSIZE = 11 double-word  is forbidden when destination is TCM/AHB bus  DBUS=1.)  
        .equ MDMA_MDMA_C0TCR_SINCOS_Shift, 8   @ bitWidth 2 (source increment offset  size)  
        .equ MDMA_MDMA_C0TCR_DINCOS_Shift, 10   @ bitWidth 2 (Destination increment  offset)  
        .equ MDMA_MDMA_C0TCR_SBURST_Shift, 12   @ bitWidth 3 (source burst transfer  configuration)  
        .equ MDMA_MDMA_C0TCR_DBURST_Shift, 15   @ bitWidth 3 (Destination burst transfer  configuration)  
        .equ MDMA_MDMA_C0TCR_TLEN_Shift, 18   @ bitWidth 7 (buffer transfer lengh)  
        .equ MDMA_MDMA_C0TCR_PKE, 1 << 25   @ bitWidth 1 (PacK Enable These bit is set and cleared  by software. If the Source Size is smaller than the  destination, it will be padded according to the PAM  value. If the Source data size is larger than the  destination one, it will be truncated. The alignment  will be done according to the PAM[0] value. This bit  is protected and can be written only if EN is  0)  
        .equ MDMA_MDMA_C0TCR_PAM_Shift, 26   @ bitWidth 2 (Padding/Alignement Mode These bits are  set and cleared by software. Case 1: Source data size  smaller than destination data size - 3 options are  valid. Case 2: Source data size larger than  destination data size. The remainder part is  discarded. When PKE = 1 or DSIZE=SSIZE, these bits  are ignored. These bits are protected and can be  written only if EN is 0)  
        .equ MDMA_MDMA_C0TCR_TRGM_Shift, 28   @ bitWidth 2 (Trigger Mode These bits are set and  cleared by software. Note: If TRGM is 11 for the  current block, all the values loaded at the end of  the current block through the linked list mechanism  must keep the same value TRGM=11 and the same SWRM  value, otherwise the result is undefined. These bits  are protected and can be written only if EN is  0.)  
        .equ MDMA_MDMA_C0TCR_SWRM, 1 << 30   @ bitWidth 1 (SW Request Mode This bit is set and  cleared by software. If a HW or SW request is  currently active, the bit change will be delayed  until the current transfer is completed. If the CxMAR  contains a valid address, the CxMDR value will also  be written @ CxMAR address. This bit is protected and  can be written only if EN is 0.)  
        .equ MDMA_MDMA_C0TCR_BWM, 1 << 31   @ bitWidth 1 (Bufferable Write Mode This bit is set  and cleared by software. This bit is protected and  can be written only if EN is 0. Note: All MDMA  destination accesses are non-cacheable.)  
 
    .equ MDMA_MDMA_C0BNDTR, MDMA_BASE + 0x54 @ (MDMA Channel x block number of data  register) 
        .equ MDMA_MDMA_C0BNDTR_BNDT_Shift, 0   @ bitWidth 17 (block number of data to  transfer)  
        .equ MDMA_MDMA_C0BNDTR_BRSUM, 1 << 18   @ bitWidth 1 (Block Repeat Source address Update Mode  These bits are protected and can be written only if  EN is 0.)  
        .equ MDMA_MDMA_C0BNDTR_BRDUM, 1 << 19   @ bitWidth 1 (Block Repeat Destination address Update  Mode These bits are protected and can be written only  if EN is 0.)  
        .equ MDMA_MDMA_C0BNDTR_BRC_Shift, 20   @ bitWidth 12 (Block Repeat Count This field contains  the number of repetitions of the current block 0 to  4095. When the channel is enabled, this register is  read-only, indicating the remaining number of blocks,  excluding the current one. This register decrements  after each complete block transfer. Once the last  block transfer has completed, this register can  either stay at zero or be reloaded automatically from  memory in Linked List mode - i.e. Link Address  valid. These bits are protected and can be written  only if EN is 0.)  
 
    .equ MDMA_MDMA_C0SAR, MDMA_BASE + 0x58 @ (MDMA channel x source address  register) 
        .equ MDMA_MDMA_C0SAR_SAR_Shift, 0   @ bitWidth 32 (source adr base)  
 
    .equ MDMA_MDMA_C0DAR, MDMA_BASE + 0x5C @ (MDMA channel x destination address  register) 
        .equ MDMA_MDMA_C0DAR_DAR_Shift, 0   @ bitWidth 32 (Destination adr base)  
 
    .equ MDMA_MDMA_C0BRUR, MDMA_BASE + 0x60 @ (MDMA channel x Block Repeat address Update  register) 
        .equ MDMA_MDMA_C0BRUR_SUV_Shift, 0   @ bitWidth 16 (source adresse update  value)  
        .equ MDMA_MDMA_C0BRUR_DUV_Shift, 16   @ bitWidth 16 (destination address update)  
 
    .equ MDMA_MDMA_C0LAR, MDMA_BASE + 0x64 @ (MDMA channel x Link Address  register) 
        .equ MDMA_MDMA_C0LAR_LAR_Shift, 0   @ bitWidth 32 (Link address register)  
 
    .equ MDMA_MDMA_C0TBR, MDMA_BASE + 0x68 @ (MDMA channel x Trigger and Bus selection  Register) 
        .equ MDMA_MDMA_C0TBR_TSEL_Shift, 0   @ bitWidth 6 (Trigger selection)  
        .equ MDMA_MDMA_C0TBR_SBUS, 1 << 16   @ bitWidth 1 (Source BUS select This bit is protected  and can be written only if EN is 0.)  
        .equ MDMA_MDMA_C0TBR_DBUS, 1 << 17   @ bitWidth 1 (Destination BUS slect This bit is  protected and can be written only if EN is  0.)  
 
    .equ MDMA_MDMA_C0MAR, MDMA_BASE + 0x70 @ (MDMA channel x Mask address  register) 
        .equ MDMA_MDMA_C0MAR_MAR_Shift, 0   @ bitWidth 32 (Mask address)  
 
    .equ MDMA_MDMA_C0MDR, MDMA_BASE + 0x74 @ (MDMA channel x Mask Data  register) 
        .equ MDMA_MDMA_C0MDR_MDR_Shift, 0   @ bitWidth 32 (Mask data)  
 
    .equ MDMA_MDMA_C1ISR, MDMA_BASE + 0x80 @ (MDMA channel x interrupt/status  register) 
        .equ MDMA_MDMA_C1ISR_TEIF1, 1 << 0   @ bitWidth 1 (Channel x transfer error interrupt flag  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCRy register.)  
        .equ MDMA_MDMA_C1ISR_CTCIF1, 1 << 1   @ bitWidth 1 (Channel x Channel Transfer Complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register. CTC is set when the  last block was transferred and the channel has been  automatically disabled. CTC is also set when the  channel is suspended, as a result of writing EN bit  to 0.)  
        .equ MDMA_MDMA_C1ISR_BRTIF1, 1 << 2   @ bitWidth 1 (Channel x block repeat transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C1ISR_BTIF1, 1 << 3   @ bitWidth 1 (Channel x block transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C1ISR_TCIF1, 1 << 4   @ bitWidth 1 (channel x buffer transfer  complete)  
        .equ MDMA_MDMA_C1ISR_CRQA1, 1 << 16   @ bitWidth 1 (channel x request active  flag)  
 
    .equ MDMA_MDMA_C1IFCR, MDMA_BASE + 0x84 @ (MDMA channel x interrupt flag clear  register) 
        .equ MDMA_MDMA_C1IFCR_CTEIF1, 1 << 0   @ bitWidth 1 (Channel x clear transfer error interrupt  flag Writing a 1 into this bit clears TEIFx in the  MDMA_ISRy register)  
        .equ MDMA_MDMA_C1IFCR_CCTCIF1, 1 << 1   @ bitWidth 1 (Clear Channel transfer complete  interrupt flag for channel x Writing a 1 into this  bit clears CTCIFx in the MDMA_ISRy  register)  
        .equ MDMA_MDMA_C1IFCR_CBRTIF1, 1 << 2   @ bitWidth 1 (Channel x clear block repeat transfer  complete interrupt flag Writing a 1 into this bit  clears BRTIFx in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C1IFCR_CBTIF1, 1 << 3   @ bitWidth 1 (Channel x Clear block transfer complete  interrupt flag Writing a 1 into this bit clears BTIFx  in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C1IFCR_CLTCIF1, 1 << 4   @ bitWidth 1 (CLear buffer Transfer Complete Interrupt  Flag for channel x Writing a 1 into this bit clears  TCIFx in the MDMA_ISRy register)  
 
    .equ MDMA_MDMA_C1ESR, MDMA_BASE + 0x88 @ (MDMA Channel x error status  register) 
        .equ MDMA_MDMA_C1ESR_TEA_Shift, 0   @ bitWidth 7 (Transfer Error Address These bits are  set and cleared by HW, in case of an MDMA data  transfer error. It is used in conjunction with TED.  This field indicates the 7 LSBits of the address  which generated a transfer/access error. It may be  used by SW to retrieve the failing address, by adding  this value truncated to the buffer transfer length  size to the current SAR/DAR value. Note: The SAR/DAR  current value doesnt reflect this last address due to  the FIFO management system. The SAR/DAR are only  updated at the end of a buffer transfer of TLEN+1  bytes. Note: It is not set in case of a link data  error.)  
        .equ MDMA_MDMA_C1ESR_TED, 1 << 7   @ bitWidth 1 (Transfer Error Direction These bit is  set and cleared by HW, in case of an MDMA data  transfer error.)  
        .equ MDMA_MDMA_C1ESR_TELD, 1 << 8   @ bitWidth 1 (Transfer Error Link Data These bit is  set by HW, in case of a transfer error while reading  the block link data structure. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C1ESR_TEMD, 1 << 9   @ bitWidth 1 (Transfer Error Mask Data These bit is  set by HW, in case of a transfer error while writing  the Mask Data. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C1ESR_ASE, 1 << 10   @ bitWidth 1 (Address/Size Error These bit is set by  HW, when the programmed address is not aligned with  the data size. TED will indicate whether the problem  is on the source or destination. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C1ESR_BSE, 1 << 11   @ bitWidth 1 (Block Size Error These bit is set by HW,  when the block size is not an integer multiple of the  data size either for source or destination. TED will  indicate whether the problem is on the source or  destination. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
 
    .equ MDMA_MDMA_C1CR, MDMA_BASE + 0x8C @ (This register is used to control the  concerned channel.) 
        .equ MDMA_MDMA_C1CR_EN, 1 << 0   @ bitWidth 1 (channel enable)  
        .equ MDMA_MDMA_C1CR_TEIE, 1 << 1   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C1CR_CTCIE, 1 << 2   @ bitWidth 1 (Channel Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C1CR_BRTIE, 1 << 3   @ bitWidth 1 (Block Repeat transfer interrupt enable  This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C1CR_BTIE, 1 << 4   @ bitWidth 1 (Block Transfer interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C1CR_TCIE, 1 << 5   @ bitWidth 1 (buffer Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C1CR_PL_Shift, 6   @ bitWidth 2 (Priority level These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0.)  
        .equ MDMA_MDMA_C1CR_BEX, 1 << 12   @ bitWidth 1 (byte Endianness exchange)  
        .equ MDMA_MDMA_C1CR_HEX, 1 << 13   @ bitWidth 1 (Half word Endianes  exchange)  
        .equ MDMA_MDMA_C1CR_WEX, 1 << 14   @ bitWidth 1 (Word Endianness exchange)  
        .equ MDMA_MDMA_C1CR_SWRQ, 1 << 16   @ bitWidth 1 (SW ReQuest Writing a 1 into this bit  sets the CRQAx in MDMA_ISRy register, activating the  request on Channel x Note: Either the whole CxCR  register or the 8-bit/16-bit register @ Address  offset: 0x4E + 0x40 chn may be used for SWRQ  activation. In case of a SW request, acknowledge is  not generated neither HW signal, nor CxMAR write  access.)  
 
    .equ MDMA_MDMA_C1TCR, MDMA_BASE + 0x90 @ (This register is used to configure the  concerned channel.) 
        .equ MDMA_MDMA_C1TCR_SINC_Shift, 0   @ bitWidth 2 (Source increment mode These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0 Note: When source is  AHB SBUS=1, SINC = 00 is forbidden. In Linked List  Mode, at the end of a block single or last block in  repeated block transfer mode, this register will be  loaded from memory from address given by current  LAR[31:0] + 0x00.)  
        .equ MDMA_MDMA_C1TCR_DINC_Shift, 2   @ bitWidth 2 (Destination increment mode These bits  are set and cleared by software. These bits are  protected and can be written only if EN is 0 Note:  When destination is AHB DBUS=1, DINC = 00 is  forbidden.)  
        .equ MDMA_MDMA_C1TCR_SSIZE_Shift, 4   @ bitWidth 2 (Source data size These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0 Note: If a value of 11 is  programmed for the TCM access/AHB port, a transfer  error will occur TEIF bit set If SINCOS &lt;  SSIZE and SINC &#8800; 00, the result will be  unpredictable. Note: SSIZE = 11 double-word is  forbidden when source is TCM/AHB bus  SBUS=1.)  
        .equ MDMA_MDMA_C1TCR_DSIZE_Shift, 6   @ bitWidth 2 (Destination data size These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0. Note: If a value of  11 is programmed for the TCM access/AHB port, a  transfer error will occur TEIF bit set If DINCOS  &lt; DSIZE and DINC &#8800; 00, the result  will be unpredictable. Note: DSIZE = 11 double-word  is forbidden when destination is TCM/AHB bus  DBUS=1.)  
        .equ MDMA_MDMA_C1TCR_SINCOS_Shift, 8   @ bitWidth 2 (source increment offset  size)  
        .equ MDMA_MDMA_C1TCR_DINCOS_Shift, 10   @ bitWidth 2 (Destination increment  offset)  
        .equ MDMA_MDMA_C1TCR_SBURST_Shift, 12   @ bitWidth 3 (source burst transfer  configuration)  
        .equ MDMA_MDMA_C1TCR_DBURST_Shift, 15   @ bitWidth 3 (Destination burst transfer  configuration)  
        .equ MDMA_MDMA_C1TCR_TLEN_Shift, 18   @ bitWidth 7 (buffer transfer lengh)  
        .equ MDMA_MDMA_C1TCR_PKE, 1 << 25   @ bitWidth 1 (PacK Enable These bit is set and cleared  by software. If the Source Size is smaller than the  destination, it will be padded according to the PAM  value. If the Source data size is larger than the  destination one, it will be truncated. The alignment  will be done according to the PAM[0] value. This bit  is protected and can be written only if EN is  0)  
        .equ MDMA_MDMA_C1TCR_PAM_Shift, 26   @ bitWidth 2 (Padding/Alignement Mode These bits are  set and cleared by software. Case 1: Source data size  smaller than destination data size - 3 options are  valid. Case 2: Source data size larger than  destination data size. The remainder part is  discarded. When PKE = 1 or DSIZE=SSIZE, these bits  are ignored. These bits are protected and can be  written only if EN is 0)  
        .equ MDMA_MDMA_C1TCR_TRGM_Shift, 28   @ bitWidth 2 (Trigger Mode These bits are set and  cleared by software. Note: If TRGM is 11 for the  current block, all the values loaded at the end of  the current block through the linked list mechanism  must keep the same value TRGM=11 and the same SWRM  value, otherwise the result is undefined. These bits  are protected and can be written only if EN is  0.)  
        .equ MDMA_MDMA_C1TCR_SWRM, 1 << 30   @ bitWidth 1 (SW Request Mode This bit is set and  cleared by software. If a HW or SW request is  currently active, the bit change will be delayed  until the current transfer is completed. If the CxMAR  contains a valid address, the CxMDR value will also  be written @ CxMAR address. This bit is protected and  can be written only if EN is 0.)  
        .equ MDMA_MDMA_C1TCR_BWM, 1 << 31   @ bitWidth 1 (Bufferable Write Mode This bit is set  and cleared by software. This bit is protected and  can be written only if EN is 0. Note: All MDMA  destination accesses are non-cacheable.)  
 
    .equ MDMA_MDMA_C1BNDTR, MDMA_BASE + 0x94 @ (MDMA Channel x block number of data  register) 
        .equ MDMA_MDMA_C1BNDTR_BNDT_Shift, 0   @ bitWidth 17 (block number of data to  transfer)  
        .equ MDMA_MDMA_C1BNDTR_BRSUM, 1 << 18   @ bitWidth 1 (Block Repeat Source address Update Mode  These bits are protected and can be written only if  EN is 0.)  
        .equ MDMA_MDMA_C1BNDTR_BRDUM, 1 << 19   @ bitWidth 1 (Block Repeat Destination address Update  Mode These bits are protected and can be written only  if EN is 0.)  
        .equ MDMA_MDMA_C1BNDTR_BRC_Shift, 20   @ bitWidth 12 (Block Repeat Count This field contains  the number of repetitions of the current block 0 to  4095. When the channel is enabled, this register is  read-only, indicating the remaining number of blocks,  excluding the current one. This register decrements  after each complete block transfer. Once the last  block transfer has completed, this register can  either stay at zero or be reloaded automatically from  memory in Linked List mode - i.e. Link Address  valid. These bits are protected and can be written  only if EN is 0.)  
 
    .equ MDMA_MDMA_C1SAR, MDMA_BASE + 0x98 @ (MDMA channel x source address  register) 
        .equ MDMA_MDMA_C1SAR_SAR_Shift, 0   @ bitWidth 32 (source adr base)  
 
    .equ MDMA_MDMA_C1DAR, MDMA_BASE + 0x9C @ (MDMA channel x destination address  register) 
        .equ MDMA_MDMA_C1DAR_DAR_Shift, 0   @ bitWidth 32 (Destination adr base)  
 
    .equ MDMA_MDMA_C1BRUR, MDMA_BASE + 0xA0 @ (MDMA channel x Block Repeat address Update  register) 
        .equ MDMA_MDMA_C1BRUR_SUV_Shift, 0   @ bitWidth 16 (source adresse update  value)  
        .equ MDMA_MDMA_C1BRUR_DUV_Shift, 16   @ bitWidth 16 (destination address update)  
 
    .equ MDMA_MDMA_C1LAR, MDMA_BASE + 0xA4 @ (MDMA channel x Link Address  register) 
        .equ MDMA_MDMA_C1LAR_LAR_Shift, 0   @ bitWidth 32 (Link address register)  
 
    .equ MDMA_MDMA_C1TBR, MDMA_BASE + 0xA8 @ (MDMA channel x Trigger and Bus selection  Register) 
        .equ MDMA_MDMA_C1TBR_TSEL_Shift, 0   @ bitWidth 6 (Trigger selection)  
        .equ MDMA_MDMA_C1TBR_SBUS, 1 << 16   @ bitWidth 1 (Source BUS select This bit is protected  and can be written only if EN is 0.)  
        .equ MDMA_MDMA_C1TBR_DBUS, 1 << 17   @ bitWidth 1 (Destination BUS slect This bit is  protected and can be written only if EN is  0.)  
 
    .equ MDMA_MDMA_C1MAR, MDMA_BASE + 0xB0 @ (MDMA channel x Mask address  register) 
        .equ MDMA_MDMA_C1MAR_MAR_Shift, 0   @ bitWidth 32 (Mask address)  
 
    .equ MDMA_MDMA_C1MDR, MDMA_BASE + 0xB4 @ (MDMA channel x Mask Data  register) 
        .equ MDMA_MDMA_C1MDR_MDR_Shift, 0   @ bitWidth 32 (Mask data)  
 
    .equ MDMA_MDMA_C2ISR, MDMA_BASE + 0xC0 @ (MDMA channel x interrupt/status  register) 
        .equ MDMA_MDMA_C2ISR_TEIF2, 1 << 0   @ bitWidth 1 (Channel x transfer error interrupt flag  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCRy register.)  
        .equ MDMA_MDMA_C2ISR_CTCIF2, 1 << 1   @ bitWidth 1 (Channel x Channel Transfer Complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register. CTC is set when the  last block was transferred and the channel has been  automatically disabled. CTC is also set when the  channel is suspended, as a result of writing EN bit  to 0.)  
        .equ MDMA_MDMA_C2ISR_BRTIF2, 1 << 2   @ bitWidth 1 (Channel x block repeat transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C2ISR_BTIF2, 1 << 3   @ bitWidth 1 (Channel x block transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C2ISR_TCIF2, 1 << 4   @ bitWidth 1 (channel x buffer transfer  complete)  
        .equ MDMA_MDMA_C2ISR_CRQA2, 1 << 16   @ bitWidth 1 (channel x request active  flag)  
 
    .equ MDMA_MDMA_C2IFCR, MDMA_BASE + 0xC4 @ (MDMA channel x interrupt flag clear  register) 
        .equ MDMA_MDMA_C2IFCR_CTEIF2, 1 << 0   @ bitWidth 1 (Channel x clear transfer error interrupt  flag Writing a 1 into this bit clears TEIFx in the  MDMA_ISRy register)  
        .equ MDMA_MDMA_C2IFCR_CCTCIF2, 1 << 1   @ bitWidth 1 (Clear Channel transfer complete  interrupt flag for channel x Writing a 1 into this  bit clears CTCIFx in the MDMA_ISRy  register)  
        .equ MDMA_MDMA_C2IFCR_CBRTIF2, 1 << 2   @ bitWidth 1 (Channel x clear block repeat transfer  complete interrupt flag Writing a 1 into this bit  clears BRTIFx in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C2IFCR_CBTIF2, 1 << 3   @ bitWidth 1 (Channel x Clear block transfer complete  interrupt flag Writing a 1 into this bit clears BTIFx  in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C2IFCR_CLTCIF2, 1 << 4   @ bitWidth 1 (CLear buffer Transfer Complete Interrupt  Flag for channel x Writing a 1 into this bit clears  TCIFx in the MDMA_ISRy register)  
 
    .equ MDMA_MDMA_C2ESR, MDMA_BASE + 0xC8 @ (MDMA Channel x error status  register) 
        .equ MDMA_MDMA_C2ESR_TEA_Shift, 0   @ bitWidth 7 (Transfer Error Address These bits are  set and cleared by HW, in case of an MDMA data  transfer error. It is used in conjunction with TED.  This field indicates the 7 LSBits of the address  which generated a transfer/access error. It may be  used by SW to retrieve the failing address, by adding  this value truncated to the buffer transfer length  size to the current SAR/DAR value. Note: The SAR/DAR  current value doesnt reflect this last address due to  the FIFO management system. The SAR/DAR are only  updated at the end of a buffer transfer of TLEN+1  bytes. Note: It is not set in case of a link data  error.)  
        .equ MDMA_MDMA_C2ESR_TED, 1 << 7   @ bitWidth 1 (Transfer Error Direction These bit is  set and cleared by HW, in case of an MDMA data  transfer error.)  
        .equ MDMA_MDMA_C2ESR_TELD, 1 << 8   @ bitWidth 1 (Transfer Error Link Data These bit is  set by HW, in case of a transfer error while reading  the block link data structure. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C2ESR_TEMD, 1 << 9   @ bitWidth 1 (Transfer Error Mask Data These bit is  set by HW, in case of a transfer error while writing  the Mask Data. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C2ESR_ASE, 1 << 10   @ bitWidth 1 (Address/Size Error These bit is set by  HW, when the programmed address is not aligned with  the data size. TED will indicate whether the problem  is on the source or destination. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C2ESR_BSE, 1 << 11   @ bitWidth 1 (Block Size Error These bit is set by HW,  when the block size is not an integer multiple of the  data size either for source or destination. TED will  indicate whether the problem is on the source or  destination. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
 
    .equ MDMA_MDMA_C2CR, MDMA_BASE + 0xCC @ (This register is used to control the  concerned channel.) 
        .equ MDMA_MDMA_C2CR_EN, 1 << 0   @ bitWidth 1 (channel enable)  
        .equ MDMA_MDMA_C2CR_TEIE, 1 << 1   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C2CR_CTCIE, 1 << 2   @ bitWidth 1 (Channel Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C2CR_BRTIE, 1 << 3   @ bitWidth 1 (Block Repeat transfer interrupt enable  This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C2CR_BTIE, 1 << 4   @ bitWidth 1 (Block Transfer interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C2CR_TCIE, 1 << 5   @ bitWidth 1 (buffer Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C2CR_PL_Shift, 6   @ bitWidth 2 (Priority level These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0.)  
        .equ MDMA_MDMA_C2CR_BEX, 1 << 12   @ bitWidth 1 (byte Endianness exchange)  
        .equ MDMA_MDMA_C2CR_HEX, 1 << 13   @ bitWidth 1 (Half word Endianes  exchange)  
        .equ MDMA_MDMA_C2CR_WEX, 1 << 14   @ bitWidth 1 (Word Endianness exchange)  
        .equ MDMA_MDMA_C2CR_SWRQ, 1 << 16   @ bitWidth 1 (SW ReQuest Writing a 1 into this bit  sets the CRQAx in MDMA_ISRy register, activating the  request on Channel x Note: Either the whole CxCR  register or the 8-bit/16-bit register @ Address  offset: 0x4E + 0x40 chn may be used for SWRQ  activation. In case of a SW request, acknowledge is  not generated neither HW signal, nor CxMAR write  access.)  
 
    .equ MDMA_MDMA_C2TCR, MDMA_BASE + 0xD0 @ (This register is used to configure the  concerned channel.) 
        .equ MDMA_MDMA_C2TCR_SINC_Shift, 0   @ bitWidth 2 (Source increment mode These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0 Note: When source is  AHB SBUS=1, SINC = 00 is forbidden. In Linked List  Mode, at the end of a block single or last block in  repeated block transfer mode, this register will be  loaded from memory from address given by current  LAR[31:0] + 0x00.)  
        .equ MDMA_MDMA_C2TCR_DINC_Shift, 2   @ bitWidth 2 (Destination increment mode These bits  are set and cleared by software. These bits are  protected and can be written only if EN is 0 Note:  When destination is AHB DBUS=1, DINC = 00 is  forbidden.)  
        .equ MDMA_MDMA_C2TCR_SSIZE_Shift, 4   @ bitWidth 2 (Source data size These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0 Note: If a value of 11 is  programmed for the TCM access/AHB port, a transfer  error will occur TEIF bit set If SINCOS &lt;  SSIZE and SINC &#8800; 00, the result will be  unpredictable. Note: SSIZE = 11 double-word is  forbidden when source is TCM/AHB bus  SBUS=1.)  
        .equ MDMA_MDMA_C2TCR_DSIZE_Shift, 6   @ bitWidth 2 (Destination data size These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0. Note: If a value of  11 is programmed for the TCM access/AHB port, a  transfer error will occur TEIF bit set If DINCOS  &lt; DSIZE and DINC &#8800; 00, the result  will be unpredictable. Note: DSIZE = 11 double-word  is forbidden when destination is TCM/AHB bus  DBUS=1.)  
        .equ MDMA_MDMA_C2TCR_SINCOS_Shift, 8   @ bitWidth 2 (source increment offset  size)  
        .equ MDMA_MDMA_C2TCR_DINCOS_Shift, 10   @ bitWidth 2 (Destination increment  offset)  
        .equ MDMA_MDMA_C2TCR_SBURST_Shift, 12   @ bitWidth 3 (source burst transfer  configuration)  
        .equ MDMA_MDMA_C2TCR_DBURST_Shift, 15   @ bitWidth 3 (Destination burst transfer  configuration)  
        .equ MDMA_MDMA_C2TCR_TLEN_Shift, 18   @ bitWidth 7 (buffer transfer lengh)  
        .equ MDMA_MDMA_C2TCR_PKE, 1 << 25   @ bitWidth 1 (PacK Enable These bit is set and cleared  by software. If the Source Size is smaller than the  destination, it will be padded according to the PAM  value. If the Source data size is larger than the  destination one, it will be truncated. The alignment  will be done according to the PAM[0] value. This bit  is protected and can be written only if EN is  0)  
        .equ MDMA_MDMA_C2TCR_PAM_Shift, 26   @ bitWidth 2 (Padding/Alignement Mode These bits are  set and cleared by software. Case 1: Source data size  smaller than destination data size - 3 options are  valid. Case 2: Source data size larger than  destination data size. The remainder part is  discarded. When PKE = 1 or DSIZE=SSIZE, these bits  are ignored. These bits are protected and can be  written only if EN is 0)  
        .equ MDMA_MDMA_C2TCR_TRGM_Shift, 28   @ bitWidth 2 (Trigger Mode These bits are set and  cleared by software. Note: If TRGM is 11 for the  current block, all the values loaded at the end of  the current block through the linked list mechanism  must keep the same value TRGM=11 and the same SWRM  value, otherwise the result is undefined. These bits  are protected and can be written only if EN is  0.)  
        .equ MDMA_MDMA_C2TCR_SWRM, 1 << 30   @ bitWidth 1 (SW Request Mode This bit is set and  cleared by software. If a HW or SW request is  currently active, the bit change will be delayed  until the current transfer is completed. If the CxMAR  contains a valid address, the CxMDR value will also  be written @ CxMAR address. This bit is protected and  can be written only if EN is 0.)  
        .equ MDMA_MDMA_C2TCR_BWM, 1 << 31   @ bitWidth 1 (Bufferable Write Mode This bit is set  and cleared by software. This bit is protected and  can be written only if EN is 0. Note: All MDMA  destination accesses are non-cacheable.)  
 
    .equ MDMA_MDMA_C2BNDTR, MDMA_BASE + 0xD4 @ (MDMA Channel x block number of data  register) 
        .equ MDMA_MDMA_C2BNDTR_BNDT_Shift, 0   @ bitWidth 17 (block number of data to  transfer)  
        .equ MDMA_MDMA_C2BNDTR_BRSUM, 1 << 18   @ bitWidth 1 (Block Repeat Source address Update Mode  These bits are protected and can be written only if  EN is 0.)  
        .equ MDMA_MDMA_C2BNDTR_BRDUM, 1 << 19   @ bitWidth 1 (Block Repeat Destination address Update  Mode These bits are protected and can be written only  if EN is 0.)  
        .equ MDMA_MDMA_C2BNDTR_BRC_Shift, 20   @ bitWidth 12 (Block Repeat Count This field contains  the number of repetitions of the current block 0 to  4095. When the channel is enabled, this register is  read-only, indicating the remaining number of blocks,  excluding the current one. This register decrements  after each complete block transfer. Once the last  block transfer has completed, this register can  either stay at zero or be reloaded automatically from  memory in Linked List mode - i.e. Link Address  valid. These bits are protected and can be written  only if EN is 0.)  
 
    .equ MDMA_MDMA_C2SAR, MDMA_BASE + 0xD8 @ (MDMA channel x source address  register) 
        .equ MDMA_MDMA_C2SAR_SAR_Shift, 0   @ bitWidth 32 (source adr base)  
 
    .equ MDMA_MDMA_C2DAR, MDMA_BASE + 0xDC @ (MDMA channel x destination address  register) 
        .equ MDMA_MDMA_C2DAR_DAR_Shift, 0   @ bitWidth 32 (Destination adr base)  
 
    .equ MDMA_MDMA_C2BRUR, MDMA_BASE + 0xE0 @ (MDMA channel x Block Repeat address Update  register) 
        .equ MDMA_MDMA_C2BRUR_SUV_Shift, 0   @ bitWidth 16 (source adresse update  value)  
        .equ MDMA_MDMA_C2BRUR_DUV_Shift, 16   @ bitWidth 16 (destination address update)  
 
    .equ MDMA_MDMA_C2LAR, MDMA_BASE + 0xE4 @ (MDMA channel x Link Address  register) 
        .equ MDMA_MDMA_C2LAR_LAR_Shift, 0   @ bitWidth 32 (Link address register)  
 
    .equ MDMA_MDMA_C2TBR, MDMA_BASE + 0xE8 @ (MDMA channel x Trigger and Bus selection  Register) 
        .equ MDMA_MDMA_C2TBR_TSEL_Shift, 0   @ bitWidth 6 (Trigger selection)  
        .equ MDMA_MDMA_C2TBR_SBUS, 1 << 16   @ bitWidth 1 (Source BUS select This bit is protected  and can be written only if EN is 0.)  
        .equ MDMA_MDMA_C2TBR_DBUS, 1 << 17   @ bitWidth 1 (Destination BUS slect This bit is  protected and can be written only if EN is  0.)  
 
    .equ MDMA_MDMA_C2MAR, MDMA_BASE + 0xF0 @ (MDMA channel x Mask address  register) 
        .equ MDMA_MDMA_C2MAR_MAR_Shift, 0   @ bitWidth 32 (Mask address)  
 
    .equ MDMA_MDMA_C2MDR, MDMA_BASE + 0xF4 @ (MDMA channel x Mask Data  register) 
        .equ MDMA_MDMA_C2MDR_MDR_Shift, 0   @ bitWidth 32 (Mask data)  
 
    .equ MDMA_MDMA_C3ISR, MDMA_BASE + 0x100 @ (MDMA channel x interrupt/status  register) 
        .equ MDMA_MDMA_C3ISR_TEIF3, 1 << 0   @ bitWidth 1 (Channel x transfer error interrupt flag  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCRy register.)  
        .equ MDMA_MDMA_C3ISR_CTCIF3, 1 << 1   @ bitWidth 1 (Channel x Channel Transfer Complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register. CTC is set when the  last block was transferred and the channel has been  automatically disabled. CTC is also set when the  channel is suspended, as a result of writing EN bit  to 0.)  
        .equ MDMA_MDMA_C3ISR_BRTIF3, 1 << 2   @ bitWidth 1 (Channel x block repeat transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C3ISR_BTIF3, 1 << 3   @ bitWidth 1 (Channel x block transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C3ISR_TCIF3, 1 << 4   @ bitWidth 1 (channel x buffer transfer  complete)  
        .equ MDMA_MDMA_C3ISR_CRQA3, 1 << 16   @ bitWidth 1 (channel x request active  flag)  
 
    .equ MDMA_MDMA_C3IFCR, MDMA_BASE + 0x104 @ (MDMA channel x interrupt flag clear  register) 
        .equ MDMA_MDMA_C3IFCR_CTEIF3, 1 << 0   @ bitWidth 1 (Channel x clear transfer error interrupt  flag Writing a 1 into this bit clears TEIFx in the  MDMA_ISRy register)  
        .equ MDMA_MDMA_C3IFCR_CCTCIF3, 1 << 1   @ bitWidth 1 (Clear Channel transfer complete  interrupt flag for channel x Writing a 1 into this  bit clears CTCIFx in the MDMA_ISRy  register)  
        .equ MDMA_MDMA_C3IFCR_CBRTIF3, 1 << 2   @ bitWidth 1 (Channel x clear block repeat transfer  complete interrupt flag Writing a 1 into this bit  clears BRTIFx in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C3IFCR_CBTIF3, 1 << 3   @ bitWidth 1 (Channel x Clear block transfer complete  interrupt flag Writing a 1 into this bit clears BTIFx  in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C3IFCR_CLTCIF3, 1 << 4   @ bitWidth 1 (CLear buffer Transfer Complete Interrupt  Flag for channel x Writing a 1 into this bit clears  TCIFx in the MDMA_ISRy register)  
 
    .equ MDMA_MDMA_C3ESR, MDMA_BASE + 0x108 @ (MDMA Channel x error status  register) 
        .equ MDMA_MDMA_C3ESR_TEA_Shift, 0   @ bitWidth 7 (Transfer Error Address These bits are  set and cleared by HW, in case of an MDMA data  transfer error. It is used in conjunction with TED.  This field indicates the 7 LSBits of the address  which generated a transfer/access error. It may be  used by SW to retrieve the failing address, by adding  this value truncated to the buffer transfer length  size to the current SAR/DAR value. Note: The SAR/DAR  current value doesnt reflect this last address due to  the FIFO management system. The SAR/DAR are only  updated at the end of a buffer transfer of TLEN+1  bytes. Note: It is not set in case of a link data  error.)  
        .equ MDMA_MDMA_C3ESR_TED, 1 << 7   @ bitWidth 1 (Transfer Error Direction These bit is  set and cleared by HW, in case of an MDMA data  transfer error.)  
        .equ MDMA_MDMA_C3ESR_TELD, 1 << 8   @ bitWidth 1 (Transfer Error Link Data These bit is  set by HW, in case of a transfer error while reading  the block link data structure. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C3ESR_TEMD, 1 << 9   @ bitWidth 1 (Transfer Error Mask Data These bit is  set by HW, in case of a transfer error while writing  the Mask Data. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C3ESR_ASE, 1 << 10   @ bitWidth 1 (Address/Size Error These bit is set by  HW, when the programmed address is not aligned with  the data size. TED will indicate whether the problem  is on the source or destination. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C3ESR_BSE, 1 << 11   @ bitWidth 1 (Block Size Error These bit is set by HW,  when the block size is not an integer multiple of the  data size either for source or destination. TED will  indicate whether the problem is on the source or  destination. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
 
    .equ MDMA_MDMA_C3CR, MDMA_BASE + 0x10C @ (This register is used to control the  concerned channel.) 
        .equ MDMA_MDMA_C3CR_EN, 1 << 0   @ bitWidth 1 (channel enable)  
        .equ MDMA_MDMA_C3CR_TEIE, 1 << 1   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C3CR_CTCIE, 1 << 2   @ bitWidth 1 (Channel Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C3CR_BRTIE, 1 << 3   @ bitWidth 1 (Block Repeat transfer interrupt enable  This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C3CR_BTIE, 1 << 4   @ bitWidth 1 (Block Transfer interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C3CR_TCIE, 1 << 5   @ bitWidth 1 (buffer Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C3CR_PL_Shift, 6   @ bitWidth 2 (Priority level These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0.)  
        .equ MDMA_MDMA_C3CR_BEX, 1 << 12   @ bitWidth 1 (byte Endianness exchange)  
        .equ MDMA_MDMA_C3CR_HEX, 1 << 13   @ bitWidth 1 (Half word Endianes  exchange)  
        .equ MDMA_MDMA_C3CR_WEX, 1 << 14   @ bitWidth 1 (Word Endianness exchange)  
        .equ MDMA_MDMA_C3CR_SWRQ, 1 << 16   @ bitWidth 1 (SW ReQuest Writing a 1 into this bit  sets the CRQAx in MDMA_ISRy register, activating the  request on Channel x Note: Either the whole CxCR  register or the 8-bit/16-bit register @ Address  offset: 0x4E + 0x40 chn may be used for SWRQ  activation. In case of a SW request, acknowledge is  not generated neither HW signal, nor CxMAR write  access.)  
 
    .equ MDMA_MDMA_C3TCR, MDMA_BASE + 0x110 @ (This register is used to configure the  concerned channel.) 
        .equ MDMA_MDMA_C3TCR_SINC_Shift, 0   @ bitWidth 2 (Source increment mode These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0 Note: When source is  AHB SBUS=1, SINC = 00 is forbidden. In Linked List  Mode, at the end of a block single or last block in  repeated block transfer mode, this register will be  loaded from memory from address given by current  LAR[31:0] + 0x00.)  
        .equ MDMA_MDMA_C3TCR_DINC_Shift, 2   @ bitWidth 2 (Destination increment mode These bits  are set and cleared by software. These bits are  protected and can be written only if EN is 0 Note:  When destination is AHB DBUS=1, DINC = 00 is  forbidden.)  
        .equ MDMA_MDMA_C3TCR_SSIZE_Shift, 4   @ bitWidth 2 (Source data size These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0 Note: If a value of 11 is  programmed for the TCM access/AHB port, a transfer  error will occur TEIF bit set If SINCOS &lt;  SSIZE and SINC &#8800; 00, the result will be  unpredictable. Note: SSIZE = 11 double-word is  forbidden when source is TCM/AHB bus  SBUS=1.)  
        .equ MDMA_MDMA_C3TCR_DSIZE_Shift, 6   @ bitWidth 2 (Destination data size These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0. Note: If a value of  11 is programmed for the TCM access/AHB port, a  transfer error will occur TEIF bit set If DINCOS  &lt; DSIZE and DINC &#8800; 00, the result  will be unpredictable. Note: DSIZE = 11 double-word  is forbidden when destination is TCM/AHB bus  DBUS=1.)  
        .equ MDMA_MDMA_C3TCR_SINCOS_Shift, 8   @ bitWidth 2 (source increment offset  size)  
        .equ MDMA_MDMA_C3TCR_DINCOS_Shift, 10   @ bitWidth 2 (Destination increment  offset)  
        .equ MDMA_MDMA_C3TCR_SBURST_Shift, 12   @ bitWidth 3 (source burst transfer  configuration)  
        .equ MDMA_MDMA_C3TCR_DBURST_Shift, 15   @ bitWidth 3 (Destination burst transfer  configuration)  
        .equ MDMA_MDMA_C3TCR_TLEN_Shift, 18   @ bitWidth 7 (buffer transfer lengh)  
        .equ MDMA_MDMA_C3TCR_PKE, 1 << 25   @ bitWidth 1 (PacK Enable These bit is set and cleared  by software. If the Source Size is smaller than the  destination, it will be padded according to the PAM  value. If the Source data size is larger than the  destination one, it will be truncated. The alignment  will be done according to the PAM[0] value. This bit  is protected and can be written only if EN is  0)  
        .equ MDMA_MDMA_C3TCR_PAM_Shift, 26   @ bitWidth 2 (Padding/Alignement Mode These bits are  set and cleared by software. Case 1: Source data size  smaller than destination data size - 3 options are  valid. Case 2: Source data size larger than  destination data size. The remainder part is  discarded. When PKE = 1 or DSIZE=SSIZE, these bits  are ignored. These bits are protected and can be  written only if EN is 0)  
        .equ MDMA_MDMA_C3TCR_TRGM_Shift, 28   @ bitWidth 2 (Trigger Mode These bits are set and  cleared by software. Note: If TRGM is 11 for the  current block, all the values loaded at the end of  the current block through the linked list mechanism  must keep the same value TRGM=11 and the same SWRM  value, otherwise the result is undefined. These bits  are protected and can be written only if EN is  0.)  
        .equ MDMA_MDMA_C3TCR_SWRM, 1 << 30   @ bitWidth 1 (SW Request Mode This bit is set and  cleared by software. If a HW or SW request is  currently active, the bit change will be delayed  until the current transfer is completed. If the CxMAR  contains a valid address, the CxMDR value will also  be written @ CxMAR address. This bit is protected and  can be written only if EN is 0.)  
        .equ MDMA_MDMA_C3TCR_BWM, 1 << 31   @ bitWidth 1 (Bufferable Write Mode This bit is set  and cleared by software. This bit is protected and  can be written only if EN is 0. Note: All MDMA  destination accesses are non-cacheable.)  
 
    .equ MDMA_MDMA_C3BNDTR, MDMA_BASE + 0x114 @ (MDMA Channel x block number of data  register) 
        .equ MDMA_MDMA_C3BNDTR_BNDT_Shift, 0   @ bitWidth 17 (block number of data to  transfer)  
        .equ MDMA_MDMA_C3BNDTR_BRSUM, 1 << 18   @ bitWidth 1 (Block Repeat Source address Update Mode  These bits are protected and can be written only if  EN is 0.)  
        .equ MDMA_MDMA_C3BNDTR_BRDUM, 1 << 19   @ bitWidth 1 (Block Repeat Destination address Update  Mode These bits are protected and can be written only  if EN is 0.)  
        .equ MDMA_MDMA_C3BNDTR_BRC_Shift, 20   @ bitWidth 12 (Block Repeat Count This field contains  the number of repetitions of the current block 0 to  4095. When the channel is enabled, this register is  read-only, indicating the remaining number of blocks,  excluding the current one. This register decrements  after each complete block transfer. Once the last  block transfer has completed, this register can  either stay at zero or be reloaded automatically from  memory in Linked List mode - i.e. Link Address  valid. These bits are protected and can be written  only if EN is 0.)  
 
    .equ MDMA_MDMA_C3SAR, MDMA_BASE + 0x118 @ (MDMA channel x source address  register) 
        .equ MDMA_MDMA_C3SAR_SAR_Shift, 0   @ bitWidth 32 (source adr base)  
 
    .equ MDMA_MDMA_C3DAR, MDMA_BASE + 0x11C @ (MDMA channel x destination address  register) 
        .equ MDMA_MDMA_C3DAR_DAR_Shift, 0   @ bitWidth 32 (Destination adr base)  
 
    .equ MDMA_MDMA_C3BRUR, MDMA_BASE + 0x120 @ (MDMA channel x Block Repeat address Update  register) 
        .equ MDMA_MDMA_C3BRUR_SUV_Shift, 0   @ bitWidth 16 (source adresse update  value)  
        .equ MDMA_MDMA_C3BRUR_DUV_Shift, 16   @ bitWidth 16 (destination address update)  
 
    .equ MDMA_MDMA_C3LAR, MDMA_BASE + 0x124 @ (MDMA channel x Link Address  register) 
        .equ MDMA_MDMA_C3LAR_LAR_Shift, 0   @ bitWidth 32 (Link address register)  
 
    .equ MDMA_MDMA_C3TBR, MDMA_BASE + 0x128 @ (MDMA channel x Trigger and Bus selection  Register) 
        .equ MDMA_MDMA_C3TBR_TSEL_Shift, 0   @ bitWidth 6 (Trigger selection)  
        .equ MDMA_MDMA_C3TBR_SBUS, 1 << 16   @ bitWidth 1 (Source BUS select This bit is protected  and can be written only if EN is 0.)  
        .equ MDMA_MDMA_C3TBR_DBUS, 1 << 17   @ bitWidth 1 (Destination BUS slect This bit is  protected and can be written only if EN is  0.)  
 
    .equ MDMA_MDMA_C3MAR, MDMA_BASE + 0x130 @ (MDMA channel x Mask address  register) 
        .equ MDMA_MDMA_C3MAR_MAR_Shift, 0   @ bitWidth 32 (Mask address)  
 
    .equ MDMA_MDMA_C3MDR, MDMA_BASE + 0x134 @ (MDMA channel x Mask Data  register) 
        .equ MDMA_MDMA_C3MDR_MDR_Shift, 0   @ bitWidth 32 (Mask data)  
 
    .equ MDMA_MDMA_C4ISR, MDMA_BASE + 0x140 @ (MDMA channel x interrupt/status  register) 
        .equ MDMA_MDMA_C4ISR_TEIF4, 1 << 0   @ bitWidth 1 (Channel x transfer error interrupt flag  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCRy register.)  
        .equ MDMA_MDMA_C4ISR_CTCIF4, 1 << 1   @ bitWidth 1 (Channel x Channel Transfer Complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register. CTC is set when the  last block was transferred and the channel has been  automatically disabled. CTC is also set when the  channel is suspended, as a result of writing EN bit  to 0.)  
        .equ MDMA_MDMA_C4ISR_BRTIF4, 1 << 2   @ bitWidth 1 (Channel x block repeat transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C4ISR_BTIF4, 1 << 3   @ bitWidth 1 (Channel x block transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C4ISR_TCIF4, 1 << 4   @ bitWidth 1 (channel x buffer transfer  complete)  
        .equ MDMA_MDMA_C4ISR_CRQA4, 1 << 16   @ bitWidth 1 (channel x request active  flag)  
 
    .equ MDMA_MDMA_C4IFCR, MDMA_BASE + 0x144 @ (MDMA channel x interrupt flag clear  register) 
        .equ MDMA_MDMA_C4IFCR_CTEIF4, 1 << 0   @ bitWidth 1 (Channel x clear transfer error interrupt  flag Writing a 1 into this bit clears TEIFx in the  MDMA_ISRy register)  
        .equ MDMA_MDMA_C4IFCR_CCTCIF4, 1 << 1   @ bitWidth 1 (Clear Channel transfer complete  interrupt flag for channel x Writing a 1 into this  bit clears CTCIFx in the MDMA_ISRy  register)  
        .equ MDMA_MDMA_C4IFCR_CBRTIF4, 1 << 2   @ bitWidth 1 (Channel x clear block repeat transfer  complete interrupt flag Writing a 1 into this bit  clears BRTIFx in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C4IFCR_CBTIF4, 1 << 3   @ bitWidth 1 (Channel x Clear block transfer complete  interrupt flag Writing a 1 into this bit clears BTIFx  in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C4IFCR_CLTCIF4, 1 << 4   @ bitWidth 1 (CLear buffer Transfer Complete Interrupt  Flag for channel x Writing a 1 into this bit clears  TCIFx in the MDMA_ISRy register)  
 
    .equ MDMA_MDMA_C4ESR, MDMA_BASE + 0x148 @ (MDMA Channel x error status  register) 
        .equ MDMA_MDMA_C4ESR_TEA_Shift, 0   @ bitWidth 7 (Transfer Error Address These bits are  set and cleared by HW, in case of an MDMA data  transfer error. It is used in conjunction with TED.  This field indicates the 7 LSBits of the address  which generated a transfer/access error. It may be  used by SW to retrieve the failing address, by adding  this value truncated to the buffer transfer length  size to the current SAR/DAR value. Note: The SAR/DAR  current value doesnt reflect this last address due to  the FIFO management system. The SAR/DAR are only  updated at the end of a buffer transfer of TLEN+1  bytes. Note: It is not set in case of a link data  error.)  
        .equ MDMA_MDMA_C4ESR_TED, 1 << 7   @ bitWidth 1 (Transfer Error Direction These bit is  set and cleared by HW, in case of an MDMA data  transfer error.)  
        .equ MDMA_MDMA_C4ESR_TELD, 1 << 8   @ bitWidth 1 (Transfer Error Link Data These bit is  set by HW, in case of a transfer error while reading  the block link data structure. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C4ESR_TEMD, 1 << 9   @ bitWidth 1 (Transfer Error Mask Data These bit is  set by HW, in case of a transfer error while writing  the Mask Data. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C4ESR_ASE, 1 << 10   @ bitWidth 1 (Address/Size Error These bit is set by  HW, when the programmed address is not aligned with  the data size. TED will indicate whether the problem  is on the source or destination. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C4ESR_BSE, 1 << 11   @ bitWidth 1 (Block Size Error These bit is set by HW,  when the block size is not an integer multiple of the  data size either for source or destination. TED will  indicate whether the problem is on the source or  destination. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
 
    .equ MDMA_MDMA_C4CR, MDMA_BASE + 0x14C @ (This register is used to control the  concerned channel.) 
        .equ MDMA_MDMA_C4CR_EN, 1 << 0   @ bitWidth 1 (channel enable)  
        .equ MDMA_MDMA_C4CR_TEIE, 1 << 1   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C4CR_CTCIE, 1 << 2   @ bitWidth 1 (Channel Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C4CR_BRTIE, 1 << 3   @ bitWidth 1 (Block Repeat transfer interrupt enable  This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C4CR_BTIE, 1 << 4   @ bitWidth 1 (Block Transfer interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C4CR_TCIE, 1 << 5   @ bitWidth 1 (buffer Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C4CR_PL_Shift, 6   @ bitWidth 2 (Priority level These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0.)  
        .equ MDMA_MDMA_C4CR_BEX, 1 << 12   @ bitWidth 1 (byte Endianness exchange)  
        .equ MDMA_MDMA_C4CR_HEX, 1 << 13   @ bitWidth 1 (Half word Endianes  exchange)  
        .equ MDMA_MDMA_C4CR_WEX, 1 << 14   @ bitWidth 1 (Word Endianness exchange)  
        .equ MDMA_MDMA_C4CR_SWRQ, 1 << 16   @ bitWidth 1 (SW ReQuest Writing a 1 into this bit  sets the CRQAx in MDMA_ISRy register, activating the  request on Channel x Note: Either the whole CxCR  register or the 8-bit/16-bit register @ Address  offset: 0x4E + 0x40 chn may be used for SWRQ  activation. In case of a SW request, acknowledge is  not generated neither HW signal, nor CxMAR write  access.)  
 
    .equ MDMA_MDMA_C4TCR, MDMA_BASE + 0x150 @ (This register is used to configure the  concerned channel.) 
        .equ MDMA_MDMA_C4TCR_SINC_Shift, 0   @ bitWidth 2 (Source increment mode These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0 Note: When source is  AHB SBUS=1, SINC = 00 is forbidden. In Linked List  Mode, at the end of a block single or last block in  repeated block transfer mode, this register will be  loaded from memory from address given by current  LAR[31:0] + 0x00.)  
        .equ MDMA_MDMA_C4TCR_DINC_Shift, 2   @ bitWidth 2 (Destination increment mode These bits  are set and cleared by software. These bits are  protected and can be written only if EN is 0 Note:  When destination is AHB DBUS=1, DINC = 00 is  forbidden.)  
        .equ MDMA_MDMA_C4TCR_SSIZE_Shift, 4   @ bitWidth 2 (Source data size These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0 Note: If a value of 11 is  programmed for the TCM access/AHB port, a transfer  error will occur TEIF bit set If SINCOS &lt;  SSIZE and SINC &#8800; 00, the result will be  unpredictable. Note: SSIZE = 11 double-word is  forbidden when source is TCM/AHB bus  SBUS=1.)  
        .equ MDMA_MDMA_C4TCR_DSIZE_Shift, 6   @ bitWidth 2 (Destination data size These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0. Note: If a value of  11 is programmed for the TCM access/AHB port, a  transfer error will occur TEIF bit set If DINCOS  &lt; DSIZE and DINC &#8800; 00, the result  will be unpredictable. Note: DSIZE = 11 double-word  is forbidden when destination is TCM/AHB bus  DBUS=1.)  
        .equ MDMA_MDMA_C4TCR_SINCOS_Shift, 8   @ bitWidth 2 (source increment offset  size)  
        .equ MDMA_MDMA_C4TCR_DINCOS_Shift, 10   @ bitWidth 2 (Destination increment  offset)  
        .equ MDMA_MDMA_C4TCR_SBURST_Shift, 12   @ bitWidth 3 (source burst transfer  configuration)  
        .equ MDMA_MDMA_C4TCR_DBURST_Shift, 15   @ bitWidth 3 (Destination burst transfer  configuration)  
        .equ MDMA_MDMA_C4TCR_TLEN_Shift, 18   @ bitWidth 7 (buffer transfer lengh)  
        .equ MDMA_MDMA_C4TCR_PKE, 1 << 25   @ bitWidth 1 (PacK Enable These bit is set and cleared  by software. If the Source Size is smaller than the  destination, it will be padded according to the PAM  value. If the Source data size is larger than the  destination one, it will be truncated. The alignment  will be done according to the PAM[0] value. This bit  is protected and can be written only if EN is  0)  
        .equ MDMA_MDMA_C4TCR_PAM_Shift, 26   @ bitWidth 2 (Padding/Alignement Mode These bits are  set and cleared by software. Case 1: Source data size  smaller than destination data size - 3 options are  valid. Case 2: Source data size larger than  destination data size. The remainder part is  discarded. When PKE = 1 or DSIZE=SSIZE, these bits  are ignored. These bits are protected and can be  written only if EN is 0)  
        .equ MDMA_MDMA_C4TCR_TRGM_Shift, 28   @ bitWidth 2 (Trigger Mode These bits are set and  cleared by software. Note: If TRGM is 11 for the  current block, all the values loaded at the end of  the current block through the linked list mechanism  must keep the same value TRGM=11 and the same SWRM  value, otherwise the result is undefined. These bits  are protected and can be written only if EN is  0.)  
        .equ MDMA_MDMA_C4TCR_SWRM, 1 << 30   @ bitWidth 1 (SW Request Mode This bit is set and  cleared by software. If a HW or SW request is  currently active, the bit change will be delayed  until the current transfer is completed. If the CxMAR  contains a valid address, the CxMDR value will also  be written @ CxMAR address. This bit is protected and  can be written only if EN is 0.)  
        .equ MDMA_MDMA_C4TCR_BWM, 1 << 31   @ bitWidth 1 (Bufferable Write Mode This bit is set  and cleared by software. This bit is protected and  can be written only if EN is 0. Note: All MDMA  destination accesses are non-cacheable.)  
 
    .equ MDMA_MDMA_C4BNDTR, MDMA_BASE + 0x154 @ (MDMA Channel x block number of data  register) 
        .equ MDMA_MDMA_C4BNDTR_BNDT_Shift, 0   @ bitWidth 17 (block number of data to  transfer)  
        .equ MDMA_MDMA_C4BNDTR_BRSUM, 1 << 18   @ bitWidth 1 (Block Repeat Source address Update Mode  These bits are protected and can be written only if  EN is 0.)  
        .equ MDMA_MDMA_C4BNDTR_BRDUM, 1 << 19   @ bitWidth 1 (Block Repeat Destination address Update  Mode These bits are protected and can be written only  if EN is 0.)  
        .equ MDMA_MDMA_C4BNDTR_BRC_Shift, 20   @ bitWidth 12 (Block Repeat Count This field contains  the number of repetitions of the current block 0 to  4095. When the channel is enabled, this register is  read-only, indicating the remaining number of blocks,  excluding the current one. This register decrements  after each complete block transfer. Once the last  block transfer has completed, this register can  either stay at zero or be reloaded automatically from  memory in Linked List mode - i.e. Link Address  valid. These bits are protected and can be written  only if EN is 0.)  
 
    .equ MDMA_MDMA_C4SAR, MDMA_BASE + 0x158 @ (MDMA channel x source address  register) 
        .equ MDMA_MDMA_C4SAR_SAR_Shift, 0   @ bitWidth 32 (source adr base)  
 
    .equ MDMA_MDMA_C4DAR, MDMA_BASE + 0x15C @ (MDMA channel x destination address  register) 
        .equ MDMA_MDMA_C4DAR_DAR_Shift, 0   @ bitWidth 32 (Destination adr base)  
 
    .equ MDMA_MDMA_C4BRUR, MDMA_BASE + 0x160 @ (MDMA channel x Block Repeat address Update  register) 
        .equ MDMA_MDMA_C4BRUR_SUV_Shift, 0   @ bitWidth 16 (source adresse update  value)  
        .equ MDMA_MDMA_C4BRUR_DUV_Shift, 16   @ bitWidth 16 (destination address update)  
 
    .equ MDMA_MDMA_C4LAR, MDMA_BASE + 0x164 @ (MDMA channel x Link Address  register) 
        .equ MDMA_MDMA_C4LAR_LAR_Shift, 0   @ bitWidth 32 (Link address register)  
 
    .equ MDMA_MDMA_C4TBR, MDMA_BASE + 0x168 @ (MDMA channel x Trigger and Bus selection  Register) 
        .equ MDMA_MDMA_C4TBR_TSEL_Shift, 0   @ bitWidth 6 (Trigger selection)  
        .equ MDMA_MDMA_C4TBR_SBUS, 1 << 16   @ bitWidth 1 (Source BUS select This bit is protected  and can be written only if EN is 0.)  
        .equ MDMA_MDMA_C4TBR_DBUS, 1 << 17   @ bitWidth 1 (Destination BUS slect This bit is  protected and can be written only if EN is  0.)  
 
    .equ MDMA_MDMA_C4MAR, MDMA_BASE + 0x170 @ (MDMA channel x Mask address  register) 
        .equ MDMA_MDMA_C4MAR_MAR_Shift, 0   @ bitWidth 32 (Mask address)  
 
    .equ MDMA_MDMA_C4MDR, MDMA_BASE + 0x174 @ (MDMA channel x Mask Data  register) 
        .equ MDMA_MDMA_C4MDR_MDR_Shift, 0   @ bitWidth 32 (Mask data)  
 
    .equ MDMA_MDMA_C5ISR, MDMA_BASE + 0x180 @ (MDMA channel x interrupt/status  register) 
        .equ MDMA_MDMA_C5ISR_TEIF5, 1 << 0   @ bitWidth 1 (Channel x transfer error interrupt flag  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCRy register.)  
        .equ MDMA_MDMA_C5ISR_CTCIF5, 1 << 1   @ bitWidth 1 (Channel x Channel Transfer Complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register. CTC is set when the  last block was transferred and the channel has been  automatically disabled. CTC is also set when the  channel is suspended, as a result of writing EN bit  to 0.)  
        .equ MDMA_MDMA_C5ISR_BRTIF5, 1 << 2   @ bitWidth 1 (Channel x block repeat transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C5ISR_BTIF5, 1 << 3   @ bitWidth 1 (Channel x block transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C5ISR_TCIF5, 1 << 4   @ bitWidth 1 (channel x buffer transfer  complete)  
        .equ MDMA_MDMA_C5ISR_CRQA5, 1 << 16   @ bitWidth 1 (channel x request active  flag)  
 
    .equ MDMA_MDMA_C5IFCR, MDMA_BASE + 0x184 @ (MDMA channel x interrupt flag clear  register) 
        .equ MDMA_MDMA_C5IFCR_CTEIF5, 1 << 0   @ bitWidth 1 (Channel x clear transfer error interrupt  flag Writing a 1 into this bit clears TEIFx in the  MDMA_ISRy register)  
        .equ MDMA_MDMA_C5IFCR_CCTCIF5, 1 << 1   @ bitWidth 1 (Clear Channel transfer complete  interrupt flag for channel x Writing a 1 into this  bit clears CTCIFx in the MDMA_ISRy  register)  
        .equ MDMA_MDMA_C5IFCR_CBRTIF5, 1 << 2   @ bitWidth 1 (Channel x clear block repeat transfer  complete interrupt flag Writing a 1 into this bit  clears BRTIFx in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C5IFCR_CBTIF5, 1 << 3   @ bitWidth 1 (Channel x Clear block transfer complete  interrupt flag Writing a 1 into this bit clears BTIFx  in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C5IFCR_CLTCIF5, 1 << 4   @ bitWidth 1 (CLear buffer Transfer Complete Interrupt  Flag for channel x Writing a 1 into this bit clears  TCIFx in the MDMA_ISRy register)  
 
    .equ MDMA_MDMA_C5ESR, MDMA_BASE + 0x188 @ (MDMA Channel x error status  register) 
        .equ MDMA_MDMA_C5ESR_TEA_Shift, 0   @ bitWidth 7 (Transfer Error Address These bits are  set and cleared by HW, in case of an MDMA data  transfer error. It is used in conjunction with TED.  This field indicates the 7 LSBits of the address  which generated a transfer/access error. It may be  used by SW to retrieve the failing address, by adding  this value truncated to the buffer transfer length  size to the current SAR/DAR value. Note: The SAR/DAR  current value doesnt reflect this last address due to  the FIFO management system. The SAR/DAR are only  updated at the end of a buffer transfer of TLEN+1  bytes. Note: It is not set in case of a link data  error.)  
        .equ MDMA_MDMA_C5ESR_TED, 1 << 7   @ bitWidth 1 (Transfer Error Direction These bit is  set and cleared by HW, in case of an MDMA data  transfer error.)  
        .equ MDMA_MDMA_C5ESR_TELD, 1 << 8   @ bitWidth 1 (Transfer Error Link Data These bit is  set by HW, in case of a transfer error while reading  the block link data structure. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C5ESR_TEMD, 1 << 9   @ bitWidth 1 (Transfer Error Mask Data These bit is  set by HW, in case of a transfer error while writing  the Mask Data. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C5ESR_ASE, 1 << 10   @ bitWidth 1 (Address/Size Error These bit is set by  HW, when the programmed address is not aligned with  the data size. TED will indicate whether the problem  is on the source or destination. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C5ESR_BSE, 1 << 11   @ bitWidth 1 (Block Size Error These bit is set by HW,  when the block size is not an integer multiple of the  data size either for source or destination. TED will  indicate whether the problem is on the source or  destination. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
 
    .equ MDMA_MDMA_C5CR, MDMA_BASE + 0x18C @ (This register is used to control the  concerned channel.) 
        .equ MDMA_MDMA_C5CR_EN, 1 << 0   @ bitWidth 1 (channel enable)  
        .equ MDMA_MDMA_C5CR_TEIE, 1 << 1   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C5CR_CTCIE, 1 << 2   @ bitWidth 1 (Channel Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C5CR_BRTIE, 1 << 3   @ bitWidth 1 (Block Repeat transfer interrupt enable  This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C5CR_BTIE, 1 << 4   @ bitWidth 1 (Block Transfer interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C5CR_TCIE, 1 << 5   @ bitWidth 1 (buffer Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C5CR_PL_Shift, 6   @ bitWidth 2 (Priority level These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0.)  
        .equ MDMA_MDMA_C5CR_BEX, 1 << 12   @ bitWidth 1 (byte Endianness exchange)  
        .equ MDMA_MDMA_C5CR_HEX, 1 << 13   @ bitWidth 1 (Half word Endianes  exchange)  
        .equ MDMA_MDMA_C5CR_WEX, 1 << 14   @ bitWidth 1 (Word Endianness exchange)  
        .equ MDMA_MDMA_C5CR_SWRQ, 1 << 16   @ bitWidth 1 (SW ReQuest Writing a 1 into this bit  sets the CRQAx in MDMA_ISRy register, activating the  request on Channel x Note: Either the whole CxCR  register or the 8-bit/16-bit register @ Address  offset: 0x4E + 0x40 chn may be used for SWRQ  activation. In case of a SW request, acknowledge is  not generated neither HW signal, nor CxMAR write  access.)  
 
    .equ MDMA_MDMA_C5TCR, MDMA_BASE + 0x190 @ (This register is used to configure the  concerned channel.) 
        .equ MDMA_MDMA_C5TCR_SINC_Shift, 0   @ bitWidth 2 (Source increment mode These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0 Note: When source is  AHB SBUS=1, SINC = 00 is forbidden. In Linked List  Mode, at the end of a block single or last block in  repeated block transfer mode, this register will be  loaded from memory from address given by current  LAR[31:0] + 0x00.)  
        .equ MDMA_MDMA_C5TCR_DINC_Shift, 2   @ bitWidth 2 (Destination increment mode These bits  are set and cleared by software. These bits are  protected and can be written only if EN is 0 Note:  When destination is AHB DBUS=1, DINC = 00 is  forbidden.)  
        .equ MDMA_MDMA_C5TCR_SSIZE_Shift, 4   @ bitWidth 2 (Source data size These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0 Note: If a value of 11 is  programmed for the TCM access/AHB port, a transfer  error will occur TEIF bit set If SINCOS &lt;  SSIZE and SINC &#8800; 00, the result will be  unpredictable. Note: SSIZE = 11 double-word is  forbidden when source is TCM/AHB bus  SBUS=1.)  
        .equ MDMA_MDMA_C5TCR_DSIZE_Shift, 6   @ bitWidth 2 (Destination data size These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0. Note: If a value of  11 is programmed for the TCM access/AHB port, a  transfer error will occur TEIF bit set If DINCOS  &lt; DSIZE and DINC &#8800; 00, the result  will be unpredictable. Note: DSIZE = 11 double-word  is forbidden when destination is TCM/AHB bus  DBUS=1.)  
        .equ MDMA_MDMA_C5TCR_SINCOS_Shift, 8   @ bitWidth 2 (source increment offset  size)  
        .equ MDMA_MDMA_C5TCR_DINCOS_Shift, 10   @ bitWidth 2 (Destination increment  offset)  
        .equ MDMA_MDMA_C5TCR_SBURST_Shift, 12   @ bitWidth 3 (source burst transfer  configuration)  
        .equ MDMA_MDMA_C5TCR_DBURST_Shift, 15   @ bitWidth 3 (Destination burst transfer  configuration)  
        .equ MDMA_MDMA_C5TCR_TLEN_Shift, 18   @ bitWidth 7 (buffer transfer lengh)  
        .equ MDMA_MDMA_C5TCR_PKE, 1 << 25   @ bitWidth 1 (PacK Enable These bit is set and cleared  by software. If the Source Size is smaller than the  destination, it will be padded according to the PAM  value. If the Source data size is larger than the  destination one, it will be truncated. The alignment  will be done according to the PAM[0] value. This bit  is protected and can be written only if EN is  0)  
        .equ MDMA_MDMA_C5TCR_PAM_Shift, 26   @ bitWidth 2 (Padding/Alignement Mode These bits are  set and cleared by software. Case 1: Source data size  smaller than destination data size - 3 options are  valid. Case 2: Source data size larger than  destination data size. The remainder part is  discarded. When PKE = 1 or DSIZE=SSIZE, these bits  are ignored. These bits are protected and can be  written only if EN is 0)  
        .equ MDMA_MDMA_C5TCR_TRGM_Shift, 28   @ bitWidth 2 (Trigger Mode These bits are set and  cleared by software. Note: If TRGM is 11 for the  current block, all the values loaded at the end of  the current block through the linked list mechanism  must keep the same value TRGM=11 and the same SWRM  value, otherwise the result is undefined. These bits  are protected and can be written only if EN is  0.)  
        .equ MDMA_MDMA_C5TCR_SWRM, 1 << 30   @ bitWidth 1 (SW Request Mode This bit is set and  cleared by software. If a HW or SW request is  currently active, the bit change will be delayed  until the current transfer is completed. If the CxMAR  contains a valid address, the CxMDR value will also  be written @ CxMAR address. This bit is protected and  can be written only if EN is 0.)  
        .equ MDMA_MDMA_C5TCR_BWM, 1 << 31   @ bitWidth 1 (Bufferable Write Mode This bit is set  and cleared by software. This bit is protected and  can be written only if EN is 0. Note: All MDMA  destination accesses are non-cacheable.)  
 
    .equ MDMA_MDMA_C5BNDTR, MDMA_BASE + 0x194 @ (MDMA Channel x block number of data  register) 
        .equ MDMA_MDMA_C5BNDTR_BNDT_Shift, 0   @ bitWidth 17 (block number of data to  transfer)  
        .equ MDMA_MDMA_C5BNDTR_BRSUM, 1 << 18   @ bitWidth 1 (Block Repeat Source address Update Mode  These bits are protected and can be written only if  EN is 0.)  
        .equ MDMA_MDMA_C5BNDTR_BRDUM, 1 << 19   @ bitWidth 1 (Block Repeat Destination address Update  Mode These bits are protected and can be written only  if EN is 0.)  
        .equ MDMA_MDMA_C5BNDTR_BRC_Shift, 20   @ bitWidth 12 (Block Repeat Count This field contains  the number of repetitions of the current block 0 to  4095. When the channel is enabled, this register is  read-only, indicating the remaining number of blocks,  excluding the current one. This register decrements  after each complete block transfer. Once the last  block transfer has completed, this register can  either stay at zero or be reloaded automatically from  memory in Linked List mode - i.e. Link Address  valid. These bits are protected and can be written  only if EN is 0.)  
 
    .equ MDMA_MDMA_C5SAR, MDMA_BASE + 0x198 @ (MDMA channel x source address  register) 
        .equ MDMA_MDMA_C5SAR_SAR_Shift, 0   @ bitWidth 32 (source adr base)  
 
    .equ MDMA_MDMA_C5DAR, MDMA_BASE + 0x19C @ (MDMA channel x destination address  register) 
        .equ MDMA_MDMA_C5DAR_DAR_Shift, 0   @ bitWidth 32 (Destination adr base)  
 
    .equ MDMA_MDMA_C5BRUR, MDMA_BASE + 0x1A0 @ (MDMA channel x Block Repeat address Update  register) 
        .equ MDMA_MDMA_C5BRUR_SUV_Shift, 0   @ bitWidth 16 (source adresse update  value)  
        .equ MDMA_MDMA_C5BRUR_DUV_Shift, 16   @ bitWidth 16 (destination address update)  
 
    .equ MDMA_MDMA_C5LAR, MDMA_BASE + 0x1A4 @ (MDMA channel x Link Address  register) 
        .equ MDMA_MDMA_C5LAR_LAR_Shift, 0   @ bitWidth 32 (Link address register)  
 
    .equ MDMA_MDMA_C5TBR, MDMA_BASE + 0x1A8 @ (MDMA channel x Trigger and Bus selection  Register) 
        .equ MDMA_MDMA_C5TBR_TSEL_Shift, 0   @ bitWidth 6 (Trigger selection)  
        .equ MDMA_MDMA_C5TBR_SBUS, 1 << 16   @ bitWidth 1 (Source BUS select This bit is protected  and can be written only if EN is 0.)  
        .equ MDMA_MDMA_C5TBR_DBUS, 1 << 17   @ bitWidth 1 (Destination BUS slect This bit is  protected and can be written only if EN is  0.)  
 
    .equ MDMA_MDMA_C5MAR, MDMA_BASE + 0x1B0 @ (MDMA channel x Mask address  register) 
        .equ MDMA_MDMA_C5MAR_MAR_Shift, 0   @ bitWidth 32 (Mask address)  
 
    .equ MDMA_MDMA_C5MDR, MDMA_BASE + 0x1B4 @ (MDMA channel x Mask Data  register) 
        .equ MDMA_MDMA_C5MDR_MDR_Shift, 0   @ bitWidth 32 (Mask data)  
 
    .equ MDMA_MDMA_C6ISR, MDMA_BASE + 0x1C0 @ (MDMA channel x interrupt/status  register) 
        .equ MDMA_MDMA_C6ISR_TEIF6, 1 << 0   @ bitWidth 1 (Channel x transfer error interrupt flag  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCRy register.)  
        .equ MDMA_MDMA_C6ISR_CTCIF6, 1 << 1   @ bitWidth 1 (Channel x Channel Transfer Complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register. CTC is set when the  last block was transferred and the channel has been  automatically disabled. CTC is also set when the  channel is suspended, as a result of writing EN bit  to 0.)  
        .equ MDMA_MDMA_C6ISR_BRTIF6, 1 << 2   @ bitWidth 1 (Channel x block repeat transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C6ISR_BTIF6, 1 << 3   @ bitWidth 1 (Channel x block transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C6ISR_TCIF6, 1 << 4   @ bitWidth 1 (channel x buffer transfer  complete)  
        .equ MDMA_MDMA_C6ISR_CRQA6, 1 << 16   @ bitWidth 1 (channel x request active  flag)  
 
    .equ MDMA_MDMA_C6IFCR, MDMA_BASE + 0x1C4 @ (MDMA channel x interrupt flag clear  register) 
        .equ MDMA_MDMA_C6IFCR_CTEIF6, 1 << 0   @ bitWidth 1 (Channel x clear transfer error interrupt  flag Writing a 1 into this bit clears TEIFx in the  MDMA_ISRy register)  
        .equ MDMA_MDMA_C6IFCR_CCTCIF6, 1 << 1   @ bitWidth 1 (Clear Channel transfer complete  interrupt flag for channel x Writing a 1 into this  bit clears CTCIFx in the MDMA_ISRy  register)  
        .equ MDMA_MDMA_C6IFCR_CBRTIF6, 1 << 2   @ bitWidth 1 (Channel x clear block repeat transfer  complete interrupt flag Writing a 1 into this bit  clears BRTIFx in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C6IFCR_CBTIF6, 1 << 3   @ bitWidth 1 (Channel x Clear block transfer complete  interrupt flag Writing a 1 into this bit clears BTIFx  in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C6IFCR_CLTCIF6, 1 << 4   @ bitWidth 1 (CLear buffer Transfer Complete Interrupt  Flag for channel x Writing a 1 into this bit clears  TCIFx in the MDMA_ISRy register)  
 
    .equ MDMA_MDMA_C6ESR, MDMA_BASE + 0x1C8 @ (MDMA Channel x error status  register) 
        .equ MDMA_MDMA_C6ESR_TEA_Shift, 0   @ bitWidth 7 (Transfer Error Address These bits are  set and cleared by HW, in case of an MDMA data  transfer error. It is used in conjunction with TED.  This field indicates the 7 LSBits of the address  which generated a transfer/access error. It may be  used by SW to retrieve the failing address, by adding  this value truncated to the buffer transfer length  size to the current SAR/DAR value. Note: The SAR/DAR  current value doesnt reflect this last address due to  the FIFO management system. The SAR/DAR are only  updated at the end of a buffer transfer of TLEN+1  bytes. Note: It is not set in case of a link data  error.)  
        .equ MDMA_MDMA_C6ESR_TED, 1 << 7   @ bitWidth 1 (Transfer Error Direction These bit is  set and cleared by HW, in case of an MDMA data  transfer error.)  
        .equ MDMA_MDMA_C6ESR_TELD, 1 << 8   @ bitWidth 1 (Transfer Error Link Data These bit is  set by HW, in case of a transfer error while reading  the block link data structure. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C6ESR_TEMD, 1 << 9   @ bitWidth 1 (Transfer Error Mask Data These bit is  set by HW, in case of a transfer error while writing  the Mask Data. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C6ESR_ASE, 1 << 10   @ bitWidth 1 (Address/Size Error These bit is set by  HW, when the programmed address is not aligned with  the data size. TED will indicate whether the problem  is on the source or destination. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C6ESR_BSE, 1 << 11   @ bitWidth 1 (Block Size Error These bit is set by HW,  when the block size is not an integer multiple of the  data size either for source or destination. TED will  indicate whether the problem is on the source or  destination. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
 
    .equ MDMA_MDMA_C6CR, MDMA_BASE + 0x1CC @ (This register is used to control the  concerned channel.) 
        .equ MDMA_MDMA_C6CR_EN, 1 << 0   @ bitWidth 1 (channel enable)  
        .equ MDMA_MDMA_C6CR_TEIE, 1 << 1   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C6CR_CTCIE, 1 << 2   @ bitWidth 1 (Channel Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C6CR_BRTIE, 1 << 3   @ bitWidth 1 (Block Repeat transfer interrupt enable  This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C6CR_BTIE, 1 << 4   @ bitWidth 1 (Block Transfer interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C6CR_TCIE, 1 << 5   @ bitWidth 1 (buffer Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C6CR_PL_Shift, 6   @ bitWidth 2 (Priority level These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0.)  
        .equ MDMA_MDMA_C6CR_BEX, 1 << 12   @ bitWidth 1 (byte Endianness exchange)  
        .equ MDMA_MDMA_C6CR_HEX, 1 << 13   @ bitWidth 1 (Half word Endianes  exchange)  
        .equ MDMA_MDMA_C6CR_WEX, 1 << 14   @ bitWidth 1 (Word Endianness exchange)  
        .equ MDMA_MDMA_C6CR_SWRQ, 1 << 16   @ bitWidth 1 (SW ReQuest Writing a 1 into this bit  sets the CRQAx in MDMA_ISRy register, activating the  request on Channel x Note: Either the whole CxCR  register or the 8-bit/16-bit register @ Address  offset: 0x4E + 0x40 chn may be used for SWRQ  activation. In case of a SW request, acknowledge is  not generated neither HW signal, nor CxMAR write  access.)  
 
    .equ MDMA_MDMA_C6TCR, MDMA_BASE + 0x1D0 @ (This register is used to configure the  concerned channel.) 
        .equ MDMA_MDMA_C6TCR_SINC_Shift, 0   @ bitWidth 2 (Source increment mode These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0 Note: When source is  AHB SBUS=1, SINC = 00 is forbidden. In Linked List  Mode, at the end of a block single or last block in  repeated block transfer mode, this register will be  loaded from memory from address given by current  LAR[31:0] + 0x00.)  
        .equ MDMA_MDMA_C6TCR_DINC_Shift, 2   @ bitWidth 2 (Destination increment mode These bits  are set and cleared by software. These bits are  protected and can be written only if EN is 0 Note:  When destination is AHB DBUS=1, DINC = 00 is  forbidden.)  
        .equ MDMA_MDMA_C6TCR_SSIZE_Shift, 4   @ bitWidth 2 (Source data size These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0 Note: If a value of 11 is  programmed for the TCM access/AHB port, a transfer  error will occur TEIF bit set If SINCOS &lt;  SSIZE and SINC &#8800; 00, the result will be  unpredictable. Note: SSIZE = 11 double-word is  forbidden when source is TCM/AHB bus  SBUS=1.)  
        .equ MDMA_MDMA_C6TCR_DSIZE_Shift, 6   @ bitWidth 2 (Destination data size These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0. Note: If a value of  11 is programmed for the TCM access/AHB port, a  transfer error will occur TEIF bit set If DINCOS  &lt; DSIZE and DINC &#8800; 00, the result  will be unpredictable. Note: DSIZE = 11 double-word  is forbidden when destination is TCM/AHB bus  DBUS=1.)  
        .equ MDMA_MDMA_C6TCR_SINCOS_Shift, 8   @ bitWidth 2 (source increment offset  size)  
        .equ MDMA_MDMA_C6TCR_DINCOS_Shift, 10   @ bitWidth 2 (Destination increment  offset)  
        .equ MDMA_MDMA_C6TCR_SBURST_Shift, 12   @ bitWidth 3 (source burst transfer  configuration)  
        .equ MDMA_MDMA_C6TCR_DBURST_Shift, 15   @ bitWidth 3 (Destination burst transfer  configuration)  
        .equ MDMA_MDMA_C6TCR_TLEN_Shift, 18   @ bitWidth 7 (buffer transfer lengh)  
        .equ MDMA_MDMA_C6TCR_PKE, 1 << 25   @ bitWidth 1 (PacK Enable These bit is set and cleared  by software. If the Source Size is smaller than the  destination, it will be padded according to the PAM  value. If the Source data size is larger than the  destination one, it will be truncated. The alignment  will be done according to the PAM[0] value. This bit  is protected and can be written only if EN is  0)  
        .equ MDMA_MDMA_C6TCR_PAM_Shift, 26   @ bitWidth 2 (Padding/Alignement Mode These bits are  set and cleared by software. Case 1: Source data size  smaller than destination data size - 3 options are  valid. Case 2: Source data size larger than  destination data size. The remainder part is  discarded. When PKE = 1 or DSIZE=SSIZE, these bits  are ignored. These bits are protected and can be  written only if EN is 0)  
        .equ MDMA_MDMA_C6TCR_TRGM_Shift, 28   @ bitWidth 2 (Trigger Mode These bits are set and  cleared by software. Note: If TRGM is 11 for the  current block, all the values loaded at the end of  the current block through the linked list mechanism  must keep the same value TRGM=11 and the same SWRM  value, otherwise the result is undefined. These bits  are protected and can be written only if EN is  0.)  
        .equ MDMA_MDMA_C6TCR_SWRM, 1 << 30   @ bitWidth 1 (SW Request Mode This bit is set and  cleared by software. If a HW or SW request is  currently active, the bit change will be delayed  until the current transfer is completed. If the CxMAR  contains a valid address, the CxMDR value will also  be written @ CxMAR address. This bit is protected and  can be written only if EN is 0.)  
        .equ MDMA_MDMA_C6TCR_BWM, 1 << 31   @ bitWidth 1 (Bufferable Write Mode This bit is set  and cleared by software. This bit is protected and  can be written only if EN is 0. Note: All MDMA  destination accesses are non-cacheable.)  
 
    .equ MDMA_MDMA_C6BNDTR, MDMA_BASE + 0x1D4 @ (MDMA Channel x block number of data  register) 
        .equ MDMA_MDMA_C6BNDTR_BNDT_Shift, 0   @ bitWidth 17 (block number of data to  transfer)  
        .equ MDMA_MDMA_C6BNDTR_BRSUM, 1 << 18   @ bitWidth 1 (Block Repeat Source address Update Mode  These bits are protected and can be written only if  EN is 0.)  
        .equ MDMA_MDMA_C6BNDTR_BRDUM, 1 << 19   @ bitWidth 1 (Block Repeat Destination address Update  Mode These bits are protected and can be written only  if EN is 0.)  
        .equ MDMA_MDMA_C6BNDTR_BRC_Shift, 20   @ bitWidth 12 (Block Repeat Count This field contains  the number of repetitions of the current block 0 to  4095. When the channel is enabled, this register is  read-only, indicating the remaining number of blocks,  excluding the current one. This register decrements  after each complete block transfer. Once the last  block transfer has completed, this register can  either stay at zero or be reloaded automatically from  memory in Linked List mode - i.e. Link Address  valid. These bits are protected and can be written  only if EN is 0)  
 
    .equ MDMA_MDMA_C6SAR, MDMA_BASE + 0x1D8 @ (MDMA channel x source address  register) 
        .equ MDMA_MDMA_C6SAR_SAR_Shift, 0   @ bitWidth 32 (source adr base)  
 
    .equ MDMA_MDMA_C6DAR, MDMA_BASE + 0x1DC @ (MDMA channel x destination address  register) 
        .equ MDMA_MDMA_C6DAR_DAR_Shift, 0   @ bitWidth 32 (Destination adr base)  
 
    .equ MDMA_MDMA_C6BRUR, MDMA_BASE + 0x1E0 @ (MDMA channel x Block Repeat address Update  register) 
        .equ MDMA_MDMA_C6BRUR_SUV_Shift, 0   @ bitWidth 16 (source adresse update  value)  
        .equ MDMA_MDMA_C6BRUR_DUV_Shift, 16   @ bitWidth 16 (destination address update)  
 
    .equ MDMA_MDMA_C6LAR, MDMA_BASE + 0x1E4 @ (MDMA channel x Link Address  register) 
        .equ MDMA_MDMA_C6LAR_LAR_Shift, 0   @ bitWidth 32 (Link address register)  
 
    .equ MDMA_MDMA_C6TBR, MDMA_BASE + 0x1E8 @ (MDMA channel x Trigger and Bus selection  Register) 
        .equ MDMA_MDMA_C6TBR_TSEL_Shift, 0   @ bitWidth 6 (Trigger selection)  
        .equ MDMA_MDMA_C6TBR_SBUS, 1 << 16   @ bitWidth 1 (Source BUS select This bit is protected  and can be written only if EN is 0.)  
        .equ MDMA_MDMA_C6TBR_DBUS, 1 << 17   @ bitWidth 1 (Destination BUS slect This bit is  protected and can be written only if EN is  0.)  
 
    .equ MDMA_MDMA_C6MAR, MDMA_BASE + 0x1F0 @ (MDMA channel x Mask address  register) 
        .equ MDMA_MDMA_C6MAR_MAR_Shift, 0   @ bitWidth 32 (Mask address)  
 
    .equ MDMA_MDMA_C6MDR, MDMA_BASE + 0x1F4 @ (MDMA channel x Mask Data  register) 
        .equ MDMA_MDMA_C6MDR_MDR_Shift, 0   @ bitWidth 32 (Mask data)  
 
    .equ MDMA_MDMA_C7ISR, MDMA_BASE + 0x200 @ (MDMA channel x interrupt/status  register) 
        .equ MDMA_MDMA_C7ISR_TEIF7, 1 << 0   @ bitWidth 1 (Channel x transfer error interrupt flag  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCRy register.)  
        .equ MDMA_MDMA_C7ISR_CTCIF7, 1 << 1   @ bitWidth 1 (Channel x Channel Transfer Complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register. CTC is set when the  last block was transferred and the channel has been  automatically disabled. CTC is also set when the  channel is suspended, as a result of writing EN bit  to 0.)  
        .equ MDMA_MDMA_C7ISR_BRTIF7, 1 << 2   @ bitWidth 1 (Channel x block repeat transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C7ISR_BTIF7, 1 << 3   @ bitWidth 1 (Channel x block transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C7ISR_TCIF7, 1 << 4   @ bitWidth 1 (channel x buffer transfer  complete)  
        .equ MDMA_MDMA_C7ISR_CRQA7, 1 << 16   @ bitWidth 1 (channel x request active  flag)  
 
    .equ MDMA_MDMA_C7IFCR, MDMA_BASE + 0x204 @ (MDMA channel x interrupt flag clear  register) 
        .equ MDMA_MDMA_C7IFCR_CTEIF7, 1 << 0   @ bitWidth 1 (Channel x clear transfer error interrupt  flag Writing a 1 into this bit clears TEIFx in the  MDMA_ISRy register)  
        .equ MDMA_MDMA_C7IFCR_CCTCIF7, 1 << 1   @ bitWidth 1 (Clear Channel transfer complete  interrupt flag for channel x Writing a 1 into this  bit clears CTCIFx in the MDMA_ISRy  register)  
        .equ MDMA_MDMA_C7IFCR_CBRTIF7, 1 << 2   @ bitWidth 1 (Channel x clear block repeat transfer  complete interrupt flag Writing a 1 into this bit  clears BRTIFx in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C7IFCR_CBTIF7, 1 << 3   @ bitWidth 1 (Channel x Clear block transfer complete  interrupt flag Writing a 1 into this bit clears BTIFx  in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C7IFCR_CLTCIF7, 1 << 4   @ bitWidth 1 (CLear buffer Transfer Complete Interrupt  Flag for channel x Writing a 1 into this bit clears  TCIFx in the MDMA_ISRy register)  
 
    .equ MDMA_MDMA_C7ESR, MDMA_BASE + 0x208 @ (MDMA Channel x error status  register) 
        .equ MDMA_MDMA_C7ESR_TEA_Shift, 0   @ bitWidth 7 (Transfer Error Address These bits are  set and cleared by HW, in case of an MDMA data  transfer error. It is used in conjunction with TED.  This field indicates the 7 LSBits of the address  which generated a transfer/access error. It may be  used by SW to retrieve the failing address, by adding  this value truncated to the buffer transfer length  size to the current SAR/DAR value. Note: The SAR/DAR  current value doesnt reflect this last address due to  the FIFO management system. The SAR/DAR are only  updated at the end of a buffer transfer of TLEN+1  bytes. Note: It is not set in case of a link data  error.)  
        .equ MDMA_MDMA_C7ESR_TED, 1 << 7   @ bitWidth 1 (Transfer Error Direction These bit is  set and cleared by HW, in case of an MDMA data  transfer error.)  
        .equ MDMA_MDMA_C7ESR_TELD, 1 << 8   @ bitWidth 1 (Transfer Error Link Data These bit is  set by HW, in case of a transfer error while reading  the block link data structure. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C7ESR_TEMD, 1 << 9   @ bitWidth 1 (Transfer Error Mask Data These bit is  set by HW, in case of a transfer error while writing  the Mask Data. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C7ESR_ASE, 1 << 10   @ bitWidth 1 (Address/Size Error These bit is set by  HW, when the programmed address is not aligned with  the data size. TED will indicate whether the problem  is on the source or destination. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C7ESR_BSE, 1 << 11   @ bitWidth 1 (Block Size Error These bit is set by HW,  when the block size is not an integer multiple of the  data size either for source or destination. TED will  indicate whether the problem is on the source or  destination. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
 
    .equ MDMA_MDMA_C7CR, MDMA_BASE + 0x20C @ (This register is used to control the  concerned channel.) 
        .equ MDMA_MDMA_C7CR_EN, 1 << 0   @ bitWidth 1 (channel enable)  
        .equ MDMA_MDMA_C7CR_TEIE, 1 << 1   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C7CR_CTCIE, 1 << 2   @ bitWidth 1 (Channel Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C7CR_BRTIE, 1 << 3   @ bitWidth 1 (Block Repeat transfer interrupt enable  This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C7CR_BTIE, 1 << 4   @ bitWidth 1 (Block Transfer interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C7CR_TCIE, 1 << 5   @ bitWidth 1 (buffer Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C7CR_PL_Shift, 6   @ bitWidth 2 (Priority level These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0.)  
        .equ MDMA_MDMA_C7CR_BEX, 1 << 12   @ bitWidth 1 (byte Endianness exchange)  
        .equ MDMA_MDMA_C7CR_HEX, 1 << 13   @ bitWidth 1 (Half word Endianes  exchange)  
        .equ MDMA_MDMA_C7CR_WEX, 1 << 14   @ bitWidth 1 (Word Endianness exchange)  
        .equ MDMA_MDMA_C7CR_SWRQ, 1 << 16   @ bitWidth 1 (SW ReQuest Writing a 1 into this bit  sets the CRQAx in MDMA_ISRy register, activating the  request on Channel x Note: Either the whole CxCR  register or the 8-bit/16-bit register @ Address  offset: 0x4E + 0x40 chn may be used for SWRQ  activation. In case of a SW request, acknowledge is  not generated neither HW signal, nor CxMAR write  access.)  
 
    .equ MDMA_MDMA_C7TCR, MDMA_BASE + 0x210 @ (This register is used to configure the  concerned channel.) 
        .equ MDMA_MDMA_C7TCR_SINC_Shift, 0   @ bitWidth 2 (Source increment mode These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0 Note: When source is  AHB SBUS=1, SINC = 00 is forbidden. In Linked List  Mode, at the end of a block single or last block in  repeated block transfer mode, this register will be  loaded from memory from address given by current  LAR[31:0] + 0x00.)  
        .equ MDMA_MDMA_C7TCR_DINC_Shift, 2   @ bitWidth 2 (Destination increment mode These bits  are set and cleared by software. These bits are  protected and can be written only if EN is 0 Note:  When destination is AHB DBUS=1, DINC = 00 is  forbidden.)  
        .equ MDMA_MDMA_C7TCR_SSIZE_Shift, 4   @ bitWidth 2 (Source data size These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0 Note: If a value of 11 is  programmed for the TCM access/AHB port, a transfer  error will occur TEIF bit set If SINCOS &lt;  SSIZE and SINC &#8800; 00, the result will be  unpredictable. Note: SSIZE = 11 double-word is  forbidden when source is TCM/AHB bus  SBUS=1.)  
        .equ MDMA_MDMA_C7TCR_DSIZE_Shift, 6   @ bitWidth 2 (Destination data size These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0. Note: If a value of  11 is programmed for the TCM access/AHB port, a  transfer error will occur TEIF bit set If DINCOS  &lt; DSIZE and DINC &#8800; 00, the result  will be unpredictable. Note: DSIZE = 11 double-word  is forbidden when destination is TCM/AHB bus  DBUS=1.)  
        .equ MDMA_MDMA_C7TCR_SINCOS_Shift, 8   @ bitWidth 2 (source increment offset  size)  
        .equ MDMA_MDMA_C7TCR_DINCOS_Shift, 10   @ bitWidth 2 (Destination increment  offset)  
        .equ MDMA_MDMA_C7TCR_SBURST_Shift, 12   @ bitWidth 3 (source burst transfer  configuration)  
        .equ MDMA_MDMA_C7TCR_DBURST_Shift, 15   @ bitWidth 3 (Destination burst transfer  configuration)  
        .equ MDMA_MDMA_C7TCR_TLEN_Shift, 18   @ bitWidth 7 (buffer transfer lengh)  
        .equ MDMA_MDMA_C7TCR_PKE, 1 << 25   @ bitWidth 1 (PacK Enable These bit is set and cleared  by software. If the Source Size is smaller than the  destination, it will be padded according to the PAM  value. If the Source data size is larger than the  destination one, it will be truncated. The alignment  will be done according to the PAM[0] value. This bit  is protected and can be written only if EN is  0)  
        .equ MDMA_MDMA_C7TCR_PAM_Shift, 26   @ bitWidth 2 (Padding/Alignement Mode These bits are  set and cleared by software. Case 1: Source data size  smaller than destination data size - 3 options are  valid. Case 2: Source data size larger than  destination data size. The remainder part is  discarded. When PKE = 1 or DSIZE=SSIZE, these bits  are ignored. These bits are protected and can be  written only if EN is 0)  
        .equ MDMA_MDMA_C7TCR_TRGM_Shift, 28   @ bitWidth 2 (Trigger Mode These bits are set and  cleared by software. Note: If TRGM is 11 for the  current block, all the values loaded at the end of  the current block through the linked list mechanism  must keep the same value TRGM=11 and the same SWRM  value, otherwise the result is undefined. These bits  are protected and can be written only if EN is  0.)  
        .equ MDMA_MDMA_C7TCR_SWRM, 1 << 30   @ bitWidth 1 (SW Request Mode This bit is set and  cleared by software. If a HW or SW request is  currently active, the bit change will be delayed  until the current transfer is completed. If the CxMAR  contains a valid address, the CxMDR value will also  be written @ CxMAR address. This bit is protected and  can be written only if EN is 0.)  
        .equ MDMA_MDMA_C7TCR_BWM, 1 << 31   @ bitWidth 1 (Bufferable Write Mode This bit is set  and cleared by software. This bit is protected and  can be written only if EN is 0. Note: All MDMA  destination accesses are non-cacheable.)  
 
    .equ MDMA_MDMA_C7BNDTR, MDMA_BASE + 0x214 @ (MDMA Channel x block number of data  register) 
        .equ MDMA_MDMA_C7BNDTR_BNDT_Shift, 0   @ bitWidth 17 (block number of data to  transfer)  
        .equ MDMA_MDMA_C7BNDTR_BRSUM, 1 << 18   @ bitWidth 1 (Block Repeat Source address Update Mode  These bits are protected and can be written only if  EN is 0.)  
        .equ MDMA_MDMA_C7BNDTR_BRDUM, 1 << 19   @ bitWidth 1 (Block Repeat Destination address Update  Mode These bits are protected and can be written only  if EN is 0.)  
        .equ MDMA_MDMA_C7BNDTR_BRC_Shift, 20   @ bitWidth 12 (Block Repeat Count This field contains  the number of repetitions of the current block 0 to  4095. When the channel is enabled, this register is  read-only, indicating the remaining number of blocks,  excluding the current one. This register decrements  after each complete block transfer. Once the last  block transfer has completed, this register can  either stay at zero or be reloaded automatically from  memory in Linked List mode - i.e. Link Address  valid. These bits are protected and can be written  only if EN is 0.)  
 
    .equ MDMA_MDMA_C7SAR, MDMA_BASE + 0x218 @ (MDMA channel x source address  register) 
        .equ MDMA_MDMA_C7SAR_SAR_Shift, 0   @ bitWidth 32 (source adr base)  
 
    .equ MDMA_MDMA_C7DAR, MDMA_BASE + 0x21C @ (MDMA channel x destination address  register) 
        .equ MDMA_MDMA_C7DAR_DAR_Shift, 0   @ bitWidth 32 (Destination adr base)  
 
    .equ MDMA_MDMA_C7BRUR, MDMA_BASE + 0x220 @ (MDMA channel x Block Repeat address Update  register) 
        .equ MDMA_MDMA_C7BRUR_SUV_Shift, 0   @ bitWidth 16 (source adresse update  value)  
        .equ MDMA_MDMA_C7BRUR_DUV_Shift, 16   @ bitWidth 16 (destination address update)  
 
    .equ MDMA_MDMA_C7LAR, MDMA_BASE + 0x224 @ (MDMA channel x Link Address  register) 
        .equ MDMA_MDMA_C7LAR_LAR_Shift, 0   @ bitWidth 32 (Link address register)  
 
    .equ MDMA_MDMA_C7TBR, MDMA_BASE + 0x228 @ (MDMA channel x Trigger and Bus selection  Register) 
        .equ MDMA_MDMA_C7TBR_TSEL_Shift, 0   @ bitWidth 6 (Trigger selection)  
        .equ MDMA_MDMA_C7TBR_SBUS, 1 << 16   @ bitWidth 1 (Source BUS select This bit is protected  and can be written only if EN is 0.)  
        .equ MDMA_MDMA_C7TBR_DBUS, 1 << 17   @ bitWidth 1 (Destination BUS slect This bit is  protected and can be written only if EN is  0.)  
 
    .equ MDMA_MDMA_C7MAR, MDMA_BASE + 0x230 @ (MDMA channel x Mask address  register) 
        .equ MDMA_MDMA_C7MAR_MAR_Shift, 0   @ bitWidth 32 (Mask address)  
 
    .equ MDMA_MDMA_C7MDR, MDMA_BASE + 0x234 @ (MDMA channel x Mask Data  register) 
        .equ MDMA_MDMA_C7MDR_MDR_Shift, 0   @ bitWidth 32 (Mask data)  
 
    .equ MDMA_MDMA_C8ISR, MDMA_BASE + 0x240 @ (MDMA channel x interrupt/status  register) 
        .equ MDMA_MDMA_C8ISR_TEIF8, 1 << 0   @ bitWidth 1 (Channel x transfer error interrupt flag  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCRy register.)  
        .equ MDMA_MDMA_C8ISR_CTCIF8, 1 << 1   @ bitWidth 1 (Channel x Channel Transfer Complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register. CTC is set when the  last block was transferred and the channel has been  automatically disabled. CTC is also set when the  channel is suspended, as a result of writing EN bit  to 0.)  
        .equ MDMA_MDMA_C8ISR_BRTIF8, 1 << 2   @ bitWidth 1 (Channel x block repeat transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C8ISR_BTIF8, 1 << 3   @ bitWidth 1 (Channel x block transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C8ISR_TCIF8, 1 << 4   @ bitWidth 1 (channel x buffer transfer  complete)  
        .equ MDMA_MDMA_C8ISR_CRQA8, 1 << 16   @ bitWidth 1 (channel x request active  flag)  
 
    .equ MDMA_MDMA_C8IFCR, MDMA_BASE + 0x244 @ (MDMA channel x interrupt flag clear  register) 
        .equ MDMA_MDMA_C8IFCR_CTEIF8, 1 << 0   @ bitWidth 1 (Channel x clear transfer error interrupt  flag Writing a 1 into this bit clears TEIFx in the  MDMA_ISRy register)  
        .equ MDMA_MDMA_C8IFCR_CCTCIF8, 1 << 1   @ bitWidth 1 (Clear Channel transfer complete  interrupt flag for channel x Writing a 1 into this  bit clears CTCIFx in the MDMA_ISRy  register)  
        .equ MDMA_MDMA_C8IFCR_CBRTIF8, 1 << 2   @ bitWidth 1 (Channel x clear block repeat transfer  complete interrupt flag Writing a 1 into this bit  clears BRTIFx in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C8IFCR_CBTIF8, 1 << 3   @ bitWidth 1 (Channel x Clear block transfer complete  interrupt flag Writing a 1 into this bit clears BTIFx  in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C8IFCR_CLTCIF8, 1 << 4   @ bitWidth 1 (CLear buffer Transfer Complete Interrupt  Flag for channel x Writing a 1 into this bit clears  TCIFx in the MDMA_ISRy register)  
 
    .equ MDMA_MDMA_C8ESR, MDMA_BASE + 0x248 @ (MDMA Channel x error status  register) 
        .equ MDMA_MDMA_C8ESR_TEA_Shift, 0   @ bitWidth 7 (Transfer Error Address These bits are  set and cleared by HW, in case of an MDMA data  transfer error. It is used in conjunction with TED.  This field indicates the 7 LSBits of the address  which generated a transfer/access error. It may be  used by SW to retrieve the failing address, by adding  this value truncated to the buffer transfer length  size to the current SAR/DAR value. Note: The SAR/DAR  current value doesnt reflect this last address due to  the FIFO management system. The SAR/DAR are only  updated at the end of a buffer transfer of TLEN+1  bytes. Note: It is not set in case of a link data  error.)  
        .equ MDMA_MDMA_C8ESR_TED, 1 << 7   @ bitWidth 1 (Transfer Error Direction These bit is  set and cleared by HW, in case of an MDMA data  transfer error.)  
        .equ MDMA_MDMA_C8ESR_TELD, 1 << 8   @ bitWidth 1 (Transfer Error Link Data These bit is  set by HW, in case of a transfer error while reading  the block link data structure. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C8ESR_TEMD, 1 << 9   @ bitWidth 1 (Transfer Error Mask Data These bit is  set by HW, in case of a transfer error while writing  the Mask Data. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C8ESR_ASE, 1 << 10   @ bitWidth 1 (Address/Size Error These bit is set by  HW, when the programmed address is not aligned with  the data size. TED will indicate whether the problem  is on the source or destination. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C8ESR_BSE, 1 << 11   @ bitWidth 1 (Block Size Error These bit is set by HW,  when the block size is not an integer multiple of the  data size either for source or destination. TED will  indicate whether the problem is on the source or  destination. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
 
    .equ MDMA_MDMA_C8CR, MDMA_BASE + 0x24C @ (This register is used to control the  concerned channel.) 
        .equ MDMA_MDMA_C8CR_EN, 1 << 0   @ bitWidth 1 (channel enable)  
        .equ MDMA_MDMA_C8CR_TEIE, 1 << 1   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C8CR_CTCIE, 1 << 2   @ bitWidth 1 (Channel Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C8CR_BRTIE, 1 << 3   @ bitWidth 1 (Block Repeat transfer interrupt enable  This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C8CR_BTIE, 1 << 4   @ bitWidth 1 (Block Transfer interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C8CR_TCIE, 1 << 5   @ bitWidth 1 (buffer Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C8CR_PL_Shift, 6   @ bitWidth 2 (Priority level These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0.)  
        .equ MDMA_MDMA_C8CR_BEX, 1 << 12   @ bitWidth 1 (byte Endianness exchange)  
        .equ MDMA_MDMA_C8CR_HEX, 1 << 13   @ bitWidth 1 (Half word Endianes  exchange)  
        .equ MDMA_MDMA_C8CR_WEX, 1 << 14   @ bitWidth 1 (Word Endianness exchange)  
        .equ MDMA_MDMA_C8CR_SWRQ, 1 << 16   @ bitWidth 1 (SW ReQuest Writing a 1 into this bit  sets the CRQAx in MDMA_ISRy register, activating the  request on Channel x Note: Either the whole CxCR  register or the 8-bit/16-bit register @ Address  offset: 0x4E + 0x40 chn may be used for SWRQ  activation. In case of a SW request, acknowledge is  not generated neither HW signal, nor CxMAR write  access.)  
 
    .equ MDMA_MDMA_C8TCR, MDMA_BASE + 0x250 @ (This register is used to configure the  concerned channel.) 
        .equ MDMA_MDMA_C8TCR_SINC_Shift, 0   @ bitWidth 2 (Source increment mode These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0 Note: When source is  AHB SBUS=1, SINC = 00 is forbidden. In Linked List  Mode, at the end of a block single or last block in  repeated block transfer mode, this register will be  loaded from memory from address given by current  LAR[31:0] + 0x00.)  
        .equ MDMA_MDMA_C8TCR_DINC_Shift, 2   @ bitWidth 2 (Destination increment mode These bits  are set and cleared by software. These bits are  protected and can be written only if EN is 0 Note:  When destination is AHB DBUS=1, DINC = 00 is  forbidden.)  
        .equ MDMA_MDMA_C8TCR_SSIZE_Shift, 4   @ bitWidth 2 (Source data size These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0 Note: If a value of 11 is  programmed for the TCM access/AHB port, a transfer  error will occur TEIF bit set If SINCOS &lt;  SSIZE and SINC &#8800; 00, the result will be  unpredictable. Note: SSIZE = 11 double-word is  forbidden when source is TCM/AHB bus  SBUS=1.)  
        .equ MDMA_MDMA_C8TCR_DSIZE_Shift, 6   @ bitWidth 2 (Destination data size These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0. Note: If a value of  11 is programmed for the TCM access/AHB port, a  transfer error will occur TEIF bit set If DINCOS  &lt; DSIZE and DINC &#8800; 00, the result  will be unpredictable. Note: DSIZE = 11 double-word  is forbidden when destination is TCM/AHB bus  DBUS=1.)  
        .equ MDMA_MDMA_C8TCR_SINCOS_Shift, 8   @ bitWidth 2 (source increment offset  size)  
        .equ MDMA_MDMA_C8TCR_DINCOS_Shift, 10   @ bitWidth 2 (Destination increment  offset)  
        .equ MDMA_MDMA_C8TCR_SBURST_Shift, 12   @ bitWidth 3 (source burst transfer  configuration)  
        .equ MDMA_MDMA_C8TCR_DBURST_Shift, 15   @ bitWidth 3 (Destination burst transfer  configuration)  
        .equ MDMA_MDMA_C8TCR_TLEN_Shift, 18   @ bitWidth 7 (buffer transfer lengh)  
        .equ MDMA_MDMA_C8TCR_PKE, 1 << 25   @ bitWidth 1 (PacK Enable These bit is set and cleared  by software. If the Source Size is smaller than the  destination, it will be padded according to the PAM  value. If the Source data size is larger than the  destination one, it will be truncated. The alignment  will be done according to the PAM[0] value. This bit  is protected and can be written only if EN is  0)  
        .equ MDMA_MDMA_C8TCR_PAM_Shift, 26   @ bitWidth 2 (Padding/Alignement Mode These bits are  set and cleared by software. Case 1: Source data size  smaller than destination data size - 3 options are  valid. Case 2: Source data size larger than  destination data size. The remainder part is  discarded. When PKE = 1 or DSIZE=SSIZE, these bits  are ignored. These bits are protected and can be  written only if EN is 0)  
        .equ MDMA_MDMA_C8TCR_TRGM_Shift, 28   @ bitWidth 2 (Trigger Mode These bits are set and  cleared by software. Note: If TRGM is 11 for the  current block, all the values loaded at the end of  the current block through the linked list mechanism  must keep the same value TRGM=11 and the same SWRM  value, otherwise the result is undefined. These bits  are protected and can be written only if EN is  0.)  
        .equ MDMA_MDMA_C8TCR_SWRM, 1 << 30   @ bitWidth 1 (SW Request Mode This bit is set and  cleared by software. If a HW or SW request is  currently active, the bit change will be delayed  until the current transfer is completed. If the CxMAR  contains a valid address, the CxMDR value will also  be written @ CxMAR address. This bit is protected and  can be written only if EN is 0.)  
        .equ MDMA_MDMA_C8TCR_BWM, 1 << 31   @ bitWidth 1 (Bufferable Write Mode This bit is set  and cleared by software. This bit is protected and  can be written only if EN is 0. Note: All MDMA  destination accesses are non-cacheable.)  
 
    .equ MDMA_MDMA_C8BNDTR, MDMA_BASE + 0x254 @ (MDMA Channel x block number of data  register) 
        .equ MDMA_MDMA_C8BNDTR_BNDT_Shift, 0   @ bitWidth 17 (block number of data to  transfer)  
        .equ MDMA_MDMA_C8BNDTR_BRSUM, 1 << 18   @ bitWidth 1 (Block Repeat Source address Update Mode  These bits are protected and can be written only if  EN is 0.)  
        .equ MDMA_MDMA_C8BNDTR_BRDUM, 1 << 19   @ bitWidth 1 (Block Repeat Destination address Update  Mode These bits are protected and can be written only  if EN is 0.)  
        .equ MDMA_MDMA_C8BNDTR_BRC_Shift, 20   @ bitWidth 12 (Block Repeat Count This field contains  the number of repetitions of the current block 0 to  4095. When the channel is enabled, this register is  read-only, indicating the remaining number of blocks,  excluding the current one. This register decrements  after each complete block transfer. Once the last  block transfer has completed, this register can  either stay at zero or be reloaded automatically from  memory in Linked List mode - i.e. Link Address  valid. These bits are protected and can be written  only if EN is 0.)  
 
    .equ MDMA_MDMA_C8SAR, MDMA_BASE + 0x258 @ (MDMA channel x source address  register) 
        .equ MDMA_MDMA_C8SAR_SAR_Shift, 0   @ bitWidth 32 (source adr base)  
 
    .equ MDMA_MDMA_C8DAR, MDMA_BASE + 0x25C @ (MDMA channel x destination address  register) 
        .equ MDMA_MDMA_C8DAR_DAR_Shift, 0   @ bitWidth 32 (Destination adr base)  
 
    .equ MDMA_MDMA_C8BRUR, MDMA_BASE + 0x260 @ (MDMA channel x Block Repeat address Update  register) 
        .equ MDMA_MDMA_C8BRUR_SUV_Shift, 0   @ bitWidth 16 (source adresse update  value)  
        .equ MDMA_MDMA_C8BRUR_DUV_Shift, 16   @ bitWidth 16 (destination address update)  
 
    .equ MDMA_MDMA_C8LAR, MDMA_BASE + 0x264 @ (MDMA channel x Link Address  register) 
        .equ MDMA_MDMA_C8LAR_LAR_Shift, 0   @ bitWidth 32 (Link address register)  
 
    .equ MDMA_MDMA_C8TBR, MDMA_BASE + 0x268 @ (MDMA channel x Trigger and Bus selection  Register) 
        .equ MDMA_MDMA_C8TBR_TSEL_Shift, 0   @ bitWidth 6 (Trigger selection)  
        .equ MDMA_MDMA_C8TBR_SBUS, 1 << 16   @ bitWidth 1 (Source BUS select This bit is protected  and can be written only if EN is 0.)  
        .equ MDMA_MDMA_C8TBR_DBUS, 1 << 17   @ bitWidth 1 (Destination BUS slect This bit is  protected and can be written only if EN is  0.)  
 
    .equ MDMA_MDMA_C8MAR, MDMA_BASE + 0x270 @ (MDMA channel x Mask address  register) 
        .equ MDMA_MDMA_C8MAR_MAR_Shift, 0   @ bitWidth 32 (Mask address)  
 
    .equ MDMA_MDMA_C8MDR, MDMA_BASE + 0x274 @ (MDMA channel x Mask Data  register) 
        .equ MDMA_MDMA_C8MDR_MDR_Shift, 0   @ bitWidth 32 (Mask data)  
 
    .equ MDMA_MDMA_C9ISR, MDMA_BASE + 0x280 @ (MDMA channel x interrupt/status  register) 
        .equ MDMA_MDMA_C9ISR_TEIF9, 1 << 0   @ bitWidth 1 (Channel x transfer error interrupt flag  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCRy register.)  
        .equ MDMA_MDMA_C9ISR_CTCIF9, 1 << 1   @ bitWidth 1 (Channel x Channel Transfer Complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register. CTC is set when the  last block was transferred and the channel has been  automatically disabled. CTC is also set when the  channel is suspended, as a result of writing EN bit  to 0.)  
        .equ MDMA_MDMA_C9ISR_BRTIF9, 1 << 2   @ bitWidth 1 (Channel x block repeat transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C9ISR_BTIF9, 1 << 3   @ bitWidth 1 (Channel x block transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C9ISR_TCIF9, 1 << 4   @ bitWidth 1 (channel x buffer transfer  complete)  
        .equ MDMA_MDMA_C9ISR_CRQA9, 1 << 16   @ bitWidth 1 (channel x request active  flag)  
 
    .equ MDMA_MDMA_C9IFCR, MDMA_BASE + 0x284 @ (MDMA channel x interrupt flag clear  register) 
        .equ MDMA_MDMA_C9IFCR_CTEIF9, 1 << 0   @ bitWidth 1 (Channel x clear transfer error interrupt  flag Writing a 1 into this bit clears TEIFx in the  MDMA_ISRy register)  
        .equ MDMA_MDMA_C9IFCR_CCTCIF9, 1 << 1   @ bitWidth 1 (Clear Channel transfer complete  interrupt flag for channel x Writing a 1 into this  bit clears CTCIFx in the MDMA_ISRy  register)  
        .equ MDMA_MDMA_C9IFCR_CBRTIF9, 1 << 2   @ bitWidth 1 (Channel x clear block repeat transfer  complete interrupt flag Writing a 1 into this bit  clears BRTIFx in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C9IFCR_CBTIF9, 1 << 3   @ bitWidth 1 (Channel x Clear block transfer complete  interrupt flag Writing a 1 into this bit clears BTIFx  in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C9IFCR_CLTCIF9, 1 << 4   @ bitWidth 1 (CLear buffer Transfer Complete Interrupt  Flag for channel x Writing a 1 into this bit clears  TCIFx in the MDMA_ISRy register)  
 
    .equ MDMA_MDMA_C9ESR, MDMA_BASE + 0x288 @ (MDMA Channel x error status  register) 
        .equ MDMA_MDMA_C9ESR_TEA_Shift, 0   @ bitWidth 7 (Transfer Error Address These bits are  set and cleared by HW, in case of an MDMA data  transfer error. It is used in conjunction with TED.  This field indicates the 7 LSBits of the address  which generated a transfer/access error. It may be  used by SW to retrieve the failing address, by adding  this value truncated to the buffer transfer length  size to the current SAR/DAR value. Note: The SAR/DAR  current value doesnt reflect this last address due to  the FIFO management system. The SAR/DAR are only  updated at the end of a buffer transfer of TLEN+1  bytes. Note: It is not set in case of a link data  error.)  
        .equ MDMA_MDMA_C9ESR_TED, 1 << 7   @ bitWidth 1 (Transfer Error Direction These bit is  set and cleared by HW, in case of an MDMA data  transfer error.)  
        .equ MDMA_MDMA_C9ESR_TELD, 1 << 8   @ bitWidth 1 (Transfer Error Link Data These bit is  set by HW, in case of a transfer error while reading  the block link data structure. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C9ESR_TEMD, 1 << 9   @ bitWidth 1 (Transfer Error Mask Data These bit is  set by HW, in case of a transfer error while writing  the Mask Data. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C9ESR_ASE, 1 << 10   @ bitWidth 1 (Address/Size Error These bit is set by  HW, when the programmed address is not aligned with  the data size. TED will indicate whether the problem  is on the source or destination. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C9ESR_BSE, 1 << 11   @ bitWidth 1 (Block Size Error These bit is set by HW,  when the block size is not an integer multiple of the  data size either for source or destination. TED will  indicate whether the problem is on the source or  destination. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
 
    .equ MDMA_MDMA_C9CR, MDMA_BASE + 0x28C @ (This register is used to control the  concerned channel.) 
        .equ MDMA_MDMA_C9CR_EN, 1 << 0   @ bitWidth 1 (channel enable)  
        .equ MDMA_MDMA_C9CR_TEIE, 1 << 1   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C9CR_CTCIE, 1 << 2   @ bitWidth 1 (Channel Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C9CR_BRTIE, 1 << 3   @ bitWidth 1 (Block Repeat transfer interrupt enable  This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C9CR_BTIE, 1 << 4   @ bitWidth 1 (Block Transfer interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C9CR_TCIE, 1 << 5   @ bitWidth 1 (buffer Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C9CR_PL_Shift, 6   @ bitWidth 2 (Priority level These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0.)  
        .equ MDMA_MDMA_C9CR_BEX, 1 << 12   @ bitWidth 1 (byte Endianness exchange)  
        .equ MDMA_MDMA_C9CR_HEX, 1 << 13   @ bitWidth 1 (Half word Endianes  exchange)  
        .equ MDMA_MDMA_C9CR_WEX, 1 << 14   @ bitWidth 1 (Word Endianness exchange)  
        .equ MDMA_MDMA_C9CR_SWRQ, 1 << 16   @ bitWidth 1 (SW ReQuest Writing a 1 into this bit  sets the CRQAx in MDMA_ISRy register, activating the  request on Channel x Note: Either the whole CxCR  register or the 8-bit/16-bit register @ Address  offset: 0x4E + 0x40 chn may be used for SWRQ  activation. In case of a SW request, acknowledge is  not generated neither HW signal, nor CxMAR write  access.)  
 
    .equ MDMA_MDMA_C9TCR, MDMA_BASE + 0x290 @ (This register is used to configure the  concerned channel.) 
        .equ MDMA_MDMA_C9TCR_SINC_Shift, 0   @ bitWidth 2 (Source increment mode These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0 Note: When source is  AHB SBUS=1, SINC = 00 is forbidden. In Linked List  Mode, at the end of a block single or last block in  repeated block transfer mode, this register will be  loaded from memory from address given by current  LAR[31:0] + 0x00.)  
        .equ MDMA_MDMA_C9TCR_DINC_Shift, 2   @ bitWidth 2 (Destination increment mode These bits  are set and cleared by software. These bits are  protected and can be written only if EN is 0 Note:  When destination is AHB DBUS=1, DINC = 00 is  forbidden.)  
        .equ MDMA_MDMA_C9TCR_SSIZE_Shift, 4   @ bitWidth 2 (Source data size These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0 Note: If a value of 11 is  programmed for the TCM access/AHB port, a transfer  error will occur TEIF bit set If SINCOS &lt;  SSIZE and SINC &#8800; 00, the result will be  unpredictable. Note: SSIZE = 11 double-word is  forbidden when source is TCM/AHB bus  SBUS=1.)  
        .equ MDMA_MDMA_C9TCR_DSIZE_Shift, 6   @ bitWidth 2 (Destination data size These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0. Note: If a value of  11 is programmed for the TCM access/AHB port, a  transfer error will occur TEIF bit set If DINCOS  &lt; DSIZE and DINC &#8800; 00, the result  will be unpredictable. Note: DSIZE = 11 double-word  is forbidden when destination is TCM/AHB bus  DBUS=1.)  
        .equ MDMA_MDMA_C9TCR_SINCOS_Shift, 8   @ bitWidth 2 (source increment offset  size)  
        .equ MDMA_MDMA_C9TCR_DINCOS_Shift, 10   @ bitWidth 2 (Destination increment  offset)  
        .equ MDMA_MDMA_C9TCR_SBURST_Shift, 12   @ bitWidth 3 (source burst transfer  configuration)  
        .equ MDMA_MDMA_C9TCR_DBURST_Shift, 15   @ bitWidth 3 (Destination burst transfer  configuration)  
        .equ MDMA_MDMA_C9TCR_TLEN_Shift, 18   @ bitWidth 7 (buffer transfer lengh)  
        .equ MDMA_MDMA_C9TCR_PKE, 1 << 25   @ bitWidth 1 (PacK Enable These bit is set and cleared  by software. If the Source Size is smaller than the  destination, it will be padded according to the PAM  value. If the Source data size is larger than the  destination one, it will be truncated. The alignment  will be done according to the PAM[0] value. This bit  is protected and can be written only if EN is  0)  
        .equ MDMA_MDMA_C9TCR_PAM_Shift, 26   @ bitWidth 2 (Padding/Alignement Mode These bits are  set and cleared by software. Case 1: Source data size  smaller than destination data size - 3 options are  valid. Case 2: Source data size larger than  destination data size. The remainder part is  discarded. When PKE = 1 or DSIZE=SSIZE, these bits  are ignored. These bits are protected and can be  written only if EN is 0)  
        .equ MDMA_MDMA_C9TCR_TRGM_Shift, 28   @ bitWidth 2 (Trigger Mode These bits are set and  cleared by software. Note: If TRGM is 11 for the  current block, all the values loaded at the end of  the current block through the linked list mechanism  must keep the same value TRGM=11 and the same SWRM  value, otherwise the result is undefined. These bits  are protected and can be written only if EN is  0.)  
        .equ MDMA_MDMA_C9TCR_SWRM, 1 << 30   @ bitWidth 1 (SW Request Mode This bit is set and  cleared by software. If a HW or SW request is  currently active, the bit change will be delayed  until the current transfer is completed. If the CxMAR  contains a valid address, the CxMDR value will also  be written @ CxMAR address. This bit is protected and  can be written only if EN is 0.)  
        .equ MDMA_MDMA_C9TCR_BWM, 1 << 31   @ bitWidth 1 (Bufferable Write Mode This bit is set  and cleared by software. This bit is protected and  can be written only if EN is 0. Note: All MDMA  destination accesses are non-cacheable.)  
 
    .equ MDMA_MDMA_C9BNDTR, MDMA_BASE + 0x294 @ (MDMA Channel x block number of data  register) 
        .equ MDMA_MDMA_C9BNDTR_BNDT_Shift, 0   @ bitWidth 17 (block number of data to  transfer)  
        .equ MDMA_MDMA_C9BNDTR_BRSUM, 1 << 18   @ bitWidth 1 (Block Repeat Source address Update Mode  These bits are protected and can be written only if  EN is 0.)  
        .equ MDMA_MDMA_C9BNDTR_BRDUM, 1 << 19   @ bitWidth 1 (Block Repeat Destination address Update  Mode These bits are protected and can be written only  if EN is 0.)  
        .equ MDMA_MDMA_C9BNDTR_BRC_Shift, 20   @ bitWidth 12 (Block Repeat Count This field contains  the number of repetitions of the current block 0 to  4095. When the channel is enabled, this register is  read-only, indicating the remaining number of blocks,  excluding the current one. This register decrements  after each complete block transfer. Once the last  block transfer has completed, this register can  either stay at zero or be reloaded automatically from  memory in Linked List mode - i.e. Link Address  valid. These bits are protected and can be written  only if EN is 0.)  
 
    .equ MDMA_MDMA_C9SAR, MDMA_BASE + 0x298 @ (MDMA channel x source address  register) 
        .equ MDMA_MDMA_C9SAR_SAR_Shift, 0   @ bitWidth 32 (source adr base)  
 
    .equ MDMA_MDMA_C9DAR, MDMA_BASE + 0x29C @ (MDMA channel x destination address  register) 
        .equ MDMA_MDMA_C9DAR_DAR_Shift, 0   @ bitWidth 32 (Destination adr base)  
 
    .equ MDMA_MDMA_C9BRUR, MDMA_BASE + 0x2A0 @ (MDMA channel x Block Repeat address Update  register) 
        .equ MDMA_MDMA_C9BRUR_SUV_Shift, 0   @ bitWidth 16 (source adresse update  value)  
        .equ MDMA_MDMA_C9BRUR_DUV_Shift, 16   @ bitWidth 16 (destination address update)  
 
    .equ MDMA_MDMA_C9LAR, MDMA_BASE + 0x2A4 @ (MDMA channel x Link Address  register) 
        .equ MDMA_MDMA_C9LAR_LAR_Shift, 0   @ bitWidth 32 (Link address register)  
 
    .equ MDMA_MDMA_C9TBR, MDMA_BASE + 0x2A8 @ (MDMA channel x Trigger and Bus selection  Register) 
        .equ MDMA_MDMA_C9TBR_TSEL_Shift, 0   @ bitWidth 6 (Trigger selection)  
        .equ MDMA_MDMA_C9TBR_SBUS, 1 << 16   @ bitWidth 1 (Source BUS select This bit is protected  and can be written only if EN is 0.)  
        .equ MDMA_MDMA_C9TBR_DBUS, 1 << 17   @ bitWidth 1 (Destination BUS slect This bit is  protected and can be written only if EN is  0.)  
 
    .equ MDMA_MDMA_C9MAR, MDMA_BASE + 0x2B0 @ (MDMA channel x Mask address  register) 
        .equ MDMA_MDMA_C9MAR_MAR_Shift, 0   @ bitWidth 32 (Mask address)  
 
    .equ MDMA_MDMA_C9MDR, MDMA_BASE + 0x2B4 @ (MDMA channel x Mask Data  register) 
        .equ MDMA_MDMA_C9MDR_MDR_Shift, 0   @ bitWidth 32 (Mask data)  
 
    .equ MDMA_MDMA_C10ISR, MDMA_BASE + 0x2C0 @ (MDMA channel x interrupt/status  register) 
        .equ MDMA_MDMA_C10ISR_TEIF10, 1 << 0   @ bitWidth 1 (Channel x transfer error interrupt flag  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCRy register.)  
        .equ MDMA_MDMA_C10ISR_CTCIF10, 1 << 1   @ bitWidth 1 (Channel x Channel Transfer Complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register. CTC is set when the  last block was transferred and the channel has been  automatically disabled. CTC is also set when the  channel is suspended, as a result of writing EN bit  to 0.)  
        .equ MDMA_MDMA_C10ISR_BRTIF10, 1 << 2   @ bitWidth 1 (Channel x block repeat transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C10ISR_BTIF10, 1 << 3   @ bitWidth 1 (Channel x block transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C10ISR_TCIF10, 1 << 4   @ bitWidth 1 (channel x buffer transfer  complete)  
        .equ MDMA_MDMA_C10ISR_CRQA10, 1 << 16   @ bitWidth 1 (channel x request active  flag)  
 
    .equ MDMA_MDMA_C10IFCR, MDMA_BASE + 0x2C4 @ (MDMA channel x interrupt flag clear  register) 
        .equ MDMA_MDMA_C10IFCR_CTEIF10, 1 << 0   @ bitWidth 1 (Channel x clear transfer error interrupt  flag Writing a 1 into this bit clears TEIFx in the  MDMA_ISRy register)  
        .equ MDMA_MDMA_C10IFCR_CCTCIF10, 1 << 1   @ bitWidth 1 (Clear Channel transfer complete  interrupt flag for channel x Writing a 1 into this  bit clears CTCIFx in the MDMA_ISRy  register)  
        .equ MDMA_MDMA_C10IFCR_CBRTIF10, 1 << 2   @ bitWidth 1 (Channel x clear block repeat transfer  complete interrupt flag Writing a 1 into this bit  clears BRTIFx in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C10IFCR_CBTIF10, 1 << 3   @ bitWidth 1 (Channel x Clear block transfer complete  interrupt flag Writing a 1 into this bit clears BTIFx  in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C10IFCR_CLTCIF10, 1 << 4   @ bitWidth 1 (CLear buffer Transfer Complete Interrupt  Flag for channel x Writing a 1 into this bit clears  TCIFx in the MDMA_ISRy register)  
 
    .equ MDMA_MDMA_C10ESR, MDMA_BASE + 0x2C8 @ (MDMA Channel x error status  register) 
        .equ MDMA_MDMA_C10ESR_TEA_Shift, 0   @ bitWidth 7 (Transfer Error Address These bits are  set and cleared by HW, in case of an MDMA data  transfer error. It is used in conjunction with TED.  This field indicates the 7 LSBits of the address  which generated a transfer/access error. It may be  used by SW to retrieve the failing address, by adding  this value truncated to the buffer transfer length  size to the current SAR/DAR value. Note: The SAR/DAR  current value doesnt reflect this last address due to  the FIFO management system. The SAR/DAR are only  updated at the end of a buffer transfer of TLEN+1  bytes. Note: It is not set in case of a link data  error.)  
        .equ MDMA_MDMA_C10ESR_TED, 1 << 7   @ bitWidth 1 (Transfer Error Direction These bit is  set and cleared by HW, in case of an MDMA data  transfer error.)  
        .equ MDMA_MDMA_C10ESR_TELD, 1 << 8   @ bitWidth 1 (Transfer Error Link Data These bit is  set by HW, in case of a transfer error while reading  the block link data structure. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C10ESR_TEMD, 1 << 9   @ bitWidth 1 (Transfer Error Mask Data These bit is  set by HW, in case of a transfer error while writing  the Mask Data. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C10ESR_ASE, 1 << 10   @ bitWidth 1 (Address/Size Error These bit is set by  HW, when the programmed address is not aligned with  the data size. TED will indicate whether the problem  is on the source or destination. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C10ESR_BSE, 1 << 11   @ bitWidth 1 (Block Size Error These bit is set by HW,  when the block size is not an integer multiple of the  data size either for source or destination. TED will  indicate whether the problem is on the source or  destination. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
 
    .equ MDMA_MDMA_C10CR, MDMA_BASE + 0x2CC @ (This register is used to control the  concerned channel.) 
        .equ MDMA_MDMA_C10CR_EN, 1 << 0   @ bitWidth 1 (channel enable)  
        .equ MDMA_MDMA_C10CR_TEIE, 1 << 1   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C10CR_CTCIE, 1 << 2   @ bitWidth 1 (Channel Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C10CR_BRTIE, 1 << 3   @ bitWidth 1 (Block Repeat transfer interrupt enable  This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C10CR_BTIE, 1 << 4   @ bitWidth 1 (Block Transfer interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C10CR_TCIE, 1 << 5   @ bitWidth 1 (buffer Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C10CR_PL_Shift, 6   @ bitWidth 2 (Priority level These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0.)  
        .equ MDMA_MDMA_C10CR_BEX, 1 << 12   @ bitWidth 1 (byte Endianness exchange)  
        .equ MDMA_MDMA_C10CR_HEX, 1 << 13   @ bitWidth 1 (Half word Endianes  exchange)  
        .equ MDMA_MDMA_C10CR_WEX, 1 << 14   @ bitWidth 1 (Word Endianness exchange)  
        .equ MDMA_MDMA_C10CR_SWRQ, 1 << 16   @ bitWidth 1 (SW ReQuest Writing a 1 into this bit  sets the CRQAx in MDMA_ISRy register, activating the  request on Channel x Note: Either the whole CxCR  register or the 8-bit/16-bit register @ Address  offset: 0x4E + 0x40 chn may be used for SWRQ  activation. In case of a SW request, acknowledge is  not generated neither HW signal, nor CxMAR write  access.)  
 
    .equ MDMA_MDMA_C10TCR, MDMA_BASE + 0x2D0 @ (This register is used to configure the  concerned channel.) 
        .equ MDMA_MDMA_C10TCR_SINC_Shift, 0   @ bitWidth 2 (Source increment mode These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0 Note: When source is  AHB SBUS=1, SINC = 00 is forbidden. In Linked List  Mode, at the end of a block single or last block in  repeated block transfer mode, this register will be  loaded from memory from address given by current  LAR[31:0] + 0x00.)  
        .equ MDMA_MDMA_C10TCR_DINC_Shift, 2   @ bitWidth 2 (Destination increment mode These bits  are set and cleared by software. These bits are  protected and can be written only if EN is 0 Note:  When destination is AHB DBUS=1, DINC = 00 is  forbidden.)  
        .equ MDMA_MDMA_C10TCR_SSIZE_Shift, 4   @ bitWidth 2 (Source data size These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0 Note: If a value of 11 is  programmed for the TCM access/AHB port, a transfer  error will occur TEIF bit set If SINCOS &lt;  SSIZE and SINC &#8800; 00, the result will be  unpredictable. Note: SSIZE = 11 double-word is  forbidden when source is TCM/AHB bus  SBUS=1.)  
        .equ MDMA_MDMA_C10TCR_DSIZE_Shift, 6   @ bitWidth 2 (Destination data size These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0. Note: If a value of  11 is programmed for the TCM access/AHB port, a  transfer error will occur TEIF bit set If DINCOS  &lt; DSIZE and DINC &#8800; 00, the result  will be unpredictable. Note: DSIZE = 11 double-word  is forbidden when destination is TCM/AHB bus  DBUS=1.)  
        .equ MDMA_MDMA_C10TCR_SINCOS_Shift, 8   @ bitWidth 2 (source increment offset  size)  
        .equ MDMA_MDMA_C10TCR_DINCOS_Shift, 10   @ bitWidth 2 (Destination increment  offset)  
        .equ MDMA_MDMA_C10TCR_SBURST_Shift, 12   @ bitWidth 3 (source burst transfer  configuration)  
        .equ MDMA_MDMA_C10TCR_DBURST_Shift, 15   @ bitWidth 3 (Destination burst transfer  configuration)  
        .equ MDMA_MDMA_C10TCR_TLEN_Shift, 18   @ bitWidth 7 (buffer transfer lengh)  
        .equ MDMA_MDMA_C10TCR_PKE, 1 << 25   @ bitWidth 1 (PacK Enable These bit is set and cleared  by software. If the Source Size is smaller than the  destination, it will be padded according to the PAM  value. If the Source data size is larger than the  destination one, it will be truncated. The alignment  will be done according to the PAM[0] value. This bit  is protected and can be written only if EN is  0)  
        .equ MDMA_MDMA_C10TCR_PAM_Shift, 26   @ bitWidth 2 (Padding/Alignement Mode These bits are  set and cleared by software. Case 1: Source data size  smaller than destination data size - 3 options are  valid. Case 2: Source data size larger than  destination data size. The remainder part is  discarded. When PKE = 1 or DSIZE=SSIZE, these bits  are ignored. These bits are protected and can be  written only if EN is 0)  
        .equ MDMA_MDMA_C10TCR_TRGM_Shift, 28   @ bitWidth 2 (Trigger Mode These bits are set and  cleared by software. Note: If TRGM is 11 for the  current block, all the values loaded at the end of  the current block through the linked list mechanism  must keep the same value TRGM=11 and the same SWRM  value, otherwise the result is undefined. These bits  are protected and can be written only if EN is  0.)  
        .equ MDMA_MDMA_C10TCR_SWRM, 1 << 30   @ bitWidth 1 (SW Request Mode This bit is set and  cleared by software. If a HW or SW request is  currently active, the bit change will be delayed  until the current transfer is completed. If the CxMAR  contains a valid address, the CxMDR value will also  be written @ CxMAR address. This bit is protected and  can be written only if EN is 0.)  
        .equ MDMA_MDMA_C10TCR_BWM, 1 << 31   @ bitWidth 1 (Bufferable Write Mode This bit is set  and cleared by software. This bit is protected and  can be written only if EN is 0. Note: All MDMA  destination accesses are non-cacheable.)  
 
    .equ MDMA_MDMA_C10BNDTR, MDMA_BASE + 0x2D4 @ (MDMA Channel x block number of data  register) 
        .equ MDMA_MDMA_C10BNDTR_BNDT_Shift, 0   @ bitWidth 17 (block number of data to  transfer)  
        .equ MDMA_MDMA_C10BNDTR_BRSUM, 1 << 18   @ bitWidth 1 (Block Repeat Source address Update Mode  These bits are protected and can be written only if  EN is 0.)  
        .equ MDMA_MDMA_C10BNDTR_BRDUM, 1 << 19   @ bitWidth 1 (Block Repeat Destination address Update  Mode These bits are protected and can be written only  if EN is 0.)  
        .equ MDMA_MDMA_C10BNDTR_BRC_Shift, 20   @ bitWidth 12 (Block Repeat Count This field contains  the number of repetitions of the current block 0 to  4095. When the channel is enabled, this register is  read-only, indicating the remaining number of blocks,  excluding the current one. This register decrements  after each complete block transfer. Once the last  block transfer has completed, this register can  either stay at zero or be reloaded automatically from  memory in Linked List mode - i.e. Link Address  valid. These bits are protected and can be written  only if EN is 0.)  
 
    .equ MDMA_MDMA_C10SAR, MDMA_BASE + 0x2D8 @ (MDMA channel x source address  register) 
        .equ MDMA_MDMA_C10SAR_SAR_Shift, 0   @ bitWidth 32 (source adr base)  
 
    .equ MDMA_MDMA_C10DAR, MDMA_BASE + 0x2DC @ (MDMA channel x destination address  register) 
        .equ MDMA_MDMA_C10DAR_DAR_Shift, 0   @ bitWidth 32 (Destination adr base)  
 
    .equ MDMA_MDMA_C10BRUR, MDMA_BASE + 0x2E0 @ (MDMA channel x Block Repeat address Update  register) 
        .equ MDMA_MDMA_C10BRUR_SUV_Shift, 0   @ bitWidth 16 (source adresse update  value)  
        .equ MDMA_MDMA_C10BRUR_DUV_Shift, 16   @ bitWidth 16 (destination address update)  
 
    .equ MDMA_MDMA_C10LAR, MDMA_BASE + 0x2E4 @ (MDMA channel x Link Address  register) 
        .equ MDMA_MDMA_C10LAR_LAR_Shift, 0   @ bitWidth 32 (Link address register)  
 
    .equ MDMA_MDMA_C10TBR, MDMA_BASE + 0x2E8 @ (MDMA channel x Trigger and Bus selection  Register) 
        .equ MDMA_MDMA_C10TBR_TSEL_Shift, 0   @ bitWidth 6 (Trigger selection)  
        .equ MDMA_MDMA_C10TBR_SBUS, 1 << 16   @ bitWidth 1 (Source BUS select This bit is protected  and can be written only if EN is 0.)  
        .equ MDMA_MDMA_C10TBR_DBUS, 1 << 17   @ bitWidth 1 (Destination BUS slect This bit is  protected and can be written only if EN is  0.)  
 
    .equ MDMA_MDMA_C10MAR, MDMA_BASE + 0x2F0 @ (MDMA channel x Mask address  register) 
        .equ MDMA_MDMA_C10MAR_MAR_Shift, 0   @ bitWidth 32 (Mask address)  
 
    .equ MDMA_MDMA_C10MDR, MDMA_BASE + 0x2F4 @ (MDMA channel x Mask Data  register) 
        .equ MDMA_MDMA_C10MDR_MDR_Shift, 0   @ bitWidth 32 (Mask data)  
 
    .equ MDMA_MDMA_C11ISR, MDMA_BASE + 0x300 @ (MDMA channel x interrupt/status  register) 
        .equ MDMA_MDMA_C11ISR_TEIF11, 1 << 0   @ bitWidth 1 (Channel x transfer error interrupt flag  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCRy register.)  
        .equ MDMA_MDMA_C11ISR_CTCIF11, 1 << 1   @ bitWidth 1 (Channel x Channel Transfer Complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register. CTC is set when the  last block was transferred and the channel has been  automatically disabled. CTC is also set when the  channel is suspended, as a result of writing EN bit  to 0.)  
        .equ MDMA_MDMA_C11ISR_BRTIF11, 1 << 2   @ bitWidth 1 (Channel x block repeat transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C11ISR_BTIF11, 1 << 3   @ bitWidth 1 (Channel x block transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C11ISR_TCIF11, 1 << 4   @ bitWidth 1 (channel x buffer transfer  complete)  
        .equ MDMA_MDMA_C11ISR_CRQA11, 1 << 16   @ bitWidth 1 (channel x request active  flag)  
 
    .equ MDMA_MDMA_C11IFCR, MDMA_BASE + 0x304 @ (MDMA channel x interrupt flag clear  register) 
        .equ MDMA_MDMA_C11IFCR_CTEIF11, 1 << 0   @ bitWidth 1 (Channel x clear transfer error interrupt  flag Writing a 1 into this bit clears TEIFx in the  MDMA_ISRy register)  
        .equ MDMA_MDMA_C11IFCR_CCTCIF11, 1 << 1   @ bitWidth 1 (Clear Channel transfer complete  interrupt flag for channel x Writing a 1 into this  bit clears CTCIFx in the MDMA_ISRy  register)  
        .equ MDMA_MDMA_C11IFCR_CBRTIF11, 1 << 2   @ bitWidth 1 (Channel x clear block repeat transfer  complete interrupt flag Writing a 1 into this bit  clears BRTIFx in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C11IFCR_CBTIF11, 1 << 3   @ bitWidth 1 (Channel x Clear block transfer complete  interrupt flag Writing a 1 into this bit clears BTIFx  in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C11IFCR_CLTCIF11, 1 << 4   @ bitWidth 1 (CLear buffer Transfer Complete Interrupt  Flag for channel x Writing a 1 into this bit clears  TCIFx in the MDMA_ISRy register)  
 
    .equ MDMA_MDMA_C11ESR, MDMA_BASE + 0x308 @ (MDMA Channel x error status  register) 
        .equ MDMA_MDMA_C11ESR_TEA_Shift, 0   @ bitWidth 7 (Transfer Error Address These bits are  set and cleared by HW, in case of an MDMA data  transfer error. It is used in conjunction with TED.  This field indicates the 7 LSBits of the address  which generated a transfer/access error. It may be  used by SW to retrieve the failing address, by adding  this value truncated to the buffer transfer length  size to the current SAR/DAR value. Note: The SAR/DAR  current value doesnt reflect this last address due to  the FIFO management system. The SAR/DAR are only  updated at the end of a buffer transfer of TLEN+1  bytes. Note: It is not set in case of a link data  error.)  
        .equ MDMA_MDMA_C11ESR_TED, 1 << 7   @ bitWidth 1 (Transfer Error Direction These bit is  set and cleared by HW, in case of an MDMA data  transfer error.)  
        .equ MDMA_MDMA_C11ESR_TELD, 1 << 8   @ bitWidth 1 (Transfer Error Link Data These bit is  set by HW, in case of a transfer error while reading  the block link data structure. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C11ESR_TEMD, 1 << 9   @ bitWidth 1 (Transfer Error Mask Data These bit is  set by HW, in case of a transfer error while writing  the Mask Data. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C11ESR_ASE, 1 << 10   @ bitWidth 1 (Address/Size Error These bit is set by  HW, when the programmed address is not aligned with  the data size. TED will indicate whether the problem  is on the source or destination. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C11ESR_BSE, 1 << 11   @ bitWidth 1 (Block Size Error These bit is set by HW,  when the block size is not an integer multiple of the  data size either for source or destination. TED will  indicate whether the problem is on the source or  destination. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
 
    .equ MDMA_MDMA_C11CR, MDMA_BASE + 0x30C @ (This register is used to control the  concerned channel.) 
        .equ MDMA_MDMA_C11CR_EN, 1 << 0   @ bitWidth 1 (channel enable)  
        .equ MDMA_MDMA_C11CR_TEIE, 1 << 1   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C11CR_CTCIE, 1 << 2   @ bitWidth 1 (Channel Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C11CR_BRTIE, 1 << 3   @ bitWidth 1 (Block Repeat transfer interrupt enable  This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C11CR_BTIE, 1 << 4   @ bitWidth 1 (Block Transfer interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C11CR_TCIE, 1 << 5   @ bitWidth 1 (buffer Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C11CR_PL_Shift, 6   @ bitWidth 2 (Priority level These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0.)  
        .equ MDMA_MDMA_C11CR_BEX, 1 << 12   @ bitWidth 1 (byte Endianness exchange)  
        .equ MDMA_MDMA_C11CR_HEX, 1 << 13   @ bitWidth 1 (Half word Endianes  exchange)  
        .equ MDMA_MDMA_C11CR_WEX, 1 << 14   @ bitWidth 1 (Word Endianness exchange)  
        .equ MDMA_MDMA_C11CR_SWRQ, 1 << 16   @ bitWidth 1 (SW ReQuest Writing a 1 into this bit  sets the CRQAx in MDMA_ISRy register, activating the  request on Channel x Note: Either the whole CxCR  register or the 8-bit/16-bit register @ Address  offset: 0x4E + 0x40 chn may be used for SWRQ  activation. In case of a SW request, acknowledge is  not generated neither HW signal, nor CxMAR write  access.)  
 
    .equ MDMA_MDMA_C11TCR, MDMA_BASE + 0x310 @ (This register is used to configure the  concerned channel.) 
        .equ MDMA_MDMA_C11TCR_SINC_Shift, 0   @ bitWidth 2 (Source increment mode These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0 Note: When source is  AHB SBUS=1, SINC = 00 is forbidden. In Linked List  Mode, at the end of a block single or last block in  repeated block transfer mode, this register will be  loaded from memory from address given by current  LAR[31:0] + 0x00.)  
        .equ MDMA_MDMA_C11TCR_DINC_Shift, 2   @ bitWidth 2 (Destination increment mode These bits  are set and cleared by software. These bits are  protected and can be written only if EN is 0 Note:  When destination is AHB DBUS=1, DINC = 00 is  forbidden.)  
        .equ MDMA_MDMA_C11TCR_SSIZE_Shift, 4   @ bitWidth 2 (Source data size These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0 Note: If a value of 11 is  programmed for the TCM access/AHB port, a transfer  error will occur TEIF bit set If SINCOS &lt;  SSIZE and SINC &#8800; 00, the result will be  unpredictable. Note: SSIZE = 11 double-word is  forbidden when source is TCM/AHB bus  SBUS=1.)  
        .equ MDMA_MDMA_C11TCR_DSIZE_Shift, 6   @ bitWidth 2 (Destination data size These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0. Note: If a value of  11 is programmed for the TCM access/AHB port, a  transfer error will occur TEIF bit set If DINCOS  &lt; DSIZE and DINC &#8800; 00, the result  will be unpredictable. Note: DSIZE = 11 double-word  is forbidden when destination is TCM/AHB bus  DBUS=1.)  
        .equ MDMA_MDMA_C11TCR_SINCOS_Shift, 8   @ bitWidth 2 (source increment offset  size)  
        .equ MDMA_MDMA_C11TCR_DINCOS_Shift, 10   @ bitWidth 2 (Destination increment  offset)  
        .equ MDMA_MDMA_C11TCR_SBURST_Shift, 12   @ bitWidth 3 (source burst transfer  configuration)  
        .equ MDMA_MDMA_C11TCR_DBURST_Shift, 15   @ bitWidth 3 (Destination burst transfer  configuration)  
        .equ MDMA_MDMA_C11TCR_TLEN_Shift, 18   @ bitWidth 7 (buffer transfer lengh)  
        .equ MDMA_MDMA_C11TCR_PKE, 1 << 25   @ bitWidth 1 (PacK Enable These bit is set and cleared  by software. If the Source Size is smaller than the  destination, it will be padded according to the PAM  value. If the Source data size is larger than the  destination one, it will be truncated. The alignment  will be done according to the PAM[0] value. This bit  is protected and can be written only if EN is  0)  
        .equ MDMA_MDMA_C11TCR_PAM_Shift, 26   @ bitWidth 2 (Padding/Alignement Mode These bits are  set and cleared by software. Case 1: Source data size  smaller than destination data size - 3 options are  valid. Case 2: Source data size larger than  destination data size. The remainder part is  discarded. When PKE = 1 or DSIZE=SSIZE, these bits  are ignored. These bits are protected and can be  written only if EN is 0)  
        .equ MDMA_MDMA_C11TCR_TRGM_Shift, 28   @ bitWidth 2 (Trigger Mode These bits are set and  cleared by software. Note: If TRGM is 11 for the  current block, all the values loaded at the end of  the current block through the linked list mechanism  must keep the same value TRGM=11 and the same SWRM  value, otherwise the result is undefined. These bits  are protected and can be written only if EN is  0.)  
        .equ MDMA_MDMA_C11TCR_SWRM, 1 << 30   @ bitWidth 1 (SW Request Mode This bit is set and  cleared by software. If a HW or SW request is  currently active, the bit change will be delayed  until the current transfer is completed. If the CxMAR  contains a valid address, the CxMDR value will also  be written @ CxMAR address. This bit is protected and  can be written only if EN is 0.)  
        .equ MDMA_MDMA_C11TCR_BWM, 1 << 31   @ bitWidth 1 (Bufferable Write Mode This bit is set  and cleared by software. This bit is protected and  can be written only if EN is 0. Note: All MDMA  destination accesses are non-cacheable.)  
 
    .equ MDMA_MDMA_C11BNDTR, MDMA_BASE + 0x314 @ (MDMA Channel x block number of data  register) 
        .equ MDMA_MDMA_C11BNDTR_BNDT_Shift, 0   @ bitWidth 17 (block number of data to  transfer)  
        .equ MDMA_MDMA_C11BNDTR_BRSUM, 1 << 18   @ bitWidth 1 (Block Repeat Source address Update Mode  These bits are protected and can be written only if  EN is 0.)  
        .equ MDMA_MDMA_C11BNDTR_BRDUM, 1 << 19   @ bitWidth 1 (Block Repeat Destination address Update  Mode These bits are protected and can be written only  if EN is 0.)  
        .equ MDMA_MDMA_C11BNDTR_BRC_Shift, 20   @ bitWidth 12 (Block Repeat Count This field contains  the number of repetitions of the current block 0 to  4095. When the channel is enabled, this register is  read-only, indicating the remaining number of blocks,  excluding the current one. This register decrements  after each complete block transfer. Once the last  block transfer has completed, this register can  either stay at zero or be reloaded automatically from  memory in Linked List mode - i.e. Link Address  valid. These bits are protected and can be written  only if EN is 0.)  
 
    .equ MDMA_MDMA_C11SAR, MDMA_BASE + 0x318 @ (MDMA channel x source address  register) 
        .equ MDMA_MDMA_C11SAR_SAR_Shift, 0   @ bitWidth 32 (source adr base)  
 
    .equ MDMA_MDMA_C11DAR, MDMA_BASE + 0x31C @ (MDMA channel x destination address  register) 
        .equ MDMA_MDMA_C11DAR_DAR_Shift, 0   @ bitWidth 32 (Destination adr base)  
 
    .equ MDMA_MDMA_C11BRUR, MDMA_BASE + 0x320 @ (MDMA channel x Block Repeat address Update  register) 
        .equ MDMA_MDMA_C11BRUR_SUV_Shift, 0   @ bitWidth 16 (source adresse update  value)  
        .equ MDMA_MDMA_C11BRUR_DUV_Shift, 16   @ bitWidth 16 (destination address update)  
 
    .equ MDMA_MDMA_C11LAR, MDMA_BASE + 0x324 @ (MDMA channel x Link Address  register) 
        .equ MDMA_MDMA_C11LAR_LAR_Shift, 0   @ bitWidth 32 (Link address register)  
 
    .equ MDMA_MDMA_C11TBR, MDMA_BASE + 0x328 @ (MDMA channel x Trigger and Bus selection  Register) 
        .equ MDMA_MDMA_C11TBR_TSEL_Shift, 0   @ bitWidth 6 (Trigger selection)  
        .equ MDMA_MDMA_C11TBR_SBUS, 1 << 16   @ bitWidth 1 (Source BUS select This bit is protected  and can be written only if EN is 0.)  
        .equ MDMA_MDMA_C11TBR_DBUS, 1 << 17   @ bitWidth 1 (Destination BUS slect This bit is  protected and can be written only if EN is  0.)  
 
    .equ MDMA_MDMA_C11MAR, MDMA_BASE + 0x330 @ (MDMA channel x Mask address  register) 
        .equ MDMA_MDMA_C11MAR_MAR_Shift, 0   @ bitWidth 32 (Mask address)  
 
    .equ MDMA_MDMA_C11MDR, MDMA_BASE + 0x334 @ (MDMA channel x Mask Data  register) 
        .equ MDMA_MDMA_C11MDR_MDR_Shift, 0   @ bitWidth 32 (Mask data)  
 
    .equ MDMA_MDMA_C12ISR, MDMA_BASE + 0x340 @ (MDMA channel x interrupt/status  register) 
        .equ MDMA_MDMA_C12ISR_TEIF12, 1 << 0   @ bitWidth 1 (Channel x transfer error interrupt flag  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCRy register.)  
        .equ MDMA_MDMA_C12ISR_CTCIF12, 1 << 1   @ bitWidth 1 (Channel x Channel Transfer Complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register. CTC is set when the  last block was transferred and the channel has been  automatically disabled. CTC is also set when the  channel is suspended, as a result of writing EN bit  to 0.)  
        .equ MDMA_MDMA_C12ISR_BRTIF12, 1 << 2   @ bitWidth 1 (Channel x block repeat transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C12ISR_BTIF12, 1 << 3   @ bitWidth 1 (Channel x block transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C12ISR_TCIF12, 1 << 4   @ bitWidth 1 (channel x buffer transfer  complete)  
        .equ MDMA_MDMA_C12ISR_CRQA12, 1 << 16   @ bitWidth 1 (channel x request active  flag)  
 
    .equ MDMA_MDMA_C12IFCR, MDMA_BASE + 0x344 @ (MDMA channel x interrupt flag clear  register) 
        .equ MDMA_MDMA_C12IFCR_CTEIF12, 1 << 0   @ bitWidth 1 (Channel x clear transfer error interrupt  flag Writing a 1 into this bit clears TEIFx in the  MDMA_ISRy register)  
        .equ MDMA_MDMA_C12IFCR_CCTCIF12, 1 << 1   @ bitWidth 1 (Clear Channel transfer complete  interrupt flag for channel x Writing a 1 into this  bit clears CTCIFx in the MDMA_ISRy  register)  
        .equ MDMA_MDMA_C12IFCR_CBRTIF12, 1 << 2   @ bitWidth 1 (Channel x clear block repeat transfer  complete interrupt flag Writing a 1 into this bit  clears BRTIFx in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C12IFCR_CBTIF12, 1 << 3   @ bitWidth 1 (Channel x Clear block transfer complete  interrupt flag Writing a 1 into this bit clears BTIFx  in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C12IFCR_CLTCIF12, 1 << 4   @ bitWidth 1 (CLear buffer Transfer Complete Interrupt  Flag for channel x Writing a 1 into this bit clears  TCIFx in the MDMA_ISRy register)  
 
    .equ MDMA_MDMA_C12ESR, MDMA_BASE + 0x348 @ (MDMA Channel x error status  register) 
        .equ MDMA_MDMA_C12ESR_TEA_Shift, 0   @ bitWidth 7 (Transfer Error Address These bits are  set and cleared by HW, in case of an MDMA data  transfer error. It is used in conjunction with TED.  This field indicates the 7 LSBits of the address  which generated a transfer/access error. It may be  used by SW to retrieve the failing address, by adding  this value truncated to the buffer transfer length  size to the current SAR/DAR value. Note: The SAR/DAR  current value doesnt reflect this last address due to  the FIFO management system. The SAR/DAR are only  updated at the end of a buffer transfer of TLEN+1  bytes. Note: It is not set in case of a link data  error.)  
        .equ MDMA_MDMA_C12ESR_TED, 1 << 7   @ bitWidth 1 (Transfer Error Direction These bit is  set and cleared by HW, in case of an MDMA data  transfer error.)  
        .equ MDMA_MDMA_C12ESR_TELD, 1 << 8   @ bitWidth 1 (Transfer Error Link Data These bit is  set by HW, in case of a transfer error while reading  the block link data structure. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C12ESR_TEMD, 1 << 9   @ bitWidth 1 (Transfer Error Mask Data These bit is  set by HW, in case of a transfer error while writing  the Mask Data. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C12ESR_ASE, 1 << 10   @ bitWidth 1 (Address/Size Error These bit is set by  HW, when the programmed address is not aligned with  the data size. TED will indicate whether the problem  is on the source or destination. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C12ESR_BSE, 1 << 11   @ bitWidth 1 (Block Size Error These bit is set by HW,  when the block size is not an integer multiple of the  data size either for source or destination. TED will  indicate whether the problem is on the source or  destination. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
 
    .equ MDMA_MDMA_C12CR, MDMA_BASE + 0x34C @ (This register is used to control the  concerned channel.) 
        .equ MDMA_MDMA_C12CR_EN, 1 << 0   @ bitWidth 1 (channel enable)  
        .equ MDMA_MDMA_C12CR_TEIE, 1 << 1   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C12CR_CTCIE, 1 << 2   @ bitWidth 1 (Channel Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C12CR_BRTIE, 1 << 3   @ bitWidth 1 (Block Repeat transfer interrupt enable  This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C12CR_BTIE, 1 << 4   @ bitWidth 1 (Block Transfer interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C12CR_TCIE, 1 << 5   @ bitWidth 1 (buffer Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C12CR_PL_Shift, 6   @ bitWidth 2 (Priority level These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0.)  
        .equ MDMA_MDMA_C12CR_BEX, 1 << 12   @ bitWidth 1 (byte Endianness exchange)  
        .equ MDMA_MDMA_C12CR_HEX, 1 << 13   @ bitWidth 1 (Half word Endianes  exchange)  
        .equ MDMA_MDMA_C12CR_WEX, 1 << 14   @ bitWidth 1 (Word Endianness exchange)  
        .equ MDMA_MDMA_C12CR_SWRQ, 1 << 16   @ bitWidth 1 (SW ReQuest Writing a 1 into this bit  sets the CRQAx in MDMA_ISRy register, activating the  request on Channel x Note: Either the whole CxCR  register or the 8-bit/16-bit register @ Address  offset: 0x4E + 0x40 chn may be used for SWRQ  activation. In case of a SW request, acknowledge is  not generated neither HW signal, nor CxMAR write  access.)  
 
    .equ MDMA_MDMA_C12TCR, MDMA_BASE + 0x350 @ (This register is used to configure the  concerned channel.) 
        .equ MDMA_MDMA_C12TCR_SINC_Shift, 0   @ bitWidth 2 (Source increment mode These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0 Note: When source is  AHB SBUS=1, SINC = 00 is forbidden. In Linked List  Mode, at the end of a block single or last block in  repeated block transfer mode, this register will be  loaded from memory from address given by current  LAR[31:0] + 0x00.)  
        .equ MDMA_MDMA_C12TCR_DINC_Shift, 2   @ bitWidth 2 (Destination increment mode These bits  are set and cleared by software. These bits are  protected and can be written only if EN is 0 Note:  When destination is AHB DBUS=1, DINC = 00 is  forbidden.)  
        .equ MDMA_MDMA_C12TCR_SSIZE_Shift, 4   @ bitWidth 2 (Source data size These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0 Note: If a value of 11 is  programmed for the TCM access/AHB port, a transfer  error will occur TEIF bit set If SINCOS &lt;  SSIZE and SINC &#8800; 00, the result will be  unpredictable. Note: SSIZE = 11 double-word is  forbidden when source is TCM/AHB bus  SBUS=1.)  
        .equ MDMA_MDMA_C12TCR_DSIZE_Shift, 6   @ bitWidth 2 (Destination data size These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0. Note: If a value of  11 is programmed for the TCM access/AHB port, a  transfer error will occur TEIF bit set If DINCOS  &lt; DSIZE and DINC &#8800; 00, the result  will be unpredictable. Note: DSIZE = 11 double-word  is forbidden when destination is TCM/AHB bus  DBUS=1.)  
        .equ MDMA_MDMA_C12TCR_SINCOS_Shift, 8   @ bitWidth 2 (source increment offset  size)  
        .equ MDMA_MDMA_C12TCR_DINCOS_Shift, 10   @ bitWidth 2 (Destination increment  offset)  
        .equ MDMA_MDMA_C12TCR_SBURST_Shift, 12   @ bitWidth 3 (source burst transfer  configuration)  
        .equ MDMA_MDMA_C12TCR_DBURST_Shift, 15   @ bitWidth 3 (Destination burst transfer  configuration)  
        .equ MDMA_MDMA_C12TCR_TLEN_Shift, 18   @ bitWidth 7 (buffer transfer lengh)  
        .equ MDMA_MDMA_C12TCR_PKE, 1 << 25   @ bitWidth 1 (PacK Enable These bit is set and cleared  by software. If the Source Size is smaller than the  destination, it will be padded according to the PAM  value. If the Source data size is larger than the  destination one, it will be truncated. The alignment  will be done according to the PAM[0] value. This bit  is protected and can be written only if EN is  0)  
        .equ MDMA_MDMA_C12TCR_PAM_Shift, 26   @ bitWidth 2 (Padding/Alignement Mode These bits are  set and cleared by software. Case 1: Source data size  smaller than destination data size - 3 options are  valid. Case 2: Source data size larger than  destination data size. The remainder part is  discarded. When PKE = 1 or DSIZE=SSIZE, these bits  are ignored. These bits are protected and can be  written only if EN is 0)  
        .equ MDMA_MDMA_C12TCR_TRGM_Shift, 28   @ bitWidth 2 (Trigger Mode These bits are set and  cleared by software. Note: If TRGM is 11 for the  current block, all the values loaded at the end of  the current block through the linked list mechanism  must keep the same value TRGM=11 and the same SWRM  value, otherwise the result is undefined. These bits  are protected and can be written only if EN is  0.)  
        .equ MDMA_MDMA_C12TCR_SWRM, 1 << 30   @ bitWidth 1 (SW Request Mode This bit is set and  cleared by software. If a HW or SW request is  currently active, the bit change will be delayed  until the current transfer is completed. If the CxMAR  contains a valid address, the CxMDR value will also  be written @ CxMAR address. This bit is protected and  can be written only if EN is 0.)  
        .equ MDMA_MDMA_C12TCR_BWM, 1 << 31   @ bitWidth 1 (Bufferable Write Mode This bit is set  and cleared by software. This bit is protected and  can be written only if EN is 0. Note: All MDMA  destination accesses are non-cacheable.)  
 
    .equ MDMA_MDMA_C12BNDTR, MDMA_BASE + 0x354 @ (MDMA Channel x block number of data  register) 
        .equ MDMA_MDMA_C12BNDTR_BNDT_Shift, 0   @ bitWidth 17 (block number of data to  transfer)  
        .equ MDMA_MDMA_C12BNDTR_BRSUM, 1 << 18   @ bitWidth 1 (Block Repeat Source address Update Mode  These bits are protected and can be written only if  EN is 0.)  
        .equ MDMA_MDMA_C12BNDTR_BRDUM, 1 << 19   @ bitWidth 1 (Block Repeat Destination address Update  Mode These bits are protected and can be written only  if EN is 0.)  
        .equ MDMA_MDMA_C12BNDTR_BRC_Shift, 20   @ bitWidth 12 (Block Repeat Count This field contains  the number of repetitions of the current block 0 to  4095. When the channel is enabled, this register is  read-only, indicating the remaining number of blocks,  excluding the current one. This register decrements  after each complete block transfer. Once the last  block transfer has completed, this register can  either stay at zero or be reloaded automatically from  memory in Linked List mode - i.e. Link Address  valid. These bits are protected and can be written  only if EN is 0.)  
 
    .equ MDMA_MDMA_C12SAR, MDMA_BASE + 0x358 @ (MDMA channel x source address  register) 
        .equ MDMA_MDMA_C12SAR_SAR_Shift, 0   @ bitWidth 32 (source adr base)  
 
    .equ MDMA_MDMA_C12DAR, MDMA_BASE + 0x35C @ (MDMA channel x destination address  register) 
        .equ MDMA_MDMA_C12DAR_DAR_Shift, 0   @ bitWidth 32 (Destination adr base)  
 
    .equ MDMA_MDMA_C12BRUR, MDMA_BASE + 0x360 @ (MDMA channel x Block Repeat address Update  register) 
        .equ MDMA_MDMA_C12BRUR_SUV_Shift, 0   @ bitWidth 16 (source adresse update  value)  
        .equ MDMA_MDMA_C12BRUR_DUV_Shift, 16   @ bitWidth 16 (destination address update)  
 
    .equ MDMA_MDMA_C12LAR, MDMA_BASE + 0x364 @ (MDMA channel x Link Address  register) 
        .equ MDMA_MDMA_C12LAR_LAR_Shift, 0   @ bitWidth 32 (Link address register)  
 
    .equ MDMA_MDMA_C12TBR, MDMA_BASE + 0x368 @ (MDMA channel x Trigger and Bus selection  Register) 
        .equ MDMA_MDMA_C12TBR_TSEL_Shift, 0   @ bitWidth 6 (Trigger selection)  
        .equ MDMA_MDMA_C12TBR_SBUS, 1 << 16   @ bitWidth 1 (Source BUS select This bit is protected  and can be written only if EN is 0.)  
        .equ MDMA_MDMA_C12TBR_DBUS, 1 << 17   @ bitWidth 1 (Destination BUS slect This bit is  protected and can be written only if EN is  0.)  
 
    .equ MDMA_MDMA_C12MAR, MDMA_BASE + 0x370 @ (MDMA channel x Mask address  register) 
        .equ MDMA_MDMA_C12MAR_MAR_Shift, 0   @ bitWidth 32 (Mask address)  
 
    .equ MDMA_MDMA_C12MDR, MDMA_BASE + 0x374 @ (MDMA channel x Mask Data  register) 
        .equ MDMA_MDMA_C12MDR_MDR_Shift, 0   @ bitWidth 32 (Mask data)  
 
    .equ MDMA_MDMA_C13ISR, MDMA_BASE + 0x380 @ (MDMA channel x interrupt/status  register) 
        .equ MDMA_MDMA_C13ISR_TEIF13, 1 << 0   @ bitWidth 1 (Channel x transfer error interrupt flag  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCRy register.)  
        .equ MDMA_MDMA_C13ISR_CTCIF13, 1 << 1   @ bitWidth 1 (Channel x Channel Transfer Complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register. CTC is set when the  last block was transferred and the channel has been  automatically disabled. CTC is also set when the  channel is suspended, as a result of writing EN bit  to 0.)  
        .equ MDMA_MDMA_C13ISR_BRTIF13, 1 << 2   @ bitWidth 1 (Channel x block repeat transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C13ISR_BTIF13, 1 << 3   @ bitWidth 1 (Channel x block transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C13ISR_TCIF13, 1 << 4   @ bitWidth 1 (channel x buffer transfer  complete)  
        .equ MDMA_MDMA_C13ISR_CRQA13, 1 << 16   @ bitWidth 1 (channel x request active  flag)  
 
    .equ MDMA_MDMA_C13IFCR, MDMA_BASE + 0x384 @ (MDMA channel x interrupt flag clear  register) 
        .equ MDMA_MDMA_C13IFCR_CTEIF13, 1 << 0   @ bitWidth 1 (Channel x clear transfer error interrupt  flag Writing a 1 into this bit clears TEIFx in the  MDMA_ISRy register)  
        .equ MDMA_MDMA_C13IFCR_CCTCIF13, 1 << 1   @ bitWidth 1 (Clear Channel transfer complete  interrupt flag for channel x Writing a 1 into this  bit clears CTCIFx in the MDMA_ISRy  register)  
        .equ MDMA_MDMA_C13IFCR_CBRTIF13, 1 << 2   @ bitWidth 1 (Channel x clear block repeat transfer  complete interrupt flag Writing a 1 into this bit  clears BRTIFx in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C13IFCR_CBTIF13, 1 << 3   @ bitWidth 1 (Channel x Clear block transfer complete  interrupt flag Writing a 1 into this bit clears BTIFx  in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C13IFCR_CLTCIF13, 1 << 4   @ bitWidth 1 (CLear buffer Transfer Complete Interrupt  Flag for channel x Writing a 1 into this bit clears  TCIFx in the MDMA_ISRy register)  
 
    .equ MDMA_MDMA_C13ESR, MDMA_BASE + 0x388 @ (MDMA Channel x error status  register) 
        .equ MDMA_MDMA_C13ESR_TEA_Shift, 0   @ bitWidth 7 (Transfer Error Address These bits are  set and cleared by HW, in case of an MDMA data  transfer error. It is used in conjunction with TED.  This field indicates the 7 LSBits of the address  which generated a transfer/access error. It may be  used by SW to retrieve the failing address, by adding  this value truncated to the buffer transfer length  size to the current SAR/DAR value. Note: The SAR/DAR  current value doesnt reflect this last address due to  the FIFO management system. The SAR/DAR are only  updated at the end of a buffer transfer of TLEN+1  bytes. Note: It is not set in case of a link data  error.)  
        .equ MDMA_MDMA_C13ESR_TED, 1 << 7   @ bitWidth 1 (Transfer Error Direction These bit is  set and cleared by HW, in case of an MDMA data  transfer error.)  
        .equ MDMA_MDMA_C13ESR_TELD, 1 << 8   @ bitWidth 1 (Transfer Error Link Data These bit is  set by HW, in case of a transfer error while reading  the block link data structure. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C13ESR_TEMD, 1 << 9   @ bitWidth 1 (Transfer Error Mask Data These bit is  set by HW, in case of a transfer error while writing  the Mask Data. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C13ESR_ASE, 1 << 10   @ bitWidth 1 (Address/Size Error These bit is set by  HW, when the programmed address is not aligned with  the data size. TED will indicate whether the problem  is on the source or destination. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C13ESR_BSE, 1 << 11   @ bitWidth 1 (Block Size Error These bit is set by HW,  when the block size is not an integer multiple of the  data size either for source or destination. TED will  indicate whether the problem is on the source or  destination. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
 
    .equ MDMA_MDMA_C13CR, MDMA_BASE + 0x38C @ (This register is used to control the  concerned channel.) 
        .equ MDMA_MDMA_C13CR_EN, 1 << 0   @ bitWidth 1 (channel enable)  
        .equ MDMA_MDMA_C13CR_TEIE, 1 << 1   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C13CR_CTCIE, 1 << 2   @ bitWidth 1 (Channel Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C13CR_BRTIE, 1 << 3   @ bitWidth 1 (Block Repeat transfer interrupt enable  This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C13CR_BTIE, 1 << 4   @ bitWidth 1 (Block Transfer interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C13CR_TCIE, 1 << 5   @ bitWidth 1 (buffer Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C13CR_PL_Shift, 6   @ bitWidth 2 (Priority level These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0.)  
        .equ MDMA_MDMA_C13CR_BEX, 1 << 12   @ bitWidth 1 (byte Endianness exchange)  
        .equ MDMA_MDMA_C13CR_HEX, 1 << 13   @ bitWidth 1 (Half word Endianes  exchange)  
        .equ MDMA_MDMA_C13CR_WEX, 1 << 14   @ bitWidth 1 (Word Endianness exchange)  
        .equ MDMA_MDMA_C13CR_SWRQ, 1 << 16   @ bitWidth 1 (SW ReQuest Writing a 1 into this bit  sets the CRQAx in MDMA_ISRy register, activating the  request on Channel x Note: Either the whole CxCR  register or the 8-bit/16-bit register @ Address  offset: 0x4E + 0x40 chn may be used for SWRQ  activation. In case of a SW request, acknowledge is  not generated neither HW signal, nor CxMAR write  access.)  
 
    .equ MDMA_MDMA_C13TCR, MDMA_BASE + 0x390 @ (This register is used to configure the  concerned channel.) 
        .equ MDMA_MDMA_C13TCR_SINC_Shift, 0   @ bitWidth 2 (Source increment mode These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0 Note: When source is  AHB SBUS=1, SINC = 00 is forbidden. In Linked List  Mode, at the end of a block single or last block in  repeated block transfer mode, this register will be  loaded from memory from address given by current  LAR[31:0] + 0x00.)  
        .equ MDMA_MDMA_C13TCR_DINC_Shift, 2   @ bitWidth 2 (Destination increment mode These bits  are set and cleared by software. These bits are  protected and can be written only if EN is 0 Note:  When destination is AHB DBUS=1, DINC = 00 is  forbidden.)  
        .equ MDMA_MDMA_C13TCR_SSIZE_Shift, 4   @ bitWidth 2 (Source data size These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0 Note: If a value of 11 is  programmed for the TCM access/AHB port, a transfer  error will occur TEIF bit set If SINCOS &lt;  SSIZE and SINC &#8800; 00, the result will be  unpredictable. Note: SSIZE = 11 double-word is  forbidden when source is TCM/AHB bus  SBUS=1.)  
        .equ MDMA_MDMA_C13TCR_DSIZE_Shift, 6   @ bitWidth 2 (Destination data size These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0. Note: If a value of  11 is programmed for the TCM access/AHB port, a  transfer error will occur TEIF bit set If DINCOS  &lt; DSIZE and DINC &#8800; 00, the result  will be unpredictable. Note: DSIZE = 11 double-word  is forbidden when destination is TCM/AHB bus  DBUS=1.)  
        .equ MDMA_MDMA_C13TCR_SINCOS_Shift, 8   @ bitWidth 2 (source increment offset  size)  
        .equ MDMA_MDMA_C13TCR_DINCOS_Shift, 10   @ bitWidth 2 (Destination increment  offset)  
        .equ MDMA_MDMA_C13TCR_SBURST_Shift, 12   @ bitWidth 3 (source burst transfer  configuration)  
        .equ MDMA_MDMA_C13TCR_DBURST_Shift, 15   @ bitWidth 3 (Destination burst transfer  configuration)  
        .equ MDMA_MDMA_C13TCR_TLEN_Shift, 18   @ bitWidth 7 (buffer transfer lengh)  
        .equ MDMA_MDMA_C13TCR_PKE, 1 << 25   @ bitWidth 1 (PacK Enable These bit is set and cleared  by software. If the Source Size is smaller than the  destination, it will be padded according to the PAM  value. If the Source data size is larger than the  destination one, it will be truncated. The alignment  will be done according to the PAM[0] value. This bit  is protected and can be written only if EN is  0)  
        .equ MDMA_MDMA_C13TCR_PAM_Shift, 26   @ bitWidth 2 (Padding/Alignement Mode These bits are  set and cleared by software. Case 1: Source data size  smaller than destination data size - 3 options are  valid. Case 2: Source data size larger than  destination data size. The remainder part is  discarded. When PKE = 1 or DSIZE=SSIZE, these bits  are ignored. These bits are protected and can be  written only if EN is 0)  
        .equ MDMA_MDMA_C13TCR_TRGM_Shift, 28   @ bitWidth 2 (Trigger Mode These bits are set and  cleared by software. Note: If TRGM is 11 for the  current block, all the values loaded at the end of  the current block through the linked list mechanism  must keep the same value TRGM=11 and the same SWRM  value, otherwise the result is undefined. These bits  are protected and can be written only if EN is  0.)  
        .equ MDMA_MDMA_C13TCR_SWRM, 1 << 30   @ bitWidth 1 (SW Request Mode This bit is set and  cleared by software. If a HW or SW request is  currently active, the bit change will be delayed  until the current transfer is completed. If the CxMAR  contains a valid address, the CxMDR value will also  be written @ CxMAR address. This bit is protected and  can be written only if EN is 0.)  
        .equ MDMA_MDMA_C13TCR_BWM, 1 << 31   @ bitWidth 1 (Bufferable Write Mode This bit is set  and cleared by software. This bit is protected and  can be written only if EN is 0. Note: All MDMA  destination accesses are non-cacheable.)  
 
    .equ MDMA_MDMA_C13BNDTR, MDMA_BASE + 0x394 @ (MDMA Channel x block number of data  register) 
        .equ MDMA_MDMA_C13BNDTR_BNDT_Shift, 0   @ bitWidth 17 (block number of data to  transfer)  
        .equ MDMA_MDMA_C13BNDTR_BRSUM, 1 << 18   @ bitWidth 1 (Block Repeat Source address Update Mode  These bits are protected and can be written only if  EN is 0.)  
        .equ MDMA_MDMA_C13BNDTR_BRDUM, 1 << 19   @ bitWidth 1 (Block Repeat Destination address Update  Mode These bits are protected and can be written only  if EN is 0.)  
        .equ MDMA_MDMA_C13BNDTR_BRC_Shift, 20   @ bitWidth 12 (Block Repeat Count This field contains  the number of repetitions of the current block 0 to  4095. When the channel is enabled, this register is  read-only, indicating the remaining number of blocks,  excluding the current one. This register decrements  after each complete block transfer. Once the last  block transfer has completed, this register can  either stay at zero or be reloaded automatically from  memory in Linked List mode - i.e. Link Address  valid. These bits are protected and can be written  only if EN is 0.)  
 
    .equ MDMA_MDMA_C13SAR, MDMA_BASE + 0x398 @ (MDMA channel x source address  register) 
        .equ MDMA_MDMA_C13SAR_SAR_Shift, 0   @ bitWidth 32 (source adr base)  
 
    .equ MDMA_MDMA_C13DAR, MDMA_BASE + 0x39C @ (MDMA channel x destination address  register) 
        .equ MDMA_MDMA_C13DAR_DAR_Shift, 0   @ bitWidth 32 (Destination adr base)  
 
    .equ MDMA_MDMA_C13BRUR, MDMA_BASE + 0x3A0 @ (MDMA channel x Block Repeat address Update  register) 
        .equ MDMA_MDMA_C13BRUR_SUV_Shift, 0   @ bitWidth 16 (source adresse update  value)  
        .equ MDMA_MDMA_C13BRUR_DUV_Shift, 16   @ bitWidth 16 (destination address update)  
 
    .equ MDMA_MDMA_C13LAR, MDMA_BASE + 0x3A4 @ (MDMA channel x Link Address  register) 
        .equ MDMA_MDMA_C13LAR_LAR_Shift, 0   @ bitWidth 32 (Link address register)  
 
    .equ MDMA_MDMA_C13TBR, MDMA_BASE + 0x3A8 @ (MDMA channel x Trigger and Bus selection  Register) 
        .equ MDMA_MDMA_C13TBR_TSEL_Shift, 0   @ bitWidth 6 (Trigger selection)  
        .equ MDMA_MDMA_C13TBR_SBUS, 1 << 16   @ bitWidth 1 (Source BUS select This bit is protected  and can be written only if EN is 0.)  
        .equ MDMA_MDMA_C13TBR_DBUS, 1 << 17   @ bitWidth 1 (Destination BUS slect This bit is  protected and can be written only if EN is  0.)  
 
    .equ MDMA_MDMA_C13MAR, MDMA_BASE + 0x3B0 @ (MDMA channel x Mask address  register) 
        .equ MDMA_MDMA_C13MAR_MAR_Shift, 0   @ bitWidth 32 (Mask address)  
 
    .equ MDMA_MDMA_C13MDR, MDMA_BASE + 0x3B4 @ (MDMA channel x Mask Data  register) 
        .equ MDMA_MDMA_C13MDR_MDR_Shift, 0   @ bitWidth 32 (Mask data)  
 
    .equ MDMA_MDMA_C14ISR, MDMA_BASE + 0x3C0 @ (MDMA channel x interrupt/status  register) 
        .equ MDMA_MDMA_C14ISR_TEIF14, 1 << 0   @ bitWidth 1 (Channel x transfer error interrupt flag  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCRy register.)  
        .equ MDMA_MDMA_C14ISR_CTCIF14, 1 << 1   @ bitWidth 1 (Channel x Channel Transfer Complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register. CTC is set when the  last block was transferred and the channel has been  automatically disabled. CTC is also set when the  channel is suspended, as a result of writing EN bit  to 0.)  
        .equ MDMA_MDMA_C14ISR_BRTIF14, 1 << 2   @ bitWidth 1 (Channel x block repeat transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C14ISR_BTIF14, 1 << 3   @ bitWidth 1 (Channel x block transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C14ISR_TCIF14, 1 << 4   @ bitWidth 1 (channel x buffer transfer  complete)  
        .equ MDMA_MDMA_C14ISR_CRQA14, 1 << 16   @ bitWidth 1 (channel x request active  flag)  
 
    .equ MDMA_MDMA_C14IFCR, MDMA_BASE + 0x3C4 @ (MDMA channel x interrupt flag clear  register) 
        .equ MDMA_MDMA_C14IFCR_CTEIF14, 1 << 0   @ bitWidth 1 (Channel x clear transfer error interrupt  flag Writing a 1 into this bit clears TEIFx in the  MDMA_ISRy register)  
        .equ MDMA_MDMA_C14IFCR_CCTCIF14, 1 << 1   @ bitWidth 1 (Clear Channel transfer complete  interrupt flag for channel x Writing a 1 into this  bit clears CTCIFx in the MDMA_ISRy  register)  
        .equ MDMA_MDMA_C14IFCR_CBRTIF14, 1 << 2   @ bitWidth 1 (Channel x clear block repeat transfer  complete interrupt flag Writing a 1 into this bit  clears BRTIFx in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C14IFCR_CBTIF14, 1 << 3   @ bitWidth 1 (Channel x Clear block transfer complete  interrupt flag Writing a 1 into this bit clears BTIFx  in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C14IFCR_CLTCIF14, 1 << 4   @ bitWidth 1 (CLear buffer Transfer Complete Interrupt  Flag for channel x Writing a 1 into this bit clears  TCIFx in the MDMA_ISRy register)  
 
    .equ MDMA_MDMA_C14ESR, MDMA_BASE + 0x3C8 @ (MDMA Channel x error status  register) 
        .equ MDMA_MDMA_C14ESR_TEA_Shift, 0   @ bitWidth 7 (Transfer Error Address These bits are  set and cleared by HW, in case of an MDMA data  transfer error. It is used in conjunction with TED.  This field indicates the 7 LSBits of the address  which generated a transfer/access error. It may be  used by SW to retrieve the failing address, by adding  this value truncated to the buffer transfer length  size to the current SAR/DAR value. Note: The SAR/DAR  current value doesnt reflect this last address due to  the FIFO management system. The SAR/DAR are only  updated at the end of a buffer transfer of TLEN+1  bytes. Note: It is not set in case of a link data  error.)  
        .equ MDMA_MDMA_C14ESR_TED, 1 << 7   @ bitWidth 1 (Transfer Error Direction These bit is  set and cleared by HW, in case of an MDMA data  transfer error.)  
        .equ MDMA_MDMA_C14ESR_TELD, 1 << 8   @ bitWidth 1 (Transfer Error Link Data These bit is  set by HW, in case of a transfer error while reading  the block link data structure. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C14ESR_TEMD, 1 << 9   @ bitWidth 1 (Transfer Error Mask Data These bit is  set by HW, in case of a transfer error while writing  the Mask Data. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C14ESR_ASE, 1 << 10   @ bitWidth 1 (Address/Size Error These bit is set by  HW, when the programmed address is not aligned with  the data size. TED will indicate whether the problem  is on the source or destination. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C14ESR_BSE, 1 << 11   @ bitWidth 1 (Block Size Error These bit is set by HW,  when the block size is not an integer multiple of the  data size either for source or destination. TED will  indicate whether the problem is on the source or  destination. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
 
    .equ MDMA_MDMA_C14CR, MDMA_BASE + 0x3CC @ (This register is used to control the  concerned channel.) 
        .equ MDMA_MDMA_C14CR_EN, 1 << 0   @ bitWidth 1 (channel enable)  
        .equ MDMA_MDMA_C14CR_TEIE, 1 << 1   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C14CR_CTCIE, 1 << 2   @ bitWidth 1 (Channel Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C14CR_BRTIE, 1 << 3   @ bitWidth 1 (Block Repeat transfer interrupt enable  This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C14CR_BTIE, 1 << 4   @ bitWidth 1 (Block Transfer interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C14CR_TCIE, 1 << 5   @ bitWidth 1 (buffer Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C14CR_PL_Shift, 6   @ bitWidth 2 (Priority level These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0.)  
        .equ MDMA_MDMA_C14CR_BEX, 1 << 12   @ bitWidth 1 (byte Endianness exchange)  
        .equ MDMA_MDMA_C14CR_HEX, 1 << 13   @ bitWidth 1 (Half word Endianes  exchange)  
        .equ MDMA_MDMA_C14CR_WEX, 1 << 14   @ bitWidth 1 (Word Endianness exchange)  
        .equ MDMA_MDMA_C14CR_SWRQ, 1 << 16   @ bitWidth 1 (SW ReQuest Writing a 1 into this bit  sets the CRQAx in MDMA_ISRy register, activating the  request on Channel x Note: Either the whole CxCR  register or the 8-bit/16-bit register @ Address  offset: 0x4E + 0x40 chn may be used for SWRQ  activation. In case of a SW request, acknowledge is  not generated neither HW signal, nor CxMAR write  access.)  
 
    .equ MDMA_MDMA_C14TCR, MDMA_BASE + 0x3D0 @ (This register is used to configure the  concerned channel.) 
        .equ MDMA_MDMA_C14TCR_SINC_Shift, 0   @ bitWidth 2 (Source increment mode These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0 Note: When source is  AHB SBUS=1, SINC = 00 is forbidden. In Linked List  Mode, at the end of a block single or last block in  repeated block transfer mode, this register will be  loaded from memory from address given by current  LAR[31:0] + 0x00.)  
        .equ MDMA_MDMA_C14TCR_DINC_Shift, 2   @ bitWidth 2 (Destination increment mode These bits  are set and cleared by software. These bits are  protected and can be written only if EN is 0 Note:  When destination is AHB DBUS=1, DINC = 00 is  forbidden.)  
        .equ MDMA_MDMA_C14TCR_SSIZE_Shift, 4   @ bitWidth 2 (Source data size These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0 Note: If a value of 11 is  programmed for the TCM access/AHB port, a transfer  error will occur TEIF bit set If SINCOS &lt;  SSIZE and SINC &#8800; 00, the result will be  unpredictable. Note: SSIZE = 11 double-word is  forbidden when source is TCM/AHB bus  SBUS=1.)  
        .equ MDMA_MDMA_C14TCR_DSIZE_Shift, 6   @ bitWidth 2 (Destination data size These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0. Note: If a value of  11 is programmed for the TCM access/AHB port, a  transfer error will occur TEIF bit set If DINCOS  &lt; DSIZE and DINC &#8800; 00, the result  will be unpredictable. Note: DSIZE = 11 double-word  is forbidden when destination is TCM/AHB bus  DBUS=1.)  
        .equ MDMA_MDMA_C14TCR_SINCOS_Shift, 8   @ bitWidth 2 (source increment offset  size)  
        .equ MDMA_MDMA_C14TCR_DINCOS_Shift, 10   @ bitWidth 2 (Destination increment  offset)  
        .equ MDMA_MDMA_C14TCR_SBURST_Shift, 12   @ bitWidth 3 (source burst transfer  configuration)  
        .equ MDMA_MDMA_C14TCR_DBURST_Shift, 15   @ bitWidth 3 (Destination burst transfer  configuration)  
        .equ MDMA_MDMA_C14TCR_TLEN_Shift, 18   @ bitWidth 7 (buffer transfer lengh)  
        .equ MDMA_MDMA_C14TCR_PKE, 1 << 25   @ bitWidth 1 (PacK Enable These bit is set and cleared  by software. If the Source Size is smaller than the  destination, it will be padded according to the PAM  value. If the Source data size is larger than the  destination one, it will be truncated. The alignment  will be done according to the PAM[0] value. This bit  is protected and can be written only if EN is  0)  
        .equ MDMA_MDMA_C14TCR_PAM_Shift, 26   @ bitWidth 2 (Padding/Alignement Mode These bits are  set and cleared by software. Case 1: Source data size  smaller than destination data size - 3 options are  valid. Case 2: Source data size larger than  destination data size. The remainder part is  discarded. When PKE = 1 or DSIZE=SSIZE, these bits  are ignored. These bits are protected and can be  written only if EN is 0)  
        .equ MDMA_MDMA_C14TCR_TRGM_Shift, 28   @ bitWidth 2 (Trigger Mode These bits are set and  cleared by software. Note: If TRGM is 11 for the  current block, all the values loaded at the end of  the current block through the linked list mechanism  must keep the same value TRGM=11 and the same SWRM  value, otherwise the result is undefined. These bits  are protected and can be written only if EN is  0.)  
        .equ MDMA_MDMA_C14TCR_SWRM, 1 << 30   @ bitWidth 1 (SW Request Mode This bit is set and  cleared by software. If a HW or SW request is  currently active, the bit change will be delayed  until the current transfer is completed. If the CxMAR  contains a valid address, the CxMDR value will also  be written @ CxMAR address. This bit is protected and  can be written only if EN is 0.)  
        .equ MDMA_MDMA_C14TCR_BWM, 1 << 31   @ bitWidth 1 (Bufferable Write Mode This bit is set  and cleared by software. This bit is protected and  can be written only if EN is 0. Note: All MDMA  destination accesses are non-cacheable.)  
 
    .equ MDMA_MDMA_C14BNDTR, MDMA_BASE + 0x3D4 @ (MDMA Channel x block number of data  register) 
        .equ MDMA_MDMA_C14BNDTR_BNDT_Shift, 0   @ bitWidth 17 (block number of data to  transfer)  
        .equ MDMA_MDMA_C14BNDTR_BRSUM, 1 << 18   @ bitWidth 1 (Block Repeat Source address Update Mode  These bits are protected and can be written only if  EN is 0.)  
        .equ MDMA_MDMA_C14BNDTR_BRDUM, 1 << 19   @ bitWidth 1 (Block Repeat Destination address Update  Mode These bits are protected and can be written only  if EN is 0.)  
        .equ MDMA_MDMA_C14BNDTR_BRC_Shift, 20   @ bitWidth 12 (Block Repeat Count This field contains  the number of repetitions of the current block 0 to  4095. When the channel is enabled, this register is  read-only, indicating the remaining number of blocks,  excluding the current one. This register decrements  after each complete block transfer. Once the last  block transfer has completed, this register can  either stay at zero or be reloaded automatically from  memory in Linked List mode - i.e. Link Address  valid. These bits are protected and can be written  only if EN is 0.)  
 
    .equ MDMA_MDMA_C14SAR, MDMA_BASE + 0x3D8 @ (MDMA channel x source address  register) 
        .equ MDMA_MDMA_C14SAR_SAR_Shift, 0   @ bitWidth 32 (source adr base)  
 
    .equ MDMA_MDMA_C14DAR, MDMA_BASE + 0x3DC @ (MDMA channel x destination address  register) 
        .equ MDMA_MDMA_C14DAR_DAR_Shift, 0   @ bitWidth 32 (Destination adr base)  
 
    .equ MDMA_MDMA_C14BRUR, MDMA_BASE + 0x3E0 @ (MDMA channel x Block Repeat address Update  register) 
        .equ MDMA_MDMA_C14BRUR_SUV_Shift, 0   @ bitWidth 16 (source adresse update  value)  
        .equ MDMA_MDMA_C14BRUR_DUV_Shift, 16   @ bitWidth 16 (destination address update)  
 
    .equ MDMA_MDMA_C14LAR, MDMA_BASE + 0x3E4 @ (MDMA channel x Link Address  register) 
        .equ MDMA_MDMA_C14LAR_LAR_Shift, 0   @ bitWidth 32 (Link address register)  
 
    .equ MDMA_MDMA_C14TBR, MDMA_BASE + 0x3E8 @ (MDMA channel x Trigger and Bus selection  Register) 
        .equ MDMA_MDMA_C14TBR_TSEL_Shift, 0   @ bitWidth 6 (Trigger selection)  
        .equ MDMA_MDMA_C14TBR_SBUS, 1 << 16   @ bitWidth 1 (Source BUS select This bit is protected  and can be written only if EN is 0.)  
        .equ MDMA_MDMA_C14TBR_DBUS, 1 << 17   @ bitWidth 1 (Destination BUS slect This bit is  protected and can be written only if EN is  0.)  
 
    .equ MDMA_MDMA_C14MAR, MDMA_BASE + 0x3F0 @ (MDMA channel x Mask address  register) 
        .equ MDMA_MDMA_C14MAR_MAR_Shift, 0   @ bitWidth 32 (Mask address)  
 
    .equ MDMA_MDMA_C14MDR, MDMA_BASE + 0x3F4 @ (MDMA channel x Mask Data  register) 
        .equ MDMA_MDMA_C14MDR_MDR_Shift, 0   @ bitWidth 32 (Mask data)  
 
    .equ MDMA_MDMA_C15ISR, MDMA_BASE + 0x400 @ (MDMA channel x interrupt/status  register) 
        .equ MDMA_MDMA_C15ISR_TEIF15, 1 << 0   @ bitWidth 1 (Channel x transfer error interrupt flag  This bit is set by hardware. It is cleared by  software writing 1 to the corresponding bit in the  DMA_IFCRy register.)  
        .equ MDMA_MDMA_C15ISR_CTCIF15, 1 << 1   @ bitWidth 1 (Channel x Channel Transfer Complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register. CTC is set when the  last block was transferred and the channel has been  automatically disabled. CTC is also set when the  channel is suspended, as a result of writing EN bit  to 0.)  
        .equ MDMA_MDMA_C15ISR_BRTIF15, 1 << 2   @ bitWidth 1 (Channel x block repeat transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C15ISR_BTIF15, 1 << 3   @ bitWidth 1 (Channel x block transfer complete  interrupt flag This bit is set by hardware. It is  cleared by software writing 1 to the corresponding  bit in the DMA_IFCRy register.)  
        .equ MDMA_MDMA_C15ISR_TCIF15, 1 << 4   @ bitWidth 1 (channel x buffer transfer  complete)  
        .equ MDMA_MDMA_C15ISR_CRQA15, 1 << 16   @ bitWidth 1 (channel x request active  flag)  
 
    .equ MDMA_MDMA_C15IFCR, MDMA_BASE + 0x404 @ (MDMA channel x interrupt flag clear  register) 
        .equ MDMA_MDMA_C15IFCR_CTEIF15, 1 << 0   @ bitWidth 1 (Channel x clear transfer error interrupt  flag Writing a 1 into this bit clears TEIFx in the  MDMA_ISRy register)  
        .equ MDMA_MDMA_C15IFCR_CCTCIF15, 1 << 1   @ bitWidth 1 (Clear Channel transfer complete  interrupt flag for channel x Writing a 1 into this  bit clears CTCIFx in the MDMA_ISRy  register)  
        .equ MDMA_MDMA_C15IFCR_CBRTIF15, 1 << 2   @ bitWidth 1 (Channel x clear block repeat transfer  complete interrupt flag Writing a 1 into this bit  clears BRTIFx in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C15IFCR_CBTIF15, 1 << 3   @ bitWidth 1 (Channel x Clear block transfer complete  interrupt flag Writing a 1 into this bit clears BTIFx  in the MDMA_ISRy register)  
        .equ MDMA_MDMA_C15IFCR_CLTCIF15, 1 << 4   @ bitWidth 1 (CLear buffer Transfer Complete Interrupt  Flag for channel x Writing a 1 into this bit clears  TCIFx in the MDMA_ISRy register)  
 
    .equ MDMA_MDMA_C15ESR, MDMA_BASE + 0x408 @ (MDMA Channel x error status  register) 
        .equ MDMA_MDMA_C15ESR_TEA_Shift, 0   @ bitWidth 7 (Transfer Error Address These bits are  set and cleared by HW, in case of an MDMA data  transfer error. It is used in conjunction with TED.  This field indicates the 7 LSBits of the address  which generated a transfer/access error. It may be  used by SW to retrieve the failing address, by adding  this value truncated to the buffer transfer length  size to the current SAR/DAR value. Note: The SAR/DAR  current value doesnt reflect this last address due to  the FIFO management system. The SAR/DAR are only  updated at the end of a buffer transfer of TLEN+1  bytes. Note: It is not set in case of a link data  error.)  
        .equ MDMA_MDMA_C15ESR_TED, 1 << 7   @ bitWidth 1 (Transfer Error Direction These bit is  set and cleared by HW, in case of an MDMA data  transfer error.)  
        .equ MDMA_MDMA_C15ESR_TELD, 1 << 8   @ bitWidth 1 (Transfer Error Link Data These bit is  set by HW, in case of a transfer error while reading  the block link data structure. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C15ESR_TEMD, 1 << 9   @ bitWidth 1 (Transfer Error Mask Data These bit is  set by HW, in case of a transfer error while writing  the Mask Data. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C15ESR_ASE, 1 << 10   @ bitWidth 1 (Address/Size Error These bit is set by  HW, when the programmed address is not aligned with  the data size. TED will indicate whether the problem  is on the source or destination. It is cleared by  software writing 1 to the CTEIFx bit in the DMA_IFCRy  register.)  
        .equ MDMA_MDMA_C15ESR_BSE, 1 << 11   @ bitWidth 1 (Block Size Error These bit is set by HW,  when the block size is not an integer multiple of the  data size either for source or destination. TED will  indicate whether the problem is on the source or  destination. It is cleared by software writing 1 to  the CTEIFx bit in the DMA_IFCRy  register.)  
 
    .equ MDMA_MDMA_C15CR, MDMA_BASE + 0x40C @ (This register is used to control the  concerned channel.) 
        .equ MDMA_MDMA_C15CR_EN, 1 << 0   @ bitWidth 1 (channel enable)  
        .equ MDMA_MDMA_C15CR_TEIE, 1 << 1   @ bitWidth 1 (Transfer error interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C15CR_CTCIE, 1 << 2   @ bitWidth 1 (Channel Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C15CR_BRTIE, 1 << 3   @ bitWidth 1 (Block Repeat transfer interrupt enable  This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C15CR_BTIE, 1 << 4   @ bitWidth 1 (Block Transfer interrupt enable This bit  is set and cleared by software.)  
        .equ MDMA_MDMA_C15CR_TCIE, 1 << 5   @ bitWidth 1 (buffer Transfer Complete interrupt  enable This bit is set and cleared by  software.)  
        .equ MDMA_MDMA_C15CR_PL_Shift, 6   @ bitWidth 2 (Priority level These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0.)  
        .equ MDMA_MDMA_C15CR_BEX, 1 << 12   @ bitWidth 1 (byte Endianness exchange)  
        .equ MDMA_MDMA_C15CR_HEX, 1 << 13   @ bitWidth 1 (Half word Endianes  exchange)  
        .equ MDMA_MDMA_C15CR_WEX, 1 << 14   @ bitWidth 1 (Word Endianness exchange)  
        .equ MDMA_MDMA_C15CR_SWRQ, 1 << 16   @ bitWidth 1 (SW ReQuest Writing a 1 into this bit  sets the CRQAx in MDMA_ISRy register, activating the  request on Channel x Note: Either the whole CxCR  register or the 8-bit/16-bit register @ Address  offset: 0x4E + 0x40 chn may be used for SWRQ  activation. In case of a SW request, acknowledge is  not generated neither HW signal, nor CxMAR write  access.)  
 
    .equ MDMA_MDMA_C15TCR, MDMA_BASE + 0x410 @ (This register is used to configure the  concerned channel.) 
        .equ MDMA_MDMA_C15TCR_SINC_Shift, 0   @ bitWidth 2 (Source increment mode These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0 Note: When source is  AHB SBUS=1, SINC = 00 is forbidden. In Linked List  Mode, at the end of a block single or last block in  repeated block transfer mode, this register will be  loaded from memory from address given by current  LAR[31:0] + 0x00.)  
        .equ MDMA_MDMA_C15TCR_DINC_Shift, 2   @ bitWidth 2 (Destination increment mode These bits  are set and cleared by software. These bits are  protected and can be written only if EN is 0 Note:  When destination is AHB DBUS=1, DINC = 00 is  forbidden.)  
        .equ MDMA_MDMA_C15TCR_SSIZE_Shift, 4   @ bitWidth 2 (Source data size These bits are set and  cleared by software. These bits are protected and can  be written only if EN is 0 Note: If a value of 11 is  programmed for the TCM access/AHB port, a transfer  error will occur TEIF bit set If SINCOS &lt;  SSIZE and SINC &#8800; 00, the result will be  unpredictable. Note: SSIZE = 11 double-word is  forbidden when source is TCM/AHB bus  SBUS=1.)  
        .equ MDMA_MDMA_C15TCR_DSIZE_Shift, 6   @ bitWidth 2 (Destination data size These bits are set  and cleared by software. These bits are protected and  can be written only if EN is 0. Note: If a value of  11 is programmed for the TCM access/AHB port, a  transfer error will occur TEIF bit set If DINCOS  &lt; DSIZE and DINC &#8800; 00, the result  will be unpredictable. Note: DSIZE = 11 double-word  is forbidden when destination is TCM/AHB bus  DBUS=1.)  
        .equ MDMA_MDMA_C15TCR_SINCOS_Shift, 8   @ bitWidth 2 (source increment offset  size)  
        .equ MDMA_MDMA_C15TCR_DINCOS_Shift, 10   @ bitWidth 2 (Destination increment  offset)  
        .equ MDMA_MDMA_C15TCR_SBURST_Shift, 12   @ bitWidth 3 (source burst transfer  configuration)  
        .equ MDMA_MDMA_C15TCR_DBURST_Shift, 15   @ bitWidth 3 (Destination burst transfer  configuration)  
        .equ MDMA_MDMA_C15TCR_TLEN_Shift, 18   @ bitWidth 7 (buffer transfer lengh)  
        .equ MDMA_MDMA_C15TCR_PKE, 1 << 25   @ bitWidth 1 (PacK Enable These bit is set and cleared  by software. If the Source Size is smaller than the  destination, it will be padded according to the PAM  value. If the Source data size is larger than the  destination one, it will be truncated. The alignment  will be done according to the PAM[0] value. This bit  is protected and can be written only if EN is  0)  
        .equ MDMA_MDMA_C15TCR_PAM_Shift, 26   @ bitWidth 2 (Padding/Alignement Mode These bits are  set and cleared by software. Case 1: Source data size  smaller than destination data size - 3 options are  valid. Case 2: Source data size larger than  destination data size. The remainder part is  discarded. When PKE = 1 or DSIZE=SSIZE, these bits  are ignored. These bits are protected and can be  written only if EN is 0)  
        .equ MDMA_MDMA_C15TCR_TRGM_Shift, 28   @ bitWidth 2 (Trigger Mode These bits are set and  cleared by software. Note: If TRGM is 11 for the  current block, all the values loaded at the end of  the current block through the linked list mechanism  must keep the same value TRGM=11 and the same SWRM  value, otherwise the result is undefined. These bits  are protected and can be written only if EN is  0.)  
        .equ MDMA_MDMA_C15TCR_SWRM, 1 << 30   @ bitWidth 1 (SW Request Mode This bit is set and  cleared by software. If a HW or SW request is  currently active, the bit change will be delayed  until the current transfer is completed. If the CxMAR  contains a valid address, the CxMDR value will also  be written @ CxMAR address. This bit is protected and  can be written only if EN is 0.)  
        .equ MDMA_MDMA_C15TCR_BWM, 1 << 31   @ bitWidth 1 (Bufferable Write Mode This bit is set  and cleared by software. This bit is protected and  can be written only if EN is 0. Note: All MDMA  destination accesses are non-cacheable.)  
 
    .equ MDMA_MDMA_C15BNDTR, MDMA_BASE + 0x414 @ (MDMA Channel x block number of data  register) 
        .equ MDMA_MDMA_C15BNDTR_BNDT_Shift, 0   @ bitWidth 17 (block number of data to  transfer)  
        .equ MDMA_MDMA_C15BNDTR_BRSUM, 1 << 18   @ bitWidth 1 (Block Repeat Source address Update Mode  These bits are protected and can be written only if  EN is 0.)  
        .equ MDMA_MDMA_C15BNDTR_BRDUM, 1 << 19   @ bitWidth 1 (Block Repeat Destination address Update  Mode These bits are protected and can be written only  if EN is 0.)  
        .equ MDMA_MDMA_C15BNDTR_BRC_Shift, 20   @ bitWidth 12 (Block Repeat Count This field contains  the number of repetitions of the current block 0 to  4095. When the channel is enabled, this register is  read-only, indicating the remaining number of blocks,  excluding the current one. This register decrements  after each complete block transfer. Once the last  block transfer has completed, this register can  either stay at zero or be reloaded automatically from  memory in Linked List mode - i.e. Link Address  valid. These bits are protected and can be written  only if EN is 0.)  
 
    .equ MDMA_MDMA_C15SAR, MDMA_BASE + 0x418 @ (MDMA channel x source address  register) 
        .equ MDMA_MDMA_C15SAR_SAR_Shift, 0   @ bitWidth 32 (source adr base)  
 
    .equ MDMA_MDMA_C15DAR, MDMA_BASE + 0x41C @ (MDMA channel x destination address  register) 
        .equ MDMA_MDMA_C15DAR_DAR_Shift, 0   @ bitWidth 32 (Destination adr base)  
 
    .equ MDMA_MDMA_C15BRUR, MDMA_BASE + 0x420 @ (MDMA channel x Block Repeat address Update  register) 
        .equ MDMA_MDMA_C15BRUR_SUV_Shift, 0   @ bitWidth 16 (source adresse update  value)  
        .equ MDMA_MDMA_C15BRUR_DUV_Shift, 16   @ bitWidth 16 (destination address update)  
 
    .equ MDMA_MDMA_C15LAR, MDMA_BASE + 0x424 @ (MDMA channel x Link Address  register) 
        .equ MDMA_MDMA_C15LAR_LAR_Shift, 0   @ bitWidth 32 (Link address register)  
 
    .equ MDMA_MDMA_C15TBR, MDMA_BASE + 0x428 @ (MDMA channel x Trigger and Bus selection  Register) 
        .equ MDMA_MDMA_C15TBR_TSEL_Shift, 0   @ bitWidth 6 (Trigger selection)  
        .equ MDMA_MDMA_C15TBR_SBUS, 1 << 16   @ bitWidth 1 (Source BUS select This bit is protected  and can be written only if EN is 0.)  
        .equ MDMA_MDMA_C15TBR_DBUS, 1 << 17   @ bitWidth 1 (Destination BUS slect This bit is  protected and can be written only if EN is  0.)  
 
    .equ MDMA_MDMA_C15MAR, MDMA_BASE + 0x430 @ (MDMA channel x Mask address  register) 
        .equ MDMA_MDMA_C15MAR_MAR_Shift, 0   @ bitWidth 32 (Mask address)  
 
    .equ MDMA_MDMA_C15MDR, MDMA_BASE + 0x434 @ (MDMA channel x Mask Data  register) 
        .equ MDMA_MDMA_C15MDR_MDR_Shift, 0   @ bitWidth 32 (Mask data)  
 

@=========================== QUADSPI ===========================@
.equ QUADSPI_BASE, 0x52005000 @ (QUADSPI) 
    .equ QUADSPI_CR, QUADSPI_BASE + 0x0 @ (QUADSPI control register) 
        .equ QUADSPI_CR_EN, 1 << 0   @ bitWidth 1 (Enable Enable the QUADSPI.)  
        .equ QUADSPI_CR_ABORT, 1 << 1   @ bitWidth 1 (Abort request This bit aborts the  on-going command sequence. It is automatically reset  once the abort is complete. This bit stops the  current transfer. In polling mode or memory-mapped  mode, this bit also reset the APM bit or the DM  bit.)  
        .equ QUADSPI_CR_DMAEN, 1 << 2   @ bitWidth 1 (DMA enable In indirect mode, DMA can be  used to input or output data via the QUADSPI_DR  register. DMA transfers are initiated when the FIFO  threshold flag, FTF, is set.)  
        .equ QUADSPI_CR_TCEN, 1 << 3   @ bitWidth 1 (Timeout counter enable This bit is valid  only when memory-mapped mode FMODE = 11 is  selected. Activating this bit causes the chip select  nCS to be released and thus reduces consumption  if there has not been an access after a certain  amount of time, where this time is defined by  TIMEOUT[15:0] QUADSPI_LPTR. Enable the timeout  counter. By default, the QUADSPI never stops its  prefetch operation, keeping the previous read  operation active with nCS maintained low, even if no  access to the Flash memory occurs for a long time.  Since Flash memories tend to consume more when nCS is  held low, the application might want to activate the  timeout counter TCEN = 1, QUADSPI_CR[3] so that nCS  is released after a period of TIMEOUT[15:0]  QUADSPI_LPTR cycles have elapsed without an access  since when the FIFO becomes full with prefetch data.  This bit can be modified only when BUSY =  0.)  
        .equ QUADSPI_CR_SSHIFT, 1 << 4   @ bitWidth 1 (Sample shift By default, the QUADSPI  samples data 1/2 of a CLK cycle after the data is  driven by the Flash memory. This bit allows the data  is to be sampled later in order to account for  external signal delays. Firmware must assure that  SSHIFT = 0 when in DDR mode when DDRM = 1. This  field can be modified only when BUSY =  0.)  
        .equ QUADSPI_CR_DFM, 1 << 6   @ bitWidth 1 (Dual-flash mode This bit activates  dual-flash mode, where two external Flash memories  are used simultaneously to double throughput and  capacity. This bit can be modified only when BUSY =  0.)  
        .equ QUADSPI_CR_FSEL, 1 << 7   @ bitWidth 1 (Flash memory selection This bit selects  the Flash memory to be addressed in single flash mode  when DFM = 0. This bit can be modified only when  BUSY = 0. This bit is ignored when DFM =  1.)  
        .equ QUADSPI_CR_FTHRES_Shift, 8   @ bitWidth 5 (FIFO threshold level Defines, in  indirect mode, the threshold number of bytes in the  FIFO that will cause the FIFO threshold flag FTF,  QUADSPI_SR[2] to be set. In indirect write mode  FMODE = 00: ... In indirect read mode FMODE = 01:  ... If DMAEN = 1, then the DMA controller for the  corresponding channel must be disabled before  changing the FTHRES value.)  
        .equ QUADSPI_CR_TEIE, 1 << 16   @ bitWidth 1 (Transfer error interrupt enable This bit  enables the transfer error interrupt.)  
        .equ QUADSPI_CR_TCIE, 1 << 17   @ bitWidth 1 (Transfer complete interrupt enable This  bit enables the transfer complete  interrupt.)  
        .equ QUADSPI_CR_FTIE, 1 << 18   @ bitWidth 1 (FIFO threshold interrupt enable This bit  enables the FIFO threshold interrupt.)  
        .equ QUADSPI_CR_SMIE, 1 << 19   @ bitWidth 1 (Status match interrupt enable This bit  enables the status match interrupt.)  
        .equ QUADSPI_CR_TOIE, 1 << 20   @ bitWidth 1 (TimeOut interrupt enable This bit  enables the TimeOut interrupt.)  
        .equ QUADSPI_CR_APMS, 1 << 22   @ bitWidth 1 (Automatic poll mode stop This bit  determines if automatic polling is stopped after a  match. This bit can be modified only when BUSY =  0.)  
        .equ QUADSPI_CR_PMM, 1 << 23   @ bitWidth 1 (Polling match mode This bit indicates  which method should be used for determining a match  during automatic polling mode. This bit can be  modified only when BUSY = 0.)  
        .equ QUADSPI_CR_PRESCALER_Shift, 24   @ bitWidth 8 (clock prescaler)  
 
    .equ QUADSPI_DCR, QUADSPI_BASE + 0x4 @ (QUADSPI device configuration  register) 
        .equ QUADSPI_DCR_CKMODE, 1 << 0   @ bitWidth 1 (indicates the level that clk takes  between command)  
        .equ QUADSPI_DCR_CSHT_Shift, 8   @ bitWidth 3 (Chip select high time CSHT+1 defines the  minimum number of CLK cycles which the chip select  nCS must remain high between commands issued to the  Flash memory. ... This field can be modified only  when BUSY = 0.)  
        .equ QUADSPI_DCR_FSIZE_Shift, 16   @ bitWidth 5 (Flash memory size This field defines the  size of external memory using the following formula:  Number of bytes in Flash memory = 2[FSIZE+1] FSIZE+1  is effectively the number of address bits required to  address the Flash memory. The Flash memory capacity  can be up to 4GB addressed using 32 bits in  indirect mode, but the addressable space in  memory-mapped mode is limited to 256MB. If DFM = 1,  FSIZE indicates the total capacity of the two Flash  memories together. This field can be modified only  when BUSY = 0.)  
 
    .equ QUADSPI_SR, QUADSPI_BASE + 0x8 @ (QUADSPI status register) 
        .equ QUADSPI_SR_TEF, 1 << 0   @ bitWidth 1 (Transfer error flag This bit is set in  indirect mode when an invalid address is being  accessed in indirect mode. It is cleared by writing 1  to CTEF.)  
        .equ QUADSPI_SR_TCF, 1 << 1   @ bitWidth 1 (Transfer complete flag This bit is set  in indirect mode when the programmed number of data  has been transferred or in any mode when the transfer  has been aborted.It is cleared by writing 1 to  CTCF.)  
        .equ QUADSPI_SR_FTF, 1 << 2   @ bitWidth 1 (FIFO threshold flag In indirect mode,  this bit is set when the FIFO threshold has been  reached, or if there is any data left in the FIFO  after reads from the Flash memory are complete. It is  cleared automatically as soon as threshold condition  is no longer true. In automatic polling mode this bit  is set every time the status register is read, and  the bit is cleared when the data register is  read.)  
        .equ QUADSPI_SR_SMF, 1 << 3   @ bitWidth 1 (Status match flag This bit is set in  automatic polling mode when the unmasked received  data matches the corresponding bits in the match  register QUADSPI_PSMAR. It is cleared by writing 1  to CSMF.)  
        .equ QUADSPI_SR_TOF, 1 << 4   @ bitWidth 1 (Timeout flag This bit is set when  timeout occurs. It is cleared by writing 1 to  CTOF.)  
        .equ QUADSPI_SR_BUSY, 1 << 5   @ bitWidth 1 (Busy This bit is set when an operation  is on going. This bit clears automatically when the  operation with the Flash memory is finished and the  FIFO is empty.)  
        .equ QUADSPI_SR_FLEVEL_Shift, 8   @ bitWidth 6 (FIFO level This field gives the number  of valid bytes which are being held in the FIFO.  FLEVEL = 0 when the FIFO is empty, and 16 when it is  full. In memory-mapped mode and in automatic status  polling mode, FLEVEL is zero.)  
 
    .equ QUADSPI_FCR, QUADSPI_BASE + 0xC @ (QUADSPI flag clear register) 
        .equ QUADSPI_FCR_CTEF, 1 << 0   @ bitWidth 1 (Clear transfer error flag Writing 1  clears the TEF flag in the QUADSPI_SR  register)  
        .equ QUADSPI_FCR_CTCF, 1 << 1   @ bitWidth 1 (Clear transfer complete flag Writing 1  clears the TCF flag in the QUADSPI_SR  register)  
        .equ QUADSPI_FCR_CSMF, 1 << 3   @ bitWidth 1 (Clear status match flag Writing 1 clears  the SMF flag in the QUADSPI_SR register)  
        .equ QUADSPI_FCR_CTOF, 1 << 4   @ bitWidth 1 (Clear timeout flag Writing 1 clears the  TOF flag in the QUADSPI_SR register)  
 
    .equ QUADSPI_DLR, QUADSPI_BASE + 0x10 @ (QUADSPI data length register) 
        .equ QUADSPI_DLR_DL_Shift, 0   @ bitWidth 32 (Data length Number of data to be  retrieved value+1 in indirect and status-polling  modes. A value no greater than 3 indicating 4 bytes  should be used for status-polling mode. All 1s in  indirect mode means undefined length, where QUADSPI  will continue until the end of memory, as defined by  FSIZE. 0x0000_0000: 1 byte is to be transferred  0x0000_0001: 2 bytes are to be transferred  0x0000_0002: 3 bytes are to be transferred  0x0000_0003: 4 bytes are to be transferred ...  0xFFFF_FFFD: 4,294,967,294 4G-2 bytes are to be  transferred 0xFFFF_FFFE: 4,294,967,295 4G-1 bytes  are to be transferred 0xFFFF_FFFF: undefined length  -- all bytes until the end of Flash memory as  defined by FSIZE are to be transferred. Continue  reading indefinitely if FSIZE = 0x1F. DL[0] is stuck  at 1 in dual-flash mode DFM = 1 even when 0 is  written to this bit, thus assuring that each access  transfers an even number of bytes. This field has no  effect when in memory-mapped mode FMODE = 10. This  field can be written only when BUSY =  0.)  
 
    .equ QUADSPI_CCR, QUADSPI_BASE + 0x14 @ (QUADSPI communication configuration  register) 
        .equ QUADSPI_CCR_INSTRUCTION_Shift, 0   @ bitWidth 8 (Instruction Instruction to be send to  the external SPI device. This field can be written  only when BUSY = 0.)  
        .equ QUADSPI_CCR_IMODE_Shift, 8   @ bitWidth 2 (Instruction mode This field defines the  instruction phase mode of operation: This field can  be written only when BUSY = 0.)  
        .equ QUADSPI_CCR_ADMODE_Shift, 10   @ bitWidth 2 (Address mode This field defines the  address phase mode of operation: This field can be  written only when BUSY = 0.)  
        .equ QUADSPI_CCR_ADSIZE_Shift, 12   @ bitWidth 2 (Address size This bit defines address  size: This field can be written only when BUSY =  0.)  
        .equ QUADSPI_CCR_ABMODE_Shift, 14   @ bitWidth 2 (Alternate bytes mode This field defines  the alternate-bytes phase mode of operation: This  field can be written only when BUSY =  0.)  
        .equ QUADSPI_CCR_ABSIZE_Shift, 16   @ bitWidth 2 (Alternate bytes size This bit defines  alternate bytes size: This field can be written only  when BUSY = 0.)  
        .equ QUADSPI_CCR_DCYC_Shift, 18   @ bitWidth 5 (Number of dummy cycles This field  defines the duration of the dummy phase. In both SDR  and DDR modes, it specifies a number of CLK cycles  0-31. This field can be written only when BUSY =  0.)  
        .equ QUADSPI_CCR_DMODE_Shift, 24   @ bitWidth 2 (Data mode This field defines the data  phases mode of operation: This field also determines  the dummy phase mode of operation. This field can be  written only when BUSY = 0.)  
        .equ QUADSPI_CCR_FMODE_Shift, 26   @ bitWidth 2 (Functional mode This field defines the  QUADSPI functional mode of operation. If DMAEN = 1  already, then the DMA controller for the  corresponding channel must be disabled before  changing the FMODE value. This field can be written  only when BUSY = 0.)  
        .equ QUADSPI_CCR_SIOO, 1 << 28   @ bitWidth 1 (Send instruction only once mode See  Section15.3.11: Sending the instruction only once on  page13. This bit has no effect when IMODE = 00. This  field can be written only when BUSY =  0.)  
        .equ QUADSPI_CCR_DHHC, 1 << 30   @ bitWidth 1 (DDR hold Delay the data output by 1/4 of  the QUADSPI output clock cycle in DDR mode: This  feature is only active in DDR mode. This field can be  written only when BUSY = 0.)  
        .equ QUADSPI_CCR_DDRM, 1 << 31   @ bitWidth 1 (Double data rate mode This bit sets the  DDR mode for the address, alternate byte and data  phase: This field can be written only when BUSY =  0.)  
 
    .equ QUADSPI_AR, QUADSPI_BASE + 0x18 @ (QUADSPI address register) 
        .equ QUADSPI_AR_ADDRESS_Shift, 0   @ bitWidth 32 ([31 0]: Address Address to be send to  the external Flash memory Writes to this field are  ignored when BUSY = 0 or when FMODE = 11  memory-mapped mode. In dual flash mode, ADDRESS[0]  is automatically stuck to 0 as the address should  always be even)  
 
    .equ QUADSPI_ABR, QUADSPI_BASE + 0x1C @ (QUADSPI alternate bytes  registers) 
        .equ QUADSPI_ABR_ALTERNATE_Shift, 0   @ bitWidth 32 (Alternate Bytes Optional data to be send  to the external SPI device right after the address.  This field can be written only when BUSY =  0.)  
 
    .equ QUADSPI_DR, QUADSPI_BASE + 0x20 @ (QUADSPI data register) 
        .equ QUADSPI_DR_DATA_Shift, 0   @ bitWidth 32 (Data Data to be sent/received to/from  the external SPI device. In indirect write mode, data  written to this register is stored on the FIFO before  it is sent to the Flash memory during the data phase.  If the FIFO is too full, a write operation is stalled  until the FIFO has enough space to accept the amount  of data being written. In indirect read mode, reading  this register gives via the FIFO the data which was  received from the Flash memory. If the FIFO does not  have as many bytes as requested by the read operation  and if BUSY=1, the read operation is stalled until  enough data is present or until the transfer is  complete, whichever happens first. In automatic  polling mode, this register contains the last data  read from the Flash memory without masking. Word,  halfword, and byte accesses to this register are  supported. In indirect write mode, a byte write adds  1 byte to the FIFO, a halfword write 2, and a word  write 4. Similarly, in indirect read mode, a byte  read removes 1 byte from the FIFO, a halfword read 2,  and a word read 4. Accesses in indirect mode must be  aligned to the bottom of this register: a byte read  must read DATA[7:0] and a halfword read must read  DATA[15:0].)  
 
    .equ QUADSPI_PSMKR, QUADSPI_BASE + 0x24 @ (QUADSPI polling status mask  register) 
        .equ QUADSPI_PSMKR_MASK_Shift, 0   @ bitWidth 32 (Status mask Mask to be applied to the  status bytes received in polling mode. For bit n:  This field can be written only when BUSY =  0.)  
 
    .equ QUADSPI_PSMAR, QUADSPI_BASE + 0x28 @ (QUADSPI polling status match  register) 
        .equ QUADSPI_PSMAR_MATCH_Shift, 0   @ bitWidth 32 (Status match Value to be compared with  the masked status register to get a match. This field  can be written only when BUSY = 0.)  
 
    .equ QUADSPI_PIR, QUADSPI_BASE + 0x2C @ (QUADSPI polling interval  register) 
        .equ QUADSPI_PIR_INTERVAL_Shift, 0   @ bitWidth 16 (Polling interval Number of CLK cycles  between to read during automatic polling phases. This  field can be written only when BUSY =  0.)  
 
    .equ QUADSPI_LPTR, QUADSPI_BASE + 0x30 @ (QUADSPI low-power timeout  register) 
        .equ QUADSPI_LPTR_TIMEOUT_Shift, 0   @ bitWidth 16 (Timeout period After each access in  memory-mapped mode, the QUADSPI prefetches the  subsequent bytes and holds these bytes in the FIFO.  This field indicates how many CLK cycles the QUADSPI  waits after the FIFO becomes full until it raises  nCS, putting the Flash memory in a lower-consumption  state. This field can be written only when BUSY =  0.)  
 

@=========================== RNG ===========================@
.equ RNG_BASE, 0x48021800 @ (RNG) 
    .equ RNG_CR, RNG_BASE + 0x0 @ (RNG control register) 
        .equ RNG_CR_RNGEN, 1 << 2   @ bitWidth 1 (Random number generator  enable)  
        .equ RNG_CR_IE, 1 << 3   @ bitWidth 1 (Interrupt enable)  
        .equ RNG_CR_CED, 1 << 5   @ bitWidth 1 (Clock error detection Note: The clock  error detection can be used only when ck_rc48 or  ck_pll1_q ck_pll1_q = 48MHz source is selected  otherwise, CED bit must be equal to 1. The clock  error detection cannot be enabled nor disabled on the  fly when RNG peripheral is enabled, to enable or  disable CED the RNG must be disabled.)  
 
    .equ RNG_SR, RNG_BASE + 0x4 @ (RNG status register) 
        .equ RNG_SR_DRDY, 1 << 0   @ bitWidth 1 (Data ready Note: If IE=1 in RNG_CR, an  interrupt is generated when DRDY=1. It can rise when  the peripheral is disabled. When the output buffer  becomes empty after reading RNG_DR, this bit  returns to 0 until a new random value is  generated.)  
        .equ RNG_SR_CECS, 1 << 1   @ bitWidth 1 (Clock error current status Note: This  bit is meaningless if CED Clock error detection bit  in RNG_CR is equal to 1.)  
        .equ RNG_SR_SECS, 1 << 2   @ bitWidth 1 (Seed error current status ** More than  64 consecutive bits at the same value 0 or 1 **  More than 32 consecutive alternances of 0 and 1  0101010101...01)  
        .equ RNG_SR_CEIS, 1 << 5   @ bitWidth 1 (Clock error interrupt status This bit is  set at the same time as CECS. It is cleared by  writing it to 0. An interrupt is pending if IE = 1 in  the RNG_CR register. Note: This bit is meaningless if  CED Clock error detection bit in RNG_CR is equal to  1.)  
        .equ RNG_SR_SEIS, 1 << 6   @ bitWidth 1 (Seed error interrupt status This bit is  set at the same time as SECS. It is cleared by  writing it to 0. ** More than 64 consecutive bits at  the same value 0 or 1 ** More than 32 consecutive  alternances of 0 and 1 0101010101...01 An interrupt  is pending if IE = 1 in the RNG_CR  register.)  
 
    .equ RNG_DR, RNG_BASE + 0x8 @ (The RNG_DR register is a read-only register  that delivers a 32-bit random value when read. The  content of this register is valid when DRDY= 1, even if  RNGEN=0.) 
        .equ RNG_DR_RNDATA_Shift, 0   @ bitWidth 32 (Random data 32-bit random data which are  valid when DRDY=1.)  
 

@=========================== RTC ===========================@
.equ RTC_BASE, 0x58004000 @ (RTC) 
    .equ RTC_RTC_TR, RTC_BASE + 0x0 @ (The RTC_TR is the calendar time shadow  register. This register must be written in initialization  mode only. Refer to Calendar initialization and  configuration on page9 and Reading the calendar on  page10.This register is write protected. The write access  procedure is described in RTC register write protection  on page9.) 
        .equ RTC_RTC_TR_SU_Shift, 0   @ bitWidth 4 (Second units in BCD format)  
        .equ RTC_RTC_TR_ST_Shift, 4   @ bitWidth 3 (Second tens in BCD format)  
        .equ RTC_RTC_TR_MNU_Shift, 8   @ bitWidth 4 (Minute units in BCD format)  
        .equ RTC_RTC_TR_MNT_Shift, 12   @ bitWidth 3 (Minute tens in BCD format)  
        .equ RTC_RTC_TR_HU_Shift, 16   @ bitWidth 4 (Hour units in BCD format)  
        .equ RTC_RTC_TR_HT_Shift, 20   @ bitWidth 2 (Hour tens in BCD format)  
        .equ RTC_RTC_TR_PM, 1 << 22   @ bitWidth 1 (AM/PM notation)  
 
    .equ RTC_RTC_DR, RTC_BASE + 0x4 @ (The RTC_DR is the calendar date shadow  register. This register must be written in initialization  mode only. Refer to Calendar initialization and  configuration on page9 and Reading the calendar on  page10.This register is write protected. The write access  procedure is described in RTC register write protection  on page9.) 
        .equ RTC_RTC_DR_DU_Shift, 0   @ bitWidth 4 (Date units in BCD format)  
        .equ RTC_RTC_DR_DT_Shift, 4   @ bitWidth 2 (Date tens in BCD format)  
        .equ RTC_RTC_DR_MU_Shift, 8   @ bitWidth 4 (Month units in BCD format)  
        .equ RTC_RTC_DR_MT, 1 << 12   @ bitWidth 1 (Month tens in BCD format)  
        .equ RTC_RTC_DR_WDU_Shift, 13   @ bitWidth 3 (Week day units)  
        .equ RTC_RTC_DR_YU_Shift, 16   @ bitWidth 4 (Year units in BCD format)  
        .equ RTC_RTC_DR_YT_Shift, 20   @ bitWidth 4 (Year tens in BCD format)  
 
    .equ RTC_RTC_CR, RTC_BASE + 0x8 @ (RTC control register) 
        .equ RTC_RTC_CR_WUCKSEL_Shift, 0   @ bitWidth 3 (Wakeup clock selection)  
        .equ RTC_RTC_CR_TSEDGE, 1 << 3   @ bitWidth 1 (Time-stamp event active edge TSE must be  reset when TSEDGE is changed to avoid unwanted TSF  setting.)  
        .equ RTC_RTC_CR_REFCKON, 1 << 4   @ bitWidth 1 (RTC_REFIN reference clock detection  enable 50 or 60Hz Note: PREDIV_S must be  0x00FF.)  
        .equ RTC_RTC_CR_BYPSHAD, 1 << 5   @ bitWidth 1 (Bypass the shadow registers Note: If the  frequency of the APB clock is less than seven times  the frequency of RTCCLK, BYPSHAD must be set to  1.)  
        .equ RTC_RTC_CR_FMT, 1 << 6   @ bitWidth 1 (Hour format)  
        .equ RTC_RTC_CR_ALRAE, 1 << 8   @ bitWidth 1 (Alarm A enable)  
        .equ RTC_RTC_CR_ALRBE, 1 << 9   @ bitWidth 1 (Alarm B enable)  
        .equ RTC_RTC_CR_WUTE, 1 << 10   @ bitWidth 1 (Wakeup timer enable)  
        .equ RTC_RTC_CR_TSE, 1 << 11   @ bitWidth 1 (timestamp enable)  
        .equ RTC_RTC_CR_ALRAIE, 1 << 12   @ bitWidth 1 (Alarm A interrupt enable)  
        .equ RTC_RTC_CR_ALRBIE, 1 << 13   @ bitWidth 1 (Alarm B interrupt enable)  
        .equ RTC_RTC_CR_WUTIE, 1 << 14   @ bitWidth 1 (Wakeup timer interrupt  enable)  
        .equ RTC_RTC_CR_TSIE, 1 << 15   @ bitWidth 1 (Time-stamp interrupt  enable)  
        .equ RTC_RTC_CR_ADD1H, 1 << 16   @ bitWidth 1 (Add 1 hour summer time change When  this bit is set outside initialization mode, 1 hour  is added to the calendar time. This bit is always  read as 0.)  
        .equ RTC_RTC_CR_SUB1H, 1 << 17   @ bitWidth 1 (Subtract 1 hour winter time change  When this bit is set outside initialization mode, 1  hour is subtracted to the calendar time if the  current hour is not 0. This bit is always read as 0.  Setting this bit has no effect when current hour is  0.)  
        .equ RTC_RTC_CR_BKP, 1 << 18   @ bitWidth 1 (Backup This bit can be written by the  user to memorize whether the daylight saving time  change has been performed or not.)  
        .equ RTC_RTC_CR_COSEL, 1 << 19   @ bitWidth 1 (Calibration output selection When COE=1,  this bit selects which signal is output on RTC_CALIB.  These frequencies are valid for RTCCLK at 32.768 kHz  and prescalers at their default values PREDIV_A=127  and PREDIV_S=255. Refer to Section24.3.15:  Calibration clock output)  
        .equ RTC_RTC_CR_POL, 1 << 20   @ bitWidth 1 (Output polarity This bit is used to  configure the polarity of RTC_ALARM  output)  
        .equ RTC_RTC_CR_OSEL_Shift, 21   @ bitWidth 2 (Output selection These bits are used to  select the flag to be routed to RTC_ALARM  output)  
        .equ RTC_RTC_CR_COE, 1 << 23   @ bitWidth 1 (Calibration output enable This bit  enables the RTC_CALIB output)  
        .equ RTC_RTC_CR_ITSE, 1 << 24   @ bitWidth 1 (timestamp on internal event  enable)  
 
    .equ RTC_RTC_ISR, RTC_BASE + 0xC @ (This register is write protected except for  RTC_ISR[13:8] bits. The write access procedure is  described in RTC register write protection on  page9.) 
        .equ RTC_RTC_ISR_ALRAWF, 1 << 0   @ bitWidth 1 (Alarm A write flag This bit is set by  hardware when Alarm A values can be changed, after  the ALRAE bit has been set to 0 in RTC_CR. It is  cleared by hardware in initialization  mode.)  
        .equ RTC_RTC_ISR_ALRBWF, 1 << 1   @ bitWidth 1 (Alarm B write flag This bit is set by  hardware when Alarm B values can be changed, after  the ALRBE bit has been set to 0 in RTC_CR. It is  cleared by hardware in initialization  mode.)  
        .equ RTC_RTC_ISR_WUTWF, 1 << 2   @ bitWidth 1 (Wakeup timer write flag This bit is set  by hardware up to 2 RTCCLK cycles after the WUTE bit  has been set to 0 in RTC_CR, and is cleared up to 2  RTCCLK cycles after the WUTE bit has been set to 1.  The wakeup timer values can be changed when WUTE bit  is cleared and WUTWF is set.)  
        .equ RTC_RTC_ISR_SHPF, 1 << 3   @ bitWidth 1 (Shift operation pending This flag is set  by hardware as soon as a shift operation is initiated  by a write to the RTC_SHIFTR register. It is cleared  by hardware when the corresponding shift operation  has been executed. Writing to the SHPF bit has no  effect.)  
        .equ RTC_RTC_ISR_INITS, 1 << 4   @ bitWidth 1 (Initialization status flag This bit is  set by hardware when the calendar year field is  different from 0 Backup domain reset  state.)  
        .equ RTC_RTC_ISR_RSF, 1 << 5   @ bitWidth 1 (Registers synchronization flag This bit  is set by hardware each time the calendar registers  are copied into the shadow registers RTC_SSRx,  RTC_TRx and RTC_DRx. This bit is cleared by hardware  in initialization mode, while a shift operation is  pending SHPF=1, or when in bypass shadow register  mode BYPSHAD=1. This bit can also be cleared by  software. It is cleared either by software or by  hardware in initialization mode.)  
        .equ RTC_RTC_ISR_INITF, 1 << 6   @ bitWidth 1 (Initialization flag When this bit is set  to 1, the RTC is in initialization state, and the  time, date and prescaler registers can be  updated.)  
        .equ RTC_RTC_ISR_INIT, 1 << 7   @ bitWidth 1 (Initialization mode)  
        .equ RTC_RTC_ISR_ALRAF, 1 << 8   @ bitWidth 1 (Alarm A flag This flag is set by  hardware when the time/date registers RTC_TR and  RTC_DR match the Alarm A register RTC_ALRMAR. This  flag is cleared by software by writing  0.)  
        .equ RTC_RTC_ISR_ALRBF, 1 << 9   @ bitWidth 1 (Alarm B flag This flag is set by  hardware when the time/date registers RTC_TR and  RTC_DR match the Alarm B register RTC_ALRMBR. This  flag is cleared by software by writing  0.)  
        .equ RTC_RTC_ISR_WUTF, 1 << 10   @ bitWidth 1 (Wakeup timer flag This flag is set by  hardware when the wakeup auto-reload counter reaches  0. This flag is cleared by software by writing 0.  This flag must be cleared by software at least 1.5  RTCCLK periods before WUTF is set to 1  again.)  
        .equ RTC_RTC_ISR_TSF, 1 << 11   @ bitWidth 1 (Time-stamp flag This flag is set by  hardware when a time-stamp event occurs. This flag is  cleared by software by writing 0.)  
        .equ RTC_RTC_ISR_TSOVF, 1 << 12   @ bitWidth 1 (Time-stamp overflow flag This flag is  set by hardware when a time-stamp event occurs while  TSF is already set. This flag is cleared by software  by writing 0. It is recommended to check and then  clear TSOVF only after clearing the TSF bit.  Otherwise, an overflow might not be noticed if a  time-stamp event occurs immediately before the TSF  bit is cleared.)  
        .equ RTC_RTC_ISR_TAMP1F, 1 << 13   @ bitWidth 1 (RTC_TAMP1 detection flag This flag is  set by hardware when a tamper detection event is  detected on the RTC_TAMP1 input. It is cleared by  software writing 0)  
        .equ RTC_RTC_ISR_TAMP2F, 1 << 14   @ bitWidth 1 (RTC_TAMP2 detection flag This flag is  set by hardware when a tamper detection event is  detected on the RTC_TAMP2 input. It is cleared by  software writing 0)  
        .equ RTC_RTC_ISR_TAMP3F, 1 << 15   @ bitWidth 1 (RTC_TAMP3 detection flag This flag is  set by hardware when a tamper detection event is  detected on the RTC_TAMP3 input. It is cleared by  software writing 0)  
        .equ RTC_RTC_ISR_RECALPF, 1 << 16   @ bitWidth 1 (Recalibration pending Flag The RECALPF  status flag is automatically set to 1 when software  writes to the RTC_CALR register, indicating that the  RTC_CALR register is blocked. When the new  calibration settings are taken into account, this bit  returns to 0. Refer to Re-calibration  on-the-fly.)  
        .equ RTC_RTC_ISR_ITSF, 1 << 17   @ bitWidth 1 (Internal tTime-stamp flag)  
 
    .equ RTC_RTC_PRER, RTC_BASE + 0x10 @ (This register must be written in  initialization mode only. The initialization must be  performed in two separate write accesses. Refer to  Calendar initialization and configuration on page9.This  register is write protected. The write access procedure  is described in RTC register write protection on  page9.) 
        .equ RTC_RTC_PRER_PREDIV_S_Shift, 0   @ bitWidth 15 (Synchronous prescaler factor This is the  synchronous division factor: ck_spre frequency =  ck_apre frequency/PREDIV_S+1)  
        .equ RTC_RTC_PRER_PREDIV_A_Shift, 16   @ bitWidth 7 (Asynchronous prescaler factor This is  the asynchronous division factor: ck_apre frequency =  RTCCLK frequency/PREDIV_A+1)  
 
    .equ RTC_RTC_WUTR, RTC_BASE + 0x14 @ (This register can be written only when WUTWF  is set to 1 in RTC_ISR.This register is write protected.  The write access procedure is described in RTC register  write protection on page9.) 
        .equ RTC_RTC_WUTR_WUT_Shift, 0   @ bitWidth 16 (Wakeup auto-reload value bits When the  wakeup timer is enabled WUTE set to 1, the WUTF  flag is set every WUT[15:0] + 1 ck_wut cycles. The  ck_wut period is selected through WUCKSEL[2:0] bits  of the RTC_CR register When WUCKSEL[2] = 1, the  wakeup timer becomes 17-bits and WUCKSEL[1]  effectively becomes WUT[16] the most-significant bit  to be reloaded into the timer. The first assertion of  WUTF occurs WUT+1 ck_wut cycles after WUTE is set.  Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] =011  RTCCLK/2 is forbidden.)  
 
    .equ RTC_RTC_ALRMAR, RTC_BASE + 0x1C @ (This register can be written only when  ALRAWF is set to 1 in RTC_ISR, or in initialization  mode.This register is write protected. The write access  procedure is described in RTC register write protection  on page9.) 
        .equ RTC_RTC_ALRMAR_SU_Shift, 0   @ bitWidth 4 (Second units in BCD  format.)  
        .equ RTC_RTC_ALRMAR_ST_Shift, 4   @ bitWidth 3 (Second tens in BCD format.)  
        .equ RTC_RTC_ALRMAR_MSK1, 1 << 7   @ bitWidth 1 (Alarm A seconds mask)  
        .equ RTC_RTC_ALRMAR_MNU_Shift, 8   @ bitWidth 4 (Minute units in BCD  format.)  
        .equ RTC_RTC_ALRMAR_MNT_Shift, 12   @ bitWidth 3 (Minute tens in BCD format.)  
        .equ RTC_RTC_ALRMAR_MSK2, 1 << 15   @ bitWidth 1 (Alarm A minutes mask)  
        .equ RTC_RTC_ALRMAR_HU_Shift, 16   @ bitWidth 4 (Hour units in BCD format.)  
        .equ RTC_RTC_ALRMAR_HT_Shift, 20   @ bitWidth 2 (Hour tens in BCD format.)  
        .equ RTC_RTC_ALRMAR_PM, 1 << 22   @ bitWidth 1 (AM/PM notation)  
        .equ RTC_RTC_ALRMAR_MSK3, 1 << 23   @ bitWidth 1 (Alarm A hours mask)  
        .equ RTC_RTC_ALRMAR_DU_Shift, 24   @ bitWidth 4 (Date units or day in BCD  format.)  
        .equ RTC_RTC_ALRMAR_DT_Shift, 28   @ bitWidth 2 (Date tens in BCD format.)  
        .equ RTC_RTC_ALRMAR_WDSEL, 1 << 30   @ bitWidth 1 (Week day selection)  
        .equ RTC_RTC_ALRMAR_MSK4, 1 << 31   @ bitWidth 1 (Alarm A date mask)  
 
    .equ RTC_RTC_ALRMBR, RTC_BASE + 0x20 @ (This register can be written only when  ALRBWF is set to 1 in RTC_ISR, or in initialization  mode.This register is write protected. The write access  procedure is described in RTC register write protection  on page9.) 
        .equ RTC_RTC_ALRMBR_SU_Shift, 0   @ bitWidth 4 (Second units in BCD format)  
        .equ RTC_RTC_ALRMBR_ST_Shift, 4   @ bitWidth 3 (Second tens in BCD format)  
        .equ RTC_RTC_ALRMBR_MSK1, 1 << 7   @ bitWidth 1 (Alarm B seconds mask)  
        .equ RTC_RTC_ALRMBR_MNU_Shift, 8   @ bitWidth 4 (Minute units in BCD format)  
        .equ RTC_RTC_ALRMBR_MNT_Shift, 12   @ bitWidth 3 (Minute tens in BCD format)  
        .equ RTC_RTC_ALRMBR_MSK2, 1 << 15   @ bitWidth 1 (Alarm B minutes mask)  
        .equ RTC_RTC_ALRMBR_HU_Shift, 16   @ bitWidth 4 (Hour units in BCD format)  
        .equ RTC_RTC_ALRMBR_HT_Shift, 20   @ bitWidth 2 (Hour tens in BCD format)  
        .equ RTC_RTC_ALRMBR_PM, 1 << 22   @ bitWidth 1 (AM/PM notation)  
        .equ RTC_RTC_ALRMBR_MSK3, 1 << 23   @ bitWidth 1 (Alarm B hours mask)  
        .equ RTC_RTC_ALRMBR_DU_Shift, 24   @ bitWidth 4 (Date units or day in BCD  format)  
        .equ RTC_RTC_ALRMBR_DT_Shift, 28   @ bitWidth 2 (Date tens in BCD format)  
        .equ RTC_RTC_ALRMBR_WDSEL, 1 << 30   @ bitWidth 1 (Week day selection)  
        .equ RTC_RTC_ALRMBR_MSK4, 1 << 31   @ bitWidth 1 (Alarm B date mask)  
 
    .equ RTC_RTC_WPR, RTC_BASE + 0x24 @ (RTC write protection register) 
        .equ RTC_RTC_WPR_KEY_Shift, 0   @ bitWidth 8 (Write protection key This byte is  written by software. Reading this byte always returns  0x00. Refer to RTC register write protection for a  description of how to unlock RTC register write  protection.)  
 
    .equ RTC_RTC_SSR, RTC_BASE + 0x28 @ (RTC sub second register) 
        .equ RTC_RTC_SSR_SS_Shift, 0   @ bitWidth 16 (Sub second value SS[15:0] is the value  in the synchronous prescaler counter. The fraction of  a second is given by the formula below: Second  fraction = PREDIV_S - SS / PREDIV_S + 1 Note: SS  can be larger than PREDIV_S only after a shift  operation. In that case, the correct time/date is one  second less than as indicated by  RTC_TR/RTC_DR.)  
 
    .equ RTC_RTC_SHIFTR, RTC_BASE + 0x2C @ (This register is write protected. The write  access procedure is described in RTC register write  protection on page9.) 
        .equ RTC_RTC_SHIFTR_SUBFS_Shift, 0   @ bitWidth 15 (Subtract a fraction of a second These  bits are write only and is always read as zero.  Writing to this bit has no effect when a shift  operation is pending when SHPF=1, in RTC_ISR. The  value which is written to SUBFS is added to the  synchronous prescaler counter. Since this counter  counts down, this operation effectively subtracts  from delays the clock by: Delay seconds = SUBFS /  PREDIV_S + 1 A fraction of a second can effectively  be added to the clock advancing the clock when the  ADD1S function is used in conjunction with SUBFS,  effectively advancing the clock by: Advance seconds  = 1 - SUBFS / PREDIV_S + 1. Note: Writing to  SUBFS causes RSF to be cleared. Software can then  wait until RSF=1 to be sure that the shadow registers  have been updated with the shifted  time.)  
        .equ RTC_RTC_SHIFTR_ADD1S, 1 << 31   @ bitWidth 1 (Add one second This bit is write only  and is always read as zero. Writing to this bit has  no effect when a shift operation is pending when  SHPF=1, in RTC_ISR. This function is intended to be  used with SUBFS see description below in order to  effectively add a fraction of a second to the clock  in an atomic operation.)  
 
    .equ RTC_RTC_TSTR, RTC_BASE + 0x30 @ (The content of this register is valid only  when TSF is set to 1 in RTC_ISR. It is cleared when TSF  bit is reset.) 
        .equ RTC_RTC_TSTR_SU_Shift, 0   @ bitWidth 4 (Second units in BCD  format.)  
        .equ RTC_RTC_TSTR_ST_Shift, 4   @ bitWidth 3 (Second tens in BCD format.)  
        .equ RTC_RTC_TSTR_MNU_Shift, 8   @ bitWidth 4 (Minute units in BCD  format.)  
        .equ RTC_RTC_TSTR_MNT_Shift, 12   @ bitWidth 3 (Minute tens in BCD format.)  
        .equ RTC_RTC_TSTR_HU_Shift, 16   @ bitWidth 4 (Hour units in BCD format.)  
        .equ RTC_RTC_TSTR_HT_Shift, 20   @ bitWidth 2 (Hour tens in BCD format.)  
        .equ RTC_RTC_TSTR_PM, 1 << 22   @ bitWidth 1 (AM/PM notation)  
 
    .equ RTC_RTC_TSDR, RTC_BASE + 0x34 @ (The content of this register is valid only  when TSF is set to 1 in RTC_ISR. It is cleared when TSF  bit is reset.) 
        .equ RTC_RTC_TSDR_DU_Shift, 0   @ bitWidth 4 (Date units in BCD format)  
        .equ RTC_RTC_TSDR_DT_Shift, 4   @ bitWidth 2 (Date tens in BCD format)  
        .equ RTC_RTC_TSDR_MU_Shift, 8   @ bitWidth 4 (Month units in BCD format)  
        .equ RTC_RTC_TSDR_MT, 1 << 12   @ bitWidth 1 (Month tens in BCD format)  
        .equ RTC_RTC_TSDR_WDU_Shift, 13   @ bitWidth 3 (Week day units)  
 
    .equ RTC_RTC_TSSSR, RTC_BASE + 0x38 @ (The content of this register is valid only  when RTC_ISR/TSF is set. It is cleared when the  RTC_ISR/TSF bit is reset.) 
        .equ RTC_RTC_TSSSR_SS_Shift, 0   @ bitWidth 16 (Sub second value SS[15:0] is the value  of the synchronous prescaler counter when the  timestamp event occurred.)  
 
    .equ RTC_RTC_CALR, RTC_BASE + 0x3C @ (This register is write protected. The write  access procedure is described in RTC register write  protection on page9.) 
        .equ RTC_RTC_CALR_CALM_Shift, 0   @ bitWidth 9 (Calibration minus The frequency of the  calendar is reduced by masking CALM out of 220 RTCCLK  pulses 32 seconds if the input frequency is 32768  Hz. This decreases the frequency of the calendar  with a resolution of 0.9537 ppm. To increase the  frequency of the calendar, this feature should be  used in conjunction with CALP. See Section24.3.12:  RTC smooth digital calibration on  page13.)  
        .equ RTC_RTC_CALR_CALW16, 1 << 13   @ bitWidth 1 (Use a 16-second calibration cycle period  When CALW16 is set to 1, the 16-second calibration  cycle period is selected.This bit must not be set to  1 if CALW8=1. Note: CALM[0] is stuck at 0 when  CALW16= 1. Refer to Section24.3.12: RTC smooth  digital calibration.)  
        .equ RTC_RTC_CALR_CALW8, 1 << 14   @ bitWidth 1 (Use an 8-second calibration cycle period  When CALW8 is set to 1, the 8-second calibration  cycle period is selected. Note: CALM[1:0] are stuck  at 00; when CALW8= 1. Refer to Section24.3.12: RTC  smooth digital calibration.)  
        .equ RTC_RTC_CALR_CALP, 1 << 15   @ bitWidth 1 (Increase frequency of RTC by 488.5 ppm  This feature is intended to be used in conjunction  with CALM, which lowers the frequency of the calendar  with a fine resolution. if the input frequency is  32768 Hz, the number of RTCCLK pulses added during a  32-second window is calculated as follows: 512 *  CALP - CALM. Refer to Section24.3.12: RTC smooth  digital calibration.)  
 
    .equ RTC_RTC_TAMPCR, RTC_BASE + 0x40 @ (RTC tamper and alternate function  configuration register) 
        .equ RTC_RTC_TAMPCR_TAMP1E, 1 << 0   @ bitWidth 1 (RTC_TAMP1 input detection  enable)  
        .equ RTC_RTC_TAMPCR_TAMP1TRG, 1 << 1   @ bitWidth 1 (Active level for RTC_TAMP1 input If  TAMPFLT != 00 if TAMPFLT = 00:)  
        .equ RTC_RTC_TAMPCR_TAMPIE, 1 << 2   @ bitWidth 1 (Tamper interrupt enable)  
        .equ RTC_RTC_TAMPCR_TAMP2E, 1 << 3   @ bitWidth 1 (RTC_TAMP2 input detection  enable)  
        .equ RTC_RTC_TAMPCR_TAMP2TRG, 1 << 4   @ bitWidth 1 (Active level for RTC_TAMP2 input if  TAMPFLT != 00: if TAMPFLT = 00:)  
        .equ RTC_RTC_TAMPCR_TAMP3E, 1 << 5   @ bitWidth 1 (RTC_TAMP3 detection enable)  
        .equ RTC_RTC_TAMPCR_TAMP3TRG, 1 << 6   @ bitWidth 1 (Active level for RTC_TAMP3 input if  TAMPFLT != 00: if TAMPFLT = 00:)  
        .equ RTC_RTC_TAMPCR_TAMPTS, 1 << 7   @ bitWidth 1 (Activate timestamp on tamper detection  event TAMPTS is valid even if TSE=0 in the RTC_CR  register.)  
        .equ RTC_RTC_TAMPCR_TAMPFREQ_Shift, 8   @ bitWidth 3 (Tamper sampling frequency Determines the  frequency at which each of the RTC_TAMPx inputs are  sampled.)  
        .equ RTC_RTC_TAMPCR_TAMPFLT_Shift, 11   @ bitWidth 2 (RTC_TAMPx filter count These bits  determines the number of consecutive samples at the  specified level TAMP*TRG needed to activate a  Tamper event. TAMPFLT is valid for each of the  RTC_TAMPx inputs.)  
        .equ RTC_RTC_TAMPCR_TAMPPRCH_Shift, 13   @ bitWidth 2 (RTC_TAMPx precharge duration These bit  determines the duration of time during which the  pull-up/is activated before each sample. TAMPPRCH is  valid for each of the RTC_TAMPx inputs.)  
        .equ RTC_RTC_TAMPCR_TAMPPUDIS, 1 << 15   @ bitWidth 1 (RTC_TAMPx pull-up disable This bit  determines if each of the RTC_TAMPx pins are  pre-charged before each sample.)  
        .equ RTC_RTC_TAMPCR_TAMP1IE, 1 << 16   @ bitWidth 1 (Tamper 1 interrupt enable)  
        .equ RTC_RTC_TAMPCR_TAMP1NOERASE, 1 << 17   @ bitWidth 1 (Tamper 1 no erase)  
        .equ RTC_RTC_TAMPCR_TAMP1MF, 1 << 18   @ bitWidth 1 (Tamper 1 mask flag)  
        .equ RTC_RTC_TAMPCR_TAMP2IE, 1 << 19   @ bitWidth 1 (Tamper 2 interrupt enable)  
        .equ RTC_RTC_TAMPCR_TAMP2NOERASE, 1 << 20   @ bitWidth 1 (Tamper 2 no erase)  
        .equ RTC_RTC_TAMPCR_TAMP2MF, 1 << 21   @ bitWidth 1 (Tamper 2 mask flag)  
        .equ RTC_RTC_TAMPCR_TAMP3IE, 1 << 22   @ bitWidth 1 (Tamper 3 interrupt enable)  
        .equ RTC_RTC_TAMPCR_TAMP3NOERASE, 1 << 23   @ bitWidth 1 (Tamper 3 no erase)  
        .equ RTC_RTC_TAMPCR_TAMP3MF, 1 << 24   @ bitWidth 1 (Tamper 3 mask flag)  
 
    .equ RTC_RTC_ALRMASSR, RTC_BASE + 0x44 @ (This register can be written only when ALRAE  is reset in RTC_CR register, or in initialization  mode.This register is write protected. The write access  procedure is described in RTC register write protection  on page9) 
        .equ RTC_RTC_ALRMASSR_SS_Shift, 0   @ bitWidth 15 (Sub seconds value This value is compared  with the contents of the synchronous prescaler  counter to determine if Alarm A is to be activated.  Only bits 0 up MASKSS-1 are compared.)  
        .equ RTC_RTC_ALRMASSR_MASKSS_Shift, 24   @ bitWidth 4 (Mask the most-significant bits starting  at this bit ... The overflow bits of the synchronous  counter bits 15 is never compared. This bit can be  different from 0 only after a shift  operation.)  
 
    .equ RTC_RTC_ALRMBSSR, RTC_BASE + 0x48 @ (This register can be written only when ALRBE  is reset in RTC_CR register, or in initialization  mode.This register is write protected.The write access  procedure is described in Section: RTC register write  protection.) 
        .equ RTC_RTC_ALRMBSSR_SS_Shift, 0   @ bitWidth 15 (Sub seconds value This value is compared  with the contents of the synchronous prescaler  counter to determine if Alarm B is to be activated.  Only bits 0 up to MASKSS-1 are  compared.)  
        .equ RTC_RTC_ALRMBSSR_MASKSS_Shift, 24   @ bitWidth 4 (Mask the most-significant bits starting  at this bit ... The overflow bits of the synchronous  counter bits 15 is never compared. This bit can be  different from 0 only after a shift  operation.)  
 
    .equ RTC_RTC_BKP0R, RTC_BASE + 0x50 @ (RTC backup registers) 
        .equ RTC_RTC_BKP0R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP1R, RTC_BASE + 0x54 @ (RTC backup registers) 
        .equ RTC_RTC_BKP1R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP2R, RTC_BASE + 0x58 @ (RTC backup registers) 
        .equ RTC_RTC_BKP2R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP3R, RTC_BASE + 0x5C @ (RTC backup registers) 
        .equ RTC_RTC_BKP3R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP4R, RTC_BASE + 0x60 @ (RTC backup registers) 
        .equ RTC_RTC_BKP4R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP5R, RTC_BASE + 0x64 @ (RTC backup registers) 
        .equ RTC_RTC_BKP5R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP6R, RTC_BASE + 0x68 @ (RTC backup registers) 
        .equ RTC_RTC_BKP6R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP7R, RTC_BASE + 0x6C @ (RTC backup registers) 
        .equ RTC_RTC_BKP7R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP8R, RTC_BASE + 0x70 @ (RTC backup registers) 
        .equ RTC_RTC_BKP8R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP9R, RTC_BASE + 0x74 @ (RTC backup registers) 
        .equ RTC_RTC_BKP9R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP10R, RTC_BASE + 0x78 @ (RTC backup registers) 
        .equ RTC_RTC_BKP10R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP11R, RTC_BASE + 0x7C @ (RTC backup registers) 
        .equ RTC_RTC_BKP11R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP12R, RTC_BASE + 0x80 @ (RTC backup registers) 
        .equ RTC_RTC_BKP12R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP13R, RTC_BASE + 0x84 @ (RTC backup registers) 
        .equ RTC_RTC_BKP13R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP14R, RTC_BASE + 0x88 @ (RTC backup registers) 
        .equ RTC_RTC_BKP14R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP15R, RTC_BASE + 0x8C @ (RTC backup registers) 
        .equ RTC_RTC_BKP15R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_OR, RTC_BASE + 0x4C @ (RTC option register) 
        .equ RTC_RTC_OR_RTC_ALARM_TYPE, 1 << 0   @ bitWidth 1 (RTC_ALARM output type on  PC13)  
        .equ RTC_RTC_OR_RTC_OUT_RMP, 1 << 1   @ bitWidth 1 (RTC_OUT remap)  
 
    .equ RTC_RTC_BKP16R, RTC_BASE + 0x90 @ (RTC backup registers) 
        .equ RTC_RTC_BKP16R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP17R, RTC_BASE + 0x94 @ (RTC backup registers) 
        .equ RTC_RTC_BKP17R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP18R, RTC_BASE + 0x98 @ (RTC backup registers) 
        .equ RTC_RTC_BKP18R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP19R, RTC_BASE + 0x9C @ (RTC backup registers) 
        .equ RTC_RTC_BKP19R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP20R, RTC_BASE + 0xA0 @ (RTC backup registers) 
        .equ RTC_RTC_BKP20R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP21R, RTC_BASE + 0xA4 @ (RTC backup registers) 
        .equ RTC_RTC_BKP21R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP22R, RTC_BASE + 0xA8 @ (RTC backup registers) 
        .equ RTC_RTC_BKP22R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP23R, RTC_BASE + 0xAC @ (RTC backup registers) 
        .equ RTC_RTC_BKP23R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP24R, RTC_BASE + 0xB0 @ (RTC backup registers) 
        .equ RTC_RTC_BKP24R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP25R, RTC_BASE + 0xB4 @ (RTC backup registers) 
        .equ RTC_RTC_BKP25R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP26R, RTC_BASE + 0xB8 @ (RTC backup registers) 
        .equ RTC_RTC_BKP26R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP27R, RTC_BASE + 0xBC @ (RTC backup registers) 
        .equ RTC_RTC_BKP27R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP28R, RTC_BASE + 0xC0 @ (RTC backup registers) 
        .equ RTC_RTC_BKP28R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP29R, RTC_BASE + 0xC4 @ (RTC backup registers) 
        .equ RTC_RTC_BKP29R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP30R, RTC_BASE + 0xC8 @ (RTC backup registers) 
        .equ RTC_RTC_BKP30R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 
    .equ RTC_RTC_BKP31R, RTC_BASE + 0xCC @ (RTC backup registers) 
        .equ RTC_RTC_BKP31R_BKP_Shift, 0   @ bitWidth 32 (The application can write or read data  to and from these registers. They are powered-on by  VBAT when VDD is switched off, so that they are not  reset by System reset, and their contents remain  valid when the device operates in low-power mode.  This register is reset on a tamper detection event,  as long as TAMPxF=1. or when the Flash readout  protection is disabled.)  
 

@=========================== SAI4 ===========================@
.equ SAI4_BASE, 0x58005400 @ (SAI) 
    .equ SAI4_SAI_GCR, SAI4_BASE + 0x0 @ (Global configuration register) 
        .equ SAI4_SAI_GCR_SYNCOUT_Shift, 4   @ bitWidth 2 (Synchronization outputs These bits are  set and cleared by software.)  
        .equ SAI4_SAI_GCR_SYNCIN_Shift, 0   @ bitWidth 2 (Synchronization inputs)  
 
    .equ SAI4_SAI_ACR1, SAI4_BASE + 0x4 @ (Configuration register 1) 
        .equ SAI4_SAI_ACR1_MODE_Shift, 0   @ bitWidth 2 (SAIx audio block mode  immediately)  
        .equ SAI4_SAI_ACR1_PRTCFG_Shift, 2   @ bitWidth 2 (Protocol configuration. These bits are  set and cleared by software. These bits have to be  configured when the audio block is  disabled.)  
        .equ SAI4_SAI_ACR1_DS_Shift, 5   @ bitWidth 3 (Data size. These bits are set and  cleared by software. These bits are ignored when the  SPDIF protocols are selected bit PRTCFG[1:0],  because the frame and the data size are fixed in such  case. When the companding mode is selected through  COMP[1:0] bits, DS[1:0] are ignored since the data  size is fixed to 8 bits by the algorithm. These bits  must be configured when the audio block is  disabled.)  
        .equ SAI4_SAI_ACR1_LSBFIRST, 1 << 8   @ bitWidth 1 (Least significant bit first. This bit is  set and cleared by software. It must be configured  when the audio block is disabled. This bit has no  meaning in AC97 audio protocol since AC97 data are  always transferred with the MSB first. This bit has  no meaning in SPDIF audio protocol since in SPDIF  data are always transferred with LSB  first.)  
        .equ SAI4_SAI_ACR1_CKSTR, 1 << 9   @ bitWidth 1 (Clock strobing edge. This bit is set and  cleared by software. It must be configured when the  audio block is disabled. This bit has no meaning in  SPDIF audio protocol.)  
        .equ SAI4_SAI_ACR1_SYNCEN_Shift, 10   @ bitWidth 2 (Synchronization enable. These bits are  set and cleared by software. They must be configured  when the audio sub-block is disabled. Note: The audio  sub-block should be configured as asynchronous when  SPDIF mode is enabled.)  
        .equ SAI4_SAI_ACR1_MONO, 1 << 12   @ bitWidth 1 (Mono mode. This bit is set and cleared  by software. It is meaningful only when the number of  slots is equal to 2. When the mono mode is selected,  slot 0 data are duplicated on slot 1 when the audio  block operates as a transmitter. In reception mode,  the slot1 is discarded and only the data received  from slot 0 are stored. Refer to Section: Mono/stereo  mode for more details.)  
        .equ SAI4_SAI_ACR1_OUTDRIV, 1 << 13   @ bitWidth 1 (Output drive. This bit is set and  cleared by software. Note: This bit has to be set  before enabling the audio block and after the audio  block configuration.)  
        .equ SAI4_SAI_ACR1_SAIXEN, 1 << 16   @ bitWidth 1 (Audio block enable where x is A or B.  This bit is set by software. To switch off the audio  block, the application software must program this bit  to 0 and poll the bit till it reads back 0, meaning  that the block is completely disabled. Before setting  this bit to 1, check that it is set to 0, otherwise  the enable command will not be taken into account.  This bit allows to control the state of SAIx audio  block. If it is disabled when an audio frame transfer  is ongoing, the ongoing transfer completes and the  cell is fully disabled at the end of this audio frame  transfer. Note: When SAIx block is configured in  master mode, the clock must be present on the input  of SAIx before setting SAIXEN bit.)  
        .equ SAI4_SAI_ACR1_DMAEN, 1 << 17   @ bitWidth 1 (DMA enable. This bit is set and cleared  by software. Note: Since the audio block defaults to  operate as a transmitter after reset, the MODE[1:0]  bits must be configured before setting DMAEN to avoid  a DMA request in receiver mode.)  
        .equ SAI4_SAI_ACR1_NOMCK, 1 << 19   @ bitWidth 1 (No divider)  
        .equ SAI4_SAI_ACR1_MCKDIV_Shift, 20   @ bitWidth 4 (Master clock divider. These bits are set  and cleared by software. These bits are meaningless  when the audio block operates in slave mode. They  have to be configured when the audio block is  disabled. Others: the master clock frequency is  calculated accordingly to the following  formula:)  
        .equ SAI4_SAI_ACR1_OSR, 1 << 26   @ bitWidth 1 (Oversampling ratio for master  clock)  
 
    .equ SAI4_SAI_ACR2, SAI4_BASE + 0x8 @ (Configuration register 2) 
        .equ SAI4_SAI_ACR2_FTH_Shift, 0   @ bitWidth 3 (FIFO threshold. This bit is set and  cleared by software.)  
        .equ SAI4_SAI_ACR2_FFLUSH, 1 << 3   @ bitWidth 1 (FIFO flush. This bit is set by software.  It is always read as 0. This bit should be configured  when the SAI is disabled.)  
        .equ SAI4_SAI_ACR2_TRIS, 1 << 4   @ bitWidth 1 (Tristate management on data line. This  bit is set and cleared by software. It is meaningful  only if the audio block is configured as a  transmitter. This bit is not used when the audio  block is configured in SPDIF mode. It should be  configured when SAI is disabled. Refer to Section:  Output data line management on an inactive slot for  more details.)  
        .equ SAI4_SAI_ACR2_MUTE, 1 << 5   @ bitWidth 1 (Mute. This bit is set and cleared by  software. It is meaningful only when the audio block  operates as a transmitter. The MUTE value is linked  to value of MUTEVAL if the number of slots is lower  or equal to 2, or equal to 0 if it is greater than 2.  Refer to Section: Mute mode for more details. Note:  This bit is meaningless and should not be used for  SPDIF audio blocks.)  
        .equ SAI4_SAI_ACR2_MUTEVAL, 1 << 6   @ bitWidth 1 (Mute value. This bit is set and cleared  by software.It must be written before enabling the  audio block: SAIXEN. This bit is meaningful only when  the audio block operates as a transmitter, the number  of slots is lower or equal to 2 and the MUTE bit is  set. If more slots are declared, the bit value sent  during the transmission in mute mode is equal to 0,  whatever the value of MUTEVAL. if the number of slot  is lower or equal to 2 and MUTEVAL = 1, the MUTE  value transmitted for each slot is the one sent  during the previous frame. Refer to Section: Mute  mode for more details. Note: This bit is meaningless  and should not be used for SPDIF audio  blocks.)  
        .equ SAI4_SAI_ACR2_MUTECNT_Shift, 7   @ bitWidth 6 (Mute counter. These bits are set and  cleared by software. They are used only in reception  mode. The value set in these bits is compared to the  number of consecutive mute frames detected in  reception. When the number of mute frames is equal to  this value, the flag MUTEDET will be set and an  interrupt will be generated if bit MUTEDETIE is set.  Refer to Section: Mute mode for more  details.)  
        .equ SAI4_SAI_ACR2_CPL, 1 << 13   @ bitWidth 1 (Complement bit. This bit is set and  cleared by software. It defines the type of  complement to be used for companding mode Note: This  bit has effect only when the companding mode is -Law  algorithm or A-Law algorithm.)  
        .equ SAI4_SAI_ACR2_COMP_Shift, 14   @ bitWidth 2 (Companding mode. These bits are set and  cleared by software. The -Law and the A-Law log are a  part of the CCITT G.711 recommendation, the type of  complement that will be used depends on CPL bit. The  data expansion or data compression are determined by  the state of bit MODE[0]. The data compression is  applied if the audio block is configured as a  transmitter. The data expansion is automatically  applied when the audio block is configured as a  receiver. Refer to Section: Companding mode for more  details. Note: Companding mode is applicable only  when TDM is selected.)  
 
    .equ SAI4_SAI_AFRCR, SAI4_BASE + 0xC @ (This register has no meaning in AC97 and  SPDIF audio protocol) 
        .equ SAI4_SAI_AFRCR_FRL_Shift, 0   @ bitWidth 8 (Frame length. These bits are set and  cleared by software. They define the audio frame  length expressed in number of SCK clock cycles: the  number of bits in the frame is equal to FRL[7:0] + 1.  The minimum number of bits to transfer in an audio  frame must be equal to 8, otherwise the audio block  will behaves in an unexpected way. This is the case  when the data size is 8 bits and only one slot 0 is  defined in NBSLOT[4:0] of SAI_xSLOTR register  NBSLOT[3:0] = 0000. In master mode, if the master  clock available on MCLK_x pin is used, the frame  length should be aligned with a number equal to a  power of 2, ranging from 8 to 256. When the master  clock is not used NODIV = 1, it is recommended to  program the frame length to an value ranging from 8  to 256. These bits are meaningless and are not used  in AC97 or SPDIF audio block  configuration.)  
        .equ SAI4_SAI_AFRCR_FSALL_Shift, 8   @ bitWidth 7 (Frame synchronization active level  length. These bits are set and cleared by software.  They specify the length in number of bit clock SCK  + 1 FSALL[6:0] + 1 of the active level of the FS  signal in the audio frame These bits are meaningless  and are not used in AC97 or SPDIF audio block  configuration. They must be configured when the audio  block is disabled.)  
        .equ SAI4_SAI_AFRCR_FSDEF, 1 << 16   @ bitWidth 1 (Frame synchronization definition. This  bit is set and cleared by software. When the bit is  set, the number of slots defined in the SAI_xSLOTR  register has to be even. It means that half of this  number of slots will be dedicated to the left channel  and the other slots for the right channel e.g: this  bit has to be set for I2S or MSB/LSB-justified  protocols.... This bit is meaningless and is not  used in AC97 or SPDIF audio block configuration. It  must be configured when the audio block is  disabled.)  
        .equ SAI4_SAI_AFRCR_FSPOL, 1 << 17   @ bitWidth 1 (Frame synchronization polarity. This bit  is set and cleared by software. It is used to  configure the level of the start of frame on the FS  signal. It is meaningless and is not used in AC97 or  SPDIF audio block configuration. This bit must be  configured when the audio block is  disabled.)  
        .equ SAI4_SAI_AFRCR_FSOFF, 1 << 18   @ bitWidth 1 (Frame synchronization offset. This bit  is set and cleared by software. It is meaningless and  is not used in AC97 or SPDIF audio block  configuration. This bit must be configured when the  audio block is disabled.)  
 
    .equ SAI4_SAI_ASLOTR, SAI4_BASE + 0x10 @ (This register has no meaning in AC97 and  SPDIF audio protocol) 
        .equ SAI4_SAI_ASLOTR_FBOFF_Shift, 0   @ bitWidth 5 (First bit offset These bits are set and  cleared by software. The value set in this bitfield  defines the position of the first data transfer bit  in the slot. It represents an offset value. In  transmission mode, the bits outside the data field  are forced to 0. In reception mode, the extra  received bits are discarded. These bits must be set  when the audio block is disabled. They are ignored in  AC97 or SPDIF mode.)  
        .equ SAI4_SAI_ASLOTR_SLOTSZ_Shift, 6   @ bitWidth 2 (Slot size This bits is set and cleared  by software. The slot size must be higher or equal to  the data size. If this condition is not respected,  the behavior of the SAI will be undetermined. Refer  to Section: Output data line management on an  inactive slot for information on how to drive SD  line. These bits must be set when the audio block is  disabled. They are ignored in AC97 or SPDIF  mode.)  
        .equ SAI4_SAI_ASLOTR_NBSLOT_Shift, 8   @ bitWidth 4 (Number of slots in an audio frame. These  bits are set and cleared by software. The value set  in this bitfield represents the number of slots + 1  in the audio frame including the number of inactive  slots. The maximum number of slots is 16. The number  of slots should be even if FSDEF bit in the SAI_xFRCR  register is set. The number of slots must be  configured when the audio block is disabled. They are  ignored in AC97 or SPDIF mode.)  
        .equ SAI4_SAI_ASLOTR_SLOTEN_Shift, 16   @ bitWidth 16 (Slot enable. These bits are set and  cleared by software. Each SLOTEN bit corresponds to a  slot position from 0 to 15 maximum 16 slots. The  slot must be enabled when the audio block is  disabled. They are ignored in AC97 or SPDIF  mode.)  
 
    .equ SAI4_SAI_AIM, SAI4_BASE + 0x14 @ (Interrupt mask register 2) 
        .equ SAI4_SAI_AIM_OVRUDRIE, 1 << 0   @ bitWidth 1 (Overrun/underrun interrupt enable. This  bit is set and cleared by software. When this bit is  set, an interrupt is generated if the OVRUDR bit in  the SAI_xSR register is set.)  
        .equ SAI4_SAI_AIM_MUTEDETIE, 1 << 1   @ bitWidth 1 (Mute detection interrupt enable. This  bit is set and cleared by software. When this bit is  set, an interrupt is generated if the MUTEDET bit in  the SAI_xSR register is set. This bit has a meaning  only if the audio block is configured in receiver  mode.)  
        .equ SAI4_SAI_AIM_WCKCFGIE, 1 << 2   @ bitWidth 1 (Wrong clock configuration interrupt  enable. This bit is set and cleared by software. This  bit is taken into account only if the audio block is  configured as a master MODE[1] = 0 and NODIV = 0.  It generates an interrupt if the WCKCFG flag in the  SAI_xSR register is set. Note: This bit is used only  in TDM mode and is meaningless in other  modes.)  
        .equ SAI4_SAI_AIM_FREQIE, 1 << 3   @ bitWidth 1 (FIFO request interrupt enable. This bit  is set and cleared by software. When this bit is set,  an interrupt is generated if the FREQ bit in the  SAI_xSR register is set. Since the audio block  defaults to operate as a transmitter after reset, the  MODE bit must be configured before setting FREQIE to  avoid a parasitic interruption in receiver  mode,)  
        .equ SAI4_SAI_AIM_CNRDYIE, 1 << 4   @ bitWidth 1 (Codec not ready interrupt enable AC97.  This bit is set and cleared by software. When the  interrupt is enabled, the audio block detects in the  slot 0 tag0 of the AC97 frame if the Codec  connected to this line is ready or not. If it is not  ready, the CNRDY flag in the SAI_xSR register is set  and an interruption i generated. This bit has a  meaning only if the AC97 mode is selected through  PRTCFG[1:0] bits and the audio block is operates as a  receiver.)  
        .equ SAI4_SAI_AIM_AFSDETIE, 1 << 5   @ bitWidth 1 (Anticipated frame synchronization  detection interrupt enable. This bit is set and  cleared by software. When this bit is set, an  interrupt will be generated if the AFSDET bit in the  SAI_xSR register is set. This bit is meaningless in  AC97, SPDIF mode or when the audio block operates as  a master.)  
        .equ SAI4_SAI_AIM_LFSDETIE, 1 << 6   @ bitWidth 1 (Late frame synchronization detection  interrupt enable. This bit is set and cleared by  software. When this bit is set, an interrupt will be  generated if the LFSDET bit is set in the SAI_xSR  register. This bit is meaningless in AC97, SPDIF mode  or when the audio block operates as a  master.)  
 
    .equ SAI4_SAI_ASR, SAI4_BASE + 0x18 @ (Status register) 
        .equ SAI4_SAI_ASR_OVRUDR, 1 << 0   @ bitWidth 1 (Overrun / underrun. This bit is read  only. The overrun and underrun conditions can occur  only when the audio block is configured as a receiver  and a transmitter, respectively. It can generate an  interrupt if OVRUDRIE bit is set in SAI_xIM register.  This flag is cleared when the software sets COVRUDR  bit in SAI_xCLRFR register.)  
        .equ SAI4_SAI_ASR_MUTEDET, 1 << 1   @ bitWidth 1 (Mute detection. This bit is read only.  This flag is set if consecutive 0 values are received  in each slot of a given audio frame and for a  consecutive number of audio frames set in the  MUTECNT bit in the SAI_xCR2 register. It can  generate an interrupt if MUTEDETIE bit is set in  SAI_xIM register. This flag is cleared when the  software sets bit CMUTEDET in the SAI_xCLRFR  register.)  
        .equ SAI4_SAI_ASR_WCKCFG, 1 << 2   @ bitWidth 1 (Wrong clock configuration flag. This bit  is read only. This bit is used only when the audio  block operates in master mode MODE[1] = 0 and NODIV  = 0. It can generate an interrupt if WCKCFGIE bit is  set in SAI_xIM register. This flag is cleared when  the software sets CWCKCFG bit in SAI_xCLRFR  register.)  
        .equ SAI4_SAI_ASR_FREQ, 1 << 3   @ bitWidth 1 (FIFO request. This bit is read only. The  request depends on the audio block configuration: If  the block is configured in transmission mode, the  FIFO request is related to a write request operation  in the SAI_xDR. If the block configured in reception,  the FIFO request related to a read request operation  from the SAI_xDR. This flag can generate an interrupt  if FREQIE bit is set in SAI_xIM  register.)  
        .equ SAI4_SAI_ASR_CNRDY, 1 << 4   @ bitWidth 1 (Codec not ready. This bit is read only.  This bit is used only when the AC97 audio protocol is  selected in the SAI_xCR1 register and configured in  receiver mode. It can generate an interrupt if  CNRDYIE bit is set in SAI_xIM register. This flag is  cleared when the software sets CCNRDY bit in  SAI_xCLRFR register.)  
        .equ SAI4_SAI_ASR_AFSDET, 1 << 5   @ bitWidth 1 (Anticipated frame synchronization  detection. This bit is read only. This flag can be  set only if the audio block is configured in slave  mode. It is not used in AC97or SPDIF mode. It can  generate an interrupt if AFSDETIE bit is set in  SAI_xIM register. This flag is cleared when the  software sets CAFSDET bit in SAI_xCLRFR  register.)  
        .equ SAI4_SAI_ASR_LFSDET, 1 << 6   @ bitWidth 1 (Late frame synchronization detection.  This bit is read only. This flag can be set only if  the audio block is configured in slave mode. It is  not used in AC97 or SPDIF mode. It can generate an  interrupt if LFSDETIE bit is set in the SAI_xIM  register. This flag is cleared when the software sets  bit CLFSDET in SAI_xCLRFR register)  
        .equ SAI4_SAI_ASR_FLVL_Shift, 16   @ bitWidth 3 (FIFO level threshold. This bit is read  only. The FIFO level threshold flag is managed only  by hardware and its setting depends on SAI block  configuration transmitter or receiver mode. If the  SAI block is configured as transmitter: If SAI block  is configured as receiver:)  
 
    .equ SAI4_SAI_ACLRFR, SAI4_BASE + 0x1C @ (Clear flag register) 
        .equ SAI4_SAI_ACLRFR_COVRUDR, 1 << 0   @ bitWidth 1 (Clear overrun / underrun. This bit is  write only. Programming this bit to 1 clears the  OVRUDR flag in the SAI_xSR register. Reading this bit  always returns the value 0.)  
        .equ SAI4_SAI_ACLRFR_CMUTEDET, 1 << 1   @ bitWidth 1 (Mute detection flag. This bit is write  only. Programming this bit to 1 clears the MUTEDET  flag in the SAI_xSR register. Reading this bit always  returns the value 0.)  
        .equ SAI4_SAI_ACLRFR_CWCKCFG, 1 << 2   @ bitWidth 1 (Clear wrong clock configuration flag.  This bit is write only. Programming this bit to 1  clears the WCKCFG flag in the SAI_xSR register. This  bit is used only when the audio block is set as  master MODE[1] = 0 and NODIV = 0 in the SAI_xCR1  register. Reading this bit always returns the value  0.)  
        .equ SAI4_SAI_ACLRFR_CCNRDY, 1 << 4   @ bitWidth 1 (Clear Codec not ready flag. This bit is  write only. Programming this bit to 1 clears the  CNRDY flag in the SAI_xSR register. This bit is used  only when the AC97 audio protocol is selected in the  SAI_xCR1 register. Reading this bit always returns  the value 0.)  
        .equ SAI4_SAI_ACLRFR_CAFSDET, 1 << 5   @ bitWidth 1 (Clear anticipated frame synchronization  detection flag. This bit is write only. Programming  this bit to 1 clears the AFSDET flag in the SAI_xSR  register. It is not used in AC97or SPDIF mode.  Reading this bit always returns the value  0.)  
        .equ SAI4_SAI_ACLRFR_CLFSDET, 1 << 6   @ bitWidth 1 (Clear late frame synchronization  detection flag. This bit is write only. Programming  this bit to 1 clears the LFSDET flag in the SAI_xSR  register. This bit is not used in AC97or SPDIF mode  Reading this bit always returns the value  0.)  
 
    .equ SAI4_SAI_ADR, SAI4_BASE + 0x20 @ (Data register) 
        .equ SAI4_SAI_ADR_DATA_Shift, 0   @ bitWidth 32 (Data A write to this register loads the  FIFO provided the FIFO is not full. A read from this  register empties the FIFO if the FIFO is not  empty.)  
 
    .equ SAI4_SAI_BCR1, SAI4_BASE + 0x24 @ (Configuration register 1) 
        .equ SAI4_SAI_BCR1_MODE_Shift, 0   @ bitWidth 2 (SAIx audio block mode  immediately)  
        .equ SAI4_SAI_BCR1_PRTCFG_Shift, 2   @ bitWidth 2 (Protocol configuration. These bits are  set and cleared by software. These bits have to be  configured when the audio block is  disabled.)  
        .equ SAI4_SAI_BCR1_DS_Shift, 5   @ bitWidth 3 (Data size. These bits are set and  cleared by software. These bits are ignored when the  SPDIF protocols are selected bit PRTCFG[1:0],  because the frame and the data size are fixed in such  case. When the companding mode is selected through  COMP[1:0] bits, DS[1:0] are ignored since the data  size is fixed to 8 bits by the algorithm. These bits  must be configured when the audio block is  disabled.)  
        .equ SAI4_SAI_BCR1_LSBFIRST, 1 << 8   @ bitWidth 1 (Least significant bit first. This bit is  set and cleared by software. It must be configured  when the audio block is disabled. This bit has no  meaning in AC97 audio protocol since AC97 data are  always transferred with the MSB first. This bit has  no meaning in SPDIF audio protocol since in SPDIF  data are always transferred with LSB  first.)  
        .equ SAI4_SAI_BCR1_CKSTR, 1 << 9   @ bitWidth 1 (Clock strobing edge. This bit is set and  cleared by software. It must be configured when the  audio block is disabled. This bit has no meaning in  SPDIF audio protocol.)  
        .equ SAI4_SAI_BCR1_SYNCEN_Shift, 10   @ bitWidth 2 (Synchronization enable. These bits are  set and cleared by software. They must be configured  when the audio sub-block is disabled. Note: The audio  sub-block should be configured as asynchronous when  SPDIF mode is enabled.)  
        .equ SAI4_SAI_BCR1_MONO, 1 << 12   @ bitWidth 1 (Mono mode. This bit is set and cleared  by software. It is meaningful only when the number of  slots is equal to 2. When the mono mode is selected,  slot 0 data are duplicated on slot 1 when the audio  block operates as a transmitter. In reception mode,  the slot1 is discarded and only the data received  from slot 0 are stored. Refer to Section: Mono/stereo  mode for more details.)  
        .equ SAI4_SAI_BCR1_OUTDRIV, 1 << 13   @ bitWidth 1 (Output drive. This bit is set and  cleared by software. Note: This bit has to be set  before enabling the audio block and after the audio  block configuration.)  
        .equ SAI4_SAI_BCR1_SAIXEN, 1 << 16   @ bitWidth 1 (Audio block enable where x is A or B.  This bit is set by software. To switch off the audio  block, the application software must program this bit  to 0 and poll the bit till it reads back 0, meaning  that the block is completely disabled. Before setting  this bit to 1, check that it is set to 0, otherwise  the enable command will not be taken into account.  This bit allows to control the state of SAIx audio  block. If it is disabled when an audio frame transfer  is ongoing, the ongoing transfer completes and the  cell is fully disabled at the end of this audio frame  transfer. Note: When SAIx block is configured in  master mode, the clock must be present on the input  of SAIx before setting SAIXEN bit.)  
        .equ SAI4_SAI_BCR1_DMAEN, 1 << 17   @ bitWidth 1 (DMA enable. This bit is set and cleared  by software. Note: Since the audio block defaults to  operate as a transmitter after reset, the MODE[1:0]  bits must be configured before setting DMAEN to avoid  a DMA request in receiver mode.)  
        .equ SAI4_SAI_BCR1_NOMCK, 1 << 19   @ bitWidth 1 (No divider)  
        .equ SAI4_SAI_BCR1_MCKDIV_Shift, 20   @ bitWidth 4 (Master clock divider. These bits are set  and cleared by software. These bits are meaningless  when the audio block operates in slave mode. They  have to be configured when the audio block is  disabled. Others: the master clock frequency is  calculated accordingly to the following  formula:)  
        .equ SAI4_SAI_BCR1_OSR, 1 << 26   @ bitWidth 1 (Oversampling ratio for master  clock)  
 
    .equ SAI4_SAI_BCR2, SAI4_BASE + 0x28 @ (Configuration register 2) 
        .equ SAI4_SAI_BCR2_FTH_Shift, 0   @ bitWidth 3 (FIFO threshold. This bit is set and  cleared by software.)  
        .equ SAI4_SAI_BCR2_FFLUSH, 1 << 3   @ bitWidth 1 (FIFO flush. This bit is set by software.  It is always read as 0. This bit should be configured  when the SAI is disabled.)  
        .equ SAI4_SAI_BCR2_TRIS, 1 << 4   @ bitWidth 1 (Tristate management on data line. This  bit is set and cleared by software. It is meaningful  only if the audio block is configured as a  transmitter. This bit is not used when the audio  block is configured in SPDIF mode. It should be  configured when SAI is disabled. Refer to Section:  Output data line management on an inactive slot for  more details.)  
        .equ SAI4_SAI_BCR2_MUTE, 1 << 5   @ bitWidth 1 (Mute. This bit is set and cleared by  software. It is meaningful only when the audio block  operates as a transmitter. The MUTE value is linked  to value of MUTEVAL if the number of slots is lower  or equal to 2, or equal to 0 if it is greater than 2.  Refer to Section: Mute mode for more details. Note:  This bit is meaningless and should not be used for  SPDIF audio blocks.)  
        .equ SAI4_SAI_BCR2_MUTEVAL, 1 << 6   @ bitWidth 1 (Mute value. This bit is set and cleared  by software.It must be written before enabling the  audio block: SAIXEN. This bit is meaningful only when  the audio block operates as a transmitter, the number  of slots is lower or equal to 2 and the MUTE bit is  set. If more slots are declared, the bit value sent  during the transmission in mute mode is equal to 0,  whatever the value of MUTEVAL. if the number of slot  is lower or equal to 2 and MUTEVAL = 1, the MUTE  value transmitted for each slot is the one sent  during the previous frame. Refer to Section: Mute  mode for more details. Note: This bit is meaningless  and should not be used for SPDIF audio  blocks.)  
        .equ SAI4_SAI_BCR2_MUTECNT_Shift, 7   @ bitWidth 6 (Mute counter. These bits are set and  cleared by software. They are used only in reception  mode. The value set in these bits is compared to the  number of consecutive mute frames detected in  reception. When the number of mute frames is equal to  this value, the flag MUTEDET will be set and an  interrupt will be generated if bit MUTEDETIE is set.  Refer to Section: Mute mode for more  details.)  
        .equ SAI4_SAI_BCR2_CPL, 1 << 13   @ bitWidth 1 (Complement bit. This bit is set and  cleared by software. It defines the type of  complement to be used for companding mode Note: This  bit has effect only when the companding mode is -Law  algorithm or A-Law algorithm.)  
        .equ SAI4_SAI_BCR2_COMP_Shift, 14   @ bitWidth 2 (Companding mode. These bits are set and  cleared by software. The -Law and the A-Law log are a  part of the CCITT G.711 recommendation, the type of  complement that will be used depends on CPL bit. The  data expansion or data compression are determined by  the state of bit MODE[0]. The data compression is  applied if the audio block is configured as a  transmitter. The data expansion is automatically  applied when the audio block is configured as a  receiver. Refer to Section: Companding mode for more  details. Note: Companding mode is applicable only  when TDM is selected.)  
 
    .equ SAI4_SAI_BFRCR, SAI4_BASE + 0x2C @ (This register has no meaning in AC97 and  SPDIF audio protocol) 
        .equ SAI4_SAI_BFRCR_FRL_Shift, 0   @ bitWidth 8 (Frame length. These bits are set and  cleared by software. They define the audio frame  length expressed in number of SCK clock cycles: the  number of bits in the frame is equal to FRL[7:0] + 1.  The minimum number of bits to transfer in an audio  frame must be equal to 8, otherwise the audio block  will behaves in an unexpected way. This is the case  when the data size is 8 bits and only one slot 0 is  defined in NBSLOT[4:0] of SAI_xSLOTR register  NBSLOT[3:0] = 0000. In master mode, if the master  clock available on MCLK_x pin is used, the frame  length should be aligned with a number equal to a  power of 2, ranging from 8 to 256. When the master  clock is not used NODIV = 1, it is recommended to  program the frame length to an value ranging from 8  to 256. These bits are meaningless and are not used  in AC97 or SPDIF audio block  configuration.)  
        .equ SAI4_SAI_BFRCR_FSALL_Shift, 8   @ bitWidth 7 (Frame synchronization active level  length. These bits are set and cleared by software.  They specify the length in number of bit clock SCK  + 1 FSALL[6:0] + 1 of the active level of the FS  signal in the audio frame These bits are meaningless  and are not used in AC97 or SPDIF audio block  configuration. They must be configured when the audio  block is disabled.)  
        .equ SAI4_SAI_BFRCR_FSDEF, 1 << 16   @ bitWidth 1 (Frame synchronization definition. This  bit is set and cleared by software. When the bit is  set, the number of slots defined in the SAI_xSLOTR  register has to be even. It means that half of this  number of slots will be dedicated to the left channel  and the other slots for the right channel e.g: this  bit has to be set for I2S or MSB/LSB-justified  protocols.... This bit is meaningless and is not  used in AC97 or SPDIF audio block configuration. It  must be configured when the audio block is  disabled.)  
        .equ SAI4_SAI_BFRCR_FSPOL, 1 << 17   @ bitWidth 1 (Frame synchronization polarity. This bit  is set and cleared by software. It is used to  configure the level of the start of frame on the FS  signal. It is meaningless and is not used in AC97 or  SPDIF audio block configuration. This bit must be  configured when the audio block is  disabled.)  
        .equ SAI4_SAI_BFRCR_FSOFF, 1 << 18   @ bitWidth 1 (Frame synchronization offset. This bit  is set and cleared by software. It is meaningless and  is not used in AC97 or SPDIF audio block  configuration. This bit must be configured when the  audio block is disabled.)  
 
    .equ SAI4_SAI_BSLOTR, SAI4_BASE + 0x30 @ (This register has no meaning in AC97 and  SPDIF audio protocol) 
        .equ SAI4_SAI_BSLOTR_FBOFF_Shift, 0   @ bitWidth 5 (First bit offset These bits are set and  cleared by software. The value set in this bitfield  defines the position of the first data transfer bit  in the slot. It represents an offset value. In  transmission mode, the bits outside the data field  are forced to 0. In reception mode, the extra  received bits are discarded. These bits must be set  when the audio block is disabled. They are ignored in  AC97 or SPDIF mode.)  
        .equ SAI4_SAI_BSLOTR_SLOTSZ_Shift, 6   @ bitWidth 2 (Slot size This bits is set and cleared  by software. The slot size must be higher or equal to  the data size. If this condition is not respected,  the behavior of the SAI will be undetermined. Refer  to Section: Output data line management on an  inactive slot for information on how to drive SD  line. These bits must be set when the audio block is  disabled. They are ignored in AC97 or SPDIF  mode.)  
        .equ SAI4_SAI_BSLOTR_NBSLOT_Shift, 8   @ bitWidth 4 (Number of slots in an audio frame. These  bits are set and cleared by software. The value set  in this bitfield represents the number of slots + 1  in the audio frame including the number of inactive  slots. The maximum number of slots is 16. The number  of slots should be even if FSDEF bit in the SAI_xFRCR  register is set. The number of slots must be  configured when the audio block is disabled. They are  ignored in AC97 or SPDIF mode.)  
        .equ SAI4_SAI_BSLOTR_SLOTEN_Shift, 16   @ bitWidth 16 (Slot enable. These bits are set and  cleared by software. Each SLOTEN bit corresponds to a  slot position from 0 to 15 maximum 16 slots. The  slot must be enabled when the audio block is  disabled. They are ignored in AC97 or SPDIF  mode.)  
 
    .equ SAI4_SAI_BIM, SAI4_BASE + 0x34 @ (Interrupt mask register 2) 
        .equ SAI4_SAI_BIM_OVRUDRIE, 1 << 0   @ bitWidth 1 (Overrun/underrun interrupt enable. This  bit is set and cleared by software. When this bit is  set, an interrupt is generated if the OVRUDR bit in  the SAI_xSR register is set.)  
        .equ SAI4_SAI_BIM_MUTEDETIE, 1 << 1   @ bitWidth 1 (Mute detection interrupt enable. This  bit is set and cleared by software. When this bit is  set, an interrupt is generated if the MUTEDET bit in  the SAI_xSR register is set. This bit has a meaning  only if the audio block is configured in receiver  mode.)  
        .equ SAI4_SAI_BIM_WCKCFGIE, 1 << 2   @ bitWidth 1 (Wrong clock configuration interrupt  enable. This bit is set and cleared by software. This  bit is taken into account only if the audio block is  configured as a master MODE[1] = 0 and NODIV = 0.  It generates an interrupt if the WCKCFG flag in the  SAI_xSR register is set. Note: This bit is used only  in TDM mode and is meaningless in other  modes.)  
        .equ SAI4_SAI_BIM_FREQIE, 1 << 3   @ bitWidth 1 (FIFO request interrupt enable. This bit  is set and cleared by software. When this bit is set,  an interrupt is generated if the FREQ bit in the  SAI_xSR register is set. Since the audio block  defaults to operate as a transmitter after reset, the  MODE bit must be configured before setting FREQIE to  avoid a parasitic interruption in receiver  mode,)  
        .equ SAI4_SAI_BIM_CNRDYIE, 1 << 4   @ bitWidth 1 (Codec not ready interrupt enable AC97.  This bit is set and cleared by software. When the  interrupt is enabled, the audio block detects in the  slot 0 tag0 of the AC97 frame if the Codec  connected to this line is ready or not. If it is not  ready, the CNRDY flag in the SAI_xSR register is set  and an interruption i generated. This bit has a  meaning only if the AC97 mode is selected through  PRTCFG[1:0] bits and the audio block is operates as a  receiver.)  
        .equ SAI4_SAI_BIM_AFSDETIE, 1 << 5   @ bitWidth 1 (Anticipated frame synchronization  detection interrupt enable. This bit is set and  cleared by software. When this bit is set, an  interrupt will be generated if the AFSDET bit in the  SAI_xSR register is set. This bit is meaningless in  AC97, SPDIF mode or when the audio block operates as  a master.)  
        .equ SAI4_SAI_BIM_LFSDETIE, 1 << 6   @ bitWidth 1 (Late frame synchronization detection  interrupt enable. This bit is set and cleared by  software. When this bit is set, an interrupt will be  generated if the LFSDET bit is set in the SAI_xSR  register. This bit is meaningless in AC97, SPDIF mode  or when the audio block operates as a  master.)  
 
    .equ SAI4_SAI_BSR, SAI4_BASE + 0x38 @ (Status register) 
        .equ SAI4_SAI_BSR_OVRUDR, 1 << 0   @ bitWidth 1 (Overrun / underrun. This bit is read  only. The overrun and underrun conditions can occur  only when the audio block is configured as a receiver  and a transmitter, respectively. It can generate an  interrupt if OVRUDRIE bit is set in SAI_xIM register.  This flag is cleared when the software sets COVRUDR  bit in SAI_xCLRFR register.)  
        .equ SAI4_SAI_BSR_MUTEDET, 1 << 1   @ bitWidth 1 (Mute detection. This bit is read only.  This flag is set if consecutive 0 values are received  in each slot of a given audio frame and for a  consecutive number of audio frames set in the  MUTECNT bit in the SAI_xCR2 register. It can  generate an interrupt if MUTEDETIE bit is set in  SAI_xIM register. This flag is cleared when the  software sets bit CMUTEDET in the SAI_xCLRFR  register.)  
        .equ SAI4_SAI_BSR_WCKCFG, 1 << 2   @ bitWidth 1 (Wrong clock configuration flag. This bit  is read only. This bit is used only when the audio  block operates in master mode MODE[1] = 0 and NODIV  = 0. It can generate an interrupt if WCKCFGIE bit is  set in SAI_xIM register. This flag is cleared when  the software sets CWCKCFG bit in SAI_xCLRFR  register.)  
        .equ SAI4_SAI_BSR_FREQ, 1 << 3   @ bitWidth 1 (FIFO request. This bit is read only. The  request depends on the audio block configuration: If  the block is configured in transmission mode, the  FIFO request is related to a write request operation  in the SAI_xDR. If the block configured in reception,  the FIFO request related to a read request operation  from the SAI_xDR. This flag can generate an interrupt  if FREQIE bit is set in SAI_xIM  register.)  
        .equ SAI4_SAI_BSR_CNRDY, 1 << 4   @ bitWidth 1 (Codec not ready. This bit is read only.  This bit is used only when the AC97 audio protocol is  selected in the SAI_xCR1 register and configured in  receiver mode. It can generate an interrupt if  CNRDYIE bit is set in SAI_xIM register. This flag is  cleared when the software sets CCNRDY bit in  SAI_xCLRFR register.)  
        .equ SAI4_SAI_BSR_AFSDET, 1 << 5   @ bitWidth 1 (Anticipated frame synchronization  detection. This bit is read only. This flag can be  set only if the audio block is configured in slave  mode. It is not used in AC97or SPDIF mode. It can  generate an interrupt if AFSDETIE bit is set in  SAI_xIM register. This flag is cleared when the  software sets CAFSDET bit in SAI_xCLRFR  register.)  
        .equ SAI4_SAI_BSR_LFSDET, 1 << 6   @ bitWidth 1 (Late frame synchronization detection.  This bit is read only. This flag can be set only if  the audio block is configured in slave mode. It is  not used in AC97 or SPDIF mode. It can generate an  interrupt if LFSDETIE bit is set in the SAI_xIM  register. This flag is cleared when the software sets  bit CLFSDET in SAI_xCLRFR register)  
        .equ SAI4_SAI_BSR_FLVL_Shift, 16   @ bitWidth 3 (FIFO level threshold. This bit is read  only. The FIFO level threshold flag is managed only  by hardware and its setting depends on SAI block  configuration transmitter or receiver mode. If the  SAI block is configured as transmitter: If SAI block  is configured as receiver:)  
 
    .equ SAI4_SAI_BCLRFR, SAI4_BASE + 0x3C @ (Clear flag register) 
        .equ SAI4_SAI_BCLRFR_COVRUDR, 1 << 0   @ bitWidth 1 (Clear overrun / underrun. This bit is  write only. Programming this bit to 1 clears the  OVRUDR flag in the SAI_xSR register. Reading this bit  always returns the value 0.)  
        .equ SAI4_SAI_BCLRFR_CMUTEDET, 1 << 1   @ bitWidth 1 (Mute detection flag. This bit is write  only. Programming this bit to 1 clears the MUTEDET  flag in the SAI_xSR register. Reading this bit always  returns the value 0.)  
        .equ SAI4_SAI_BCLRFR_CWCKCFG, 1 << 2   @ bitWidth 1 (Clear wrong clock configuration flag.  This bit is write only. Programming this bit to 1  clears the WCKCFG flag in the SAI_xSR register. This  bit is used only when the audio block is set as  master MODE[1] = 0 and NODIV = 0 in the SAI_xCR1  register. Reading this bit always returns the value  0.)  
        .equ SAI4_SAI_BCLRFR_CCNRDY, 1 << 4   @ bitWidth 1 (Clear Codec not ready flag. This bit is  write only. Programming this bit to 1 clears the  CNRDY flag in the SAI_xSR register. This bit is used  only when the AC97 audio protocol is selected in the  SAI_xCR1 register. Reading this bit always returns  the value 0.)  
        .equ SAI4_SAI_BCLRFR_CAFSDET, 1 << 5   @ bitWidth 1 (Clear anticipated frame synchronization  detection flag. This bit is write only. Programming  this bit to 1 clears the AFSDET flag in the SAI_xSR  register. It is not used in AC97or SPDIF mode.  Reading this bit always returns the value  0.)  
        .equ SAI4_SAI_BCLRFR_CLFSDET, 1 << 6   @ bitWidth 1 (Clear late frame synchronization  detection flag. This bit is write only. Programming  this bit to 1 clears the LFSDET flag in the SAI_xSR  register. This bit is not used in AC97or SPDIF mode  Reading this bit always returns the value  0.)  
 
    .equ SAI4_SAI_BDR, SAI4_BASE + 0x40 @ (Data register) 
        .equ SAI4_SAI_BDR_DATA_Shift, 0   @ bitWidth 32 (Data A write to this register loads the  FIFO provided the FIFO is not full. A read from this  register empties the FIFO if the FIFO is not  empty.)  
 
    .equ SAI4_SAI_PDMCR, SAI4_BASE + 0x44 @ (PDM control register) 
        .equ SAI4_SAI_PDMCR_PDMEN, 1 << 0   @ bitWidth 1 (PDM enable)  
        .equ SAI4_SAI_PDMCR_MICNBR_Shift, 4   @ bitWidth 2 (Number of microphones)  
        .equ SAI4_SAI_PDMCR_CKEN1, 1 << 8   @ bitWidth 1 (Clock enable of bitstream clock number  1)  
        .equ SAI4_SAI_PDMCR_CKEN2, 1 << 9   @ bitWidth 1 (Clock enable of bitstream clock number  2)  
        .equ SAI4_SAI_PDMCR_CKEN3, 1 << 10   @ bitWidth 1 (Clock enable of bitstream clock number  3)  
        .equ SAI4_SAI_PDMCR_CKEN4, 1 << 11   @ bitWidth 1 (Clock enable of bitstream clock number  4)  
 
    .equ SAI4_SAI_PDMDLY, SAI4_BASE + 0x48 @ (PDM delay register) 
        .equ SAI4_SAI_PDMDLY_DLYM1L_Shift, 0   @ bitWidth 3 (Delay line adjust for first microphone  of pair 1)  
        .equ SAI4_SAI_PDMDLY_DLYM1R_Shift, 4   @ bitWidth 3 (Delay line adjust for second microphone  of pair 1)  
        .equ SAI4_SAI_PDMDLY_DLYM2L_Shift, 8   @ bitWidth 3 (Delay line for first microphone of pair  2)  
        .equ SAI4_SAI_PDMDLY_DLYM2R_Shift, 12   @ bitWidth 3 (Delay line for second microphone of pair  2)  
        .equ SAI4_SAI_PDMDLY_DLYM3L_Shift, 16   @ bitWidth 3 (Delay line for first microphone of pair  3)  
        .equ SAI4_SAI_PDMDLY_DLYM3R_Shift, 20   @ bitWidth 3 (Delay line for second microphone of pair  3)  
        .equ SAI4_SAI_PDMDLY_DLYM4L_Shift, 24   @ bitWidth 3 (Delay line for first microphone of pair  4)  
        .equ SAI4_SAI_PDMDLY_DLYM4R_Shift, 28   @ bitWidth 3 (Delay line for second microphone of pair  4)  
 

@=========================== SAI1 ===========================@
.equ SAI1_BASE, 0x40015800 @ (SAI) 
    .equ SAI1_SAI_GCR, SAI1_BASE + 0x0 @ (Global configuration register) 
        .equ SAI1_SAI_GCR_SYNCOUT_Shift, 4   @ bitWidth 2 (Synchronization outputs These bits are  set and cleared by software.)  
        .equ SAI1_SAI_GCR_SYNCIN_Shift, 0   @ bitWidth 2 (Synchronization inputs)  
 
    .equ SAI1_SAI_ACR1, SAI1_BASE + 0x4 @ (Configuration register 1) 
        .equ SAI1_SAI_ACR1_MODE_Shift, 0   @ bitWidth 2 (SAIx audio block mode  immediately)  
        .equ SAI1_SAI_ACR1_PRTCFG_Shift, 2   @ bitWidth 2 (Protocol configuration. These bits are  set and cleared by software. These bits have to be  configured when the audio block is  disabled.)  
        .equ SAI1_SAI_ACR1_DS_Shift, 5   @ bitWidth 3 (Data size. These bits are set and  cleared by software. These bits are ignored when the  SPDIF protocols are selected bit PRTCFG[1:0],  because the frame and the data size are fixed in such  case. When the companding mode is selected through  COMP[1:0] bits, DS[1:0] are ignored since the data  size is fixed to 8 bits by the algorithm. These bits  must be configured when the audio block is  disabled.)  
        .equ SAI1_SAI_ACR1_LSBFIRST, 1 << 8   @ bitWidth 1 (Least significant bit first. This bit is  set and cleared by software. It must be configured  when the audio block is disabled. This bit has no  meaning in AC97 audio protocol since AC97 data are  always transferred with the MSB first. This bit has  no meaning in SPDIF audio protocol since in SPDIF  data are always transferred with LSB  first.)  
        .equ SAI1_SAI_ACR1_CKSTR, 1 << 9   @ bitWidth 1 (Clock strobing edge. This bit is set and  cleared by software. It must be configured when the  audio block is disabled. This bit has no meaning in  SPDIF audio protocol.)  
        .equ SAI1_SAI_ACR1_SYNCEN_Shift, 10   @ bitWidth 2 (Synchronization enable. These bits are  set and cleared by software. They must be configured  when the audio sub-block is disabled. Note: The audio  sub-block should be configured as asynchronous when  SPDIF mode is enabled.)  
        .equ SAI1_SAI_ACR1_MONO, 1 << 12   @ bitWidth 1 (Mono mode. This bit is set and cleared  by software. It is meaningful only when the number of  slots is equal to 2. When the mono mode is selected,  slot 0 data are duplicated on slot 1 when the audio  block operates as a transmitter. In reception mode,  the slot1 is discarded and only the data received  from slot 0 are stored. Refer to Section: Mono/stereo  mode for more details.)  
        .equ SAI1_SAI_ACR1_OUTDRIV, 1 << 13   @ bitWidth 1 (Output drive. This bit is set and  cleared by software. Note: This bit has to be set  before enabling the audio block and after the audio  block configuration.)  
        .equ SAI1_SAI_ACR1_SAIXEN, 1 << 16   @ bitWidth 1 (Audio block enable where x is A or B.  This bit is set by software. To switch off the audio  block, the application software must program this bit  to 0 and poll the bit till it reads back 0, meaning  that the block is completely disabled. Before setting  this bit to 1, check that it is set to 0, otherwise  the enable command will not be taken into account.  This bit allows to control the state of SAIx audio  block. If it is disabled when an audio frame transfer  is ongoing, the ongoing transfer completes and the  cell is fully disabled at the end of this audio frame  transfer. Note: When SAIx block is configured in  master mode, the clock must be present on the input  of SAIx before setting SAIXEN bit.)  
        .equ SAI1_SAI_ACR1_DMAEN, 1 << 17   @ bitWidth 1 (DMA enable. This bit is set and cleared  by software. Note: Since the audio block defaults to  operate as a transmitter after reset, the MODE[1:0]  bits must be configured before setting DMAEN to avoid  a DMA request in receiver mode.)  
        .equ SAI1_SAI_ACR1_NOMCK, 1 << 19   @ bitWidth 1 (No divider)  
        .equ SAI1_SAI_ACR1_MCKDIV_Shift, 20   @ bitWidth 4 (Master clock divider. These bits are set  and cleared by software. These bits are meaningless  when the audio block operates in slave mode. They  have to be configured when the audio block is  disabled. Others: the master clock frequency is  calculated accordingly to the following  formula:)  
        .equ SAI1_SAI_ACR1_OSR, 1 << 26   @ bitWidth 1 (Oversampling ratio for master  clock)  
 
    .equ SAI1_SAI_ACR2, SAI1_BASE + 0x8 @ (Configuration register 2) 
        .equ SAI1_SAI_ACR2_FTH_Shift, 0   @ bitWidth 3 (FIFO threshold. This bit is set and  cleared by software.)  
        .equ SAI1_SAI_ACR2_FFLUSH, 1 << 3   @ bitWidth 1 (FIFO flush. This bit is set by software.  It is always read as 0. This bit should be configured  when the SAI is disabled.)  
        .equ SAI1_SAI_ACR2_TRIS, 1 << 4   @ bitWidth 1 (Tristate management on data line. This  bit is set and cleared by software. It is meaningful  only if the audio block is configured as a  transmitter. This bit is not used when the audio  block is configured in SPDIF mode. It should be  configured when SAI is disabled. Refer to Section:  Output data line management on an inactive slot for  more details.)  
        .equ SAI1_SAI_ACR2_MUTE, 1 << 5   @ bitWidth 1 (Mute. This bit is set and cleared by  software. It is meaningful only when the audio block  operates as a transmitter. The MUTE value is linked  to value of MUTEVAL if the number of slots is lower  or equal to 2, or equal to 0 if it is greater than 2.  Refer to Section: Mute mode for more details. Note:  This bit is meaningless and should not be used for  SPDIF audio blocks.)  
        .equ SAI1_SAI_ACR2_MUTEVAL, 1 << 6   @ bitWidth 1 (Mute value. This bit is set and cleared  by software.It must be written before enabling the  audio block: SAIXEN. This bit is meaningful only when  the audio block operates as a transmitter, the number  of slots is lower or equal to 2 and the MUTE bit is  set. If more slots are declared, the bit value sent  during the transmission in mute mode is equal to 0,  whatever the value of MUTEVAL. if the number of slot  is lower or equal to 2 and MUTEVAL = 1, the MUTE  value transmitted for each slot is the one sent  during the previous frame. Refer to Section: Mute  mode for more details. Note: This bit is meaningless  and should not be used for SPDIF audio  blocks.)  
        .equ SAI1_SAI_ACR2_MUTECNT_Shift, 7   @ bitWidth 6 (Mute counter. These bits are set and  cleared by software. They are used only in reception  mode. The value set in these bits is compared to the  number of consecutive mute frames detected in  reception. When the number of mute frames is equal to  this value, the flag MUTEDET will be set and an  interrupt will be generated if bit MUTEDETIE is set.  Refer to Section: Mute mode for more  details.)  
        .equ SAI1_SAI_ACR2_CPL, 1 << 13   @ bitWidth 1 (Complement bit. This bit is set and  cleared by software. It defines the type of  complement to be used for companding mode Note: This  bit has effect only when the companding mode is -Law  algorithm or A-Law algorithm.)  
        .equ SAI1_SAI_ACR2_COMP_Shift, 14   @ bitWidth 2 (Companding mode. These bits are set and  cleared by software. The -Law and the A-Law log are a  part of the CCITT G.711 recommendation, the type of  complement that will be used depends on CPL bit. The  data expansion or data compression are determined by  the state of bit MODE[0]. The data compression is  applied if the audio block is configured as a  transmitter. The data expansion is automatically  applied when the audio block is configured as a  receiver. Refer to Section: Companding mode for more  details. Note: Companding mode is applicable only  when TDM is selected.)  
 
    .equ SAI1_SAI_AFRCR, SAI1_BASE + 0xC @ (This register has no meaning in AC97 and  SPDIF audio protocol) 
        .equ SAI1_SAI_AFRCR_FRL_Shift, 0   @ bitWidth 8 (Frame length. These bits are set and  cleared by software. They define the audio frame  length expressed in number of SCK clock cycles: the  number of bits in the frame is equal to FRL[7:0] + 1.  The minimum number of bits to transfer in an audio  frame must be equal to 8, otherwise the audio block  will behaves in an unexpected way. This is the case  when the data size is 8 bits and only one slot 0 is  defined in NBSLOT[4:0] of SAI_xSLOTR register  NBSLOT[3:0] = 0000. In master mode, if the master  clock available on MCLK_x pin is used, the frame  length should be aligned with a number equal to a  power of 2, ranging from 8 to 256. When the master  clock is not used NODIV = 1, it is recommended to  program the frame length to an value ranging from 8  to 256. These bits are meaningless and are not used  in AC97 or SPDIF audio block  configuration.)  
        .equ SAI1_SAI_AFRCR_FSALL_Shift, 8   @ bitWidth 7 (Frame synchronization active level  length. These bits are set and cleared by software.  They specify the length in number of bit clock SCK  + 1 FSALL[6:0] + 1 of the active level of the FS  signal in the audio frame These bits are meaningless  and are not used in AC97 or SPDIF audio block  configuration. They must be configured when the audio  block is disabled.)  
        .equ SAI1_SAI_AFRCR_FSDEF, 1 << 16   @ bitWidth 1 (Frame synchronization definition. This  bit is set and cleared by software. When the bit is  set, the number of slots defined in the SAI_xSLOTR  register has to be even. It means that half of this  number of slots will be dedicated to the left channel  and the other slots for the right channel e.g: this  bit has to be set for I2S or MSB/LSB-justified  protocols.... This bit is meaningless and is not  used in AC97 or SPDIF audio block configuration. It  must be configured when the audio block is  disabled.)  
        .equ SAI1_SAI_AFRCR_FSPOL, 1 << 17   @ bitWidth 1 (Frame synchronization polarity. This bit  is set and cleared by software. It is used to  configure the level of the start of frame on the FS  signal. It is meaningless and is not used in AC97 or  SPDIF audio block configuration. This bit must be  configured when the audio block is  disabled.)  
        .equ SAI1_SAI_AFRCR_FSOFF, 1 << 18   @ bitWidth 1 (Frame synchronization offset. This bit  is set and cleared by software. It is meaningless and  is not used in AC97 or SPDIF audio block  configuration. This bit must be configured when the  audio block is disabled.)  
 
    .equ SAI1_SAI_ASLOTR, SAI1_BASE + 0x10 @ (This register has no meaning in AC97 and  SPDIF audio protocol) 
        .equ SAI1_SAI_ASLOTR_FBOFF_Shift, 0   @ bitWidth 5 (First bit offset These bits are set and  cleared by software. The value set in this bitfield  defines the position of the first data transfer bit  in the slot. It represents an offset value. In  transmission mode, the bits outside the data field  are forced to 0. In reception mode, the extra  received bits are discarded. These bits must be set  when the audio block is disabled. They are ignored in  AC97 or SPDIF mode.)  
        .equ SAI1_SAI_ASLOTR_SLOTSZ_Shift, 6   @ bitWidth 2 (Slot size This bits is set and cleared  by software. The slot size must be higher or equal to  the data size. If this condition is not respected,  the behavior of the SAI will be undetermined. Refer  to Section: Output data line management on an  inactive slot for information on how to drive SD  line. These bits must be set when the audio block is  disabled. They are ignored in AC97 or SPDIF  mode.)  
        .equ SAI1_SAI_ASLOTR_NBSLOT_Shift, 8   @ bitWidth 4 (Number of slots in an audio frame. These  bits are set and cleared by software. The value set  in this bitfield represents the number of slots + 1  in the audio frame including the number of inactive  slots. The maximum number of slots is 16. The number  of slots should be even if FSDEF bit in the SAI_xFRCR  register is set. The number of slots must be  configured when the audio block is disabled. They are  ignored in AC97 or SPDIF mode.)  
        .equ SAI1_SAI_ASLOTR_SLOTEN_Shift, 16   @ bitWidth 16 (Slot enable. These bits are set and  cleared by software. Each SLOTEN bit corresponds to a  slot position from 0 to 15 maximum 16 slots. The  slot must be enabled when the audio block is  disabled. They are ignored in AC97 or SPDIF  mode.)  
 
    .equ SAI1_SAI_AIM, SAI1_BASE + 0x14 @ (Interrupt mask register 2) 
        .equ SAI1_SAI_AIM_OVRUDRIE, 1 << 0   @ bitWidth 1 (Overrun/underrun interrupt enable. This  bit is set and cleared by software. When this bit is  set, an interrupt is generated if the OVRUDR bit in  the SAI_xSR register is set.)  
        .equ SAI1_SAI_AIM_MUTEDETIE, 1 << 1   @ bitWidth 1 (Mute detection interrupt enable. This  bit is set and cleared by software. When this bit is  set, an interrupt is generated if the MUTEDET bit in  the SAI_xSR register is set. This bit has a meaning  only if the audio block is configured in receiver  mode.)  
        .equ SAI1_SAI_AIM_WCKCFGIE, 1 << 2   @ bitWidth 1 (Wrong clock configuration interrupt  enable. This bit is set and cleared by software. This  bit is taken into account only if the audio block is  configured as a master MODE[1] = 0 and NODIV = 0.  It generates an interrupt if the WCKCFG flag in the  SAI_xSR register is set. Note: This bit is used only  in TDM mode and is meaningless in other  modes.)  
        .equ SAI1_SAI_AIM_FREQIE, 1 << 3   @ bitWidth 1 (FIFO request interrupt enable. This bit  is set and cleared by software. When this bit is set,  an interrupt is generated if the FREQ bit in the  SAI_xSR register is set. Since the audio block  defaults to operate as a transmitter after reset, the  MODE bit must be configured before setting FREQIE to  avoid a parasitic interruption in receiver  mode,)  
        .equ SAI1_SAI_AIM_CNRDYIE, 1 << 4   @ bitWidth 1 (Codec not ready interrupt enable AC97.  This bit is set and cleared by software. When the  interrupt is enabled, the audio block detects in the  slot 0 tag0 of the AC97 frame if the Codec  connected to this line is ready or not. If it is not  ready, the CNRDY flag in the SAI_xSR register is set  and an interruption i generated. This bit has a  meaning only if the AC97 mode is selected through  PRTCFG[1:0] bits and the audio block is operates as a  receiver.)  
        .equ SAI1_SAI_AIM_AFSDETIE, 1 << 5   @ bitWidth 1 (Anticipated frame synchronization  detection interrupt enable. This bit is set and  cleared by software. When this bit is set, an  interrupt will be generated if the AFSDET bit in the  SAI_xSR register is set. This bit is meaningless in  AC97, SPDIF mode or when the audio block operates as  a master.)  
        .equ SAI1_SAI_AIM_LFSDETIE, 1 << 6   @ bitWidth 1 (Late frame synchronization detection  interrupt enable. This bit is set and cleared by  software. When this bit is set, an interrupt will be  generated if the LFSDET bit is set in the SAI_xSR  register. This bit is meaningless in AC97, SPDIF mode  or when the audio block operates as a  master.)  
 
    .equ SAI1_SAI_ASR, SAI1_BASE + 0x18 @ (Status register) 
        .equ SAI1_SAI_ASR_OVRUDR, 1 << 0   @ bitWidth 1 (Overrun / underrun. This bit is read  only. The overrun and underrun conditions can occur  only when the audio block is configured as a receiver  and a transmitter, respectively. It can generate an  interrupt if OVRUDRIE bit is set in SAI_xIM register.  This flag is cleared when the software sets COVRUDR  bit in SAI_xCLRFR register.)  
        .equ SAI1_SAI_ASR_MUTEDET, 1 << 1   @ bitWidth 1 (Mute detection. This bit is read only.  This flag is set if consecutive 0 values are received  in each slot of a given audio frame and for a  consecutive number of audio frames set in the  MUTECNT bit in the SAI_xCR2 register. It can  generate an interrupt if MUTEDETIE bit is set in  SAI_xIM register. This flag is cleared when the  software sets bit CMUTEDET in the SAI_xCLRFR  register.)  
        .equ SAI1_SAI_ASR_WCKCFG, 1 << 2   @ bitWidth 1 (Wrong clock configuration flag. This bit  is read only. This bit is used only when the audio  block operates in master mode MODE[1] = 0 and NODIV  = 0. It can generate an interrupt if WCKCFGIE bit is  set in SAI_xIM register. This flag is cleared when  the software sets CWCKCFG bit in SAI_xCLRFR  register.)  
        .equ SAI1_SAI_ASR_FREQ, 1 << 3   @ bitWidth 1 (FIFO request. This bit is read only. The  request depends on the audio block configuration: If  the block is configured in transmission mode, the  FIFO request is related to a write request operation  in the SAI_xDR. If the block configured in reception,  the FIFO request related to a read request operation  from the SAI_xDR. This flag can generate an interrupt  if FREQIE bit is set in SAI_xIM  register.)  
        .equ SAI1_SAI_ASR_CNRDY, 1 << 4   @ bitWidth 1 (Codec not ready. This bit is read only.  This bit is used only when the AC97 audio protocol is  selected in the SAI_xCR1 register and configured in  receiver mode. It can generate an interrupt if  CNRDYIE bit is set in SAI_xIM register. This flag is  cleared when the software sets CCNRDY bit in  SAI_xCLRFR register.)  
        .equ SAI1_SAI_ASR_AFSDET, 1 << 5   @ bitWidth 1 (Anticipated frame synchronization  detection. This bit is read only. This flag can be  set only if the audio block is configured in slave  mode. It is not used in AC97or SPDIF mode. It can  generate an interrupt if AFSDETIE bit is set in  SAI_xIM register. This flag is cleared when the  software sets CAFSDET bit in SAI_xCLRFR  register.)  
        .equ SAI1_SAI_ASR_LFSDET, 1 << 6   @ bitWidth 1 (Late frame synchronization detection.  This bit is read only. This flag can be set only if  the audio block is configured in slave mode. It is  not used in AC97 or SPDIF mode. It can generate an  interrupt if LFSDETIE bit is set in the SAI_xIM  register. This flag is cleared when the software sets  bit CLFSDET in SAI_xCLRFR register)  
        .equ SAI1_SAI_ASR_FLVL_Shift, 16   @ bitWidth 3 (FIFO level threshold. This bit is read  only. The FIFO level threshold flag is managed only  by hardware and its setting depends on SAI block  configuration transmitter or receiver mode. If the  SAI block is configured as transmitter: If SAI block  is configured as receiver:)  
 
    .equ SAI1_SAI_ACLRFR, SAI1_BASE + 0x1C @ (Clear flag register) 
        .equ SAI1_SAI_ACLRFR_COVRUDR, 1 << 0   @ bitWidth 1 (Clear overrun / underrun. This bit is  write only. Programming this bit to 1 clears the  OVRUDR flag in the SAI_xSR register. Reading this bit  always returns the value 0.)  
        .equ SAI1_SAI_ACLRFR_CMUTEDET, 1 << 1   @ bitWidth 1 (Mute detection flag. This bit is write  only. Programming this bit to 1 clears the MUTEDET  flag in the SAI_xSR register. Reading this bit always  returns the value 0.)  
        .equ SAI1_SAI_ACLRFR_CWCKCFG, 1 << 2   @ bitWidth 1 (Clear wrong clock configuration flag.  This bit is write only. Programming this bit to 1  clears the WCKCFG flag in the SAI_xSR register. This  bit is used only when the audio block is set as  master MODE[1] = 0 and NODIV = 0 in the SAI_xCR1  register. Reading this bit always returns the value  0.)  
        .equ SAI1_SAI_ACLRFR_CCNRDY, 1 << 4   @ bitWidth 1 (Clear Codec not ready flag. This bit is  write only. Programming this bit to 1 clears the  CNRDY flag in the SAI_xSR register. This bit is used  only when the AC97 audio protocol is selected in the  SAI_xCR1 register. Reading this bit always returns  the value 0.)  
        .equ SAI1_SAI_ACLRFR_CAFSDET, 1 << 5   @ bitWidth 1 (Clear anticipated frame synchronization  detection flag. This bit is write only. Programming  this bit to 1 clears the AFSDET flag in the SAI_xSR  register. It is not used in AC97or SPDIF mode.  Reading this bit always returns the value  0.)  
        .equ SAI1_SAI_ACLRFR_CLFSDET, 1 << 6   @ bitWidth 1 (Clear late frame synchronization  detection flag. This bit is write only. Programming  this bit to 1 clears the LFSDET flag in the SAI_xSR  register. This bit is not used in AC97or SPDIF mode  Reading this bit always returns the value  0.)  
 
    .equ SAI1_SAI_ADR, SAI1_BASE + 0x20 @ (Data register) 
        .equ SAI1_SAI_ADR_DATA_Shift, 0   @ bitWidth 32 (Data A write to this register loads the  FIFO provided the FIFO is not full. A read from this  register empties the FIFO if the FIFO is not  empty.)  
 
    .equ SAI1_SAI_BCR1, SAI1_BASE + 0x24 @ (Configuration register 1) 
        .equ SAI1_SAI_BCR1_MODE_Shift, 0   @ bitWidth 2 (SAIx audio block mode  immediately)  
        .equ SAI1_SAI_BCR1_PRTCFG_Shift, 2   @ bitWidth 2 (Protocol configuration. These bits are  set and cleared by software. These bits have to be  configured when the audio block is  disabled.)  
        .equ SAI1_SAI_BCR1_DS_Shift, 5   @ bitWidth 3 (Data size. These bits are set and  cleared by software. These bits are ignored when the  SPDIF protocols are selected bit PRTCFG[1:0],  because the frame and the data size are fixed in such  case. When the companding mode is selected through  COMP[1:0] bits, DS[1:0] are ignored since the data  size is fixed to 8 bits by the algorithm. These bits  must be configured when the audio block is  disabled.)  
        .equ SAI1_SAI_BCR1_LSBFIRST, 1 << 8   @ bitWidth 1 (Least significant bit first. This bit is  set and cleared by software. It must be configured  when the audio block is disabled. This bit has no  meaning in AC97 audio protocol since AC97 data are  always transferred with the MSB first. This bit has  no meaning in SPDIF audio protocol since in SPDIF  data are always transferred with LSB  first.)  
        .equ SAI1_SAI_BCR1_CKSTR, 1 << 9   @ bitWidth 1 (Clock strobing edge. This bit is set and  cleared by software. It must be configured when the  audio block is disabled. This bit has no meaning in  SPDIF audio protocol.)  
        .equ SAI1_SAI_BCR1_SYNCEN_Shift, 10   @ bitWidth 2 (Synchronization enable. These bits are  set and cleared by software. They must be configured  when the audio sub-block is disabled. Note: The audio  sub-block should be configured as asynchronous when  SPDIF mode is enabled.)  
        .equ SAI1_SAI_BCR1_MONO, 1 << 12   @ bitWidth 1 (Mono mode. This bit is set and cleared  by software. It is meaningful only when the number of  slots is equal to 2. When the mono mode is selected,  slot 0 data are duplicated on slot 1 when the audio  block operates as a transmitter. In reception mode,  the slot1 is discarded and only the data received  from slot 0 are stored. Refer to Section: Mono/stereo  mode for more details.)  
        .equ SAI1_SAI_BCR1_OUTDRIV, 1 << 13   @ bitWidth 1 (Output drive. This bit is set and  cleared by software. Note: This bit has to be set  before enabling the audio block and after the audio  block configuration.)  
        .equ SAI1_SAI_BCR1_SAIXEN, 1 << 16   @ bitWidth 1 (Audio block enable where x is A or B.  This bit is set by software. To switch off the audio  block, the application software must program this bit  to 0 and poll the bit till it reads back 0, meaning  that the block is completely disabled. Before setting  this bit to 1, check that it is set to 0, otherwise  the enable command will not be taken into account.  This bit allows to control the state of SAIx audio  block. If it is disabled when an audio frame transfer  is ongoing, the ongoing transfer completes and the  cell is fully disabled at the end of this audio frame  transfer. Note: When SAIx block is configured in  master mode, the clock must be present on the input  of SAIx before setting SAIXEN bit.)  
        .equ SAI1_SAI_BCR1_DMAEN, 1 << 17   @ bitWidth 1 (DMA enable. This bit is set and cleared  by software. Note: Since the audio block defaults to  operate as a transmitter after reset, the MODE[1:0]  bits must be configured before setting DMAEN to avoid  a DMA request in receiver mode.)  
        .equ SAI1_SAI_BCR1_NOMCK, 1 << 19   @ bitWidth 1 (No divider)  
        .equ SAI1_SAI_BCR1_MCKDIV_Shift, 20   @ bitWidth 4 (Master clock divider. These bits are set  and cleared by software. These bits are meaningless  when the audio block operates in slave mode. They  have to be configured when the audio block is  disabled. Others: the master clock frequency is  calculated accordingly to the following  formula:)  
        .equ SAI1_SAI_BCR1_OSR, 1 << 26   @ bitWidth 1 (Oversampling ratio for master  clock)  
 
    .equ SAI1_SAI_BCR2, SAI1_BASE + 0x28 @ (Configuration register 2) 
        .equ SAI1_SAI_BCR2_FTH_Shift, 0   @ bitWidth 3 (FIFO threshold. This bit is set and  cleared by software.)  
        .equ SAI1_SAI_BCR2_FFLUSH, 1 << 3   @ bitWidth 1 (FIFO flush. This bit is set by software.  It is always read as 0. This bit should be configured  when the SAI is disabled.)  
        .equ SAI1_SAI_BCR2_TRIS, 1 << 4   @ bitWidth 1 (Tristate management on data line. This  bit is set and cleared by software. It is meaningful  only if the audio block is configured as a  transmitter. This bit is not used when the audio  block is configured in SPDIF mode. It should be  configured when SAI is disabled. Refer to Section:  Output data line management on an inactive slot for  more details.)  
        .equ SAI1_SAI_BCR2_MUTE, 1 << 5   @ bitWidth 1 (Mute. This bit is set and cleared by  software. It is meaningful only when the audio block  operates as a transmitter. The MUTE value is linked  to value of MUTEVAL if the number of slots is lower  or equal to 2, or equal to 0 if it is greater than 2.  Refer to Section: Mute mode for more details. Note:  This bit is meaningless and should not be used for  SPDIF audio blocks.)  
        .equ SAI1_SAI_BCR2_MUTEVAL, 1 << 6   @ bitWidth 1 (Mute value. This bit is set and cleared  by software.It must be written before enabling the  audio block: SAIXEN. This bit is meaningful only when  the audio block operates as a transmitter, the number  of slots is lower or equal to 2 and the MUTE bit is  set. If more slots are declared, the bit value sent  during the transmission in mute mode is equal to 0,  whatever the value of MUTEVAL. if the number of slot  is lower or equal to 2 and MUTEVAL = 1, the MUTE  value transmitted for each slot is the one sent  during the previous frame. Refer to Section: Mute  mode for more details. Note: This bit is meaningless  and should not be used for SPDIF audio  blocks.)  
        .equ SAI1_SAI_BCR2_MUTECNT_Shift, 7   @ bitWidth 6 (Mute counter. These bits are set and  cleared by software. They are used only in reception  mode. The value set in these bits is compared to the  number of consecutive mute frames detected in  reception. When the number of mute frames is equal to  this value, the flag MUTEDET will be set and an  interrupt will be generated if bit MUTEDETIE is set.  Refer to Section: Mute mode for more  details.)  
        .equ SAI1_SAI_BCR2_CPL, 1 << 13   @ bitWidth 1 (Complement bit. This bit is set and  cleared by software. It defines the type of  complement to be used for companding mode Note: This  bit has effect only when the companding mode is -Law  algorithm or A-Law algorithm.)  
        .equ SAI1_SAI_BCR2_COMP_Shift, 14   @ bitWidth 2 (Companding mode. These bits are set and  cleared by software. The -Law and the A-Law log are a  part of the CCITT G.711 recommendation, the type of  complement that will be used depends on CPL bit. The  data expansion or data compression are determined by  the state of bit MODE[0]. The data compression is  applied if the audio block is configured as a  transmitter. The data expansion is automatically  applied when the audio block is configured as a  receiver. Refer to Section: Companding mode for more  details. Note: Companding mode is applicable only  when TDM is selected.)  
 
    .equ SAI1_SAI_BFRCR, SAI1_BASE + 0x2C @ (This register has no meaning in AC97 and  SPDIF audio protocol) 
        .equ SAI1_SAI_BFRCR_FRL_Shift, 0   @ bitWidth 8 (Frame length. These bits are set and  cleared by software. They define the audio frame  length expressed in number of SCK clock cycles: the  number of bits in the frame is equal to FRL[7:0] + 1.  The minimum number of bits to transfer in an audio  frame must be equal to 8, otherwise the audio block  will behaves in an unexpected way. This is the case  when the data size is 8 bits and only one slot 0 is  defined in NBSLOT[4:0] of SAI_xSLOTR register  NBSLOT[3:0] = 0000. In master mode, if the master  clock available on MCLK_x pin is used, the frame  length should be aligned with a number equal to a  power of 2, ranging from 8 to 256. When the master  clock is not used NODIV = 1, it is recommended to  program the frame length to an value ranging from 8  to 256. These bits are meaningless and are not used  in AC97 or SPDIF audio block  configuration.)  
        .equ SAI1_SAI_BFRCR_FSALL_Shift, 8   @ bitWidth 7 (Frame synchronization active level  length. These bits are set and cleared by software.  They specify the length in number of bit clock SCK  + 1 FSALL[6:0] + 1 of the active level of the FS  signal in the audio frame These bits are meaningless  and are not used in AC97 or SPDIF audio block  configuration. They must be configured when the audio  block is disabled.)  
        .equ SAI1_SAI_BFRCR_FSDEF, 1 << 16   @ bitWidth 1 (Frame synchronization definition. This  bit is set and cleared by software. When the bit is  set, the number of slots defined in the SAI_xSLOTR  register has to be even. It means that half of this  number of slots will be dedicated to the left channel  and the other slots for the right channel e.g: this  bit has to be set for I2S or MSB/LSB-justified  protocols.... This bit is meaningless and is not  used in AC97 or SPDIF audio block configuration. It  must be configured when the audio block is  disabled.)  
        .equ SAI1_SAI_BFRCR_FSPOL, 1 << 17   @ bitWidth 1 (Frame synchronization polarity. This bit  is set and cleared by software. It is used to  configure the level of the start of frame on the FS  signal. It is meaningless and is not used in AC97 or  SPDIF audio block configuration. This bit must be  configured when the audio block is  disabled.)  
        .equ SAI1_SAI_BFRCR_FSOFF, 1 << 18   @ bitWidth 1 (Frame synchronization offset. This bit  is set and cleared by software. It is meaningless and  is not used in AC97 or SPDIF audio block  configuration. This bit must be configured when the  audio block is disabled.)  
 
    .equ SAI1_SAI_BSLOTR, SAI1_BASE + 0x30 @ (This register has no meaning in AC97 and  SPDIF audio protocol) 
        .equ SAI1_SAI_BSLOTR_FBOFF_Shift, 0   @ bitWidth 5 (First bit offset These bits are set and  cleared by software. The value set in this bitfield  defines the position of the first data transfer bit  in the slot. It represents an offset value. In  transmission mode, the bits outside the data field  are forced to 0. In reception mode, the extra  received bits are discarded. These bits must be set  when the audio block is disabled. They are ignored in  AC97 or SPDIF mode.)  
        .equ SAI1_SAI_BSLOTR_SLOTSZ_Shift, 6   @ bitWidth 2 (Slot size This bits is set and cleared  by software. The slot size must be higher or equal to  the data size. If this condition is not respected,  the behavior of the SAI will be undetermined. Refer  to Section: Output data line management on an  inactive slot for information on how to drive SD  line. These bits must be set when the audio block is  disabled. They are ignored in AC97 or SPDIF  mode.)  
        .equ SAI1_SAI_BSLOTR_NBSLOT_Shift, 8   @ bitWidth 4 (Number of slots in an audio frame. These  bits are set and cleared by software. The value set  in this bitfield represents the number of slots + 1  in the audio frame including the number of inactive  slots. The maximum number of slots is 16. The number  of slots should be even if FSDEF bit in the SAI_xFRCR  register is set. The number of slots must be  configured when the audio block is disabled. They are  ignored in AC97 or SPDIF mode.)  
        .equ SAI1_SAI_BSLOTR_SLOTEN_Shift, 16   @ bitWidth 16 (Slot enable. These bits are set and  cleared by software. Each SLOTEN bit corresponds to a  slot position from 0 to 15 maximum 16 slots. The  slot must be enabled when the audio block is  disabled. They are ignored in AC97 or SPDIF  mode.)  
 
    .equ SAI1_SAI_BIM, SAI1_BASE + 0x34 @ (Interrupt mask register 2) 
        .equ SAI1_SAI_BIM_OVRUDRIE, 1 << 0   @ bitWidth 1 (Overrun/underrun interrupt enable. This  bit is set and cleared by software. When this bit is  set, an interrupt is generated if the OVRUDR bit in  the SAI_xSR register is set.)  
        .equ SAI1_SAI_BIM_MUTEDETIE, 1 << 1   @ bitWidth 1 (Mute detection interrupt enable. This  bit is set and cleared by software. When this bit is  set, an interrupt is generated if the MUTEDET bit in  the SAI_xSR register is set. This bit has a meaning  only if the audio block is configured in receiver  mode.)  
        .equ SAI1_SAI_BIM_WCKCFGIE, 1 << 2   @ bitWidth 1 (Wrong clock configuration interrupt  enable. This bit is set and cleared by software. This  bit is taken into account only if the audio block is  configured as a master MODE[1] = 0 and NODIV = 0.  It generates an interrupt if the WCKCFG flag in the  SAI_xSR register is set. Note: This bit is used only  in TDM mode and is meaningless in other  modes.)  
        .equ SAI1_SAI_BIM_FREQIE, 1 << 3   @ bitWidth 1 (FIFO request interrupt enable. This bit  is set and cleared by software. When this bit is set,  an interrupt is generated if the FREQ bit in the  SAI_xSR register is set. Since the audio block  defaults to operate as a transmitter after reset, the  MODE bit must be configured before setting FREQIE to  avoid a parasitic interruption in receiver  mode,)  
        .equ SAI1_SAI_BIM_CNRDYIE, 1 << 4   @ bitWidth 1 (Codec not ready interrupt enable AC97.  This bit is set and cleared by software. When the  interrupt is enabled, the audio block detects in the  slot 0 tag0 of the AC97 frame if the Codec  connected to this line is ready or not. If it is not  ready, the CNRDY flag in the SAI_xSR register is set  and an interruption i generated. This bit has a  meaning only if the AC97 mode is selected through  PRTCFG[1:0] bits and the audio block is operates as a  receiver.)  
        .equ SAI1_SAI_BIM_AFSDETIE, 1 << 5   @ bitWidth 1 (Anticipated frame synchronization  detection interrupt enable. This bit is set and  cleared by software. When this bit is set, an  interrupt will be generated if the AFSDET bit in the  SAI_xSR register is set. This bit is meaningless in  AC97, SPDIF mode or when the audio block operates as  a master.)  
        .equ SAI1_SAI_BIM_LFSDETIE, 1 << 6   @ bitWidth 1 (Late frame synchronization detection  interrupt enable. This bit is set and cleared by  software. When this bit is set, an interrupt will be  generated if the LFSDET bit is set in the SAI_xSR  register. This bit is meaningless in AC97, SPDIF mode  or when the audio block operates as a  master.)  
 
    .equ SAI1_SAI_BSR, SAI1_BASE + 0x38 @ (Status register) 
        .equ SAI1_SAI_BSR_OVRUDR, 1 << 0   @ bitWidth 1 (Overrun / underrun. This bit is read  only. The overrun and underrun conditions can occur  only when the audio block is configured as a receiver  and a transmitter, respectively. It can generate an  interrupt if OVRUDRIE bit is set in SAI_xIM register.  This flag is cleared when the software sets COVRUDR  bit in SAI_xCLRFR register.)  
        .equ SAI1_SAI_BSR_MUTEDET, 1 << 1   @ bitWidth 1 (Mute detection. This bit is read only.  This flag is set if consecutive 0 values are received  in each slot of a given audio frame and for a  consecutive number of audio frames set in the  MUTECNT bit in the SAI_xCR2 register. It can  generate an interrupt if MUTEDETIE bit is set in  SAI_xIM register. This flag is cleared when the  software sets bit CMUTEDET in the SAI_xCLRFR  register.)  
        .equ SAI1_SAI_BSR_WCKCFG, 1 << 2   @ bitWidth 1 (Wrong clock configuration flag. This bit  is read only. This bit is used only when the audio  block operates in master mode MODE[1] = 0 and NODIV  = 0. It can generate an interrupt if WCKCFGIE bit is  set in SAI_xIM register. This flag is cleared when  the software sets CWCKCFG bit in SAI_xCLRFR  register.)  
        .equ SAI1_SAI_BSR_FREQ, 1 << 3   @ bitWidth 1 (FIFO request. This bit is read only. The  request depends on the audio block configuration: If  the block is configured in transmission mode, the  FIFO request is related to a write request operation  in the SAI_xDR. If the block configured in reception,  the FIFO request related to a read request operation  from the SAI_xDR. This flag can generate an interrupt  if FREQIE bit is set in SAI_xIM  register.)  
        .equ SAI1_SAI_BSR_CNRDY, 1 << 4   @ bitWidth 1 (Codec not ready. This bit is read only.  This bit is used only when the AC97 audio protocol is  selected in the SAI_xCR1 register and configured in  receiver mode. It can generate an interrupt if  CNRDYIE bit is set in SAI_xIM register. This flag is  cleared when the software sets CCNRDY bit in  SAI_xCLRFR register.)  
        .equ SAI1_SAI_BSR_AFSDET, 1 << 5   @ bitWidth 1 (Anticipated frame synchronization  detection. This bit is read only. This flag can be  set only if the audio block is configured in slave  mode. It is not used in AC97or SPDIF mode. It can  generate an interrupt if AFSDETIE bit is set in  SAI_xIM register. This flag is cleared when the  software sets CAFSDET bit in SAI_xCLRFR  register.)  
        .equ SAI1_SAI_BSR_LFSDET, 1 << 6   @ bitWidth 1 (Late frame synchronization detection.  This bit is read only. This flag can be set only if  the audio block is configured in slave mode. It is  not used in AC97 or SPDIF mode. It can generate an  interrupt if LFSDETIE bit is set in the SAI_xIM  register. This flag is cleared when the software sets  bit CLFSDET in SAI_xCLRFR register)  
        .equ SAI1_SAI_BSR_FLVL_Shift, 16   @ bitWidth 3 (FIFO level threshold. This bit is read  only. The FIFO level threshold flag is managed only  by hardware and its setting depends on SAI block  configuration transmitter or receiver mode. If the  SAI block is configured as transmitter: If SAI block  is configured as receiver:)  
 
    .equ SAI1_SAI_BCLRFR, SAI1_BASE + 0x3C @ (Clear flag register) 
        .equ SAI1_SAI_BCLRFR_COVRUDR, 1 << 0   @ bitWidth 1 (Clear overrun / underrun. This bit is  write only. Programming this bit to 1 clears the  OVRUDR flag in the SAI_xSR register. Reading this bit  always returns the value 0.)  
        .equ SAI1_SAI_BCLRFR_CMUTEDET, 1 << 1   @ bitWidth 1 (Mute detection flag. This bit is write  only. Programming this bit to 1 clears the MUTEDET  flag in the SAI_xSR register. Reading this bit always  returns the value 0.)  
        .equ SAI1_SAI_BCLRFR_CWCKCFG, 1 << 2   @ bitWidth 1 (Clear wrong clock configuration flag.  This bit is write only. Programming this bit to 1  clears the WCKCFG flag in the SAI_xSR register. This  bit is used only when the audio block is set as  master MODE[1] = 0 and NODIV = 0 in the SAI_xCR1  register. Reading this bit always returns the value  0.)  
        .equ SAI1_SAI_BCLRFR_CCNRDY, 1 << 4   @ bitWidth 1 (Clear Codec not ready flag. This bit is  write only. Programming this bit to 1 clears the  CNRDY flag in the SAI_xSR register. This bit is used  only when the AC97 audio protocol is selected in the  SAI_xCR1 register. Reading this bit always returns  the value 0.)  
        .equ SAI1_SAI_BCLRFR_CAFSDET, 1 << 5   @ bitWidth 1 (Clear anticipated frame synchronization  detection flag. This bit is write only. Programming  this bit to 1 clears the AFSDET flag in the SAI_xSR  register. It is not used in AC97or SPDIF mode.  Reading this bit always returns the value  0.)  
        .equ SAI1_SAI_BCLRFR_CLFSDET, 1 << 6   @ bitWidth 1 (Clear late frame synchronization  detection flag. This bit is write only. Programming  this bit to 1 clears the LFSDET flag in the SAI_xSR  register. This bit is not used in AC97or SPDIF mode  Reading this bit always returns the value  0.)  
 
    .equ SAI1_SAI_BDR, SAI1_BASE + 0x40 @ (Data register) 
        .equ SAI1_SAI_BDR_DATA_Shift, 0   @ bitWidth 32 (Data A write to this register loads the  FIFO provided the FIFO is not full. A read from this  register empties the FIFO if the FIFO is not  empty.)  
 
    .equ SAI1_SAI_PDMCR, SAI1_BASE + 0x44 @ (PDM control register) 
        .equ SAI1_SAI_PDMCR_PDMEN, 1 << 0   @ bitWidth 1 (PDM enable)  
        .equ SAI1_SAI_PDMCR_MICNBR_Shift, 4   @ bitWidth 2 (Number of microphones)  
        .equ SAI1_SAI_PDMCR_CKEN1, 1 << 8   @ bitWidth 1 (Clock enable of bitstream clock number  1)  
        .equ SAI1_SAI_PDMCR_CKEN2, 1 << 9   @ bitWidth 1 (Clock enable of bitstream clock number  2)  
        .equ SAI1_SAI_PDMCR_CKEN3, 1 << 10   @ bitWidth 1 (Clock enable of bitstream clock number  3)  
        .equ SAI1_SAI_PDMCR_CKEN4, 1 << 11   @ bitWidth 1 (Clock enable of bitstream clock number  4)  
 
    .equ SAI1_SAI_PDMDLY, SAI1_BASE + 0x48 @ (PDM delay register) 
        .equ SAI1_SAI_PDMDLY_DLYM1L_Shift, 0   @ bitWidth 3 (Delay line adjust for first microphone  of pair 1)  
        .equ SAI1_SAI_PDMDLY_DLYM1R_Shift, 4   @ bitWidth 3 (Delay line adjust for second microphone  of pair 1)  
        .equ SAI1_SAI_PDMDLY_DLYM2L_Shift, 8   @ bitWidth 3 (Delay line for first microphone of pair  2)  
        .equ SAI1_SAI_PDMDLY_DLYM2R_Shift, 12   @ bitWidth 3 (Delay line for second microphone of pair  2)  
        .equ SAI1_SAI_PDMDLY_DLYM3L_Shift, 16   @ bitWidth 3 (Delay line for first microphone of pair  3)  
        .equ SAI1_SAI_PDMDLY_DLYM3R_Shift, 20   @ bitWidth 3 (Delay line for second microphone of pair  3)  
        .equ SAI1_SAI_PDMDLY_DLYM4L_Shift, 24   @ bitWidth 3 (Delay line for first microphone of pair  4)  
        .equ SAI1_SAI_PDMDLY_DLYM4R_Shift, 28   @ bitWidth 3 (Delay line for second microphone of pair  4)  
 

@=========================== SAI2 ===========================@
.equ SAI2_BASE, 0x40015C00 @ (SAI) 
    .equ SAI2_SAI_GCR, SAI2_BASE + 0x0 @ (Global configuration register) 
        .equ SAI2_SAI_GCR_SYNCOUT_Shift, 4   @ bitWidth 2 (Synchronization outputs These bits are  set and cleared by software.)  
        .equ SAI2_SAI_GCR_SYNCIN_Shift, 0   @ bitWidth 2 (Synchronization inputs)  
 
    .equ SAI2_SAI_ACR1, SAI2_BASE + 0x4 @ (Configuration register 1) 
        .equ SAI2_SAI_ACR1_MODE_Shift, 0   @ bitWidth 2 (SAIx audio block mode  immediately)  
        .equ SAI2_SAI_ACR1_PRTCFG_Shift, 2   @ bitWidth 2 (Protocol configuration. These bits are  set and cleared by software. These bits have to be  configured when the audio block is  disabled.)  
        .equ SAI2_SAI_ACR1_DS_Shift, 5   @ bitWidth 3 (Data size. These bits are set and  cleared by software. These bits are ignored when the  SPDIF protocols are selected bit PRTCFG[1:0],  because the frame and the data size are fixed in such  case. When the companding mode is selected through  COMP[1:0] bits, DS[1:0] are ignored since the data  size is fixed to 8 bits by the algorithm. These bits  must be configured when the audio block is  disabled.)  
        .equ SAI2_SAI_ACR1_LSBFIRST, 1 << 8   @ bitWidth 1 (Least significant bit first. This bit is  set and cleared by software. It must be configured  when the audio block is disabled. This bit has no  meaning in AC97 audio protocol since AC97 data are  always transferred with the MSB first. This bit has  no meaning in SPDIF audio protocol since in SPDIF  data are always transferred with LSB  first.)  
        .equ SAI2_SAI_ACR1_CKSTR, 1 << 9   @ bitWidth 1 (Clock strobing edge. This bit is set and  cleared by software. It must be configured when the  audio block is disabled. This bit has no meaning in  SPDIF audio protocol.)  
        .equ SAI2_SAI_ACR1_SYNCEN_Shift, 10   @ bitWidth 2 (Synchronization enable. These bits are  set and cleared by software. They must be configured  when the audio sub-block is disabled. Note: The audio  sub-block should be configured as asynchronous when  SPDIF mode is enabled.)  
        .equ SAI2_SAI_ACR1_MONO, 1 << 12   @ bitWidth 1 (Mono mode. This bit is set and cleared  by software. It is meaningful only when the number of  slots is equal to 2. When the mono mode is selected,  slot 0 data are duplicated on slot 1 when the audio  block operates as a transmitter. In reception mode,  the slot1 is discarded and only the data received  from slot 0 are stored. Refer to Section: Mono/stereo  mode for more details.)  
        .equ SAI2_SAI_ACR1_OUTDRIV, 1 << 13   @ bitWidth 1 (Output drive. This bit is set and  cleared by software. Note: This bit has to be set  before enabling the audio block and after the audio  block configuration.)  
        .equ SAI2_SAI_ACR1_SAIXEN, 1 << 16   @ bitWidth 1 (Audio block enable where x is A or B.  This bit is set by software. To switch off the audio  block, the application software must program this bit  to 0 and poll the bit till it reads back 0, meaning  that the block is completely disabled. Before setting  this bit to 1, check that it is set to 0, otherwise  the enable command will not be taken into account.  This bit allows to control the state of SAIx audio  block. If it is disabled when an audio frame transfer  is ongoing, the ongoing transfer completes and the  cell is fully disabled at the end of this audio frame  transfer. Note: When SAIx block is configured in  master mode, the clock must be present on the input  of SAIx before setting SAIXEN bit.)  
        .equ SAI2_SAI_ACR1_DMAEN, 1 << 17   @ bitWidth 1 (DMA enable. This bit is set and cleared  by software. Note: Since the audio block defaults to  operate as a transmitter after reset, the MODE[1:0]  bits must be configured before setting DMAEN to avoid  a DMA request in receiver mode.)  
        .equ SAI2_SAI_ACR1_NOMCK, 1 << 19   @ bitWidth 1 (No divider)  
        .equ SAI2_SAI_ACR1_MCKDIV_Shift, 20   @ bitWidth 4 (Master clock divider. These bits are set  and cleared by software. These bits are meaningless  when the audio block operates in slave mode. They  have to be configured when the audio block is  disabled. Others: the master clock frequency is  calculated accordingly to the following  formula:)  
        .equ SAI2_SAI_ACR1_OSR, 1 << 26   @ bitWidth 1 (Oversampling ratio for master  clock)  
 
    .equ SAI2_SAI_ACR2, SAI2_BASE + 0x8 @ (Configuration register 2) 
        .equ SAI2_SAI_ACR2_FTH_Shift, 0   @ bitWidth 3 (FIFO threshold. This bit is set and  cleared by software.)  
        .equ SAI2_SAI_ACR2_FFLUSH, 1 << 3   @ bitWidth 1 (FIFO flush. This bit is set by software.  It is always read as 0. This bit should be configured  when the SAI is disabled.)  
        .equ SAI2_SAI_ACR2_TRIS, 1 << 4   @ bitWidth 1 (Tristate management on data line. This  bit is set and cleared by software. It is meaningful  only if the audio block is configured as a  transmitter. This bit is not used when the audio  block is configured in SPDIF mode. It should be  configured when SAI is disabled. Refer to Section:  Output data line management on an inactive slot for  more details.)  
        .equ SAI2_SAI_ACR2_MUTE, 1 << 5   @ bitWidth 1 (Mute. This bit is set and cleared by  software. It is meaningful only when the audio block  operates as a transmitter. The MUTE value is linked  to value of MUTEVAL if the number of slots is lower  or equal to 2, or equal to 0 if it is greater than 2.  Refer to Section: Mute mode for more details. Note:  This bit is meaningless and should not be used for  SPDIF audio blocks.)  
        .equ SAI2_SAI_ACR2_MUTEVAL, 1 << 6   @ bitWidth 1 (Mute value. This bit is set and cleared  by software.It must be written before enabling the  audio block: SAIXEN. This bit is meaningful only when  the audio block operates as a transmitter, the number  of slots is lower or equal to 2 and the MUTE bit is  set. If more slots are declared, the bit value sent  during the transmission in mute mode is equal to 0,  whatever the value of MUTEVAL. if the number of slot  is lower or equal to 2 and MUTEVAL = 1, the MUTE  value transmitted for each slot is the one sent  during the previous frame. Refer to Section: Mute  mode for more details. Note: This bit is meaningless  and should not be used for SPDIF audio  blocks.)  
        .equ SAI2_SAI_ACR2_MUTECNT_Shift, 7   @ bitWidth 6 (Mute counter. These bits are set and  cleared by software. They are used only in reception  mode. The value set in these bits is compared to the  number of consecutive mute frames detected in  reception. When the number of mute frames is equal to  this value, the flag MUTEDET will be set and an  interrupt will be generated if bit MUTEDETIE is set.  Refer to Section: Mute mode for more  details.)  
        .equ SAI2_SAI_ACR2_CPL, 1 << 13   @ bitWidth 1 (Complement bit. This bit is set and  cleared by software. It defines the type of  complement to be used for companding mode Note: This  bit has effect only when the companding mode is -Law  algorithm or A-Law algorithm.)  
        .equ SAI2_SAI_ACR2_COMP_Shift, 14   @ bitWidth 2 (Companding mode. These bits are set and  cleared by software. The -Law and the A-Law log are a  part of the CCITT G.711 recommendation, the type of  complement that will be used depends on CPL bit. The  data expansion or data compression are determined by  the state of bit MODE[0]. The data compression is  applied if the audio block is configured as a  transmitter. The data expansion is automatically  applied when the audio block is configured as a  receiver. Refer to Section: Companding mode for more  details. Note: Companding mode is applicable only  when TDM is selected.)  
 
    .equ SAI2_SAI_AFRCR, SAI2_BASE + 0xC @ (This register has no meaning in AC97 and  SPDIF audio protocol) 
        .equ SAI2_SAI_AFRCR_FRL_Shift, 0   @ bitWidth 8 (Frame length. These bits are set and  cleared by software. They define the audio frame  length expressed in number of SCK clock cycles: the  number of bits in the frame is equal to FRL[7:0] + 1.  The minimum number of bits to transfer in an audio  frame must be equal to 8, otherwise the audio block  will behaves in an unexpected way. This is the case  when the data size is 8 bits and only one slot 0 is  defined in NBSLOT[4:0] of SAI_xSLOTR register  NBSLOT[3:0] = 0000. In master mode, if the master  clock available on MCLK_x pin is used, the frame  length should be aligned with a number equal to a  power of 2, ranging from 8 to 256. When the master  clock is not used NODIV = 1, it is recommended to  program the frame length to an value ranging from 8  to 256. These bits are meaningless and are not used  in AC97 or SPDIF audio block  configuration.)  
        .equ SAI2_SAI_AFRCR_FSALL_Shift, 8   @ bitWidth 7 (Frame synchronization active level  length. These bits are set and cleared by software.  They specify the length in number of bit clock SCK  + 1 FSALL[6:0] + 1 of the active level of the FS  signal in the audio frame These bits are meaningless  and are not used in AC97 or SPDIF audio block  configuration. They must be configured when the audio  block is disabled.)  
        .equ SAI2_SAI_AFRCR_FSDEF, 1 << 16   @ bitWidth 1 (Frame synchronization definition. This  bit is set and cleared by software. When the bit is  set, the number of slots defined in the SAI_xSLOTR  register has to be even. It means that half of this  number of slots will be dedicated to the left channel  and the other slots for the right channel e.g: this  bit has to be set for I2S or MSB/LSB-justified  protocols.... This bit is meaningless and is not  used in AC97 or SPDIF audio block configuration. It  must be configured when the audio block is  disabled.)  
        .equ SAI2_SAI_AFRCR_FSPOL, 1 << 17   @ bitWidth 1 (Frame synchronization polarity. This bit  is set and cleared by software. It is used to  configure the level of the start of frame on the FS  signal. It is meaningless and is not used in AC97 or  SPDIF audio block configuration. This bit must be  configured when the audio block is  disabled.)  
        .equ SAI2_SAI_AFRCR_FSOFF, 1 << 18   @ bitWidth 1 (Frame synchronization offset. This bit  is set and cleared by software. It is meaningless and  is not used in AC97 or SPDIF audio block  configuration. This bit must be configured when the  audio block is disabled.)  
 
    .equ SAI2_SAI_ASLOTR, SAI2_BASE + 0x10 @ (This register has no meaning in AC97 and  SPDIF audio protocol) 
        .equ SAI2_SAI_ASLOTR_FBOFF_Shift, 0   @ bitWidth 5 (First bit offset These bits are set and  cleared by software. The value set in this bitfield  defines the position of the first data transfer bit  in the slot. It represents an offset value. In  transmission mode, the bits outside the data field  are forced to 0. In reception mode, the extra  received bits are discarded. These bits must be set  when the audio block is disabled. They are ignored in  AC97 or SPDIF mode.)  
        .equ SAI2_SAI_ASLOTR_SLOTSZ_Shift, 6   @ bitWidth 2 (Slot size This bits is set and cleared  by software. The slot size must be higher or equal to  the data size. If this condition is not respected,  the behavior of the SAI will be undetermined. Refer  to Section: Output data line management on an  inactive slot for information on how to drive SD  line. These bits must be set when the audio block is  disabled. They are ignored in AC97 or SPDIF  mode.)  
        .equ SAI2_SAI_ASLOTR_NBSLOT_Shift, 8   @ bitWidth 4 (Number of slots in an audio frame. These  bits are set and cleared by software. The value set  in this bitfield represents the number of slots + 1  in the audio frame including the number of inactive  slots. The maximum number of slots is 16. The number  of slots should be even if FSDEF bit in the SAI_xFRCR  register is set. The number of slots must be  configured when the audio block is disabled. They are  ignored in AC97 or SPDIF mode.)  
        .equ SAI2_SAI_ASLOTR_SLOTEN_Shift, 16   @ bitWidth 16 (Slot enable. These bits are set and  cleared by software. Each SLOTEN bit corresponds to a  slot position from 0 to 15 maximum 16 slots. The  slot must be enabled when the audio block is  disabled. They are ignored in AC97 or SPDIF  mode.)  
 
    .equ SAI2_SAI_AIM, SAI2_BASE + 0x14 @ (Interrupt mask register 2) 
        .equ SAI2_SAI_AIM_OVRUDRIE, 1 << 0   @ bitWidth 1 (Overrun/underrun interrupt enable. This  bit is set and cleared by software. When this bit is  set, an interrupt is generated if the OVRUDR bit in  the SAI_xSR register is set.)  
        .equ SAI2_SAI_AIM_MUTEDETIE, 1 << 1   @ bitWidth 1 (Mute detection interrupt enable. This  bit is set and cleared by software. When this bit is  set, an interrupt is generated if the MUTEDET bit in  the SAI_xSR register is set. This bit has a meaning  only if the audio block is configured in receiver  mode.)  
        .equ SAI2_SAI_AIM_WCKCFGIE, 1 << 2   @ bitWidth 1 (Wrong clock configuration interrupt  enable. This bit is set and cleared by software. This  bit is taken into account only if the audio block is  configured as a master MODE[1] = 0 and NODIV = 0.  It generates an interrupt if the WCKCFG flag in the  SAI_xSR register is set. Note: This bit is used only  in TDM mode and is meaningless in other  modes.)  
        .equ SAI2_SAI_AIM_FREQIE, 1 << 3   @ bitWidth 1 (FIFO request interrupt enable. This bit  is set and cleared by software. When this bit is set,  an interrupt is generated if the FREQ bit in the  SAI_xSR register is set. Since the audio block  defaults to operate as a transmitter after reset, the  MODE bit must be configured before setting FREQIE to  avoid a parasitic interruption in receiver  mode,)  
        .equ SAI2_SAI_AIM_CNRDYIE, 1 << 4   @ bitWidth 1 (Codec not ready interrupt enable AC97.  This bit is set and cleared by software. When the  interrupt is enabled, the audio block detects in the  slot 0 tag0 of the AC97 frame if the Codec  connected to this line is ready or not. If it is not  ready, the CNRDY flag in the SAI_xSR register is set  and an interruption i generated. This bit has a  meaning only if the AC97 mode is selected through  PRTCFG[1:0] bits and the audio block is operates as a  receiver.)  
        .equ SAI2_SAI_AIM_AFSDETIE, 1 << 5   @ bitWidth 1 (Anticipated frame synchronization  detection interrupt enable. This bit is set and  cleared by software. When this bit is set, an  interrupt will be generated if the AFSDET bit in the  SAI_xSR register is set. This bit is meaningless in  AC97, SPDIF mode or when the audio block operates as  a master.)  
        .equ SAI2_SAI_AIM_LFSDETIE, 1 << 6   @ bitWidth 1 (Late frame synchronization detection  interrupt enable. This bit is set and cleared by  software. When this bit is set, an interrupt will be  generated if the LFSDET bit is set in the SAI_xSR  register. This bit is meaningless in AC97, SPDIF mode  or when the audio block operates as a  master.)  
 
    .equ SAI2_SAI_ASR, SAI2_BASE + 0x18 @ (Status register) 
        .equ SAI2_SAI_ASR_OVRUDR, 1 << 0   @ bitWidth 1 (Overrun / underrun. This bit is read  only. The overrun and underrun conditions can occur  only when the audio block is configured as a receiver  and a transmitter, respectively. It can generate an  interrupt if OVRUDRIE bit is set in SAI_xIM register.  This flag is cleared when the software sets COVRUDR  bit in SAI_xCLRFR register.)  
        .equ SAI2_SAI_ASR_MUTEDET, 1 << 1   @ bitWidth 1 (Mute detection. This bit is read only.  This flag is set if consecutive 0 values are received  in each slot of a given audio frame and for a  consecutive number of audio frames set in the  MUTECNT bit in the SAI_xCR2 register. It can  generate an interrupt if MUTEDETIE bit is set in  SAI_xIM register. This flag is cleared when the  software sets bit CMUTEDET in the SAI_xCLRFR  register.)  
        .equ SAI2_SAI_ASR_WCKCFG, 1 << 2   @ bitWidth 1 (Wrong clock configuration flag. This bit  is read only. This bit is used only when the audio  block operates in master mode MODE[1] = 0 and NODIV  = 0. It can generate an interrupt if WCKCFGIE bit is  set in SAI_xIM register. This flag is cleared when  the software sets CWCKCFG bit in SAI_xCLRFR  register.)  
        .equ SAI2_SAI_ASR_FREQ, 1 << 3   @ bitWidth 1 (FIFO request. This bit is read only. The  request depends on the audio block configuration: If  the block is configured in transmission mode, the  FIFO request is related to a write request operation  in the SAI_xDR. If the block configured in reception,  the FIFO request related to a read request operation  from the SAI_xDR. This flag can generate an interrupt  if FREQIE bit is set in SAI_xIM  register.)  
        .equ SAI2_SAI_ASR_CNRDY, 1 << 4   @ bitWidth 1 (Codec not ready. This bit is read only.  This bit is used only when the AC97 audio protocol is  selected in the SAI_xCR1 register and configured in  receiver mode. It can generate an interrupt if  CNRDYIE bit is set in SAI_xIM register. This flag is  cleared when the software sets CCNRDY bit in  SAI_xCLRFR register.)  
        .equ SAI2_SAI_ASR_AFSDET, 1 << 5   @ bitWidth 1 (Anticipated frame synchronization  detection. This bit is read only. This flag can be  set only if the audio block is configured in slave  mode. It is not used in AC97or SPDIF mode. It can  generate an interrupt if AFSDETIE bit is set in  SAI_xIM register. This flag is cleared when the  software sets CAFSDET bit in SAI_xCLRFR  register.)  
        .equ SAI2_SAI_ASR_LFSDET, 1 << 6   @ bitWidth 1 (Late frame synchronization detection.  This bit is read only. This flag can be set only if  the audio block is configured in slave mode. It is  not used in AC97 or SPDIF mode. It can generate an  interrupt if LFSDETIE bit is set in the SAI_xIM  register. This flag is cleared when the software sets  bit CLFSDET in SAI_xCLRFR register)  
        .equ SAI2_SAI_ASR_FLVL_Shift, 16   @ bitWidth 3 (FIFO level threshold. This bit is read  only. The FIFO level threshold flag is managed only  by hardware and its setting depends on SAI block  configuration transmitter or receiver mode. If the  SAI block is configured as transmitter: If SAI block  is configured as receiver:)  
 
    .equ SAI2_SAI_ACLRFR, SAI2_BASE + 0x1C @ (Clear flag register) 
        .equ SAI2_SAI_ACLRFR_COVRUDR, 1 << 0   @ bitWidth 1 (Clear overrun / underrun. This bit is  write only. Programming this bit to 1 clears the  OVRUDR flag in the SAI_xSR register. Reading this bit  always returns the value 0.)  
        .equ SAI2_SAI_ACLRFR_CMUTEDET, 1 << 1   @ bitWidth 1 (Mute detection flag. This bit is write  only. Programming this bit to 1 clears the MUTEDET  flag in the SAI_xSR register. Reading this bit always  returns the value 0.)  
        .equ SAI2_SAI_ACLRFR_CWCKCFG, 1 << 2   @ bitWidth 1 (Clear wrong clock configuration flag.  This bit is write only. Programming this bit to 1  clears the WCKCFG flag in the SAI_xSR register. This  bit is used only when the audio block is set as  master MODE[1] = 0 and NODIV = 0 in the SAI_xCR1  register. Reading this bit always returns the value  0.)  
        .equ SAI2_SAI_ACLRFR_CCNRDY, 1 << 4   @ bitWidth 1 (Clear Codec not ready flag. This bit is  write only. Programming this bit to 1 clears the  CNRDY flag in the SAI_xSR register. This bit is used  only when the AC97 audio protocol is selected in the  SAI_xCR1 register. Reading this bit always returns  the value 0.)  
        .equ SAI2_SAI_ACLRFR_CAFSDET, 1 << 5   @ bitWidth 1 (Clear anticipated frame synchronization  detection flag. This bit is write only. Programming  this bit to 1 clears the AFSDET flag in the SAI_xSR  register. It is not used in AC97or SPDIF mode.  Reading this bit always returns the value  0.)  
        .equ SAI2_SAI_ACLRFR_CLFSDET, 1 << 6   @ bitWidth 1 (Clear late frame synchronization  detection flag. This bit is write only. Programming  this bit to 1 clears the LFSDET flag in the SAI_xSR  register. This bit is not used in AC97or SPDIF mode  Reading this bit always returns the value  0.)  
 
    .equ SAI2_SAI_ADR, SAI2_BASE + 0x20 @ (Data register) 
        .equ SAI2_SAI_ADR_DATA_Shift, 0   @ bitWidth 32 (Data A write to this register loads the  FIFO provided the FIFO is not full. A read from this  register empties the FIFO if the FIFO is not  empty.)  
 
    .equ SAI2_SAI_BCR1, SAI2_BASE + 0x24 @ (Configuration register 1) 
        .equ SAI2_SAI_BCR1_MODE_Shift, 0   @ bitWidth 2 (SAIx audio block mode  immediately)  
        .equ SAI2_SAI_BCR1_PRTCFG_Shift, 2   @ bitWidth 2 (Protocol configuration. These bits are  set and cleared by software. These bits have to be  configured when the audio block is  disabled.)  
        .equ SAI2_SAI_BCR1_DS_Shift, 5   @ bitWidth 3 (Data size. These bits are set and  cleared by software. These bits are ignored when the  SPDIF protocols are selected bit PRTCFG[1:0],  because the frame and the data size are fixed in such  case. When the companding mode is selected through  COMP[1:0] bits, DS[1:0] are ignored since the data  size is fixed to 8 bits by the algorithm. These bits  must be configured when the audio block is  disabled.)  
        .equ SAI2_SAI_BCR1_LSBFIRST, 1 << 8   @ bitWidth 1 (Least significant bit first. This bit is  set and cleared by software. It must be configured  when the audio block is disabled. This bit has no  meaning in AC97 audio protocol since AC97 data are  always transferred with the MSB first. This bit has  no meaning in SPDIF audio protocol since in SPDIF  data are always transferred with LSB  first.)  
        .equ SAI2_SAI_BCR1_CKSTR, 1 << 9   @ bitWidth 1 (Clock strobing edge. This bit is set and  cleared by software. It must be configured when the  audio block is disabled. This bit has no meaning in  SPDIF audio protocol.)  
        .equ SAI2_SAI_BCR1_SYNCEN_Shift, 10   @ bitWidth 2 (Synchronization enable. These bits are  set and cleared by software. They must be configured  when the audio sub-block is disabled. Note: The audio  sub-block should be configured as asynchronous when  SPDIF mode is enabled.)  
        .equ SAI2_SAI_BCR1_MONO, 1 << 12   @ bitWidth 1 (Mono mode. This bit is set and cleared  by software. It is meaningful only when the number of  slots is equal to 2. When the mono mode is selected,  slot 0 data are duplicated on slot 1 when the audio  block operates as a transmitter. In reception mode,  the slot1 is discarded and only the data received  from slot 0 are stored. Refer to Section: Mono/stereo  mode for more details.)  
        .equ SAI2_SAI_BCR1_OUTDRIV, 1 << 13   @ bitWidth 1 (Output drive. This bit is set and  cleared by software. Note: This bit has to be set  before enabling the audio block and after the audio  block configuration.)  
        .equ SAI2_SAI_BCR1_SAIXEN, 1 << 16   @ bitWidth 1 (Audio block enable where x is A or B.  This bit is set by software. To switch off the audio  block, the application software must program this bit  to 0 and poll the bit till it reads back 0, meaning  that the block is completely disabled. Before setting  this bit to 1, check that it is set to 0, otherwise  the enable command will not be taken into account.  This bit allows to control the state of SAIx audio  block. If it is disabled when an audio frame transfer  is ongoing, the ongoing transfer completes and the  cell is fully disabled at the end of this audio frame  transfer. Note: When SAIx block is configured in  master mode, the clock must be present on the input  of SAIx before setting SAIXEN bit.)  
        .equ SAI2_SAI_BCR1_DMAEN, 1 << 17   @ bitWidth 1 (DMA enable. This bit is set and cleared  by software. Note: Since the audio block defaults to  operate as a transmitter after reset, the MODE[1:0]  bits must be configured before setting DMAEN to avoid  a DMA request in receiver mode.)  
        .equ SAI2_SAI_BCR1_NOMCK, 1 << 19   @ bitWidth 1 (No divider)  
        .equ SAI2_SAI_BCR1_MCKDIV_Shift, 20   @ bitWidth 4 (Master clock divider. These bits are set  and cleared by software. These bits are meaningless  when the audio block operates in slave mode. They  have to be configured when the audio block is  disabled. Others: the master clock frequency is  calculated accordingly to the following  formula:)  
        .equ SAI2_SAI_BCR1_OSR, 1 << 26   @ bitWidth 1 (Oversampling ratio for master  clock)  
 
    .equ SAI2_SAI_BCR2, SAI2_BASE + 0x28 @ (Configuration register 2) 
        .equ SAI2_SAI_BCR2_FTH_Shift, 0   @ bitWidth 3 (FIFO threshold. This bit is set and  cleared by software.)  
        .equ SAI2_SAI_BCR2_FFLUSH, 1 << 3   @ bitWidth 1 (FIFO flush. This bit is set by software.  It is always read as 0. This bit should be configured  when the SAI is disabled.)  
        .equ SAI2_SAI_BCR2_TRIS, 1 << 4   @ bitWidth 1 (Tristate management on data line. This  bit is set and cleared by software. It is meaningful  only if the audio block is configured as a  transmitter. This bit is not used when the audio  block is configured in SPDIF mode. It should be  configured when SAI is disabled. Refer to Section:  Output data line management on an inactive slot for  more details.)  
        .equ SAI2_SAI_BCR2_MUTE, 1 << 5   @ bitWidth 1 (Mute. This bit is set and cleared by  software. It is meaningful only when the audio block  operates as a transmitter. The MUTE value is linked  to value of MUTEVAL if the number of slots is lower  or equal to 2, or equal to 0 if it is greater than 2.  Refer to Section: Mute mode for more details. Note:  This bit is meaningless and should not be used for  SPDIF audio blocks.)  
        .equ SAI2_SAI_BCR2_MUTEVAL, 1 << 6   @ bitWidth 1 (Mute value. This bit is set and cleared  by software.It must be written before enabling the  audio block: SAIXEN. This bit is meaningful only when  the audio block operates as a transmitter, the number  of slots is lower or equal to 2 and the MUTE bit is  set. If more slots are declared, the bit value sent  during the transmission in mute mode is equal to 0,  whatever the value of MUTEVAL. if the number of slot  is lower or equal to 2 and MUTEVAL = 1, the MUTE  value transmitted for each slot is the one sent  during the previous frame. Refer to Section: Mute  mode for more details. Note: This bit is meaningless  and should not be used for SPDIF audio  blocks.)  
        .equ SAI2_SAI_BCR2_MUTECNT_Shift, 7   @ bitWidth 6 (Mute counter. These bits are set and  cleared by software. They are used only in reception  mode. The value set in these bits is compared to the  number of consecutive mute frames detected in  reception. When the number of mute frames is equal to  this value, the flag MUTEDET will be set and an  interrupt will be generated if bit MUTEDETIE is set.  Refer to Section: Mute mode for more  details.)  
        .equ SAI2_SAI_BCR2_CPL, 1 << 13   @ bitWidth 1 (Complement bit. This bit is set and  cleared by software. It defines the type of  complement to be used for companding mode Note: This  bit has effect only when the companding mode is -Law  algorithm or A-Law algorithm.)  
        .equ SAI2_SAI_BCR2_COMP_Shift, 14   @ bitWidth 2 (Companding mode. These bits are set and  cleared by software. The -Law and the A-Law log are a  part of the CCITT G.711 recommendation, the type of  complement that will be used depends on CPL bit. The  data expansion or data compression are determined by  the state of bit MODE[0]. The data compression is  applied if the audio block is configured as a  transmitter. The data expansion is automatically  applied when the audio block is configured as a  receiver. Refer to Section: Companding mode for more  details. Note: Companding mode is applicable only  when TDM is selected.)  
 
    .equ SAI2_SAI_BFRCR, SAI2_BASE + 0x2C @ (This register has no meaning in AC97 and  SPDIF audio protocol) 
        .equ SAI2_SAI_BFRCR_FRL_Shift, 0   @ bitWidth 8 (Frame length. These bits are set and  cleared by software. They define the audio frame  length expressed in number of SCK clock cycles: the  number of bits in the frame is equal to FRL[7:0] + 1.  The minimum number of bits to transfer in an audio  frame must be equal to 8, otherwise the audio block  will behaves in an unexpected way. This is the case  when the data size is 8 bits and only one slot 0 is  defined in NBSLOT[4:0] of SAI_xSLOTR register  NBSLOT[3:0] = 0000. In master mode, if the master  clock available on MCLK_x pin is used, the frame  length should be aligned with a number equal to a  power of 2, ranging from 8 to 256. When the master  clock is not used NODIV = 1, it is recommended to  program the frame length to an value ranging from 8  to 256. These bits are meaningless and are not used  in AC97 or SPDIF audio block  configuration.)  
        .equ SAI2_SAI_BFRCR_FSALL_Shift, 8   @ bitWidth 7 (Frame synchronization active level  length. These bits are set and cleared by software.  They specify the length in number of bit clock SCK  + 1 FSALL[6:0] + 1 of the active level of the FS  signal in the audio frame These bits are meaningless  and are not used in AC97 or SPDIF audio block  configuration. They must be configured when the audio  block is disabled.)  
        .equ SAI2_SAI_BFRCR_FSDEF, 1 << 16   @ bitWidth 1 (Frame synchronization definition. This  bit is set and cleared by software. When the bit is  set, the number of slots defined in the SAI_xSLOTR  register has to be even. It means that half of this  number of slots will be dedicated to the left channel  and the other slots for the right channel e.g: this  bit has to be set for I2S or MSB/LSB-justified  protocols.... This bit is meaningless and is not  used in AC97 or SPDIF audio block configuration. It  must be configured when the audio block is  disabled.)  
        .equ SAI2_SAI_BFRCR_FSPOL, 1 << 17   @ bitWidth 1 (Frame synchronization polarity. This bit  is set and cleared by software. It is used to  configure the level of the start of frame on the FS  signal. It is meaningless and is not used in AC97 or  SPDIF audio block configuration. This bit must be  configured when the audio block is  disabled.)  
        .equ SAI2_SAI_BFRCR_FSOFF, 1 << 18   @ bitWidth 1 (Frame synchronization offset. This bit  is set and cleared by software. It is meaningless and  is not used in AC97 or SPDIF audio block  configuration. This bit must be configured when the  audio block is disabled.)  
 
    .equ SAI2_SAI_BSLOTR, SAI2_BASE + 0x30 @ (This register has no meaning in AC97 and  SPDIF audio protocol) 
        .equ SAI2_SAI_BSLOTR_FBOFF_Shift, 0   @ bitWidth 5 (First bit offset These bits are set and  cleared by software. The value set in this bitfield  defines the position of the first data transfer bit  in the slot. It represents an offset value. In  transmission mode, the bits outside the data field  are forced to 0. In reception mode, the extra  received bits are discarded. These bits must be set  when the audio block is disabled. They are ignored in  AC97 or SPDIF mode.)  
        .equ SAI2_SAI_BSLOTR_SLOTSZ_Shift, 6   @ bitWidth 2 (Slot size This bits is set and cleared  by software. The slot size must be higher or equal to  the data size. If this condition is not respected,  the behavior of the SAI will be undetermined. Refer  to Section: Output data line management on an  inactive slot for information on how to drive SD  line. These bits must be set when the audio block is  disabled. They are ignored in AC97 or SPDIF  mode.)  
        .equ SAI2_SAI_BSLOTR_NBSLOT_Shift, 8   @ bitWidth 4 (Number of slots in an audio frame. These  bits are set and cleared by software. The value set  in this bitfield represents the number of slots + 1  in the audio frame including the number of inactive  slots. The maximum number of slots is 16. The number  of slots should be even if FSDEF bit in the SAI_xFRCR  register is set. The number of slots must be  configured when the audio block is disabled. They are  ignored in AC97 or SPDIF mode.)  
        .equ SAI2_SAI_BSLOTR_SLOTEN_Shift, 16   @ bitWidth 16 (Slot enable. These bits are set and  cleared by software. Each SLOTEN bit corresponds to a  slot position from 0 to 15 maximum 16 slots. The  slot must be enabled when the audio block is  disabled. They are ignored in AC97 or SPDIF  mode.)  
 
    .equ SAI2_SAI_BIM, SAI2_BASE + 0x34 @ (Interrupt mask register 2) 
        .equ SAI2_SAI_BIM_OVRUDRIE, 1 << 0   @ bitWidth 1 (Overrun/underrun interrupt enable. This  bit is set and cleared by software. When this bit is  set, an interrupt is generated if the OVRUDR bit in  the SAI_xSR register is set.)  
        .equ SAI2_SAI_BIM_MUTEDETIE, 1 << 1   @ bitWidth 1 (Mute detection interrupt enable. This  bit is set and cleared by software. When this bit is  set, an interrupt is generated if the MUTEDET bit in  the SAI_xSR register is set. This bit has a meaning  only if the audio block is configured in receiver  mode.)  
        .equ SAI2_SAI_BIM_WCKCFGIE, 1 << 2   @ bitWidth 1 (Wrong clock configuration interrupt  enable. This bit is set and cleared by software. This  bit is taken into account only if the audio block is  configured as a master MODE[1] = 0 and NODIV = 0.  It generates an interrupt if the WCKCFG flag in the  SAI_xSR register is set. Note: This bit is used only  in TDM mode and is meaningless in other  modes.)  
        .equ SAI2_SAI_BIM_FREQIE, 1 << 3   @ bitWidth 1 (FIFO request interrupt enable. This bit  is set and cleared by software. When this bit is set,  an interrupt is generated if the FREQ bit in the  SAI_xSR register is set. Since the audio block  defaults to operate as a transmitter after reset, the  MODE bit must be configured before setting FREQIE to  avoid a parasitic interruption in receiver  mode,)  
        .equ SAI2_SAI_BIM_CNRDYIE, 1 << 4   @ bitWidth 1 (Codec not ready interrupt enable AC97.  This bit is set and cleared by software. When the  interrupt is enabled, the audio block detects in the  slot 0 tag0 of the AC97 frame if the Codec  connected to this line is ready or not. If it is not  ready, the CNRDY flag in the SAI_xSR register is set  and an interruption i generated. This bit has a  meaning only if the AC97 mode is selected through  PRTCFG[1:0] bits and the audio block is operates as a  receiver.)  
        .equ SAI2_SAI_BIM_AFSDETIE, 1 << 5   @ bitWidth 1 (Anticipated frame synchronization  detection interrupt enable. This bit is set and  cleared by software. When this bit is set, an  interrupt will be generated if the AFSDET bit in the  SAI_xSR register is set. This bit is meaningless in  AC97, SPDIF mode or when the audio block operates as  a master.)  
        .equ SAI2_SAI_BIM_LFSDETIE, 1 << 6   @ bitWidth 1 (Late frame synchronization detection  interrupt enable. This bit is set and cleared by  software. When this bit is set, an interrupt will be  generated if the LFSDET bit is set in the SAI_xSR  register. This bit is meaningless in AC97, SPDIF mode  or when the audio block operates as a  master.)  
 
    .equ SAI2_SAI_BSR, SAI2_BASE + 0x38 @ (Status register) 
        .equ SAI2_SAI_BSR_OVRUDR, 1 << 0   @ bitWidth 1 (Overrun / underrun. This bit is read  only. The overrun and underrun conditions can occur  only when the audio block is configured as a receiver  and a transmitter, respectively. It can generate an  interrupt if OVRUDRIE bit is set in SAI_xIM register.  This flag is cleared when the software sets COVRUDR  bit in SAI_xCLRFR register.)  
        .equ SAI2_SAI_BSR_MUTEDET, 1 << 1   @ bitWidth 1 (Mute detection. This bit is read only.  This flag is set if consecutive 0 values are received  in each slot of a given audio frame and for a  consecutive number of audio frames set in the  MUTECNT bit in the SAI_xCR2 register. It can  generate an interrupt if MUTEDETIE bit is set in  SAI_xIM register. This flag is cleared when the  software sets bit CMUTEDET in the SAI_xCLRFR  register.)  
        .equ SAI2_SAI_BSR_WCKCFG, 1 << 2   @ bitWidth 1 (Wrong clock configuration flag. This bit  is read only. This bit is used only when the audio  block operates in master mode MODE[1] = 0 and NODIV  = 0. It can generate an interrupt if WCKCFGIE bit is  set in SAI_xIM register. This flag is cleared when  the software sets CWCKCFG bit in SAI_xCLRFR  register.)  
        .equ SAI2_SAI_BSR_FREQ, 1 << 3   @ bitWidth 1 (FIFO request. This bit is read only. The  request depends on the audio block configuration: If  the block is configured in transmission mode, the  FIFO request is related to a write request operation  in the SAI_xDR. If the block configured in reception,  the FIFO request related to a read request operation  from the SAI_xDR. This flag can generate an interrupt  if FREQIE bit is set in SAI_xIM  register.)  
        .equ SAI2_SAI_BSR_CNRDY, 1 << 4   @ bitWidth 1 (Codec not ready. This bit is read only.  This bit is used only when the AC97 audio protocol is  selected in the SAI_xCR1 register and configured in  receiver mode. It can generate an interrupt if  CNRDYIE bit is set in SAI_xIM register. This flag is  cleared when the software sets CCNRDY bit in  SAI_xCLRFR register.)  
        .equ SAI2_SAI_BSR_AFSDET, 1 << 5   @ bitWidth 1 (Anticipated frame synchronization  detection. This bit is read only. This flag can be  set only if the audio block is configured in slave  mode. It is not used in AC97or SPDIF mode. It can  generate an interrupt if AFSDETIE bit is set in  SAI_xIM register. This flag is cleared when the  software sets CAFSDET bit in SAI_xCLRFR  register.)  
        .equ SAI2_SAI_BSR_LFSDET, 1 << 6   @ bitWidth 1 (Late frame synchronization detection.  This bit is read only. This flag can be set only if  the audio block is configured in slave mode. It is  not used in AC97 or SPDIF mode. It can generate an  interrupt if LFSDETIE bit is set in the SAI_xIM  register. This flag is cleared when the software sets  bit CLFSDET in SAI_xCLRFR register)  
        .equ SAI2_SAI_BSR_FLVL_Shift, 16   @ bitWidth 3 (FIFO level threshold. This bit is read  only. The FIFO level threshold flag is managed only  by hardware and its setting depends on SAI block  configuration transmitter or receiver mode. If the  SAI block is configured as transmitter: If SAI block  is configured as receiver:)  
 
    .equ SAI2_SAI_BCLRFR, SAI2_BASE + 0x3C @ (Clear flag register) 
        .equ SAI2_SAI_BCLRFR_COVRUDR, 1 << 0   @ bitWidth 1 (Clear overrun / underrun. This bit is  write only. Programming this bit to 1 clears the  OVRUDR flag in the SAI_xSR register. Reading this bit  always returns the value 0.)  
        .equ SAI2_SAI_BCLRFR_CMUTEDET, 1 << 1   @ bitWidth 1 (Mute detection flag. This bit is write  only. Programming this bit to 1 clears the MUTEDET  flag in the SAI_xSR register. Reading this bit always  returns the value 0.)  
        .equ SAI2_SAI_BCLRFR_CWCKCFG, 1 << 2   @ bitWidth 1 (Clear wrong clock configuration flag.  This bit is write only. Programming this bit to 1  clears the WCKCFG flag in the SAI_xSR register. This  bit is used only when the audio block is set as  master MODE[1] = 0 and NODIV = 0 in the SAI_xCR1  register. Reading this bit always returns the value  0.)  
        .equ SAI2_SAI_BCLRFR_CCNRDY, 1 << 4   @ bitWidth 1 (Clear Codec not ready flag. This bit is  write only. Programming this bit to 1 clears the  CNRDY flag in the SAI_xSR register. This bit is used  only when the AC97 audio protocol is selected in the  SAI_xCR1 register. Reading this bit always returns  the value 0.)  
        .equ SAI2_SAI_BCLRFR_CAFSDET, 1 << 5   @ bitWidth 1 (Clear anticipated frame synchronization  detection flag. This bit is write only. Programming  this bit to 1 clears the AFSDET flag in the SAI_xSR  register. It is not used in AC97or SPDIF mode.  Reading this bit always returns the value  0.)  
        .equ SAI2_SAI_BCLRFR_CLFSDET, 1 << 6   @ bitWidth 1 (Clear late frame synchronization  detection flag. This bit is write only. Programming  this bit to 1 clears the LFSDET flag in the SAI_xSR  register. This bit is not used in AC97or SPDIF mode  Reading this bit always returns the value  0.)  
 
    .equ SAI2_SAI_BDR, SAI2_BASE + 0x40 @ (Data register) 
        .equ SAI2_SAI_BDR_DATA_Shift, 0   @ bitWidth 32 (Data A write to this register loads the  FIFO provided the FIFO is not full. A read from this  register empties the FIFO if the FIFO is not  empty.)  
 
    .equ SAI2_SAI_PDMCR, SAI2_BASE + 0x44 @ (PDM control register) 
        .equ SAI2_SAI_PDMCR_PDMEN, 1 << 0   @ bitWidth 1 (PDM enable)  
        .equ SAI2_SAI_PDMCR_MICNBR_Shift, 4   @ bitWidth 2 (Number of microphones)  
        .equ SAI2_SAI_PDMCR_CKEN1, 1 << 8   @ bitWidth 1 (Clock enable of bitstream clock number  1)  
        .equ SAI2_SAI_PDMCR_CKEN2, 1 << 9   @ bitWidth 1 (Clock enable of bitstream clock number  2)  
        .equ SAI2_SAI_PDMCR_CKEN3, 1 << 10   @ bitWidth 1 (Clock enable of bitstream clock number  3)  
        .equ SAI2_SAI_PDMCR_CKEN4, 1 << 11   @ bitWidth 1 (Clock enable of bitstream clock number  4)  
 
    .equ SAI2_SAI_PDMDLY, SAI2_BASE + 0x48 @ (PDM delay register) 
        .equ SAI2_SAI_PDMDLY_DLYM1L_Shift, 0   @ bitWidth 3 (Delay line adjust for first microphone  of pair 1)  
        .equ SAI2_SAI_PDMDLY_DLYM1R_Shift, 4   @ bitWidth 3 (Delay line adjust for second microphone  of pair 1)  
        .equ SAI2_SAI_PDMDLY_DLYM2L_Shift, 8   @ bitWidth 3 (Delay line for first microphone of pair  2)  
        .equ SAI2_SAI_PDMDLY_DLYM2R_Shift, 12   @ bitWidth 3 (Delay line for second microphone of pair  2)  
        .equ SAI2_SAI_PDMDLY_DLYM3L_Shift, 16   @ bitWidth 3 (Delay line for first microphone of pair  3)  
        .equ SAI2_SAI_PDMDLY_DLYM3R_Shift, 20   @ bitWidth 3 (Delay line for second microphone of pair  3)  
        .equ SAI2_SAI_PDMDLY_DLYM4L_Shift, 24   @ bitWidth 3 (Delay line for first microphone of pair  4)  
        .equ SAI2_SAI_PDMDLY_DLYM4R_Shift, 28   @ bitWidth 3 (Delay line for second microphone of pair  4)  
 

@=========================== SAI3 ===========================@
.equ SAI3_BASE, 0x40016000 @ (SAI) 
    .equ SAI3_SAI_GCR, SAI3_BASE + 0x0 @ (Global configuration register) 
        .equ SAI3_SAI_GCR_SYNCOUT_Shift, 4   @ bitWidth 2 (Synchronization outputs These bits are  set and cleared by software.)  
        .equ SAI3_SAI_GCR_SYNCIN_Shift, 0   @ bitWidth 2 (Synchronization inputs)  
 
    .equ SAI3_SAI_ACR1, SAI3_BASE + 0x4 @ (Configuration register 1) 
        .equ SAI3_SAI_ACR1_MODE_Shift, 0   @ bitWidth 2 (SAIx audio block mode  immediately)  
        .equ SAI3_SAI_ACR1_PRTCFG_Shift, 2   @ bitWidth 2 (Protocol configuration. These bits are  set and cleared by software. These bits have to be  configured when the audio block is  disabled.)  
        .equ SAI3_SAI_ACR1_DS_Shift, 5   @ bitWidth 3 (Data size. These bits are set and  cleared by software. These bits are ignored when the  SPDIF protocols are selected bit PRTCFG[1:0],  because the frame and the data size are fixed in such  case. When the companding mode is selected through  COMP[1:0] bits, DS[1:0] are ignored since the data  size is fixed to 8 bits by the algorithm. These bits  must be configured when the audio block is  disabled.)  
        .equ SAI3_SAI_ACR1_LSBFIRST, 1 << 8   @ bitWidth 1 (Least significant bit first. This bit is  set and cleared by software. It must be configured  when the audio block is disabled. This bit has no  meaning in AC97 audio protocol since AC97 data are  always transferred with the MSB first. This bit has  no meaning in SPDIF audio protocol since in SPDIF  data are always transferred with LSB  first.)  
        .equ SAI3_SAI_ACR1_CKSTR, 1 << 9   @ bitWidth 1 (Clock strobing edge. This bit is set and  cleared by software. It must be configured when the  audio block is disabled. This bit has no meaning in  SPDIF audio protocol.)  
        .equ SAI3_SAI_ACR1_SYNCEN_Shift, 10   @ bitWidth 2 (Synchronization enable. These bits are  set and cleared by software. They must be configured  when the audio sub-block is disabled. Note: The audio  sub-block should be configured as asynchronous when  SPDIF mode is enabled.)  
        .equ SAI3_SAI_ACR1_MONO, 1 << 12   @ bitWidth 1 (Mono mode. This bit is set and cleared  by software. It is meaningful only when the number of  slots is equal to 2. When the mono mode is selected,  slot 0 data are duplicated on slot 1 when the audio  block operates as a transmitter. In reception mode,  the slot1 is discarded and only the data received  from slot 0 are stored. Refer to Section: Mono/stereo  mode for more details.)  
        .equ SAI3_SAI_ACR1_OUTDRIV, 1 << 13   @ bitWidth 1 (Output drive. This bit is set and  cleared by software. Note: This bit has to be set  before enabling the audio block and after the audio  block configuration.)  
        .equ SAI3_SAI_ACR1_SAIXEN, 1 << 16   @ bitWidth 1 (Audio block enable where x is A or B.  This bit is set by software. To switch off the audio  block, the application software must program this bit  to 0 and poll the bit till it reads back 0, meaning  that the block is completely disabled. Before setting  this bit to 1, check that it is set to 0, otherwise  the enable command will not be taken into account.  This bit allows to control the state of SAIx audio  block. If it is disabled when an audio frame transfer  is ongoing, the ongoing transfer completes and the  cell is fully disabled at the end of this audio frame  transfer. Note: When SAIx block is configured in  master mode, the clock must be present on the input  of SAIx before setting SAIXEN bit.)  
        .equ SAI3_SAI_ACR1_DMAEN, 1 << 17   @ bitWidth 1 (DMA enable. This bit is set and cleared  by software. Note: Since the audio block defaults to  operate as a transmitter after reset, the MODE[1:0]  bits must be configured before setting DMAEN to avoid  a DMA request in receiver mode.)  
        .equ SAI3_SAI_ACR1_NOMCK, 1 << 19   @ bitWidth 1 (No divider)  
        .equ SAI3_SAI_ACR1_MCKDIV_Shift, 20   @ bitWidth 4 (Master clock divider. These bits are set  and cleared by software. These bits are meaningless  when the audio block operates in slave mode. They  have to be configured when the audio block is  disabled. Others: the master clock frequency is  calculated accordingly to the following  formula:)  
        .equ SAI3_SAI_ACR1_OSR, 1 << 26   @ bitWidth 1 (Oversampling ratio for master  clock)  
 
    .equ SAI3_SAI_ACR2, SAI3_BASE + 0x8 @ (Configuration register 2) 
        .equ SAI3_SAI_ACR2_FTH_Shift, 0   @ bitWidth 3 (FIFO threshold. This bit is set and  cleared by software.)  
        .equ SAI3_SAI_ACR2_FFLUSH, 1 << 3   @ bitWidth 1 (FIFO flush. This bit is set by software.  It is always read as 0. This bit should be configured  when the SAI is disabled.)  
        .equ SAI3_SAI_ACR2_TRIS, 1 << 4   @ bitWidth 1 (Tristate management on data line. This  bit is set and cleared by software. It is meaningful  only if the audio block is configured as a  transmitter. This bit is not used when the audio  block is configured in SPDIF mode. It should be  configured when SAI is disabled. Refer to Section:  Output data line management on an inactive slot for  more details.)  
        .equ SAI3_SAI_ACR2_MUTE, 1 << 5   @ bitWidth 1 (Mute. This bit is set and cleared by  software. It is meaningful only when the audio block  operates as a transmitter. The MUTE value is linked  to value of MUTEVAL if the number of slots is lower  or equal to 2, or equal to 0 if it is greater than 2.  Refer to Section: Mute mode for more details. Note:  This bit is meaningless and should not be used for  SPDIF audio blocks.)  
        .equ SAI3_SAI_ACR2_MUTEVAL, 1 << 6   @ bitWidth 1 (Mute value. This bit is set and cleared  by software.It must be written before enabling the  audio block: SAIXEN. This bit is meaningful only when  the audio block operates as a transmitter, the number  of slots is lower or equal to 2 and the MUTE bit is  set. If more slots are declared, the bit value sent  during the transmission in mute mode is equal to 0,  whatever the value of MUTEVAL. if the number of slot  is lower or equal to 2 and MUTEVAL = 1, the MUTE  value transmitted for each slot is the one sent  during the previous frame. Refer to Section: Mute  mode for more details. Note: This bit is meaningless  and should not be used for SPDIF audio  blocks.)  
        .equ SAI3_SAI_ACR2_MUTECNT_Shift, 7   @ bitWidth 6 (Mute counter. These bits are set and  cleared by software. They are used only in reception  mode. The value set in these bits is compared to the  number of consecutive mute frames detected in  reception. When the number of mute frames is equal to  this value, the flag MUTEDET will be set and an  interrupt will be generated if bit MUTEDETIE is set.  Refer to Section: Mute mode for more  details.)  
        .equ SAI3_SAI_ACR2_CPL, 1 << 13   @ bitWidth 1 (Complement bit. This bit is set and  cleared by software. It defines the type of  complement to be used for companding mode Note: This  bit has effect only when the companding mode is -Law  algorithm or A-Law algorithm.)  
        .equ SAI3_SAI_ACR2_COMP_Shift, 14   @ bitWidth 2 (Companding mode. These bits are set and  cleared by software. The -Law and the A-Law log are a  part of the CCITT G.711 recommendation, the type of  complement that will be used depends on CPL bit. The  data expansion or data compression are determined by  the state of bit MODE[0]. The data compression is  applied if the audio block is configured as a  transmitter. The data expansion is automatically  applied when the audio block is configured as a  receiver. Refer to Section: Companding mode for more  details. Note: Companding mode is applicable only  when TDM is selected.)  
 
    .equ SAI3_SAI_AFRCR, SAI3_BASE + 0xC @ (This register has no meaning in AC97 and  SPDIF audio protocol) 
        .equ SAI3_SAI_AFRCR_FRL_Shift, 0   @ bitWidth 8 (Frame length. These bits are set and  cleared by software. They define the audio frame  length expressed in number of SCK clock cycles: the  number of bits in the frame is equal to FRL[7:0] + 1.  The minimum number of bits to transfer in an audio  frame must be equal to 8, otherwise the audio block  will behaves in an unexpected way. This is the case  when the data size is 8 bits and only one slot 0 is  defined in NBSLOT[4:0] of SAI_xSLOTR register  NBSLOT[3:0] = 0000. In master mode, if the master  clock available on MCLK_x pin is used, the frame  length should be aligned with a number equal to a  power of 2, ranging from 8 to 256. When the master  clock is not used NODIV = 1, it is recommended to  program the frame length to an value ranging from 8  to 256. These bits are meaningless and are not used  in AC97 or SPDIF audio block  configuration.)  
        .equ SAI3_SAI_AFRCR_FSALL_Shift, 8   @ bitWidth 7 (Frame synchronization active level  length. These bits are set and cleared by software.  They specify the length in number of bit clock SCK  + 1 FSALL[6:0] + 1 of the active level of the FS  signal in the audio frame These bits are meaningless  and are not used in AC97 or SPDIF audio block  configuration. They must be configured when the audio  block is disabled.)  
        .equ SAI3_SAI_AFRCR_FSDEF, 1 << 16   @ bitWidth 1 (Frame synchronization definition. This  bit is set and cleared by software. When the bit is  set, the number of slots defined in the SAI_xSLOTR  register has to be even. It means that half of this  number of slots will be dedicated to the left channel  and the other slots for the right channel e.g: this  bit has to be set for I2S or MSB/LSB-justified  protocols.... This bit is meaningless and is not  used in AC97 or SPDIF audio block configuration. It  must be configured when the audio block is  disabled.)  
        .equ SAI3_SAI_AFRCR_FSPOL, 1 << 17   @ bitWidth 1 (Frame synchronization polarity. This bit  is set and cleared by software. It is used to  configure the level of the start of frame on the FS  signal. It is meaningless and is not used in AC97 or  SPDIF audio block configuration. This bit must be  configured when the audio block is  disabled.)  
        .equ SAI3_SAI_AFRCR_FSOFF, 1 << 18   @ bitWidth 1 (Frame synchronization offset. This bit  is set and cleared by software. It is meaningless and  is not used in AC97 or SPDIF audio block  configuration. This bit must be configured when the  audio block is disabled.)  
 
    .equ SAI3_SAI_ASLOTR, SAI3_BASE + 0x10 @ (This register has no meaning in AC97 and  SPDIF audio protocol) 
        .equ SAI3_SAI_ASLOTR_FBOFF_Shift, 0   @ bitWidth 5 (First bit offset These bits are set and  cleared by software. The value set in this bitfield  defines the position of the first data transfer bit  in the slot. It represents an offset value. In  transmission mode, the bits outside the data field  are forced to 0. In reception mode, the extra  received bits are discarded. These bits must be set  when the audio block is disabled. They are ignored in  AC97 or SPDIF mode.)  
        .equ SAI3_SAI_ASLOTR_SLOTSZ_Shift, 6   @ bitWidth 2 (Slot size This bits is set and cleared  by software. The slot size must be higher or equal to  the data size. If this condition is not respected,  the behavior of the SAI will be undetermined. Refer  to Section: Output data line management on an  inactive slot for information on how to drive SD  line. These bits must be set when the audio block is  disabled. They are ignored in AC97 or SPDIF  mode.)  
        .equ SAI3_SAI_ASLOTR_NBSLOT_Shift, 8   @ bitWidth 4 (Number of slots in an audio frame. These  bits are set and cleared by software. The value set  in this bitfield represents the number of slots + 1  in the audio frame including the number of inactive  slots. The maximum number of slots is 16. The number  of slots should be even if FSDEF bit in the SAI_xFRCR  register is set. The number of slots must be  configured when the audio block is disabled. They are  ignored in AC97 or SPDIF mode.)  
        .equ SAI3_SAI_ASLOTR_SLOTEN_Shift, 16   @ bitWidth 16 (Slot enable. These bits are set and  cleared by software. Each SLOTEN bit corresponds to a  slot position from 0 to 15 maximum 16 slots. The  slot must be enabled when the audio block is  disabled. They are ignored in AC97 or SPDIF  mode.)  
 
    .equ SAI3_SAI_AIM, SAI3_BASE + 0x14 @ (Interrupt mask register 2) 
        .equ SAI3_SAI_AIM_OVRUDRIE, 1 << 0   @ bitWidth 1 (Overrun/underrun interrupt enable. This  bit is set and cleared by software. When this bit is  set, an interrupt is generated if the OVRUDR bit in  the SAI_xSR register is set.)  
        .equ SAI3_SAI_AIM_MUTEDETIE, 1 << 1   @ bitWidth 1 (Mute detection interrupt enable. This  bit is set and cleared by software. When this bit is  set, an interrupt is generated if the MUTEDET bit in  the SAI_xSR register is set. This bit has a meaning  only if the audio block is configured in receiver  mode.)  
        .equ SAI3_SAI_AIM_WCKCFGIE, 1 << 2   @ bitWidth 1 (Wrong clock configuration interrupt  enable. This bit is set and cleared by software. This  bit is taken into account only if the audio block is  configured as a master MODE[1] = 0 and NODIV = 0.  It generates an interrupt if the WCKCFG flag in the  SAI_xSR register is set. Note: This bit is used only  in TDM mode and is meaningless in other  modes.)  
        .equ SAI3_SAI_AIM_FREQIE, 1 << 3   @ bitWidth 1 (FIFO request interrupt enable. This bit  is set and cleared by software. When this bit is set,  an interrupt is generated if the FREQ bit in the  SAI_xSR register is set. Since the audio block  defaults to operate as a transmitter after reset, the  MODE bit must be configured before setting FREQIE to  avoid a parasitic interruption in receiver  mode,)  
        .equ SAI3_SAI_AIM_CNRDYIE, 1 << 4   @ bitWidth 1 (Codec not ready interrupt enable AC97.  This bit is set and cleared by software. When the  interrupt is enabled, the audio block detects in the  slot 0 tag0 of the AC97 frame if the Codec  connected to this line is ready or not. If it is not  ready, the CNRDY flag in the SAI_xSR register is set  and an interruption i generated. This bit has a  meaning only if the AC97 mode is selected through  PRTCFG[1:0] bits and the audio block is operates as a  receiver.)  
        .equ SAI3_SAI_AIM_AFSDETIE, 1 << 5   @ bitWidth 1 (Anticipated frame synchronization  detection interrupt enable. This bit is set and  cleared by software. When this bit is set, an  interrupt will be generated if the AFSDET bit in the  SAI_xSR register is set. This bit is meaningless in  AC97, SPDIF mode or when the audio block operates as  a master.)  
        .equ SAI3_SAI_AIM_LFSDETIE, 1 << 6   @ bitWidth 1 (Late frame synchronization detection  interrupt enable. This bit is set and cleared by  software. When this bit is set, an interrupt will be  generated if the LFSDET bit is set in the SAI_xSR  register. This bit is meaningless in AC97, SPDIF mode  or when the audio block operates as a  master.)  
 
    .equ SAI3_SAI_ASR, SAI3_BASE + 0x18 @ (Status register) 
        .equ SAI3_SAI_ASR_OVRUDR, 1 << 0   @ bitWidth 1 (Overrun / underrun. This bit is read  only. The overrun and underrun conditions can occur  only when the audio block is configured as a receiver  and a transmitter, respectively. It can generate an  interrupt if OVRUDRIE bit is set in SAI_xIM register.  This flag is cleared when the software sets COVRUDR  bit in SAI_xCLRFR register.)  
        .equ SAI3_SAI_ASR_MUTEDET, 1 << 1   @ bitWidth 1 (Mute detection. This bit is read only.  This flag is set if consecutive 0 values are received  in each slot of a given audio frame and for a  consecutive number of audio frames set in the  MUTECNT bit in the SAI_xCR2 register. It can  generate an interrupt if MUTEDETIE bit is set in  SAI_xIM register. This flag is cleared when the  software sets bit CMUTEDET in the SAI_xCLRFR  register.)  
        .equ SAI3_SAI_ASR_WCKCFG, 1 << 2   @ bitWidth 1 (Wrong clock configuration flag. This bit  is read only. This bit is used only when the audio  block operates in master mode MODE[1] = 0 and NODIV  = 0. It can generate an interrupt if WCKCFGIE bit is  set in SAI_xIM register. This flag is cleared when  the software sets CWCKCFG bit in SAI_xCLRFR  register.)  
        .equ SAI3_SAI_ASR_FREQ, 1 << 3   @ bitWidth 1 (FIFO request. This bit is read only. The  request depends on the audio block configuration: If  the block is configured in transmission mode, the  FIFO request is related to a write request operation  in the SAI_xDR. If the block configured in reception,  the FIFO request related to a read request operation  from the SAI_xDR. This flag can generate an interrupt  if FREQIE bit is set in SAI_xIM  register.)  
        .equ SAI3_SAI_ASR_CNRDY, 1 << 4   @ bitWidth 1 (Codec not ready. This bit is read only.  This bit is used only when the AC97 audio protocol is  selected in the SAI_xCR1 register and configured in  receiver mode. It can generate an interrupt if  CNRDYIE bit is set in SAI_xIM register. This flag is  cleared when the software sets CCNRDY bit in  SAI_xCLRFR register.)  
        .equ SAI3_SAI_ASR_AFSDET, 1 << 5   @ bitWidth 1 (Anticipated frame synchronization  detection. This bit is read only. This flag can be  set only if the audio block is configured in slave  mode. It is not used in AC97or SPDIF mode. It can  generate an interrupt if AFSDETIE bit is set in  SAI_xIM register. This flag is cleared when the  software sets CAFSDET bit in SAI_xCLRFR  register.)  
        .equ SAI3_SAI_ASR_LFSDET, 1 << 6   @ bitWidth 1 (Late frame synchronization detection.  This bit is read only. This flag can be set only if  the audio block is configured in slave mode. It is  not used in AC97 or SPDIF mode. It can generate an  interrupt if LFSDETIE bit is set in the SAI_xIM  register. This flag is cleared when the software sets  bit CLFSDET in SAI_xCLRFR register)  
        .equ SAI3_SAI_ASR_FLVL_Shift, 16   @ bitWidth 3 (FIFO level threshold. This bit is read  only. The FIFO level threshold flag is managed only  by hardware and its setting depends on SAI block  configuration transmitter or receiver mode. If the  SAI block is configured as transmitter: If SAI block  is configured as receiver:)  
 
    .equ SAI3_SAI_ACLRFR, SAI3_BASE + 0x1C @ (Clear flag register) 
        .equ SAI3_SAI_ACLRFR_COVRUDR, 1 << 0   @ bitWidth 1 (Clear overrun / underrun. This bit is  write only. Programming this bit to 1 clears the  OVRUDR flag in the SAI_xSR register. Reading this bit  always returns the value 0.)  
        .equ SAI3_SAI_ACLRFR_CMUTEDET, 1 << 1   @ bitWidth 1 (Mute detection flag. This bit is write  only. Programming this bit to 1 clears the MUTEDET  flag in the SAI_xSR register. Reading this bit always  returns the value 0.)  
        .equ SAI3_SAI_ACLRFR_CWCKCFG, 1 << 2   @ bitWidth 1 (Clear wrong clock configuration flag.  This bit is write only. Programming this bit to 1  clears the WCKCFG flag in the SAI_xSR register. This  bit is used only when the audio block is set as  master MODE[1] = 0 and NODIV = 0 in the SAI_xCR1  register. Reading this bit always returns the value  0.)  
        .equ SAI3_SAI_ACLRFR_CCNRDY, 1 << 4   @ bitWidth 1 (Clear Codec not ready flag. This bit is  write only. Programming this bit to 1 clears the  CNRDY flag in the SAI_xSR register. This bit is used  only when the AC97 audio protocol is selected in the  SAI_xCR1 register. Reading this bit always returns  the value 0.)  
        .equ SAI3_SAI_ACLRFR_CAFSDET, 1 << 5   @ bitWidth 1 (Clear anticipated frame synchronization  detection flag. This bit is write only. Programming  this bit to 1 clears the AFSDET flag in the SAI_xSR  register. It is not used in AC97or SPDIF mode.  Reading this bit always returns the value  0.)  
        .equ SAI3_SAI_ACLRFR_CLFSDET, 1 << 6   @ bitWidth 1 (Clear late frame synchronization  detection flag. This bit is write only. Programming  this bit to 1 clears the LFSDET flag in the SAI_xSR  register. This bit is not used in AC97or SPDIF mode  Reading this bit always returns the value  0.)  
 
    .equ SAI3_SAI_ADR, SAI3_BASE + 0x20 @ (Data register) 
        .equ SAI3_SAI_ADR_DATA_Shift, 0   @ bitWidth 32 (Data A write to this register loads the  FIFO provided the FIFO is not full. A read from this  register empties the FIFO if the FIFO is not  empty.)  
 
    .equ SAI3_SAI_BCR1, SAI3_BASE + 0x24 @ (Configuration register 1) 
        .equ SAI3_SAI_BCR1_MODE_Shift, 0   @ bitWidth 2 (SAIx audio block mode  immediately)  
        .equ SAI3_SAI_BCR1_PRTCFG_Shift, 2   @ bitWidth 2 (Protocol configuration. These bits are  set and cleared by software. These bits have to be  configured when the audio block is  disabled.)  
        .equ SAI3_SAI_BCR1_DS_Shift, 5   @ bitWidth 3 (Data size. These bits are set and  cleared by software. These bits are ignored when the  SPDIF protocols are selected bit PRTCFG[1:0],  because the frame and the data size are fixed in such  case. When the companding mode is selected through  COMP[1:0] bits, DS[1:0] are ignored since the data  size is fixed to 8 bits by the algorithm. These bits  must be configured when the audio block is  disabled.)  
        .equ SAI3_SAI_BCR1_LSBFIRST, 1 << 8   @ bitWidth 1 (Least significant bit first. This bit is  set and cleared by software. It must be configured  when the audio block is disabled. This bit has no  meaning in AC97 audio protocol since AC97 data are  always transferred with the MSB first. This bit has  no meaning in SPDIF audio protocol since in SPDIF  data are always transferred with LSB  first.)  
        .equ SAI3_SAI_BCR1_CKSTR, 1 << 9   @ bitWidth 1 (Clock strobing edge. This bit is set and  cleared by software. It must be configured when the  audio block is disabled. This bit has no meaning in  SPDIF audio protocol.)  
        .equ SAI3_SAI_BCR1_SYNCEN_Shift, 10   @ bitWidth 2 (Synchronization enable. These bits are  set and cleared by software. They must be configured  when the audio sub-block is disabled. Note: The audio  sub-block should be configured as asynchronous when  SPDIF mode is enabled.)  
        .equ SAI3_SAI_BCR1_MONO, 1 << 12   @ bitWidth 1 (Mono mode. This bit is set and cleared  by software. It is meaningful only when the number of  slots is equal to 2. When the mono mode is selected,  slot 0 data are duplicated on slot 1 when the audio  block operates as a transmitter. In reception mode,  the slot1 is discarded and only the data received  from slot 0 are stored. Refer to Section: Mono/stereo  mode for more details.)  
        .equ SAI3_SAI_BCR1_OUTDRIV, 1 << 13   @ bitWidth 1 (Output drive. This bit is set and  cleared by software. Note: This bit has to be set  before enabling the audio block and after the audio  block configuration.)  
        .equ SAI3_SAI_BCR1_SAIXEN, 1 << 16   @ bitWidth 1 (Audio block enable where x is A or B.  This bit is set by software. To switch off the audio  block, the application software must program this bit  to 0 and poll the bit till it reads back 0, meaning  that the block is completely disabled. Before setting  this bit to 1, check that it is set to 0, otherwise  the enable command will not be taken into account.  This bit allows to control the state of SAIx audio  block. If it is disabled when an audio frame transfer  is ongoing, the ongoing transfer completes and the  cell is fully disabled at the end of this audio frame  transfer. Note: When SAIx block is configured in  master mode, the clock must be present on the input  of SAIx before setting SAIXEN bit.)  
        .equ SAI3_SAI_BCR1_DMAEN, 1 << 17   @ bitWidth 1 (DMA enable. This bit is set and cleared  by software. Note: Since the audio block defaults to  operate as a transmitter after reset, the MODE[1:0]  bits must be configured before setting DMAEN to avoid  a DMA request in receiver mode.)  
        .equ SAI3_SAI_BCR1_NOMCK, 1 << 19   @ bitWidth 1 (No divider)  
        .equ SAI3_SAI_BCR1_MCKDIV_Shift, 20   @ bitWidth 4 (Master clock divider. These bits are set  and cleared by software. These bits are meaningless  when the audio block operates in slave mode. They  have to be configured when the audio block is  disabled. Others: the master clock frequency is  calculated accordingly to the following  formula:)  
        .equ SAI3_SAI_BCR1_OSR, 1 << 26   @ bitWidth 1 (Oversampling ratio for master  clock)  
 
    .equ SAI3_SAI_BCR2, SAI3_BASE + 0x28 @ (Configuration register 2) 
        .equ SAI3_SAI_BCR2_FTH_Shift, 0   @ bitWidth 3 (FIFO threshold. This bit is set and  cleared by software.)  
        .equ SAI3_SAI_BCR2_FFLUSH, 1 << 3   @ bitWidth 1 (FIFO flush. This bit is set by software.  It is always read as 0. This bit should be configured  when the SAI is disabled.)  
        .equ SAI3_SAI_BCR2_TRIS, 1 << 4   @ bitWidth 1 (Tristate management on data line. This  bit is set and cleared by software. It is meaningful  only if the audio block is configured as a  transmitter. This bit is not used when the audio  block is configured in SPDIF mode. It should be  configured when SAI is disabled. Refer to Section:  Output data line management on an inactive slot for  more details.)  
        .equ SAI3_SAI_BCR2_MUTE, 1 << 5   @ bitWidth 1 (Mute. This bit is set and cleared by  software. It is meaningful only when the audio block  operates as a transmitter. The MUTE value is linked  to value of MUTEVAL if the number of slots is lower  or equal to 2, or equal to 0 if it is greater than 2.  Refer to Section: Mute mode for more details. Note:  This bit is meaningless and should not be used for  SPDIF audio blocks.)  
        .equ SAI3_SAI_BCR2_MUTEVAL, 1 << 6   @ bitWidth 1 (Mute value. This bit is set and cleared  by software.It must be written before enabling the  audio block: SAIXEN. This bit is meaningful only when  the audio block operates as a transmitter, the number  of slots is lower or equal to 2 and the MUTE bit is  set. If more slots are declared, the bit value sent  during the transmission in mute mode is equal to 0,  whatever the value of MUTEVAL. if the number of slot  is lower or equal to 2 and MUTEVAL = 1, the MUTE  value transmitted for each slot is the one sent  during the previous frame. Refer to Section: Mute  mode for more details. Note: This bit is meaningless  and should not be used for SPDIF audio  blocks.)  
        .equ SAI3_SAI_BCR2_MUTECNT_Shift, 7   @ bitWidth 6 (Mute counter. These bits are set and  cleared by software. They are used only in reception  mode. The value set in these bits is compared to the  number of consecutive mute frames detected in  reception. When the number of mute frames is equal to  this value, the flag MUTEDET will be set and an  interrupt will be generated if bit MUTEDETIE is set.  Refer to Section: Mute mode for more  details.)  
        .equ SAI3_SAI_BCR2_CPL, 1 << 13   @ bitWidth 1 (Complement bit. This bit is set and  cleared by software. It defines the type of  complement to be used for companding mode Note: This  bit has effect only when the companding mode is -Law  algorithm or A-Law algorithm.)  
        .equ SAI3_SAI_BCR2_COMP_Shift, 14   @ bitWidth 2 (Companding mode. These bits are set and  cleared by software. The -Law and the A-Law log are a  part of the CCITT G.711 recommendation, the type of  complement that will be used depends on CPL bit. The  data expansion or data compression are determined by  the state of bit MODE[0]. The data compression is  applied if the audio block is configured as a  transmitter. The data expansion is automatically  applied when the audio block is configured as a  receiver. Refer to Section: Companding mode for more  details. Note: Companding mode is applicable only  when TDM is selected.)  
 
    .equ SAI3_SAI_BFRCR, SAI3_BASE + 0x2C @ (This register has no meaning in AC97 and  SPDIF audio protocol) 
        .equ SAI3_SAI_BFRCR_FRL_Shift, 0   @ bitWidth 8 (Frame length. These bits are set and  cleared by software. They define the audio frame  length expressed in number of SCK clock cycles: the  number of bits in the frame is equal to FRL[7:0] + 1.  The minimum number of bits to transfer in an audio  frame must be equal to 8, otherwise the audio block  will behaves in an unexpected way. This is the case  when the data size is 8 bits and only one slot 0 is  defined in NBSLOT[4:0] of SAI_xSLOTR register  NBSLOT[3:0] = 0000. In master mode, if the master  clock available on MCLK_x pin is used, the frame  length should be aligned with a number equal to a  power of 2, ranging from 8 to 256. When the master  clock is not used NODIV = 1, it is recommended to  program the frame length to an value ranging from 8  to 256. These bits are meaningless and are not used  in AC97 or SPDIF audio block  configuration.)  
        .equ SAI3_SAI_BFRCR_FSALL_Shift, 8   @ bitWidth 7 (Frame synchronization active level  length. These bits are set and cleared by software.  They specify the length in number of bit clock SCK  + 1 FSALL[6:0] + 1 of the active level of the FS  signal in the audio frame These bits are meaningless  and are not used in AC97 or SPDIF audio block  configuration. They must be configured when the audio  block is disabled.)  
        .equ SAI3_SAI_BFRCR_FSDEF, 1 << 16   @ bitWidth 1 (Frame synchronization definition. This  bit is set and cleared by software. When the bit is  set, the number of slots defined in the SAI_xSLOTR  register has to be even. It means that half of this  number of slots will be dedicated to the left channel  and the other slots for the right channel e.g: this  bit has to be set for I2S or MSB/LSB-justified  protocols.... This bit is meaningless and is not  used in AC97 or SPDIF audio block configuration. It  must be configured when the audio block is  disabled.)  
        .equ SAI3_SAI_BFRCR_FSPOL, 1 << 17   @ bitWidth 1 (Frame synchronization polarity. This bit  is set and cleared by software. It is used to  configure the level of the start of frame on the FS  signal. It is meaningless and is not used in AC97 or  SPDIF audio block configuration. This bit must be  configured when the audio block is  disabled.)  
        .equ SAI3_SAI_BFRCR_FSOFF, 1 << 18   @ bitWidth 1 (Frame synchronization offset. This bit  is set and cleared by software. It is meaningless and  is not used in AC97 or SPDIF audio block  configuration. This bit must be configured when the  audio block is disabled.)  
 
    .equ SAI3_SAI_BSLOTR, SAI3_BASE + 0x30 @ (This register has no meaning in AC97 and  SPDIF audio protocol) 
        .equ SAI3_SAI_BSLOTR_FBOFF_Shift, 0   @ bitWidth 5 (First bit offset These bits are set and  cleared by software. The value set in this bitfield  defines the position of the first data transfer bit  in the slot. It represents an offset value. In  transmission mode, the bits outside the data field  are forced to 0. In reception mode, the extra  received bits are discarded. These bits must be set  when the audio block is disabled. They are ignored in  AC97 or SPDIF mode.)  
        .equ SAI3_SAI_BSLOTR_SLOTSZ_Shift, 6   @ bitWidth 2 (Slot size This bits is set and cleared  by software. The slot size must be higher or equal to  the data size. If this condition is not respected,  the behavior of the SAI will be undetermined. Refer  to Section: Output data line management on an  inactive slot for information on how to drive SD  line. These bits must be set when the audio block is  disabled. They are ignored in AC97 or SPDIF  mode.)  
        .equ SAI3_SAI_BSLOTR_NBSLOT_Shift, 8   @ bitWidth 4 (Number of slots in an audio frame. These  bits are set and cleared by software. The value set  in this bitfield represents the number of slots + 1  in the audio frame including the number of inactive  slots. The maximum number of slots is 16. The number  of slots should be even if FSDEF bit in the SAI_xFRCR  register is set. The number of slots must be  configured when the audio block is disabled. They are  ignored in AC97 or SPDIF mode.)  
        .equ SAI3_SAI_BSLOTR_SLOTEN_Shift, 16   @ bitWidth 16 (Slot enable. These bits are set and  cleared by software. Each SLOTEN bit corresponds to a  slot position from 0 to 15 maximum 16 slots. The  slot must be enabled when the audio block is  disabled. They are ignored in AC97 or SPDIF  mode.)  
 
    .equ SAI3_SAI_BIM, SAI3_BASE + 0x34 @ (Interrupt mask register 2) 
        .equ SAI3_SAI_BIM_OVRUDRIE, 1 << 0   @ bitWidth 1 (Overrun/underrun interrupt enable. This  bit is set and cleared by software. When this bit is  set, an interrupt is generated if the OVRUDR bit in  the SAI_xSR register is set.)  
        .equ SAI3_SAI_BIM_MUTEDETIE, 1 << 1   @ bitWidth 1 (Mute detection interrupt enable. This  bit is set and cleared by software. When this bit is  set, an interrupt is generated if the MUTEDET bit in  the SAI_xSR register is set. This bit has a meaning  only if the audio block is configured in receiver  mode.)  
        .equ SAI3_SAI_BIM_WCKCFGIE, 1 << 2   @ bitWidth 1 (Wrong clock configuration interrupt  enable. This bit is set and cleared by software. This  bit is taken into account only if the audio block is  configured as a master MODE[1] = 0 and NODIV = 0.  It generates an interrupt if the WCKCFG flag in the  SAI_xSR register is set. Note: This bit is used only  in TDM mode and is meaningless in other  modes.)  
        .equ SAI3_SAI_BIM_FREQIE, 1 << 3   @ bitWidth 1 (FIFO request interrupt enable. This bit  is set and cleared by software. When this bit is set,  an interrupt is generated if the FREQ bit in the  SAI_xSR register is set. Since the audio block  defaults to operate as a transmitter after reset, the  MODE bit must be configured before setting FREQIE to  avoid a parasitic interruption in receiver  mode,)  
        .equ SAI3_SAI_BIM_CNRDYIE, 1 << 4   @ bitWidth 1 (Codec not ready interrupt enable AC97.  This bit is set and cleared by software. When the  interrupt is enabled, the audio block detects in the  slot 0 tag0 of the AC97 frame if the Codec  connected to this line is ready or not. If it is not  ready, the CNRDY flag in the SAI_xSR register is set  and an interruption i generated. This bit has a  meaning only if the AC97 mode is selected through  PRTCFG[1:0] bits and the audio block is operates as a  receiver.)  
        .equ SAI3_SAI_BIM_AFSDETIE, 1 << 5   @ bitWidth 1 (Anticipated frame synchronization  detection interrupt enable. This bit is set and  cleared by software. When this bit is set, an  interrupt will be generated if the AFSDET bit in the  SAI_xSR register is set. This bit is meaningless in  AC97, SPDIF mode or when the audio block operates as  a master.)  
        .equ SAI3_SAI_BIM_LFSDETIE, 1 << 6   @ bitWidth 1 (Late frame synchronization detection  interrupt enable. This bit is set and cleared by  software. When this bit is set, an interrupt will be  generated if the LFSDET bit is set in the SAI_xSR  register. This bit is meaningless in AC97, SPDIF mode  or when the audio block operates as a  master.)  
 
    .equ SAI3_SAI_BSR, SAI3_BASE + 0x38 @ (Status register) 
        .equ SAI3_SAI_BSR_OVRUDR, 1 << 0   @ bitWidth 1 (Overrun / underrun. This bit is read  only. The overrun and underrun conditions can occur  only when the audio block is configured as a receiver  and a transmitter, respectively. It can generate an  interrupt if OVRUDRIE bit is set in SAI_xIM register.  This flag is cleared when the software sets COVRUDR  bit in SAI_xCLRFR register.)  
        .equ SAI3_SAI_BSR_MUTEDET, 1 << 1   @ bitWidth 1 (Mute detection. This bit is read only.  This flag is set if consecutive 0 values are received  in each slot of a given audio frame and for a  consecutive number of audio frames set in the  MUTECNT bit in the SAI_xCR2 register. It can  generate an interrupt if MUTEDETIE bit is set in  SAI_xIM register. This flag is cleared when the  software sets bit CMUTEDET in the SAI_xCLRFR  register.)  
        .equ SAI3_SAI_BSR_WCKCFG, 1 << 2   @ bitWidth 1 (Wrong clock configuration flag. This bit  is read only. This bit is used only when the audio  block operates in master mode MODE[1] = 0 and NODIV  = 0. It can generate an interrupt if WCKCFGIE bit is  set in SAI_xIM register. This flag is cleared when  the software sets CWCKCFG bit in SAI_xCLRFR  register.)  
        .equ SAI3_SAI_BSR_FREQ, 1 << 3   @ bitWidth 1 (FIFO request. This bit is read only. The  request depends on the audio block configuration: If  the block is configured in transmission mode, the  FIFO request is related to a write request operation  in the SAI_xDR. If the block configured in reception,  the FIFO request related to a read request operation  from the SAI_xDR. This flag can generate an interrupt  if FREQIE bit is set in SAI_xIM  register.)  
        .equ SAI3_SAI_BSR_CNRDY, 1 << 4   @ bitWidth 1 (Codec not ready. This bit is read only.  This bit is used only when the AC97 audio protocol is  selected in the SAI_xCR1 register and configured in  receiver mode. It can generate an interrupt if  CNRDYIE bit is set in SAI_xIM register. This flag is  cleared when the software sets CCNRDY bit in  SAI_xCLRFR register.)  
        .equ SAI3_SAI_BSR_AFSDET, 1 << 5   @ bitWidth 1 (Anticipated frame synchronization  detection. This bit is read only. This flag can be  set only if the audio block is configured in slave  mode. It is not used in AC97or SPDIF mode. It can  generate an interrupt if AFSDETIE bit is set in  SAI_xIM register. This flag is cleared when the  software sets CAFSDET bit in SAI_xCLRFR  register.)  
        .equ SAI3_SAI_BSR_LFSDET, 1 << 6   @ bitWidth 1 (Late frame synchronization detection.  This bit is read only. This flag can be set only if  the audio block is configured in slave mode. It is  not used in AC97 or SPDIF mode. It can generate an  interrupt if LFSDETIE bit is set in the SAI_xIM  register. This flag is cleared when the software sets  bit CLFSDET in SAI_xCLRFR register)  
        .equ SAI3_SAI_BSR_FLVL_Shift, 16   @ bitWidth 3 (FIFO level threshold. This bit is read  only. The FIFO level threshold flag is managed only  by hardware and its setting depends on SAI block  configuration transmitter or receiver mode. If the  SAI block is configured as transmitter: If SAI block  is configured as receiver:)  
 
    .equ SAI3_SAI_BCLRFR, SAI3_BASE + 0x3C @ (Clear flag register) 
        .equ SAI3_SAI_BCLRFR_COVRUDR, 1 << 0   @ bitWidth 1 (Clear overrun / underrun. This bit is  write only. Programming this bit to 1 clears the  OVRUDR flag in the SAI_xSR register. Reading this bit  always returns the value 0.)  
        .equ SAI3_SAI_BCLRFR_CMUTEDET, 1 << 1   @ bitWidth 1 (Mute detection flag. This bit is write  only. Programming this bit to 1 clears the MUTEDET  flag in the SAI_xSR register. Reading this bit always  returns the value 0.)  
        .equ SAI3_SAI_BCLRFR_CWCKCFG, 1 << 2   @ bitWidth 1 (Clear wrong clock configuration flag.  This bit is write only. Programming this bit to 1  clears the WCKCFG flag in the SAI_xSR register. This  bit is used only when the audio block is set as  master MODE[1] = 0 and NODIV = 0 in the SAI_xCR1  register. Reading this bit always returns the value  0.)  
        .equ SAI3_SAI_BCLRFR_CCNRDY, 1 << 4   @ bitWidth 1 (Clear Codec not ready flag. This bit is  write only. Programming this bit to 1 clears the  CNRDY flag in the SAI_xSR register. This bit is used  only when the AC97 audio protocol is selected in the  SAI_xCR1 register. Reading this bit always returns  the value 0.)  
        .equ SAI3_SAI_BCLRFR_CAFSDET, 1 << 5   @ bitWidth 1 (Clear anticipated frame synchronization  detection flag. This bit is write only. Programming  this bit to 1 clears the AFSDET flag in the SAI_xSR  register. It is not used in AC97or SPDIF mode.  Reading this bit always returns the value  0.)  
        .equ SAI3_SAI_BCLRFR_CLFSDET, 1 << 6   @ bitWidth 1 (Clear late frame synchronization  detection flag. This bit is write only. Programming  this bit to 1 clears the LFSDET flag in the SAI_xSR  register. This bit is not used in AC97or SPDIF mode  Reading this bit always returns the value  0.)  
 
    .equ SAI3_SAI_BDR, SAI3_BASE + 0x40 @ (Data register) 
        .equ SAI3_SAI_BDR_DATA_Shift, 0   @ bitWidth 32 (Data A write to this register loads the  FIFO provided the FIFO is not full. A read from this  register empties the FIFO if the FIFO is not  empty.)  
 
    .equ SAI3_SAI_PDMCR, SAI3_BASE + 0x44 @ (PDM control register) 
        .equ SAI3_SAI_PDMCR_PDMEN, 1 << 0   @ bitWidth 1 (PDM enable)  
        .equ SAI3_SAI_PDMCR_MICNBR_Shift, 4   @ bitWidth 2 (Number of microphones)  
        .equ SAI3_SAI_PDMCR_CKEN1, 1 << 8   @ bitWidth 1 (Clock enable of bitstream clock number  1)  
        .equ SAI3_SAI_PDMCR_CKEN2, 1 << 9   @ bitWidth 1 (Clock enable of bitstream clock number  2)  
        .equ SAI3_SAI_PDMCR_CKEN3, 1 << 10   @ bitWidth 1 (Clock enable of bitstream clock number  3)  
        .equ SAI3_SAI_PDMCR_CKEN4, 1 << 11   @ bitWidth 1 (Clock enable of bitstream clock number  4)  
 
    .equ SAI3_SAI_PDMDLY, SAI3_BASE + 0x48 @ (PDM delay register) 
        .equ SAI3_SAI_PDMDLY_DLYM1L_Shift, 0   @ bitWidth 3 (Delay line adjust for first microphone  of pair 1)  
        .equ SAI3_SAI_PDMDLY_DLYM1R_Shift, 4   @ bitWidth 3 (Delay line adjust for second microphone  of pair 1)  
        .equ SAI3_SAI_PDMDLY_DLYM2L_Shift, 8   @ bitWidth 3 (Delay line for first microphone of pair  2)  
        .equ SAI3_SAI_PDMDLY_DLYM2R_Shift, 12   @ bitWidth 3 (Delay line for second microphone of pair  2)  
        .equ SAI3_SAI_PDMDLY_DLYM3L_Shift, 16   @ bitWidth 3 (Delay line for first microphone of pair  3)  
        .equ SAI3_SAI_PDMDLY_DLYM3R_Shift, 20   @ bitWidth 3 (Delay line for second microphone of pair  3)  
        .equ SAI3_SAI_PDMDLY_DLYM4L_Shift, 24   @ bitWidth 3 (Delay line for first microphone of pair  4)  
        .equ SAI3_SAI_PDMDLY_DLYM4R_Shift, 28   @ bitWidth 3 (Delay line for second microphone of pair  4)  
 

@=========================== SDMMC1 ===========================@
.equ SDMMC1_BASE, 0x52007000 @ (SDMMC1) 
    .equ SDMMC1_POWER, SDMMC1_BASE + 0x0 @ (SDMMC power control register) 
        .equ SDMMC1_POWER_PWRCTRL_Shift, 0   @ bitWidth 2 (SDMMC state control bits. These bits can  only be written when the SDMMC is not in the power-on  state PWRCTRL?11. These bits are used to define the  functional state of the SDMMC signals: Any further  write will be ignored, PWRCTRL value will keep  11.)  
        .equ SDMMC1_POWER_VSWITCH, 1 << 2   @ bitWidth 1 (Voltage switch sequence start. This bit  is used to start the timing critical section of the  voltage switch sequence:)  
        .equ SDMMC1_POWER_VSWITCHEN, 1 << 3   @ bitWidth 1 (Voltage switch procedure enable. This  bit can only be written by firmware when CPSM is  disabled CPSMEN = 0. This bit is used to stop the  SDMMC_CK after the voltage switch command  response:)  
        .equ SDMMC1_POWER_DIRPOL, 1 << 4   @ bitWidth 1 (Data and command direction signals  polarity selection. This bit can only be written when  the SDMMC is in the power-off state PWRCTRL =  00.)  
 
    .equ SDMMC1_CLKCR, SDMMC1_BASE + 0x4 @ (The SDMMC_CLKCR register controls the  SDMMC_CK output clock, the SDMMC_RX_CLK receive clock,  and the bus width.) 
        .equ SDMMC1_CLKCR_CLKDIV_Shift, 0   @ bitWidth 10 (Clock divide factor This bit can only be  written when the CPSM and DPSM are not active  CPSMACT = 0 and DPSMACT = 0. This field defines the  divide factor between the input clock SDMMCCLK and  the output clock SDMMC_CK: SDMMC_CK frequency =  SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. xxx:  etc..)  
        .equ SDMMC1_CLKCR_PWRSAV, 1 << 12   @ bitWidth 1 (Power saving configuration bit This bit  can only be written when the CPSM and DPSM are not  active CPSMACT = 0 and DPSMACT = 0 For power  saving, the SDMMC_CK clock output can be disabled  when the bus is idle by setting PWRSAV:)  
        .equ SDMMC1_CLKCR_WIDBUS_Shift, 14   @ bitWidth 2 (Wide bus mode enable bit This bit can  only be written when the CPSM and DPSM are not active  CPSMACT = 0 and DPSMACT = 0)  
        .equ SDMMC1_CLKCR_NEGEDGE, 1 << 16   @ bitWidth 1 (SDMMC_CK dephasing selection bit for  data and Command. This bit can only be written when  the CPSM and DPSM are not active CPSMACT = 0 and  DPSMACT = 0. When clock division = 1 CLKDIV = 0,  this bit has no effect. Data and Command change on  SDMMC_CK falling edge. When clock division &gt;1  CLKDIV &gt; 0 &amp; DDR = 0: - SDMMC_CK  edge occurs on SDMMCCLK rising edge. When clock  division >1 CLKDIV > 0 & DDR = 1: - Data  changed on the SDMMCCLK falling edge succeeding a  SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK  rising edge. - Data changed on the SDMMC_CK falling  edge succeeding a SDMMC_CK edge. - SDMMC_CK edge  occurs on SDMMCCLK rising edge.)  
        .equ SDMMC1_CLKCR_HWFC_EN, 1 << 17   @ bitWidth 1 (Hardware flow control enable This bit  can only be written when the CPSM and DPSM are not  active CPSMACT = 0 and DPSMACT = 0 When Hardware  flow control is enabled, the meaning of the TXFIFOE  and RXFIFOF flags change, please see SDMMC status  register definition in Section56.8.11.)  
        .equ SDMMC1_CLKCR_DDR, 1 << 18   @ bitWidth 1 (Data rate signaling selection This bit  can only be written when the CPSM and DPSM are not  active CPSMACT = 0 and DPSMACT = 0 DDR rate shall  only be selected with 4-bit or 8-bit wide bus mode.  WIDBUS &gt; 00. DDR = 1 has no effect when  WIDBUS = 00 1-bit wide bus. DDR rate shall only be  selected with clock division &gt;1. CLKDIV  &gt; 0)  
        .equ SDMMC1_CLKCR_BUSSPEED, 1 << 19   @ bitWidth 1 (Bus speed mode selection between DS, HS,  SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can  only be written when the CPSM and DPSM are not active  CPSMACT = 0 and DPSMACT = 0)  
        .equ SDMMC1_CLKCR_SELCLKRX_Shift, 20   @ bitWidth 2 (Receive clock selection. These bits can  only be written when the CPSM and DPSM are not active  CPSMACT = 0 and DPSMACT = 0)  
 
    .equ SDMMC1_ARGR, SDMMC1_BASE + 0x8 @ (The SDMMC_ARGR register contains a 32-bit  command argument, which is sent to a card as part of a  command message.) 
        .equ SDMMC1_ARGR_CMDARG_Shift, 0   @ bitWidth 32 (Command argument. These bits can only be  written by firmware when CPSM is disabled CPSMEN =  0. Command argument sent to a card as part of a  command message. If a command contains an argument,  it must be loaded into this register before writing a  command to the command register.)  
 
    .equ SDMMC1_CMDR, SDMMC1_BASE + 0xC @ (The SDMMC_CMDR register contains the command  index and command type bits. The command index is sent to  a card as part of a command message. The command type  bits control the command path state machine  CPSM.) 
        .equ SDMMC1_CMDR_CMDINDEX_Shift, 0   @ bitWidth 6 (Command index. This bit can only be  written by firmware when CPSM is disabled CPSMEN =  0. The command index is sent to the card as part of  a command message.)  
        .equ SDMMC1_CMDR_CMDTRANS, 1 << 6   @ bitWidth 1 (The CPSM treats the command as a data  transfer command, stops the interrupt period, and  signals DataEnable to the DPSM This bit can only be  written by firmware when CPSM is disabled CPSMEN =  0. If this bit is set, the CPSM issues an end of  interrupt period and issues DataEnable signal to the  DPSM when the command is sent.)  
        .equ SDMMC1_CMDR_CMDSTOP, 1 << 7   @ bitWidth 1 (The CPSM treats the command as a Stop  Transmission command and signals Abort to the DPSM.  This bit can only be written by firmware when CPSM is  disabled CPSMEN = 0. If this bit is set, the CPSM  issues the Abort signal to the DPSM when the command  is sent.)  
        .equ SDMMC1_CMDR_WAITRESP_Shift, 8   @ bitWidth 2 (Wait for response bits. This bit can  only be written by firmware when CPSM is disabled  CPSMEN = 0. They are used to configure whether the  CPSM is to wait for a response, and if yes, which  kind of response.)  
        .equ SDMMC1_CMDR_WAITINT, 1 << 10   @ bitWidth 1 (CPSM waits for interrupt request. If  this bit is set, the CPSM disables command timeout  and waits for an card interrupt request Response.  If this bit is cleared in the CPSM Wait state, will  cause the abort of the interrupt mode.)  
        .equ SDMMC1_CMDR_WAITPEND, 1 << 11   @ bitWidth 1 (CPSM Waits for end of data transfer  CmdPend internal signal from DPSM. This bit when  set, the CPSM waits for the end of data transfer  trigger before it starts sending a command. WAITPEND  is only taken into account when DTMODE = MMC stream  data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT  = 1 and DTDIR = from host to card.)  
        .equ SDMMC1_CMDR_CPSMEN, 1 << 12   @ bitWidth 1 (Command path state machine CPSM Enable  bit This bit is written 1 by firmware, and cleared by  hardware when the CPSM enters the Idle state. If this  bit is set, the CPSM is enabled. When DTEN = 1, no  command will be transfered nor boot procedure will be  started. CPSMEN is cleared to 0.)  
        .equ SDMMC1_CMDR_DTHOLD, 1 << 13   @ bitWidth 1 (Hold new data block transmission and  reception in the DPSM. If this bit is set, the DPSM  will not move from the Wait_S state to the Send state  or from the Wait_R state to the Receive  state.)  
        .equ SDMMC1_CMDR_BOOTMODE, 1 << 14   @ bitWidth 1 (Select the boot mode procedure to be  used. This bit can only be written by firmware when  CPSM is disabled CPSMEN = 0)  
        .equ SDMMC1_CMDR_BOOTEN, 1 << 15   @ bitWidth 1 (Enable boot mode  procedure.)  
        .equ SDMMC1_CMDR_CMDSUSPEND, 1 << 16   @ bitWidth 1 (The CPSM treats the command as a Suspend  or Resume command and signals interrupt period  start/end. This bit can only be written by firmware  when CPSM is disabled CPSMEN = 0. CMDSUSPEND = 1  and CMDTRANS = 0 Suspend command, start interrupt  period when response bit BS=0. CMDSUSPEND = 1 and  CMDTRANS = 1 Resume command with data, end interrupt  period when response bit DF=1.)  
 
    .equ SDMMC1_RESP1R, SDMMC1_BASE + 0x14 @ (The SDMMC_RESP1/2/3/4R registers contain the  status of a card, which is part of the received  response.) 
        .equ SDMMC1_RESP1R_CARDSTATUS1_Shift, 0   @ bitWidth 32 (see Table 432)  
 
    .equ SDMMC1_RESP2R, SDMMC1_BASE + 0x18 @ (The SDMMC_RESP1/2/3/4R registers contain the  status of a card, which is part of the received  response.) 
        .equ SDMMC1_RESP2R_CARDSTATUS2_Shift, 0   @ bitWidth 32 (see Table404.)  
 
    .equ SDMMC1_RESP3R, SDMMC1_BASE + 0x1C @ (The SDMMC_RESP1/2/3/4R registers contain the  status of a card, which is part of the received  response.) 
        .equ SDMMC1_RESP3R_CARDSTATUS3_Shift, 0   @ bitWidth 32 (see Table404.)  
 
    .equ SDMMC1_RESP4R, SDMMC1_BASE + 0x20 @ (The SDMMC_RESP1/2/3/4R registers contain the  status of a card, which is part of the received  response.) 
        .equ SDMMC1_RESP4R_CARDSTATUS4_Shift, 0   @ bitWidth 32 (see Table404.)  
 
    .equ SDMMC1_DTIMER, SDMMC1_BASE + 0x24 @ (The SDMMC_DTIMER register contains the data  timeout period, in card bus clock periods. A counter  loads the value from the SDMMC_DTIMER register, and  starts decrementing when the data path state machine  DPSM enters the Wait_R or Busy state. If the timer  reaches 0 while the DPSM is in either of these states,  the timeout status flag is set.) 
        .equ SDMMC1_DTIMER_DATATIME_Shift, 0   @ bitWidth 32 (Data and R1b busy timeout period This  bit can only be written when the CPSM and DPSM are  not active CPSMACT = 0 and DPSMACT = 0. Data and  R1b busy timeout period expressed in card bus clock  periods.)  
 
    .equ SDMMC1_DLENR, SDMMC1_BASE + 0x28 @ (The SDMMC_DLENR register contains the number  of data bytes to be transferred. The value is loaded into  the data counter when data transfer starts.) 
        .equ SDMMC1_DLENR_DATALENGTH_Shift, 0   @ bitWidth 25 (Data length value This register can only  be written by firmware when DPSM is inactive DPSMACT  = 0. Number of data bytes to be transferred. When  DDR = 1 DATALENGTH is truncated to a multiple of 2.  The last odd byte is not transfered When DATALENGTH  = 0 no data will be transfered, when requested by a  CPSMEN and CMDTRANS = 1 also no command will be  transfered. DTEN and CPSMEN are cleared to  0.)  
 
    .equ SDMMC1_DCTRL, SDMMC1_BASE + 0x2C @ (The SDMMC_DCTRL register control the data  path state machine DPSM.) 
        .equ SDMMC1_DCTRL_DTEN, 1 << 0   @ bitWidth 1 (Data transfer enable bit This bit can  only be written by firmware when DPSM is inactive  DPSMACT = 0. This bit is cleared by Hardware when  data transfer completes. This bit shall only be used  to transfer data when no associated data transfer  command is used, i.e. shall not be used with SD or  eMMC cards.)  
        .equ SDMMC1_DCTRL_DTDIR, 1 << 1   @ bitWidth 1 (Data transfer direction selection This  bit can only be written by firmware when DPSM is  inactive DPSMACT = 0.)  
        .equ SDMMC1_DCTRL_DTMODE_Shift, 2   @ bitWidth 2 (Data transfer mode selection. This bit  can only be written by firmware when DPSM is inactive  DPSMACT = 0.)  
        .equ SDMMC1_DCTRL_DBLOCKSIZE_Shift, 4   @ bitWidth 4 (Data block size This bit can only be  written by firmware when DPSM is inactive DPSMACT =  0. Define the data block length when the block data  transfer mode is selected: When DATALENGTH is not a  multiple of DBLOCKSIZE, the transfered data is  truncated at a multiple of DBLOCKSIZE. Any remain  data will not be transfered. When DDR = 1,  DBLOCKSIZE = 0000 shall not be used. No data will be  transfered)  
        .equ SDMMC1_DCTRL_RWSTART, 1 << 8   @ bitWidth 1 (Read wait start. If this bit is set,  read wait operation starts.)  
        .equ SDMMC1_DCTRL_RWSTOP, 1 << 9   @ bitWidth 1 (Read wait stop This bit is written by  firmware and auto cleared by hardware when the DPSM  moves from the READ_WAIT state to the WAIT_R or IDLE  state.)  
        .equ SDMMC1_DCTRL_RWMOD, 1 << 10   @ bitWidth 1 (Read wait mode. This bit can only be  written by firmware when DPSM is inactive DPSMACT =  0.)  
        .equ SDMMC1_DCTRL_SDIOEN, 1 << 11   @ bitWidth 1 (SD I/O interrupt enable functions This  bit can only be written by firmware when DPSM is  inactive DPSMACT = 0. If this bit is set, the DPSM  enables the SD I/O card specific interrupt  operation.)  
        .equ SDMMC1_DCTRL_BOOTACKEN, 1 << 12   @ bitWidth 1 (Enable the reception of the boot  acknowledgment. This bit can only be written by  firmware when DPSM is inactive DPSMACT =  0.)  
        .equ SDMMC1_DCTRL_FIFORST, 1 << 13   @ bitWidth 1 (FIFO reset, will flush any remaining  data. This bit can only be written by firmware when  IDMAEN= 0 and DPSM is active DPSMACT = 1. This bit  will only take effect when a transfer error or  transfer hold occurs.)  
 
    .equ SDMMC1_DCNTR, SDMMC1_BASE + 0x30 @ (The SDMMC_DCNTR register loads the value  from the data length register see SDMMC_DLENR when the  DPSM moves from the Idle state to the Wait_R or Wait_S  state. As data is transferred, the counter decrements the  value until it reaches 0. The DPSM then moves to the Idle  state and when there has been no error, the data status  end flag DATAEND is set.) 
        .equ SDMMC1_DCNTR_DATACOUNT_Shift, 0   @ bitWidth 25 (Data count value When read, the number  of remaining data bytes to be transferred is  returned. Write has no effect.)  
 
    .equ SDMMC1_STAR, SDMMC1_BASE + 0x34 @ (The SDMMC_STAR register is a read-only  register. It contains two types of flag:Static flags  bits [29,21,11:0]: these bits remain asserted until  they are cleared by writing to the SDMMC interrupt Clear  register see SDMMC_ICRDynamic flags bits [20:12]:  these bits change state depending on the state of the  underlying logic for example, FIFO full and empty flags  are asserted and de-asserted as data while written to the  FIFO) 
        .equ SDMMC1_STAR_CCRCFAIL, 1 << 0   @ bitWidth 1 (Command response received CRC check  failed. Interrupt flag is cleared by writing  corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC1_STAR_DCRCFAIL, 1 << 1   @ bitWidth 1 (Data block sent/received CRC check  failed. Interrupt flag is cleared by writing  corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC1_STAR_CTIMEOUT, 1 << 2   @ bitWidth 1 (Command response timeout. Interrupt flag  is cleared by writing corresponding interrupt clear  bit in SDMMC_ICR. The Command Timeout period has a  fixed value of 64 SDMMC_CK clock  periods.)  
        .equ SDMMC1_STAR_DTIMEOUT, 1 << 3   @ bitWidth 1 (Data timeout. Interrupt flag is cleared  by writing corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC1_STAR_TXUNDERR, 1 << 4   @ bitWidth 1 (Transmit FIFO underrun error or IDMA  read transfer error. Interrupt flag is cleared by  writing corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC1_STAR_RXOVERR, 1 << 5   @ bitWidth 1 (Received FIFO overrun error or IDMA  write transfer error. Interrupt flag is cleared by  writing corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC1_STAR_CMDREND, 1 << 6   @ bitWidth 1 (Command response received CRC check  passed, or no CRC. Interrupt flag is cleared by  writing corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC1_STAR_CMDSENT, 1 << 7   @ bitWidth 1 (Command sent no response required.  Interrupt flag is cleared by writing corresponding  interrupt clear bit in SDMMC_ICR.)  
        .equ SDMMC1_STAR_DATAEND, 1 << 8   @ bitWidth 1 (Data transfer ended correctly. data  counter, DATACOUNT is zero and no errors occur.  Interrupt flag is cleared by writing corresponding  interrupt clear bit in SDMMC_ICR.)  
        .equ SDMMC1_STAR_DHOLD, 1 << 9   @ bitWidth 1 (Data transfer Hold. Interrupt flag is  cleared by writing corresponding interrupt clear bit  in SDMMC_ICR.)  
        .equ SDMMC1_STAR_DBCKEND, 1 << 10   @ bitWidth 1 (Data block sent/received. CRC check  passed and DPSM moves to the READWAIT state.  Interrupt flag is cleared by writing corresponding  interrupt clear bit in SDMMC_ICR.)  
        .equ SDMMC1_STAR_DABORT, 1 << 11   @ bitWidth 1 (Data transfer aborted by CMD12.  Interrupt flag is cleared by writing corresponding  interrupt clear bit in SDMMC_ICR.)  
        .equ SDMMC1_STAR_DPSMACT, 1 << 12   @ bitWidth 1 (Data path state machine active, i.e. not  in Idle state. This is a hardware status flag only,  does not generate an interrupt.)  
        .equ SDMMC1_STAR_CPSMACT, 1 << 13   @ bitWidth 1 (Command path state machine active, i.e.  not in Idle state. This is a hardware status flag  only, does not generate an interrupt.)  
        .equ SDMMC1_STAR_TXFIFOHE, 1 << 14   @ bitWidth 1 (Transmit FIFO half empty At least half  the number of words can be written into the FIFO.  This bit is cleared when the FIFO becomes half+1  full.)  
        .equ SDMMC1_STAR_RXFIFOHF, 1 << 15   @ bitWidth 1 (Receive FIFO half full There are at  least half the number of words in the FIFO. This bit  is cleared when the FIFO becomes half+1  empty.)  
        .equ SDMMC1_STAR_TXFIFOF, 1 << 16   @ bitWidth 1 (Transmit FIFO full This is a hardware  status flag only, does not generate an interrupt.  This bit is cleared when one FIFO location becomes  empty.)  
        .equ SDMMC1_STAR_RXFIFOF, 1 << 17   @ bitWidth 1 (Receive FIFO full This bit is cleared  when one FIFO location becomes empty.)  
        .equ SDMMC1_STAR_TXFIFOE, 1 << 18   @ bitWidth 1 (Transmit FIFO empty This bit is cleared  when one FIFO location becomes full.)  
        .equ SDMMC1_STAR_RXFIFOE, 1 << 19   @ bitWidth 1 (Receive FIFO empty This is a hardware  status flag only, does not generate an interrupt.  This bit is cleared when one FIFO location becomes  full.)  
        .equ SDMMC1_STAR_BUSYD0, 1 << 20   @ bitWidth 1 (Inverted value of SDMMC_D0 line Busy,  sampled at the end of a CMD response and a second  time 2 SDMMC_CK cycles after the CMD response. This  bit is reset to not busy when the SDMMCD0 line  changes from busy to not busy. This bit does not  signal busy due to data transfer. This is a hardware  status flag only, it does not generate an  interrupt.)  
        .equ SDMMC1_STAR_BUSYD0END, 1 << 21   @ bitWidth 1 (end of SDMMC_D0 Busy following a CMD  response detected. This indicates only end of busy  following a CMD response. This bit does not signal  busy due to data transfer. Interrupt flag is cleared  by writing corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC1_STAR_SDIOIT, 1 << 22   @ bitWidth 1 (SDIO interrupt received. Interrupt flag  is cleared by writing corresponding interrupt clear  bit in SDMMC_ICR.)  
        .equ SDMMC1_STAR_ACKFAIL, 1 << 23   @ bitWidth 1 (Boot acknowledgment received boot  acknowledgment check fail. Interrupt flag is cleared  by writing corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC1_STAR_ACKTIMEOUT, 1 << 24   @ bitWidth 1 (Boot acknowledgment timeout. Interrupt  flag is cleared by writing corresponding interrupt  clear bit in SDMMC_ICR.)  
        .equ SDMMC1_STAR_VSWEND, 1 << 25   @ bitWidth 1 (Voltage switch critical timing section  completion. Interrupt flag is cleared by writing  corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC1_STAR_CKSTOP, 1 << 26   @ bitWidth 1 (SDMMC_CK stopped in Voltage switch  procedure. Interrupt flag is cleared by writing  corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC1_STAR_IDMATE, 1 << 27   @ bitWidth 1 (IDMA transfer error. Interrupt flag is  cleared by writing corresponding interrupt clear bit  in SDMMC_ICR.)  
        .equ SDMMC1_STAR_IDMABTC, 1 << 28   @ bitWidth 1 (IDMA buffer transfer complete. interrupt  flag is cleared by writing corresponding interrupt  clear bit in SDMMC_ICR.)  
 
    .equ SDMMC1_ICR, SDMMC1_BASE + 0x38 @ (The SDMMC_ICR register is a write-only  register. Writing a bit with 1 clears the corresponding  bit in the SDMMC_STAR status register.) 
        .equ SDMMC1_ICR_CCRCFAILC, 1 << 0   @ bitWidth 1 (CCRCFAIL flag clear bit Set by software  to clear the CCRCFAIL flag.)  
        .equ SDMMC1_ICR_DCRCFAILC, 1 << 1   @ bitWidth 1 (DCRCFAIL flag clear bit Set by software  to clear the DCRCFAIL flag.)  
        .equ SDMMC1_ICR_CTIMEOUTC, 1 << 2   @ bitWidth 1 (CTIMEOUT flag clear bit Set by software  to clear the CTIMEOUT flag.)  
        .equ SDMMC1_ICR_DTIMEOUTC, 1 << 3   @ bitWidth 1 (DTIMEOUT flag clear bit Set by software  to clear the DTIMEOUT flag.)  
        .equ SDMMC1_ICR_TXUNDERRC, 1 << 4   @ bitWidth 1 (TXUNDERR flag clear bit Set by software  to clear TXUNDERR flag.)  
        .equ SDMMC1_ICR_RXOVERRC, 1 << 5   @ bitWidth 1 (RXOVERR flag clear bit Set by software  to clear the RXOVERR flag.)  
        .equ SDMMC1_ICR_CMDRENDC, 1 << 6   @ bitWidth 1 (CMDREND flag clear bit Set by software  to clear the CMDREND flag.)  
        .equ SDMMC1_ICR_CMDSENTC, 1 << 7   @ bitWidth 1 (CMDSENT flag clear bit Set by software  to clear the CMDSENT flag.)  
        .equ SDMMC1_ICR_DATAENDC, 1 << 8   @ bitWidth 1 (DATAEND flag clear bit Set by software  to clear the DATAEND flag.)  
        .equ SDMMC1_ICR_DHOLDC, 1 << 9   @ bitWidth 1 (DHOLD flag clear bit Set by software to  clear the DHOLD flag.)  
        .equ SDMMC1_ICR_DBCKENDC, 1 << 10   @ bitWidth 1 (DBCKEND flag clear bit Set by software  to clear the DBCKEND flag.)  
        .equ SDMMC1_ICR_DABORTC, 1 << 11   @ bitWidth 1 (DABORT flag clear bit Set by software to  clear the DABORT flag.)  
        .equ SDMMC1_ICR_BUSYD0ENDC, 1 << 21   @ bitWidth 1 (BUSYD0END flag clear bit Set by software  to clear the BUSYD0END flag.)  
        .equ SDMMC1_ICR_SDIOITC, 1 << 22   @ bitWidth 1 (SDIOIT flag clear bit Set by software to  clear the SDIOIT flag.)  
        .equ SDMMC1_ICR_ACKFAILC, 1 << 23   @ bitWidth 1 (ACKFAIL flag clear bit Set by software  to clear the ACKFAIL flag.)  
        .equ SDMMC1_ICR_ACKTIMEOUTC, 1 << 24   @ bitWidth 1 (ACKTIMEOUT flag clear bit Set by  software to clear the ACKTIMEOUT flag.)  
        .equ SDMMC1_ICR_VSWENDC, 1 << 25   @ bitWidth 1 (VSWEND flag clear bit Set by software to  clear the VSWEND flag.)  
        .equ SDMMC1_ICR_CKSTOPC, 1 << 26   @ bitWidth 1 (CKSTOP flag clear bit Set by software to  clear the CKSTOP flag.)  
        .equ SDMMC1_ICR_IDMATEC, 1 << 27   @ bitWidth 1 (IDMA transfer error clear bit Set by  software to clear the IDMATE flag.)  
        .equ SDMMC1_ICR_IDMABTCC, 1 << 28   @ bitWidth 1 (IDMA buffer transfer complete clear bit  Set by software to clear the IDMABTC  flag.)  
 
    .equ SDMMC1_MASKR, SDMMC1_BASE + 0x3C @ (The interrupt mask register determines which  status flags generate an interrupt request by setting the  corresponding bit to 1.) 
        .equ SDMMC1_MASKR_CCRCFAILIE, 1 << 0   @ bitWidth 1 (Command CRC fail interrupt enable Set  and cleared by software to enable/disable interrupt  caused by command CRC failure.)  
        .equ SDMMC1_MASKR_DCRCFAILIE, 1 << 1   @ bitWidth 1 (Data CRC fail interrupt enable Set and  cleared by software to enable/disable interrupt  caused by data CRC failure.)  
        .equ SDMMC1_MASKR_CTIMEOUTIE, 1 << 2   @ bitWidth 1 (Command timeout interrupt enable Set and  cleared by software to enable/disable interrupt  caused by command timeout.)  
        .equ SDMMC1_MASKR_DTIMEOUTIE, 1 << 3   @ bitWidth 1 (Data timeout interrupt enable Set and  cleared by software to enable/disable interrupt  caused by data timeout.)  
        .equ SDMMC1_MASKR_TXUNDERRIE, 1 << 4   @ bitWidth 1 (Tx FIFO underrun error interrupt enable  Set and cleared by software to enable/disable  interrupt caused by Tx FIFO underrun  error.)  
        .equ SDMMC1_MASKR_RXOVERRIE, 1 << 5   @ bitWidth 1 (Rx FIFO overrun error interrupt enable  Set and cleared by software to enable/disable  interrupt caused by Rx FIFO overrun  error.)  
        .equ SDMMC1_MASKR_CMDRENDIE, 1 << 6   @ bitWidth 1 (Command response received interrupt  enable Set and cleared by software to enable/disable  interrupt caused by receiving command  response.)  
        .equ SDMMC1_MASKR_CMDSENTIE, 1 << 7   @ bitWidth 1 (Command sent interrupt enable Set and  cleared by software to enable/disable interrupt  caused by sending command.)  
        .equ SDMMC1_MASKR_DATAENDIE, 1 << 8   @ bitWidth 1 (Data end interrupt enable Set and  cleared by software to enable/disable interrupt  caused by data end.)  
        .equ SDMMC1_MASKR_DHOLDIE, 1 << 9   @ bitWidth 1 (Data hold interrupt enable Set and  cleared by software to enable/disable the interrupt  generated when sending new data is hold in the DPSM  Wait_S state.)  
        .equ SDMMC1_MASKR_DBCKENDIE, 1 << 10   @ bitWidth 1 (Data block end interrupt enable Set and  cleared by software to enable/disable interrupt  caused by data block end.)  
        .equ SDMMC1_MASKR_DABORTIE, 1 << 11   @ bitWidth 1 (Data transfer aborted interrupt enable  Set and cleared by software to enable/disable  interrupt caused by a data transfer being  aborted.)  
        .equ SDMMC1_MASKR_TXFIFOHEIE, 1 << 14   @ bitWidth 1 (Tx FIFO half empty interrupt enable Set  and cleared by software to enable/disable interrupt  caused by Tx FIFO half empty.)  
        .equ SDMMC1_MASKR_RXFIFOHFIE, 1 << 15   @ bitWidth 1 (Rx FIFO half full interrupt enable Set  and cleared by software to enable/disable interrupt  caused by Rx FIFO half full.)  
        .equ SDMMC1_MASKR_RXFIFOFIE, 1 << 17   @ bitWidth 1 (Rx FIFO full interrupt enable Set and  cleared by software to enable/disable interrupt  caused by Rx FIFO full.)  
        .equ SDMMC1_MASKR_TXFIFOEIE, 1 << 18   @ bitWidth 1 (Tx FIFO empty interrupt enable Set and  cleared by software to enable/disable interrupt  caused by Tx FIFO empty.)  
        .equ SDMMC1_MASKR_BUSYD0ENDIE, 1 << 21   @ bitWidth 1 (BUSYD0END interrupt enable Set and  cleared by software to enable/disable the interrupt  generated when SDMMC_D0 signal changes from busy to  NOT busy following a CMD response.)  
        .equ SDMMC1_MASKR_SDIOITIE, 1 << 22   @ bitWidth 1 (SDIO mode interrupt received interrupt  enable Set and cleared by software to enable/disable  the interrupt generated when receiving the SDIO mode  interrupt.)  
        .equ SDMMC1_MASKR_ACKFAILIE, 1 << 23   @ bitWidth 1 (Acknowledgment Fail interrupt enable Set  and cleared by software to enable/disable interrupt  caused by acknowledgment Fail.)  
        .equ SDMMC1_MASKR_ACKTIMEOUTIE, 1 << 24   @ bitWidth 1 (Acknowledgment timeout interrupt enable  Set and cleared by software to enable/disable  interrupt caused by acknowledgment  timeout.)  
        .equ SDMMC1_MASKR_VSWENDIE, 1 << 25   @ bitWidth 1 (Voltage switch critical timing section  completion interrupt enable Set and cleared by  software to enable/disable the interrupt generated  when voltage switch critical timing section  completion.)  
        .equ SDMMC1_MASKR_CKSTOPIE, 1 << 26   @ bitWidth 1 (Voltage Switch clock stopped interrupt  enable Set and cleared by software to enable/disable  interrupt caused by Voltage Switch clock  stopped.)  
        .equ SDMMC1_MASKR_IDMABTCIE, 1 << 28   @ bitWidth 1 (IDMA buffer transfer complete interrupt  enable Set and cleared by software to enable/disable  the interrupt generated when the IDMA has transferred  all data belonging to a memory buffer.)  
 
    .equ SDMMC1_ACKTIMER, SDMMC1_BASE + 0x40 @ (The SDMMC_ACKTIMER register contains the  acknowledgment timeout period, in SDMMC_CK bus clock  periods. A counter loads the value from the  SDMMC_ACKTIMER register, and starts decrementing when the  data path state machine DPSM enters the Wait_Ack state.  If the timer reaches 0 while the DPSM is in this states,  the acknowledgment timeout status flag is  set.) 
        .equ SDMMC1_ACKTIMER_ACKTIME_Shift, 0   @ bitWidth 25 (Boot acknowledgment timeout period This  bit can only be written by firmware when CPSM is  disabled CPSMEN = 0. Boot acknowledgment timeout  period expressed in card bus clock  periods.)  
 
    .equ SDMMC1_IDMACTRLR, SDMMC1_BASE + 0x50 @ (The receive and transmit FIFOs can be read  or written as 32-bit wide registers. The FIFOs contain 32  entries on 32 sequential addresses. This allows the CPU  to use its load and store multiple operands to read  from/write to the FIFO.) 
        .equ SDMMC1_IDMACTRLR_IDMAEN, 1 << 0   @ bitWidth 1 (IDMA enable This bit can only be written  by firmware when DPSM is inactive DPSMACT =  0.)  
        .equ SDMMC1_IDMACTRLR_IDMABMODE, 1 << 1   @ bitWidth 1 (Buffer mode selection. This bit can only  be written by firmware when DPSM is inactive DPSMACT  = 0.)  
        .equ SDMMC1_IDMACTRLR_IDMABACT, 1 << 2   @ bitWidth 1 (Double buffer mode active buffer  indication This bit can only be written by firmware  when DPSM is inactive DPSMACT = 0. When IDMA is  enabled this bit is toggled by  hardware.)  
 
    .equ SDMMC1_IDMABSIZER, SDMMC1_BASE + 0x54 @ (The SDMMC_IDMABSIZER register contains the  buffers size when in double buffer  configuration.) 
        .equ SDMMC1_IDMABSIZER_IDMABNDT_Shift, 5   @ bitWidth 8 (Number of transfers per buffer. This  8-bit value shall be multiplied by 8 to get the size  of the buffer in 32-bit words and by 32 to get the  size of the buffer in bytes. Example: IDMABNDT =  0x01: buffer size = 8 words = 32 bytes. These bits  can only be written by firmware when DPSM is inactive  DPSMACT = 0.)  
 
    .equ SDMMC1_IDMABASE0R, SDMMC1_BASE + 0x58 @ (The SDMMC_IDMABASE0R register contains the  memory buffer base address in single buffer configuration  and the buffer 0 base address in double buffer  configuration.) 
        .equ SDMMC1_IDMABASE0R_IDMABASE0_Shift, 0   @ bitWidth 32 (Buffer 0 memory base address bits  [31:2], shall be word aligned bit [1:0] are always 0  and read only. This register can be written by  firmware when DPSM is inactive DPSMACT = 0, and can  dynamically be written by firmware when DPSM active  DPSMACT = 1 and memory buffer 0 is inactive  IDMABACT = 1.)  
 
    .equ SDMMC1_IDMABASE1R, SDMMC1_BASE + 0x5C @ (The SDMMC_IDMABASE1R register contains the  double buffer configuration second buffer memory base  address.) 
        .equ SDMMC1_IDMABASE1R_IDMABASE1_Shift, 0   @ bitWidth 32 (Buffer 1 memory base address, shall be  word aligned bit [1:0] are always 0 and read only.  This register can be written by firmware when DPSM is  inactive DPSMACT = 0, and can dynamically be  written by firmware when DPSM active DPSMACT = 1  and memory buffer 1 is inactive IDMABACT =  0.)  
 
    .equ SDMMC1_FIFOR, SDMMC1_BASE + 0x80 @ (The receive and transmit FIFOs can be only  read or written as word 32-bit wide registers. The  FIFOs contain 16 entries on sequential addresses. This  allows the CPU to use its load and store multiple  operands to read from/write to the FIFO.When accessing  SDMMC_FIFOR with half word or byte access an AHB bus  fault is generated.) 
        .equ SDMMC1_FIFOR_FIFODATA_Shift, 0   @ bitWidth 32 (Receive and transmit FIFO data This  register can only be read or written by firmware when  the DPSM is active DPSMACT=1. The FIFO data  occupies 16 entries of 32-bit words.)  
 
    .equ SDMMC1_VER, SDMMC1_BASE + 0x3F4 @ (SDMMC IP version register) 
        .equ SDMMC1_VER_MINREV_Shift, 0   @ bitWidth 4 (IP minor revision number.)  
        .equ SDMMC1_VER_MAJREV_Shift, 4   @ bitWidth 4 (IP major revision number.)  
 
    .equ SDMMC1_ID, SDMMC1_BASE + 0x3F8 @ (SDMMC IP identification  register) 
        .equ SDMMC1_ID_IP_ID_Shift, 0   @ bitWidth 32 (SDMMC IP identification.)  
 
    .equ SDMMC1_RESPCMDR, SDMMC1_BASE + 0x10 @ (SDMMC command response  register) 
        .equ SDMMC1_RESPCMDR_RESPCMD_Shift, 0   @ bitWidth 6 (Response command index)  
 

@=========================== SDMMC2 ===========================@
.equ SDMMC2_BASE, 0x48022400 @ (SDMMC1) 
    .equ SDMMC2_POWER, SDMMC2_BASE + 0x0 @ (SDMMC power control register) 
        .equ SDMMC2_POWER_PWRCTRL_Shift, 0   @ bitWidth 2 (SDMMC state control bits. These bits can  only be written when the SDMMC is not in the power-on  state PWRCTRL?11. These bits are used to define the  functional state of the SDMMC signals: Any further  write will be ignored, PWRCTRL value will keep  11.)  
        .equ SDMMC2_POWER_VSWITCH, 1 << 2   @ bitWidth 1 (Voltage switch sequence start. This bit  is used to start the timing critical section of the  voltage switch sequence:)  
        .equ SDMMC2_POWER_VSWITCHEN, 1 << 3   @ bitWidth 1 (Voltage switch procedure enable. This  bit can only be written by firmware when CPSM is  disabled CPSMEN = 0. This bit is used to stop the  SDMMC_CK after the voltage switch command  response:)  
        .equ SDMMC2_POWER_DIRPOL, 1 << 4   @ bitWidth 1 (Data and command direction signals  polarity selection. This bit can only be written when  the SDMMC is in the power-off state PWRCTRL =  00.)  
 
    .equ SDMMC2_CLKCR, SDMMC2_BASE + 0x4 @ (The SDMMC_CLKCR register controls the  SDMMC_CK output clock, the SDMMC_RX_CLK receive clock,  and the bus width.) 
        .equ SDMMC2_CLKCR_CLKDIV_Shift, 0   @ bitWidth 10 (Clock divide factor This bit can only be  written when the CPSM and DPSM are not active  CPSMACT = 0 and DPSMACT = 0. This field defines the  divide factor between the input clock SDMMCCLK and  the output clock SDMMC_CK: SDMMC_CK frequency =  SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. xxx:  etc..)  
        .equ SDMMC2_CLKCR_PWRSAV, 1 << 12   @ bitWidth 1 (Power saving configuration bit This bit  can only be written when the CPSM and DPSM are not  active CPSMACT = 0 and DPSMACT = 0 For power  saving, the SDMMC_CK clock output can be disabled  when the bus is idle by setting PWRSAV:)  
        .equ SDMMC2_CLKCR_WIDBUS_Shift, 14   @ bitWidth 2 (Wide bus mode enable bit This bit can  only be written when the CPSM and DPSM are not active  CPSMACT = 0 and DPSMACT = 0)  
        .equ SDMMC2_CLKCR_NEGEDGE, 1 << 16   @ bitWidth 1 (SDMMC_CK dephasing selection bit for  data and Command. This bit can only be written when  the CPSM and DPSM are not active CPSMACT = 0 and  DPSMACT = 0. When clock division = 1 CLKDIV = 0,  this bit has no effect. Data and Command change on  SDMMC_CK falling edge. When clock division &gt;1  CLKDIV &gt; 0 &amp; DDR = 0: - SDMMC_CK  edge occurs on SDMMCCLK rising edge. When clock  division >1 CLKDIV > 0 & DDR = 1: - Data  changed on the SDMMCCLK falling edge succeeding a  SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK  rising edge. - Data changed on the SDMMC_CK falling  edge succeeding a SDMMC_CK edge. - SDMMC_CK edge  occurs on SDMMCCLK rising edge.)  
        .equ SDMMC2_CLKCR_HWFC_EN, 1 << 17   @ bitWidth 1 (Hardware flow control enable This bit  can only be written when the CPSM and DPSM are not  active CPSMACT = 0 and DPSMACT = 0 When Hardware  flow control is enabled, the meaning of the TXFIFOE  and RXFIFOF flags change, please see SDMMC status  register definition in Section56.8.11.)  
        .equ SDMMC2_CLKCR_DDR, 1 << 18   @ bitWidth 1 (Data rate signaling selection This bit  can only be written when the CPSM and DPSM are not  active CPSMACT = 0 and DPSMACT = 0 DDR rate shall  only be selected with 4-bit or 8-bit wide bus mode.  WIDBUS &gt; 00. DDR = 1 has no effect when  WIDBUS = 00 1-bit wide bus. DDR rate shall only be  selected with clock division &gt;1. CLKDIV  &gt; 0)  
        .equ SDMMC2_CLKCR_BUSSPEED, 1 << 19   @ bitWidth 1 (Bus speed mode selection between DS, HS,  SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can  only be written when the CPSM and DPSM are not active  CPSMACT = 0 and DPSMACT = 0)  
        .equ SDMMC2_CLKCR_SELCLKRX_Shift, 20   @ bitWidth 2 (Receive clock selection. These bits can  only be written when the CPSM and DPSM are not active  CPSMACT = 0 and DPSMACT = 0)  
 
    .equ SDMMC2_ARGR, SDMMC2_BASE + 0x8 @ (The SDMMC_ARGR register contains a 32-bit  command argument, which is sent to a card as part of a  command message.) 
        .equ SDMMC2_ARGR_CMDARG_Shift, 0   @ bitWidth 32 (Command argument. These bits can only be  written by firmware when CPSM is disabled CPSMEN =  0. Command argument sent to a card as part of a  command message. If a command contains an argument,  it must be loaded into this register before writing a  command to the command register.)  
 
    .equ SDMMC2_CMDR, SDMMC2_BASE + 0xC @ (The SDMMC_CMDR register contains the command  index and command type bits. The command index is sent to  a card as part of a command message. The command type  bits control the command path state machine  CPSM.) 
        .equ SDMMC2_CMDR_CMDINDEX_Shift, 0   @ bitWidth 6 (Command index. This bit can only be  written by firmware when CPSM is disabled CPSMEN =  0. The command index is sent to the card as part of  a command message.)  
        .equ SDMMC2_CMDR_CMDTRANS, 1 << 6   @ bitWidth 1 (The CPSM treats the command as a data  transfer command, stops the interrupt period, and  signals DataEnable to the DPSM This bit can only be  written by firmware when CPSM is disabled CPSMEN =  0. If this bit is set, the CPSM issues an end of  interrupt period and issues DataEnable signal to the  DPSM when the command is sent.)  
        .equ SDMMC2_CMDR_CMDSTOP, 1 << 7   @ bitWidth 1 (The CPSM treats the command as a Stop  Transmission command and signals Abort to the DPSM.  This bit can only be written by firmware when CPSM is  disabled CPSMEN = 0. If this bit is set, the CPSM  issues the Abort signal to the DPSM when the command  is sent.)  
        .equ SDMMC2_CMDR_WAITRESP_Shift, 8   @ bitWidth 2 (Wait for response bits. This bit can  only be written by firmware when CPSM is disabled  CPSMEN = 0. They are used to configure whether the  CPSM is to wait for a response, and if yes, which  kind of response.)  
        .equ SDMMC2_CMDR_WAITINT, 1 << 10   @ bitWidth 1 (CPSM waits for interrupt request. If  this bit is set, the CPSM disables command timeout  and waits for an card interrupt request Response.  If this bit is cleared in the CPSM Wait state, will  cause the abort of the interrupt mode.)  
        .equ SDMMC2_CMDR_WAITPEND, 1 << 11   @ bitWidth 1 (CPSM Waits for end of data transfer  CmdPend internal signal from DPSM. This bit when  set, the CPSM waits for the end of data transfer  trigger before it starts sending a command. WAITPEND  is only taken into account when DTMODE = MMC stream  data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT  = 1 and DTDIR = from host to card.)  
        .equ SDMMC2_CMDR_CPSMEN, 1 << 12   @ bitWidth 1 (Command path state machine CPSM Enable  bit This bit is written 1 by firmware, and cleared by  hardware when the CPSM enters the Idle state. If this  bit is set, the CPSM is enabled. When DTEN = 1, no  command will be transfered nor boot procedure will be  started. CPSMEN is cleared to 0.)  
        .equ SDMMC2_CMDR_DTHOLD, 1 << 13   @ bitWidth 1 (Hold new data block transmission and  reception in the DPSM. If this bit is set, the DPSM  will not move from the Wait_S state to the Send state  or from the Wait_R state to the Receive  state.)  
        .equ SDMMC2_CMDR_BOOTMODE, 1 << 14   @ bitWidth 1 (Select the boot mode procedure to be  used. This bit can only be written by firmware when  CPSM is disabled CPSMEN = 0)  
        .equ SDMMC2_CMDR_BOOTEN, 1 << 15   @ bitWidth 1 (Enable boot mode  procedure.)  
        .equ SDMMC2_CMDR_CMDSUSPEND, 1 << 16   @ bitWidth 1 (The CPSM treats the command as a Suspend  or Resume command and signals interrupt period  start/end. This bit can only be written by firmware  when CPSM is disabled CPSMEN = 0. CMDSUSPEND = 1  and CMDTRANS = 0 Suspend command, start interrupt  period when response bit BS=0. CMDSUSPEND = 1 and  CMDTRANS = 1 Resume command with data, end interrupt  period when response bit DF=1.)  
 
    .equ SDMMC2_RESP1R, SDMMC2_BASE + 0x14 @ (The SDMMC_RESP1/2/3/4R registers contain the  status of a card, which is part of the received  response.) 
        .equ SDMMC2_RESP1R_CARDSTATUS1_Shift, 0   @ bitWidth 32 (see Table 432)  
 
    .equ SDMMC2_RESP2R, SDMMC2_BASE + 0x18 @ (The SDMMC_RESP1/2/3/4R registers contain the  status of a card, which is part of the received  response.) 
        .equ SDMMC2_RESP2R_CARDSTATUS2_Shift, 0   @ bitWidth 32 (see Table404.)  
 
    .equ SDMMC2_RESP3R, SDMMC2_BASE + 0x1C @ (The SDMMC_RESP1/2/3/4R registers contain the  status of a card, which is part of the received  response.) 
        .equ SDMMC2_RESP3R_CARDSTATUS3_Shift, 0   @ bitWidth 32 (see Table404.)  
 
    .equ SDMMC2_RESP4R, SDMMC2_BASE + 0x20 @ (The SDMMC_RESP1/2/3/4R registers contain the  status of a card, which is part of the received  response.) 
        .equ SDMMC2_RESP4R_CARDSTATUS4_Shift, 0   @ bitWidth 32 (see Table404.)  
 
    .equ SDMMC2_DTIMER, SDMMC2_BASE + 0x24 @ (The SDMMC_DTIMER register contains the data  timeout period, in card bus clock periods. A counter  loads the value from the SDMMC_DTIMER register, and  starts decrementing when the data path state machine  DPSM enters the Wait_R or Busy state. If the timer  reaches 0 while the DPSM is in either of these states,  the timeout status flag is set.) 
        .equ SDMMC2_DTIMER_DATATIME_Shift, 0   @ bitWidth 32 (Data and R1b busy timeout period This  bit can only be written when the CPSM and DPSM are  not active CPSMACT = 0 and DPSMACT = 0. Data and  R1b busy timeout period expressed in card bus clock  periods.)  
 
    .equ SDMMC2_DLENR, SDMMC2_BASE + 0x28 @ (The SDMMC_DLENR register contains the number  of data bytes to be transferred. The value is loaded into  the data counter when data transfer starts.) 
        .equ SDMMC2_DLENR_DATALENGTH_Shift, 0   @ bitWidth 25 (Data length value This register can only  be written by firmware when DPSM is inactive DPSMACT  = 0. Number of data bytes to be transferred. When  DDR = 1 DATALENGTH is truncated to a multiple of 2.  The last odd byte is not transfered When DATALENGTH  = 0 no data will be transfered, when requested by a  CPSMEN and CMDTRANS = 1 also no command will be  transfered. DTEN and CPSMEN are cleared to  0.)  
 
    .equ SDMMC2_DCTRL, SDMMC2_BASE + 0x2C @ (The SDMMC_DCTRL register control the data  path state machine DPSM.) 
        .equ SDMMC2_DCTRL_DTEN, 1 << 0   @ bitWidth 1 (Data transfer enable bit This bit can  only be written by firmware when DPSM is inactive  DPSMACT = 0. This bit is cleared by Hardware when  data transfer completes. This bit shall only be used  to transfer data when no associated data transfer  command is used, i.e. shall not be used with SD or  eMMC cards.)  
        .equ SDMMC2_DCTRL_DTDIR, 1 << 1   @ bitWidth 1 (Data transfer direction selection This  bit can only be written by firmware when DPSM is  inactive DPSMACT = 0.)  
        .equ SDMMC2_DCTRL_DTMODE_Shift, 2   @ bitWidth 2 (Data transfer mode selection. This bit  can only be written by firmware when DPSM is inactive  DPSMACT = 0.)  
        .equ SDMMC2_DCTRL_DBLOCKSIZE_Shift, 4   @ bitWidth 4 (Data block size This bit can only be  written by firmware when DPSM is inactive DPSMACT =  0. Define the data block length when the block data  transfer mode is selected: When DATALENGTH is not a  multiple of DBLOCKSIZE, the transfered data is  truncated at a multiple of DBLOCKSIZE. Any remain  data will not be transfered. When DDR = 1,  DBLOCKSIZE = 0000 shall not be used. No data will be  transfered)  
        .equ SDMMC2_DCTRL_RWSTART, 1 << 8   @ bitWidth 1 (Read wait start. If this bit is set,  read wait operation starts.)  
        .equ SDMMC2_DCTRL_RWSTOP, 1 << 9   @ bitWidth 1 (Read wait stop This bit is written by  firmware and auto cleared by hardware when the DPSM  moves from the READ_WAIT state to the WAIT_R or IDLE  state.)  
        .equ SDMMC2_DCTRL_RWMOD, 1 << 10   @ bitWidth 1 (Read wait mode. This bit can only be  written by firmware when DPSM is inactive DPSMACT =  0.)  
        .equ SDMMC2_DCTRL_SDIOEN, 1 << 11   @ bitWidth 1 (SD I/O interrupt enable functions This  bit can only be written by firmware when DPSM is  inactive DPSMACT = 0. If this bit is set, the DPSM  enables the SD I/O card specific interrupt  operation.)  
        .equ SDMMC2_DCTRL_BOOTACKEN, 1 << 12   @ bitWidth 1 (Enable the reception of the boot  acknowledgment. This bit can only be written by  firmware when DPSM is inactive DPSMACT =  0.)  
        .equ SDMMC2_DCTRL_FIFORST, 1 << 13   @ bitWidth 1 (FIFO reset, will flush any remaining  data. This bit can only be written by firmware when  IDMAEN= 0 and DPSM is active DPSMACT = 1. This bit  will only take effect when a transfer error or  transfer hold occurs.)  
 
    .equ SDMMC2_DCNTR, SDMMC2_BASE + 0x30 @ (The SDMMC_DCNTR register loads the value  from the data length register see SDMMC_DLENR when the  DPSM moves from the Idle state to the Wait_R or Wait_S  state. As data is transferred, the counter decrements the  value until it reaches 0. The DPSM then moves to the Idle  state and when there has been no error, the data status  end flag DATAEND is set.) 
        .equ SDMMC2_DCNTR_DATACOUNT_Shift, 0   @ bitWidth 25 (Data count value When read, the number  of remaining data bytes to be transferred is  returned. Write has no effect.)  
 
    .equ SDMMC2_STAR, SDMMC2_BASE + 0x34 @ (The SDMMC_STAR register is a read-only  register. It contains two types of flag:Static flags  bits [29,21,11:0]: these bits remain asserted until  they are cleared by writing to the SDMMC interrupt Clear  register see SDMMC_ICRDynamic flags bits [20:12]:  these bits change state depending on the state of the  underlying logic for example, FIFO full and empty flags  are asserted and de-asserted as data while written to the  FIFO) 
        .equ SDMMC2_STAR_CCRCFAIL, 1 << 0   @ bitWidth 1 (Command response received CRC check  failed. Interrupt flag is cleared by writing  corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC2_STAR_DCRCFAIL, 1 << 1   @ bitWidth 1 (Data block sent/received CRC check  failed. Interrupt flag is cleared by writing  corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC2_STAR_CTIMEOUT, 1 << 2   @ bitWidth 1 (Command response timeout. Interrupt flag  is cleared by writing corresponding interrupt clear  bit in SDMMC_ICR. The Command Timeout period has a  fixed value of 64 SDMMC_CK clock  periods.)  
        .equ SDMMC2_STAR_DTIMEOUT, 1 << 3   @ bitWidth 1 (Data timeout. Interrupt flag is cleared  by writing corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC2_STAR_TXUNDERR, 1 << 4   @ bitWidth 1 (Transmit FIFO underrun error or IDMA  read transfer error. Interrupt flag is cleared by  writing corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC2_STAR_RXOVERR, 1 << 5   @ bitWidth 1 (Received FIFO overrun error or IDMA  write transfer error. Interrupt flag is cleared by  writing corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC2_STAR_CMDREND, 1 << 6   @ bitWidth 1 (Command response received CRC check  passed, or no CRC. Interrupt flag is cleared by  writing corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC2_STAR_CMDSENT, 1 << 7   @ bitWidth 1 (Command sent no response required.  Interrupt flag is cleared by writing corresponding  interrupt clear bit in SDMMC_ICR.)  
        .equ SDMMC2_STAR_DATAEND, 1 << 8   @ bitWidth 1 (Data transfer ended correctly. data  counter, DATACOUNT is zero and no errors occur.  Interrupt flag is cleared by writing corresponding  interrupt clear bit in SDMMC_ICR.)  
        .equ SDMMC2_STAR_DHOLD, 1 << 9   @ bitWidth 1 (Data transfer Hold. Interrupt flag is  cleared by writing corresponding interrupt clear bit  in SDMMC_ICR.)  
        .equ SDMMC2_STAR_DBCKEND, 1 << 10   @ bitWidth 1 (Data block sent/received. CRC check  passed and DPSM moves to the READWAIT state.  Interrupt flag is cleared by writing corresponding  interrupt clear bit in SDMMC_ICR.)  
        .equ SDMMC2_STAR_DABORT, 1 << 11   @ bitWidth 1 (Data transfer aborted by CMD12.  Interrupt flag is cleared by writing corresponding  interrupt clear bit in SDMMC_ICR.)  
        .equ SDMMC2_STAR_DPSMACT, 1 << 12   @ bitWidth 1 (Data path state machine active, i.e. not  in Idle state. This is a hardware status flag only,  does not generate an interrupt.)  
        .equ SDMMC2_STAR_CPSMACT, 1 << 13   @ bitWidth 1 (Command path state machine active, i.e.  not in Idle state. This is a hardware status flag  only, does not generate an interrupt.)  
        .equ SDMMC2_STAR_TXFIFOHE, 1 << 14   @ bitWidth 1 (Transmit FIFO half empty At least half  the number of words can be written into the FIFO.  This bit is cleared when the FIFO becomes half+1  full.)  
        .equ SDMMC2_STAR_RXFIFOHF, 1 << 15   @ bitWidth 1 (Receive FIFO half full There are at  least half the number of words in the FIFO. This bit  is cleared when the FIFO becomes half+1  empty.)  
        .equ SDMMC2_STAR_TXFIFOF, 1 << 16   @ bitWidth 1 (Transmit FIFO full This is a hardware  status flag only, does not generate an interrupt.  This bit is cleared when one FIFO location becomes  empty.)  
        .equ SDMMC2_STAR_RXFIFOF, 1 << 17   @ bitWidth 1 (Receive FIFO full This bit is cleared  when one FIFO location becomes empty.)  
        .equ SDMMC2_STAR_TXFIFOE, 1 << 18   @ bitWidth 1 (Transmit FIFO empty This bit is cleared  when one FIFO location becomes full.)  
        .equ SDMMC2_STAR_RXFIFOE, 1 << 19   @ bitWidth 1 (Receive FIFO empty This is a hardware  status flag only, does not generate an interrupt.  This bit is cleared when one FIFO location becomes  full.)  
        .equ SDMMC2_STAR_BUSYD0, 1 << 20   @ bitWidth 1 (Inverted value of SDMMC_D0 line Busy,  sampled at the end of a CMD response and a second  time 2 SDMMC_CK cycles after the CMD response. This  bit is reset to not busy when the SDMMCD0 line  changes from busy to not busy. This bit does not  signal busy due to data transfer. This is a hardware  status flag only, it does not generate an  interrupt.)  
        .equ SDMMC2_STAR_BUSYD0END, 1 << 21   @ bitWidth 1 (end of SDMMC_D0 Busy following a CMD  response detected. This indicates only end of busy  following a CMD response. This bit does not signal  busy due to data transfer. Interrupt flag is cleared  by writing corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC2_STAR_SDIOIT, 1 << 22   @ bitWidth 1 (SDIO interrupt received. Interrupt flag  is cleared by writing corresponding interrupt clear  bit in SDMMC_ICR.)  
        .equ SDMMC2_STAR_ACKFAIL, 1 << 23   @ bitWidth 1 (Boot acknowledgment received boot  acknowledgment check fail. Interrupt flag is cleared  by writing corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC2_STAR_ACKTIMEOUT, 1 << 24   @ bitWidth 1 (Boot acknowledgment timeout. Interrupt  flag is cleared by writing corresponding interrupt  clear bit in SDMMC_ICR.)  
        .equ SDMMC2_STAR_VSWEND, 1 << 25   @ bitWidth 1 (Voltage switch critical timing section  completion. Interrupt flag is cleared by writing  corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC2_STAR_CKSTOP, 1 << 26   @ bitWidth 1 (SDMMC_CK stopped in Voltage switch  procedure. Interrupt flag is cleared by writing  corresponding interrupt clear bit in  SDMMC_ICR.)  
        .equ SDMMC2_STAR_IDMATE, 1 << 27   @ bitWidth 1 (IDMA transfer error. Interrupt flag is  cleared by writing corresponding interrupt clear bit  in SDMMC_ICR.)  
        .equ SDMMC2_STAR_IDMABTC, 1 << 28   @ bitWidth 1 (IDMA buffer transfer complete. interrupt  flag is cleared by writing corresponding interrupt  clear bit in SDMMC_ICR.)  
 
    .equ SDMMC2_ICR, SDMMC2_BASE + 0x38 @ (The SDMMC_ICR register is a write-only  register. Writing a bit with 1 clears the corresponding  bit in the SDMMC_STAR status register.) 
        .equ SDMMC2_ICR_CCRCFAILC, 1 << 0   @ bitWidth 1 (CCRCFAIL flag clear bit Set by software  to clear the CCRCFAIL flag.)  
        .equ SDMMC2_ICR_DCRCFAILC, 1 << 1   @ bitWidth 1 (DCRCFAIL flag clear bit Set by software  to clear the DCRCFAIL flag.)  
        .equ SDMMC2_ICR_CTIMEOUTC, 1 << 2   @ bitWidth 1 (CTIMEOUT flag clear bit Set by software  to clear the CTIMEOUT flag.)  
        .equ SDMMC2_ICR_DTIMEOUTC, 1 << 3   @ bitWidth 1 (DTIMEOUT flag clear bit Set by software  to clear the DTIMEOUT flag.)  
        .equ SDMMC2_ICR_TXUNDERRC, 1 << 4   @ bitWidth 1 (TXUNDERR flag clear bit Set by software  to clear TXUNDERR flag.)  
        .equ SDMMC2_ICR_RXOVERRC, 1 << 5   @ bitWidth 1 (RXOVERR flag clear bit Set by software  to clear the RXOVERR flag.)  
        .equ SDMMC2_ICR_CMDRENDC, 1 << 6   @ bitWidth 1 (CMDREND flag clear bit Set by software  to clear the CMDREND flag.)  
        .equ SDMMC2_ICR_CMDSENTC, 1 << 7   @ bitWidth 1 (CMDSENT flag clear bit Set by software  to clear the CMDSENT flag.)  
        .equ SDMMC2_ICR_DATAENDC, 1 << 8   @ bitWidth 1 (DATAEND flag clear bit Set by software  to clear the DATAEND flag.)  
        .equ SDMMC2_ICR_DHOLDC, 1 << 9   @ bitWidth 1 (DHOLD flag clear bit Set by software to  clear the DHOLD flag.)  
        .equ SDMMC2_ICR_DBCKENDC, 1 << 10   @ bitWidth 1 (DBCKEND flag clear bit Set by software  to clear the DBCKEND flag.)  
        .equ SDMMC2_ICR_DABORTC, 1 << 11   @ bitWidth 1 (DABORT flag clear bit Set by software to  clear the DABORT flag.)  
        .equ SDMMC2_ICR_BUSYD0ENDC, 1 << 21   @ bitWidth 1 (BUSYD0END flag clear bit Set by software  to clear the BUSYD0END flag.)  
        .equ SDMMC2_ICR_SDIOITC, 1 << 22   @ bitWidth 1 (SDIOIT flag clear bit Set by software to  clear the SDIOIT flag.)  
        .equ SDMMC2_ICR_ACKFAILC, 1 << 23   @ bitWidth 1 (ACKFAIL flag clear bit Set by software  to clear the ACKFAIL flag.)  
        .equ SDMMC2_ICR_ACKTIMEOUTC, 1 << 24   @ bitWidth 1 (ACKTIMEOUT flag clear bit Set by  software to clear the ACKTIMEOUT flag.)  
        .equ SDMMC2_ICR_VSWENDC, 1 << 25   @ bitWidth 1 (VSWEND flag clear bit Set by software to  clear the VSWEND flag.)  
        .equ SDMMC2_ICR_CKSTOPC, 1 << 26   @ bitWidth 1 (CKSTOP flag clear bit Set by software to  clear the CKSTOP flag.)  
        .equ SDMMC2_ICR_IDMATEC, 1 << 27   @ bitWidth 1 (IDMA transfer error clear bit Set by  software to clear the IDMATE flag.)  
        .equ SDMMC2_ICR_IDMABTCC, 1 << 28   @ bitWidth 1 (IDMA buffer transfer complete clear bit  Set by software to clear the IDMABTC  flag.)  
 
    .equ SDMMC2_MASKR, SDMMC2_BASE + 0x3C @ (The interrupt mask register determines which  status flags generate an interrupt request by setting the  corresponding bit to 1.) 
        .equ SDMMC2_MASKR_CCRCFAILIE, 1 << 0   @ bitWidth 1 (Command CRC fail interrupt enable Set  and cleared by software to enable/disable interrupt  caused by command CRC failure.)  
        .equ SDMMC2_MASKR_DCRCFAILIE, 1 << 1   @ bitWidth 1 (Data CRC fail interrupt enable Set and  cleared by software to enable/disable interrupt  caused by data CRC failure.)  
        .equ SDMMC2_MASKR_CTIMEOUTIE, 1 << 2   @ bitWidth 1 (Command timeout interrupt enable Set and  cleared by software to enable/disable interrupt  caused by command timeout.)  
        .equ SDMMC2_MASKR_DTIMEOUTIE, 1 << 3   @ bitWidth 1 (Data timeout interrupt enable Set and  cleared by software to enable/disable interrupt  caused by data timeout.)  
        .equ SDMMC2_MASKR_TXUNDERRIE, 1 << 4   @ bitWidth 1 (Tx FIFO underrun error interrupt enable  Set and cleared by software to enable/disable  interrupt caused by Tx FIFO underrun  error.)  
        .equ SDMMC2_MASKR_RXOVERRIE, 1 << 5   @ bitWidth 1 (Rx FIFO overrun error interrupt enable  Set and cleared by software to enable/disable  interrupt caused by Rx FIFO overrun  error.)  
        .equ SDMMC2_MASKR_CMDRENDIE, 1 << 6   @ bitWidth 1 (Command response received interrupt  enable Set and cleared by software to enable/disable  interrupt caused by receiving command  response.)  
        .equ SDMMC2_MASKR_CMDSENTIE, 1 << 7   @ bitWidth 1 (Command sent interrupt enable Set and  cleared by software to enable/disable interrupt  caused by sending command.)  
        .equ SDMMC2_MASKR_DATAENDIE, 1 << 8   @ bitWidth 1 (Data end interrupt enable Set and  cleared by software to enable/disable interrupt  caused by data end.)  
        .equ SDMMC2_MASKR_DHOLDIE, 1 << 9   @ bitWidth 1 (Data hold interrupt enable Set and  cleared by software to enable/disable the interrupt  generated when sending new data is hold in the DPSM  Wait_S state.)  
        .equ SDMMC2_MASKR_DBCKENDIE, 1 << 10   @ bitWidth 1 (Data block end interrupt enable Set and  cleared by software to enable/disable interrupt  caused by data block end.)  
        .equ SDMMC2_MASKR_DABORTIE, 1 << 11   @ bitWidth 1 (Data transfer aborted interrupt enable  Set and cleared by software to enable/disable  interrupt caused by a data transfer being  aborted.)  
        .equ SDMMC2_MASKR_TXFIFOHEIE, 1 << 14   @ bitWidth 1 (Tx FIFO half empty interrupt enable Set  and cleared by software to enable/disable interrupt  caused by Tx FIFO half empty.)  
        .equ SDMMC2_MASKR_RXFIFOHFIE, 1 << 15   @ bitWidth 1 (Rx FIFO half full interrupt enable Set  and cleared by software to enable/disable interrupt  caused by Rx FIFO half full.)  
        .equ SDMMC2_MASKR_RXFIFOFIE, 1 << 17   @ bitWidth 1 (Rx FIFO full interrupt enable Set and  cleared by software to enable/disable interrupt  caused by Rx FIFO full.)  
        .equ SDMMC2_MASKR_TXFIFOEIE, 1 << 18   @ bitWidth 1 (Tx FIFO empty interrupt enable Set and  cleared by software to enable/disable interrupt  caused by Tx FIFO empty.)  
        .equ SDMMC2_MASKR_BUSYD0ENDIE, 1 << 21   @ bitWidth 1 (BUSYD0END interrupt enable Set and  cleared by software to enable/disable the interrupt  generated when SDMMC_D0 signal changes from busy to  NOT busy following a CMD response.)  
        .equ SDMMC2_MASKR_SDIOITIE, 1 << 22   @ bitWidth 1 (SDIO mode interrupt received interrupt  enable Set and cleared by software to enable/disable  the interrupt generated when receiving the SDIO mode  interrupt.)  
        .equ SDMMC2_MASKR_ACKFAILIE, 1 << 23   @ bitWidth 1 (Acknowledgment Fail interrupt enable Set  and cleared by software to enable/disable interrupt  caused by acknowledgment Fail.)  
        .equ SDMMC2_MASKR_ACKTIMEOUTIE, 1 << 24   @ bitWidth 1 (Acknowledgment timeout interrupt enable  Set and cleared by software to enable/disable  interrupt caused by acknowledgment  timeout.)  
        .equ SDMMC2_MASKR_VSWENDIE, 1 << 25   @ bitWidth 1 (Voltage switch critical timing section  completion interrupt enable Set and cleared by  software to enable/disable the interrupt generated  when voltage switch critical timing section  completion.)  
        .equ SDMMC2_MASKR_CKSTOPIE, 1 << 26   @ bitWidth 1 (Voltage Switch clock stopped interrupt  enable Set and cleared by software to enable/disable  interrupt caused by Voltage Switch clock  stopped.)  
        .equ SDMMC2_MASKR_IDMABTCIE, 1 << 28   @ bitWidth 1 (IDMA buffer transfer complete interrupt  enable Set and cleared by software to enable/disable  the interrupt generated when the IDMA has transferred  all data belonging to a memory buffer.)  
 
    .equ SDMMC2_ACKTIMER, SDMMC2_BASE + 0x40 @ (The SDMMC_ACKTIMER register contains the  acknowledgment timeout period, in SDMMC_CK bus clock  periods. A counter loads the value from the  SDMMC_ACKTIMER register, and starts decrementing when the  data path state machine DPSM enters the Wait_Ack state.  If the timer reaches 0 while the DPSM is in this states,  the acknowledgment timeout status flag is  set.) 
        .equ SDMMC2_ACKTIMER_ACKTIME_Shift, 0   @ bitWidth 25 (Boot acknowledgment timeout period This  bit can only be written by firmware when CPSM is  disabled CPSMEN = 0. Boot acknowledgment timeout  period expressed in card bus clock  periods.)  
 
    .equ SDMMC2_IDMACTRLR, SDMMC2_BASE + 0x50 @ (The receive and transmit FIFOs can be read  or written as 32-bit wide registers. The FIFOs contain 32  entries on 32 sequential addresses. This allows the CPU  to use its load and store multiple operands to read  from/write to the FIFO.) 
        .equ SDMMC2_IDMACTRLR_IDMAEN, 1 << 0   @ bitWidth 1 (IDMA enable This bit can only be written  by firmware when DPSM is inactive DPSMACT =  0.)  
        .equ SDMMC2_IDMACTRLR_IDMABMODE, 1 << 1   @ bitWidth 1 (Buffer mode selection. This bit can only  be written by firmware when DPSM is inactive DPSMACT  = 0.)  
        .equ SDMMC2_IDMACTRLR_IDMABACT, 1 << 2   @ bitWidth 1 (Double buffer mode active buffer  indication This bit can only be written by firmware  when DPSM is inactive DPSMACT = 0. When IDMA is  enabled this bit is toggled by  hardware.)  
 
    .equ SDMMC2_IDMABSIZER, SDMMC2_BASE + 0x54 @ (The SDMMC_IDMABSIZER register contains the  buffers size when in double buffer  configuration.) 
        .equ SDMMC2_IDMABSIZER_IDMABNDT_Shift, 5   @ bitWidth 8 (Number of transfers per buffer. This  8-bit value shall be multiplied by 8 to get the size  of the buffer in 32-bit words and by 32 to get the  size of the buffer in bytes. Example: IDMABNDT =  0x01: buffer size = 8 words = 32 bytes. These bits  can only be written by firmware when DPSM is inactive  DPSMACT = 0.)  
 
    .equ SDMMC2_IDMABASE0R, SDMMC2_BASE + 0x58 @ (The SDMMC_IDMABASE0R register contains the  memory buffer base address in single buffer configuration  and the buffer 0 base address in double buffer  configuration.) 
        .equ SDMMC2_IDMABASE0R_IDMABASE0_Shift, 0   @ bitWidth 32 (Buffer 0 memory base address bits  [31:2], shall be word aligned bit [1:0] are always 0  and read only. This register can be written by  firmware when DPSM is inactive DPSMACT = 0, and can  dynamically be written by firmware when DPSM active  DPSMACT = 1 and memory buffer 0 is inactive  IDMABACT = 1.)  
 
    .equ SDMMC2_IDMABASE1R, SDMMC2_BASE + 0x5C @ (The SDMMC_IDMABASE1R register contains the  double buffer configuration second buffer memory base  address.) 
        .equ SDMMC2_IDMABASE1R_IDMABASE1_Shift, 0   @ bitWidth 32 (Buffer 1 memory base address, shall be  word aligned bit [1:0] are always 0 and read only.  This register can be written by firmware when DPSM is  inactive DPSMACT = 0, and can dynamically be  written by firmware when DPSM active DPSMACT = 1  and memory buffer 1 is inactive IDMABACT =  0.)  
 
    .equ SDMMC2_FIFOR, SDMMC2_BASE + 0x80 @ (The receive and transmit FIFOs can be only  read or written as word 32-bit wide registers. The  FIFOs contain 16 entries on sequential addresses. This  allows the CPU to use its load and store multiple  operands to read from/write to the FIFO.When accessing  SDMMC_FIFOR with half word or byte access an AHB bus  fault is generated.) 
        .equ SDMMC2_FIFOR_FIFODATA_Shift, 0   @ bitWidth 32 (Receive and transmit FIFO data This  register can only be read or written by firmware when  the DPSM is active DPSMACT=1. The FIFO data  occupies 16 entries of 32-bit words.)  
 
    .equ SDMMC2_VER, SDMMC2_BASE + 0x3F4 @ (SDMMC IP version register) 
        .equ SDMMC2_VER_MINREV_Shift, 0   @ bitWidth 4 (IP minor revision number.)  
        .equ SDMMC2_VER_MAJREV_Shift, 4   @ bitWidth 4 (IP major revision number.)  
 
    .equ SDMMC2_ID, SDMMC2_BASE + 0x3F8 @ (SDMMC IP identification  register) 
        .equ SDMMC2_ID_IP_ID_Shift, 0   @ bitWidth 32 (SDMMC IP identification.)  
 
    .equ SDMMC2_RESPCMDR, SDMMC2_BASE + 0x10 @ (SDMMC command response  register) 
        .equ SDMMC2_RESPCMDR_RESPCMD_Shift, 0   @ bitWidth 6 (Response command index)  
 

@=========================== VREFBUF ===========================@
.equ VREFBUF_BASE, 0x58003C00 @ (VREFBUF) 
    .equ VREFBUF_CSR, VREFBUF_BASE + 0x0 @ (VREFBUF control and status  register) 
        .equ VREFBUF_CSR_ENVR, 1 << 0   @ bitWidth 1 (Voltage reference buffer mode enable  This bit is used to enable the voltage reference  buffer mode.)  
        .equ VREFBUF_CSR_HIZ, 1 << 1   @ bitWidth 1 (High impedance mode This bit controls  the analog switch to connect or not the VREF+ pin.  Refer to Table196: VREF buffer modes for the mode  descriptions depending on ENVR bit  configuration.)  
        .equ VREFBUF_CSR_VRR, 1 << 3   @ bitWidth 1 (Voltage reference buffer  ready)  
        .equ VREFBUF_CSR_VRS_Shift, 4   @ bitWidth 3 (Voltage reference scale These bits  select the value generated by the voltage reference  buffer. Other: Reserved)  
 
    .equ VREFBUF_CCR, VREFBUF_BASE + 0x4 @ (VREFBUF calibration control  register) 
        .equ VREFBUF_CCR_TRIM_Shift, 0   @ bitWidth 6 (Trimming code These bits are  automatically initialized after reset with the  trimming value stored in the Flash memory during the  production test. Writing into these bits allows to  tune the internal reference buffer  voltage.)  
 

@=========================== IWDG ===========================@
.equ IWDG_BASE, 0x58004800 @ (IWDG) 
    .equ IWDG_KR, IWDG_BASE + 0x0 @ (Key register) 
        .equ IWDG_KR_KEY_Shift, 0   @ bitWidth 16 (Key value write only, read 0x0000  These bits must be written by software at regular  intervals with the key value 0xAAAA, otherwise the  watchdog generates a reset when the counter reaches  0. Writing the key value 0x5555 to enable access to  the IWDG_PR, IWDG_RLR and IWDG_WINR registers see  Section23.3.6: Register access protection Writing  the key value CCCCh starts the watchdog except if  the hardware watchdog option is  selected)  
 
    .equ IWDG_PR, IWDG_BASE + 0x4 @ (Prescaler register) 
        .equ IWDG_PR_PR_Shift, 0   @ bitWidth 3 (Prescaler divider These bits are write  access protected see Section23.3.6: Register access  protection. They are written by software to select  the prescaler divider feeding the counter clock. PVU  bit of IWDG_SR must be reset in order to be able to  change the prescaler divider. Note: Reading this  register returns the prescaler value from the VDD  voltage domain. This value may not be up to  date/valid if a write operation to this register is  ongoing. For this reason the value read from this  register is valid only when the PVU bit in the  IWDG_SR register is reset.)  
 
    .equ IWDG_RLR, IWDG_BASE + 0x8 @ (Reload register) 
        .equ IWDG_RLR_RL_Shift, 0   @ bitWidth 12 (Watchdog counter reload value These bits  are write access protected see Section23.3.6. They  are written by software to define the value to be  loaded in the watchdog counter each time the value  0xAAAA is written in the IWDG_KR register. The  watchdog counter counts down from this value. The  timeout period is a function of this value and the  clock prescaler. Refer to the datasheet for the  timeout information. The RVU bit in the IWDG_SR  register must be reset in order to be able to change  the reload value. Note: Reading this register returns  the reload value from the VDD voltage domain. This  value may not be up to date/valid if a write  operation to this register is ongoing on this  register. For this reason the value read from this  register is valid only when the RVU bit in the  IWDG_SR register is reset.)  
 
    .equ IWDG_SR, IWDG_BASE + 0xC @ (Status register) 
        .equ IWDG_SR_PVU, 1 << 0   @ bitWidth 1 (Watchdog prescaler value update This bit  is set by hardware to indicate that an update of the  prescaler value is ongoing. It is reset by hardware  when the prescaler update operation is completed in  the VDD voltage domain takes up to 5 RC 40 kHz  cycles. Prescaler value can be updated only when PVU  bit is reset.)  
        .equ IWDG_SR_RVU, 1 << 1   @ bitWidth 1 (Watchdog counter reload value update  This bit is set by hardware to indicate that an  update of the reload value is ongoing. It is reset by  hardware when the reload value update operation is  completed in the VDD voltage domain takes up to 5 RC  40 kHz cycles. Reload value can be updated only when  RVU bit is reset.)  
        .equ IWDG_SR_WVU, 1 << 2   @ bitWidth 1 (Watchdog counter window value update  This bit is set by hardware to indicate that an  update of the window value is ongoing. It is reset by  hardware when the reload value update operation is  completed in the VDD voltage domain takes up to 5 RC  40 kHz cycles. Window value can be updated only when  WVU bit is reset. This bit is generated only if  generic window = 1)  
 
    .equ IWDG_WINR, IWDG_BASE + 0x10 @ (Window register) 
        .equ IWDG_WINR_WIN_Shift, 0   @ bitWidth 12 (Watchdog counter window value These bits  are write access protected see Section23.3.6. These  bits contain the high limit of the window value to be  compared to the downcounter. To prevent a reset, the  downcounter must be reloaded when its value is lower  than the window register value and greater than 0x0  The WVU bit in the IWDG_SR register must be reset in  order to be able to change the reload value. Note:  Reading this register returns the reload value from  the VDD voltage domain. This value may not be valid  if a write operation to this register is ongoing. For  this reason the value read from this register is  valid only when the WVU bit in the IWDG_SR register  is reset.)  
 

@=========================== WWDG ===========================@
.equ WWDG_BASE, 0x50003000 @ (WWDG) 
    .equ WWDG_CR, WWDG_BASE + 0x0 @ (Control register) 
        .equ WWDG_CR_T_Shift, 0   @ bitWidth 7 (7-bit counter MSB to LSB These bits  contain the value of the watchdog counter. It is  decremented every 4096 x 2WDGTB[1:0] PCLK cycles. A  reset is produced when it is decremented from 0x40 to  0x3F T6 becomes cleared.)  
        .equ WWDG_CR_WDGA, 1 << 7   @ bitWidth 1 (Activation bit This bit is set by  software and only cleared by hardware after a reset.  When WDGA=1, the watchdog can generate a  reset.)  
 
    .equ WWDG_CFR, WWDG_BASE + 0x4 @ (Configuration register) 
        .equ WWDG_CFR_W_Shift, 0   @ bitWidth 7 (7-bit window value These bits contain  the window value to be compared to the  downcounter.)  
        .equ WWDG_CFR_WDGTB_Shift, 11   @ bitWidth 2 (Timer base The time base of the  prescaler can be modified as follows:)  
        .equ WWDG_CFR_EWI, 1 << 9   @ bitWidth 1 (Early wakeup interrupt When set, an  interrupt occurs whenever the counter reaches the  value 0x40. This interrupt is only cleared by  hardware after a reset.)  
 
    .equ WWDG_SR, WWDG_BASE + 0x8 @ (Status register) 
        .equ WWDG_SR_EWIF, 1 << 0   @ bitWidth 1 (Early wakeup interrupt flag This bit is  set by hardware when the counter has reached the  value 0x40. It must be cleared by software by writing  0. A write of 1 has no effect. This bit is also set  if the interrupt is not enabled.)  
 

@=========================== PWR ===========================@
.equ PWR_BASE, 0x58024800 @ (PWR) 
    .equ PWR_CR1, PWR_BASE + 0x0 @ (PWR control register 1) 
        .equ PWR_CR1_LPDS, 1 << 0   @ bitWidth 1 (Low-power Deepsleep with SVOS3 SVOS4  and SVOS5 always use low-power, regardless of the  setting of this bit)  
        .equ PWR_CR1_PVDE, 1 << 4   @ bitWidth 1 (Programmable voltage detector  enable)  
        .equ PWR_CR1_PLS_Shift, 5   @ bitWidth 3 (Programmable voltage detector level  selection These bits select the voltage threshold  detected by the PVD. Note: Refer to Section  Electrical characteristics of the product datasheet  for more details.)  
        .equ PWR_CR1_DBP, 1 << 8   @ bitWidth 1 (Disable backup domain write protection  In reset state, the RCC_BDCR register, the RTC  registers including the backup registers, BREN and  MOEN bits in PWR_CR2 register, are protected against  parasitic write access. This bit must be set to  enable write access to these registers.)  
        .equ PWR_CR1_FLPS, 1 << 9   @ bitWidth 1 (Flash low-power mode in DStop mode This  bit allows to obtain the best trade-off between  low-power consumption and restart time when exiting  from DStop mode. When it is set, the Flash memory  enters low-power mode when D1 domain is in DStop  mode.)  
        .equ PWR_CR1_SVOS_Shift, 14   @ bitWidth 2 (System Stop mode voltage scaling  selection These bits control the VCORE voltage level  in system Stop mode, to obtain the best trade-off  between power consumption and  performance.)  
        .equ PWR_CR1_AVDEN, 1 << 16   @ bitWidth 1 (Peripheral voltage monitor on VDDA  enable)  
        .equ PWR_CR1_ALS_Shift, 17   @ bitWidth 2 (Analog voltage detector level selection  These bits select the voltage threshold detected by  the AVD.)  
 
    .equ PWR_CSR1, PWR_BASE + 0x4 @ (PWR control status register 1) 
        .equ PWR_CSR1_PVDO, 1 << 4   @ bitWidth 1 (Programmable voltage detect output This  bit is set and cleared by hardware. It is valid only  if the PVD has been enabled by the PVDE bit. Note:  since the PVD is disabled in Standby mode, this bit  is equal to 0 after Standby or reset until the PVDE  bit is set.)  
        .equ PWR_CSR1_ACTVOSRDY, 1 << 13   @ bitWidth 1 (Voltage levels ready bit for currently  used VOS and SDLEVEL This bit is set to 1 by hardware  when the voltage regulator and the SD converter are  both disabled and Bypass mode is selected in PWR  control register 3 PWR_CR3.)  
        .equ PWR_CSR1_ACTVOS_Shift, 14   @ bitWidth 2 (VOS currently applied for VCORE voltage  scaling selection. These bits reflect the last VOS  value applied to the PMU.)  
        .equ PWR_CSR1_AVDO, 1 << 16   @ bitWidth 1 (Analog voltage detector output on VDDA  This bit is set and cleared by hardware. It is valid  only if AVD on VDDA is enabled by the AVDEN bit.  Note: Since the AVD is disabled in Standby mode, this  bit is equal to 0 after Standby or reset until the  AVDEN bit is set.)  
 
    .equ PWR_CR2, PWR_BASE + 0x8 @ (This register is not reset by wakeup from  Standby mode, RESET signal and VDD POR. It is only reset  by VSW POR and VSWRST reset. This register shall not be  accessed when VSWRST bit in RCC_BDCR register resets the  VSW domain.After reset, PWR_CR2 register is  write-protected. Prior to modifying its content, the DBP  bit in PWR_CR1 register must be set to disable the write  protection.) 
        .equ PWR_CR2_BREN, 1 << 0   @ bitWidth 1 (Backup regulator enable When set, the  Backup regulator used to maintain the backup RAM  content in Standby and VBAT modes is enabled. If  BREN is reset, the backup regulator is switched off.  The backup RAM can still be used in Run and Stop  modes. However, its content will be lost in Standby  and VBAT modes. If BREN is set, the application must  wait till the Backup Regulator Ready flag BRRDY is  set to indicate that the data written into the SRAM  will be maintained in Standby and VBAT  modes.)  
        .equ PWR_CR2_MONEN, 1 << 4   @ bitWidth 1 (VBAT and temperature monitoring enable  When set, the VBAT supply and temperature monitoring  is enabled.)  
        .equ PWR_CR2_BRRDY, 1 << 16   @ bitWidth 1 (Backup regulator ready This bit is set  by hardware to indicate that the Backup regulator is  ready.)  
        .equ PWR_CR2_VBATL, 1 << 20   @ bitWidth 1 (VBAT level monitoring versus low  threshold)  
        .equ PWR_CR2_VBATH, 1 << 21   @ bitWidth 1 (VBAT level monitoring versus high  threshold)  
        .equ PWR_CR2_TEMPL, 1 << 22   @ bitWidth 1 (Temperature level monitoring versus low  threshold)  
        .equ PWR_CR2_TEMPH, 1 << 23   @ bitWidth 1 (Temperature level monitoring versus high  threshold)  
 
    .equ PWR_CR3, PWR_BASE + 0xC @ (Reset only by POR only, not reset by wakeup  from Standby mode and RESET pad. The lower byte of this  register is written once after POR and shall be written  before changing VOS level or ck_sys clock frequency. No  limitation applies to the upper bytes.Programming data  corresponding to an invalid combination of SDLEVEL,  SDEXTHP, SDEN, LDOEN and BYPASS bits see Table9 will be  ignored: data will not be written, the written-once  mechanism will lock the register and any further write  access will be ignored. The default supply configuration  will be kept and the ACTVOSRDY bit in PWR control status  register 1 PWR_CSR1 will go on indicating invalid  voltage levels. The system shall be power cycled before  writing a new value.) 
        .equ PWR_CR3_BYPASS, 1 << 0   @ bitWidth 1 (Power management unit  bypass)  
        .equ PWR_CR3_LDOEN, 1 << 1   @ bitWidth 1 (Low drop-out regulator  enable)  
        .equ PWR_CR3_SCUEN, 1 << 2   @ bitWidth 1 (SD converter Enable)  
        .equ PWR_CR3_VBE, 1 << 8   @ bitWidth 1 (VBAT charging enable)  
        .equ PWR_CR3_VBRS, 1 << 9   @ bitWidth 1 (VBAT charging resistor  selection)  
        .equ PWR_CR3_USB33DEN, 1 << 24   @ bitWidth 1 (VDD33USB voltage level detector  enable.)  
        .equ PWR_CR3_USBREGEN, 1 << 25   @ bitWidth 1 (USB regulator enable.)  
        .equ PWR_CR3_USB33RDY, 1 << 26   @ bitWidth 1 (USB supply ready.)  
 
    .equ PWR_CPUCR, PWR_BASE + 0x10 @ (This register allows controlling CPU1  power.) 
        .equ PWR_CPUCR_PDDS_D1, 1 << 0   @ bitWidth 1 (D1 domain Power Down Deepsleep  selection. This bit allows CPU1 to define the  Deepsleep mode for D1 domain.)  
        .equ PWR_CPUCR_PDDS_D2, 1 << 1   @ bitWidth 1 (D2 domain Power Down Deepsleep. This bit  allows CPU1 to define the Deepsleep mode for D2  domain.)  
        .equ PWR_CPUCR_PDDS_D3, 1 << 2   @ bitWidth 1 (System D3 domain Power Down Deepsleep.  This bit allows CPU1 to define the Deepsleep mode for  System D3 domain.)  
        .equ PWR_CPUCR_STOPF, 1 << 5   @ bitWidth 1 (STOP flag This bit is set by hardware  and cleared only by any reset or by setting the CPU1  CSSF bit.)  
        .equ PWR_CPUCR_SBF, 1 << 6   @ bitWidth 1 (System Standby flag This bit is set by  hardware and cleared only by a POR Power-on Reset  or by setting the CPU1 CSSF bit)  
        .equ PWR_CPUCR_SBF_D1, 1 << 7   @ bitWidth 1 (D1 domain DStandby flag This bit is set  by hardware and cleared by any system reset or by  setting the CPU1 CSSF bit. Once set, this bit can be  cleared only when the D1 domain is no longer in  DStandby mode.)  
        .equ PWR_CPUCR_SBF_D2, 1 << 8   @ bitWidth 1 (D2 domain DStandby flag This bit is set  by hardware and cleared by any system reset or by  setting the CPU1 CSSF bit. Once set, this bit can be  cleared only when the D2 domain is no longer in  DStandby mode.)  
        .equ PWR_CPUCR_CSSF, 1 << 9   @ bitWidth 1 (Clear D1 domain CPU1 Standby, Stop and  HOLD flags always read as 0 This bit is cleared to  0 by hardware.)  
        .equ PWR_CPUCR_RUN_D3, 1 << 11   @ bitWidth 1 (Keep system D3 domain in Run mode  regardless of the CPU sub-systems modes)  
 
    .equ PWR_D3CR, PWR_BASE + 0x18 @ (This register allows controlling D3 domain  power.Following reset VOSRDY will be read 1 by  software) 
        .equ PWR_D3CR_VOSRDY, 1 << 13   @ bitWidth 1 (VOS Ready bit for VCORE voltage scaling  output selection. This bit is set to 1 by hardware  when Bypass mode is selected in PWR control register  3 PWR_CR3.)  
        .equ PWR_D3CR_VOS_Shift, 14   @ bitWidth 2 (Voltage scaling selection according to  performance These bits control the VCORE voltage  level and allow to obtains the best trade-off between  power consumption and performance: When increasing  the performance, the voltage scaling shall be changed  before increasing the system frequency. When  decreasing performance, the system frequency shall  first be decreased before changing the voltage  scaling.)  
 
    .equ PWR_WKUPCR, PWR_BASE + 0x20 @ (reset only by system reset, not reset by  wakeup from Standby mode5 wait states are required when  writing this register when clearing a WKUPF bit in  PWR_WKUPFR, the AHB write access will complete after the  WKUPF has been cleared.) 
        .equ PWR_WKUPCR_WKUPC_Shift, 0   @ bitWidth 6 (Clear Wakeup pin flag for WKUP. These  bits are always read as 0.)  
 
    .equ PWR_WKUPFR, PWR_BASE + 0x24 @ (reset only by system reset, not reset by  wakeup from Standby mode) 
        .equ PWR_WKUPFR_WKUPF1, 1 << 0   @ bitWidth 1 (Wakeup pin WKUPF flag. This bit is set  by hardware and cleared only by a Reset pin or by  setting the WKUPCn+1 bit in the PWR wakeup clear  register PWR_WKUPCR.)  
        .equ PWR_WKUPFR_WKUPF2, 1 << 1   @ bitWidth 1 (Wakeup pin WKUPF flag. This bit is set  by hardware and cleared only by a Reset pin or by  setting the WKUPCn+1 bit in the PWR wakeup clear  register PWR_WKUPCR.)  
        .equ PWR_WKUPFR_WKUPF3, 1 << 2   @ bitWidth 1 (Wakeup pin WKUPF flag. This bit is set  by hardware and cleared only by a Reset pin or by  setting the WKUPCn+1 bit in the PWR wakeup clear  register PWR_WKUPCR.)  
        .equ PWR_WKUPFR_WKUPF4, 1 << 3   @ bitWidth 1 (Wakeup pin WKUPF flag. This bit is set  by hardware and cleared only by a Reset pin or by  setting the WKUPCn+1 bit in the PWR wakeup clear  register PWR_WKUPCR.)  
        .equ PWR_WKUPFR_WKUPF5, 1 << 4   @ bitWidth 1 (Wakeup pin WKUPF flag. This bit is set  by hardware and cleared only by a Reset pin or by  setting the WKUPCn+1 bit in the PWR wakeup clear  register PWR_WKUPCR.)  
        .equ PWR_WKUPFR_WKUPF6, 1 << 5   @ bitWidth 1 (Wakeup pin WKUPF flag. This bit is set  by hardware and cleared only by a Reset pin or by  setting the WKUPCn+1 bit in the PWR wakeup clear  register PWR_WKUPCR.)  
 
    .equ PWR_WKUPEPR, PWR_BASE + 0x28 @ (Reset only by system reset, not reset by  wakeup from Standby mode) 
        .equ PWR_WKUPEPR_WKUPEN1, 1 << 0   @ bitWidth 1 (Enable Wakeup Pin WKUPn+1 Each bit is  set and cleared by software. Note: An additional  wakeup event is detected if WKUPn+1 pin is enabled  by setting the WKUPENn+1 bit when WKUPn+1 pin level  is already high when WKUPPn+1 selects rising edge, or  low when WKUPPn+1 selects falling edge.)  
        .equ PWR_WKUPEPR_WKUPEN2, 1 << 1   @ bitWidth 1 (Enable Wakeup Pin WKUPn+1 Each bit is  set and cleared by software. Note: An additional  wakeup event is detected if WKUPn+1 pin is enabled  by setting the WKUPENn+1 bit when WKUPn+1 pin level  is already high when WKUPPn+1 selects rising edge, or  low when WKUPPn+1 selects falling edge.)  
        .equ PWR_WKUPEPR_WKUPEN3, 1 << 2   @ bitWidth 1 (Enable Wakeup Pin WKUPn+1 Each bit is  set and cleared by software. Note: An additional  wakeup event is detected if WKUPn+1 pin is enabled  by setting the WKUPENn+1 bit when WKUPn+1 pin level  is already high when WKUPPn+1 selects rising edge, or  low when WKUPPn+1 selects falling edge.)  
        .equ PWR_WKUPEPR_WKUPEN4, 1 << 3   @ bitWidth 1 (Enable Wakeup Pin WKUPn+1 Each bit is  set and cleared by software. Note: An additional  wakeup event is detected if WKUPn+1 pin is enabled  by setting the WKUPENn+1 bit when WKUPn+1 pin level  is already high when WKUPPn+1 selects rising edge, or  low when WKUPPn+1 selects falling edge.)  
        .equ PWR_WKUPEPR_WKUPEN5, 1 << 4   @ bitWidth 1 (Enable Wakeup Pin WKUPn+1 Each bit is  set and cleared by software. Note: An additional  wakeup event is detected if WKUPn+1 pin is enabled  by setting the WKUPENn+1 bit when WKUPn+1 pin level  is already high when WKUPPn+1 selects rising edge, or  low when WKUPPn+1 selects falling edge.)  
        .equ PWR_WKUPEPR_WKUPEN6, 1 << 5   @ bitWidth 1 (Enable Wakeup Pin WKUPn+1 Each bit is  set and cleared by software. Note: An additional  wakeup event is detected if WKUPn+1 pin is enabled  by setting the WKUPENn+1 bit when WKUPn+1 pin level  is already high when WKUPPn+1 selects rising edge, or  low when WKUPPn+1 selects falling edge.)  
        .equ PWR_WKUPEPR_WKUPP1, 1 << 8   @ bitWidth 1 (Wakeup pin polarity bit for WKUPn-7  These bits define the polarity used for event  detection on WKUPn-7 external wakeup  pin.)  
        .equ PWR_WKUPEPR_WKUPP2, 1 << 9   @ bitWidth 1 (Wakeup pin polarity bit for WKUPn-7  These bits define the polarity used for event  detection on WKUPn-7 external wakeup  pin.)  
        .equ PWR_WKUPEPR_WKUPP3, 1 << 10   @ bitWidth 1 (Wakeup pin polarity bit for WKUPn-7  These bits define the polarity used for event  detection on WKUPn-7 external wakeup  pin.)  
        .equ PWR_WKUPEPR_WKUPP4, 1 << 11   @ bitWidth 1 (Wakeup pin polarity bit for WKUPn-7  These bits define the polarity used for event  detection on WKUPn-7 external wakeup  pin.)  
        .equ PWR_WKUPEPR_WKUPP5, 1 << 12   @ bitWidth 1 (Wakeup pin polarity bit for WKUPn-7  These bits define the polarity used for event  detection on WKUPn-7 external wakeup  pin.)  
        .equ PWR_WKUPEPR_WKUPP6, 1 << 13   @ bitWidth 1 (Wakeup pin polarity bit for WKUPn-7  These bits define the polarity used for event  detection on WKUPn-7 external wakeup  pin.)  
        .equ PWR_WKUPEPR_WKUPPUPD1_Shift, 16   @ bitWidth 2 (Wakeup pin pull  configuration)  
        .equ PWR_WKUPEPR_WKUPPUPD2_Shift, 18   @ bitWidth 2 (Wakeup pin pull  configuration)  
        .equ PWR_WKUPEPR_WKUPPUPD3_Shift, 20   @ bitWidth 2 (Wakeup pin pull  configuration)  
        .equ PWR_WKUPEPR_WKUPPUPD4_Shift, 22   @ bitWidth 2 (Wakeup pin pull  configuration)  
        .equ PWR_WKUPEPR_WKUPPUPD5_Shift, 24   @ bitWidth 2 (Wakeup pin pull  configuration)  
        .equ PWR_WKUPEPR_WKUPPUPD6_Shift, 26   @ bitWidth 2 (Wakeup pin pull configuration for  WKUPtruncaten/2-7 These bits define the I/O pad  pull configuration used when WKUPENtruncaten/2-7  = 1. The associated GPIO port pull configuration  shall be set to the same value or to 00. The Wakeup  pin pull configuration is kept in Standby  mode.)  
 

@=========================== SPI1 ===========================@
.equ SPI1_BASE, 0x40013000 @ (Serial peripheral interface) 
    .equ SPI1_CR1, SPI1_BASE + 0x0 @ (control register 1) 
        .equ SPI1_CR1_IOLOCK, 1 << 16   @ bitWidth 1 (Locking the AF configuration of  associated IOs)  
        .equ SPI1_CR1_TCRCI, 1 << 15   @ bitWidth 1 (CRC calculation initialization pattern  control for transmitter)  
        .equ SPI1_CR1_RCRCI, 1 << 14   @ bitWidth 1 (CRC calculation initialization pattern  control for receiver)  
        .equ SPI1_CR1_CRC33_17, 1 << 13   @ bitWidth 1 (32-bit CRC polynomial  configuration)  
        .equ SPI1_CR1_SSI, 1 << 12   @ bitWidth 1 (Internal SS signal input  level)  
        .equ SPI1_CR1_HDDIR, 1 << 11   @ bitWidth 1 (Rx/Tx direction at Half-duplex  mode)  
        .equ SPI1_CR1_CSUSP, 1 << 10   @ bitWidth 1 (Master SUSPend request)  
        .equ SPI1_CR1_CSTART, 1 << 9   @ bitWidth 1 (Master transfer start)  
        .equ SPI1_CR1_MASRX, 1 << 8   @ bitWidth 1 (Master automatic SUSP in Receive  mode)  
        .equ SPI1_CR1_SPE, 1 << 0   @ bitWidth 1 (Serial Peripheral Enable)  
 
    .equ SPI1_CR2, SPI1_BASE + 0x4 @ (control register 2) 
        .equ SPI1_CR2_TSER_Shift, 16   @ bitWidth 16 (Number of data transfer extension to be  reload into TSIZE just when a previous)  
        .equ SPI1_CR2_TSIZE_Shift, 0   @ bitWidth 16 (Number of data at current  transfer)  
 
    .equ SPI1_CFG1, SPI1_BASE + 0x8 @ (configuration register 1) 
        .equ SPI1_CFG1_MBR_Shift, 28   @ bitWidth 3 (Master baud rate)  
        .equ SPI1_CFG1_CRCEN, 1 << 22   @ bitWidth 1 (Hardware CRC computation  enable)  
        .equ SPI1_CFG1_CRCSIZE_Shift, 16   @ bitWidth 5 (Length of CRC frame to be transacted and  compared)  
        .equ SPI1_CFG1_TXDMAEN, 1 << 15   @ bitWidth 1 (Tx DMA stream enable)  
        .equ SPI1_CFG1_RXDMAEN, 1 << 14   @ bitWidth 1 (Rx DMA stream enable)  
        .equ SPI1_CFG1_UDRDET_Shift, 11   @ bitWidth 2 (Detection of underrun condition at slave  transmitter)  
        .equ SPI1_CFG1_UDRCFG_Shift, 9   @ bitWidth 2 (Behavior of slave transmitter at  underrun condition)  
        .equ SPI1_CFG1_FTHVL_Shift, 5   @ bitWidth 4 (threshold level)  
        .equ SPI1_CFG1_DSIZE_Shift, 0   @ bitWidth 5 (Number of bits in at single SPI data  frame)  
 
    .equ SPI1_CFG2, SPI1_BASE + 0xC @ (configuration register 2) 
        .equ SPI1_CFG2_AFCNTR, 1 << 31   @ bitWidth 1 (Alternate function GPIOs  control)  
        .equ SPI1_CFG2_SSOM, 1 << 30   @ bitWidth 1 (SS output management in master  mode)  
        .equ SPI1_CFG2_SSOE, 1 << 29   @ bitWidth 1 (SS output enable)  
        .equ SPI1_CFG2_SSIOP, 1 << 28   @ bitWidth 1 (SS input/output polarity)  
        .equ SPI1_CFG2_SSM, 1 << 26   @ bitWidth 1 (Software management of SS signal  input)  
        .equ SPI1_CFG2_CPOL, 1 << 25   @ bitWidth 1 (Clock polarity)  
        .equ SPI1_CFG2_CPHA, 1 << 24   @ bitWidth 1 (Clock phase)  
        .equ SPI1_CFG2_LSBFRST, 1 << 23   @ bitWidth 1 (Data frame format)  
        .equ SPI1_CFG2_MASTER, 1 << 22   @ bitWidth 1 (SPI Master)  
        .equ SPI1_CFG2_SP_Shift, 19   @ bitWidth 3 (Serial Protocol)  
        .equ SPI1_CFG2_COMM_Shift, 17   @ bitWidth 2 (SPI Communication Mode)  
        .equ SPI1_CFG2_IOSWP, 1 << 15   @ bitWidth 1 (Swap functionality of MISO and MOSI  pins)  
        .equ SPI1_CFG2_MIDI_Shift, 4   @ bitWidth 4 (Master Inter-Data Idleness)  
        .equ SPI1_CFG2_MSSI_Shift, 0   @ bitWidth 4 (Master SS Idleness)  
 
    .equ SPI1_IER, SPI1_BASE + 0x10 @ (Interrupt Enable Register) 
        .equ SPI1_IER_TSERFIE, 1 << 10   @ bitWidth 1 (Additional number of transactions reload  interrupt enable)  
        .equ SPI1_IER_MODFIE, 1 << 9   @ bitWidth 1 (Mode Fault interrupt  enable)  
        .equ SPI1_IER_TIFREIE, 1 << 8   @ bitWidth 1 (TIFRE interrupt enable)  
        .equ SPI1_IER_CRCEIE, 1 << 7   @ bitWidth 1 (CRC Interrupt enable)  
        .equ SPI1_IER_OVRIE, 1 << 6   @ bitWidth 1 (OVR interrupt enable)  
        .equ SPI1_IER_UDRIE, 1 << 5   @ bitWidth 1 (UDR interrupt enable)  
        .equ SPI1_IER_TXTFIE, 1 << 4   @ bitWidth 1 (TXTFIE interrupt enable)  
        .equ SPI1_IER_EOTIE, 1 << 3   @ bitWidth 1 (EOT, SUSP and TXC interrupt  enable)  
        .equ SPI1_IER_DPXPIE, 1 << 2   @ bitWidth 1 (DXP interrupt enabled)  
        .equ SPI1_IER_TXPIE, 1 << 1   @ bitWidth 1 (TXP interrupt enable)  
        .equ SPI1_IER_RXPIE, 1 << 0   @ bitWidth 1 (RXP Interrupt Enable)  
 
    .equ SPI1_SR, SPI1_BASE + 0x14 @ (Status Register) 
        .equ SPI1_SR_CTSIZE_Shift, 16   @ bitWidth 16 (Number of data frames remaining in  current TSIZE session)  
        .equ SPI1_SR_RXWNE, 1 << 15   @ bitWidth 1 (RxFIFO Word Not Empty)  
        .equ SPI1_SR_RXPLVL_Shift, 13   @ bitWidth 2 (RxFIFO Packing LeVeL)  
        .equ SPI1_SR_TXC, 1 << 12   @ bitWidth 1 (TxFIFO transmission  complete)  
        .equ SPI1_SR_SUSP, 1 << 11   @ bitWidth 1 (SUSPend)  
        .equ SPI1_SR_TSERF, 1 << 10   @ bitWidth 1 (Additional number of SPI data to be  transacted was reload)  
        .equ SPI1_SR_MODF, 1 << 9   @ bitWidth 1 (Mode Fault)  
        .equ SPI1_SR_TIFRE, 1 << 8   @ bitWidth 1 (TI frame format error)  
        .equ SPI1_SR_CRCE, 1 << 7   @ bitWidth 1 (CRC Error)  
        .equ SPI1_SR_OVR, 1 << 6   @ bitWidth 1 (Overrun)  
        .equ SPI1_SR_UDR, 1 << 5   @ bitWidth 1 (Underrun at slave transmission  mode)  
        .equ SPI1_SR_TXTF, 1 << 4   @ bitWidth 1 (Transmission Transfer  Filled)  
        .equ SPI1_SR_EOT, 1 << 3   @ bitWidth 1 (End Of Transfer)  
        .equ SPI1_SR_DXP, 1 << 2   @ bitWidth 1 (Duplex Packet)  
        .equ SPI1_SR_TXP, 1 << 1   @ bitWidth 1 (Tx-Packet space available)  
        .equ SPI1_SR_RXP, 1 << 0   @ bitWidth 1 (Rx-Packet available)  
 
    .equ SPI1_IFCR, SPI1_BASE + 0x18 @ (Interrupt/Status Flags Clear  Register) 
        .equ SPI1_IFCR_SUSPC, 1 << 11   @ bitWidth 1 (SUSPend flag clear)  
        .equ SPI1_IFCR_TSERFC, 1 << 10   @ bitWidth 1 (TSERFC flag clear)  
        .equ SPI1_IFCR_MODFC, 1 << 9   @ bitWidth 1 (Mode Fault flag clear)  
        .equ SPI1_IFCR_TIFREC, 1 << 8   @ bitWidth 1 (TI frame format error flag  clear)  
        .equ SPI1_IFCR_CRCEC, 1 << 7   @ bitWidth 1 (CRC Error flag clear)  
        .equ SPI1_IFCR_OVRC, 1 << 6   @ bitWidth 1 (Overrun flag clear)  
        .equ SPI1_IFCR_UDRC, 1 << 5   @ bitWidth 1 (Underrun flag clear)  
        .equ SPI1_IFCR_TXTFC, 1 << 4   @ bitWidth 1 (Transmission Transfer Filled flag  clear)  
        .equ SPI1_IFCR_EOTC, 1 << 3   @ bitWidth 1 (End Of Transfer flag clear)  
 
    .equ SPI1_TXDR, SPI1_BASE + 0x20 @ (Transmit Data Register) 
        .equ SPI1_TXDR_TXDR_Shift, 0   @ bitWidth 32 (Transmit data register)  
 
    .equ SPI1_RXDR, SPI1_BASE + 0x30 @ (Receive Data Register) 
        .equ SPI1_RXDR_RXDR_Shift, 0   @ bitWidth 32 (Receive data register)  
 
    .equ SPI1_CRCPOLY, SPI1_BASE + 0x40 @ (Polynomial Register) 
        .equ SPI1_CRCPOLY_CRCPOLY_Shift, 0   @ bitWidth 32 (CRC polynomial register)  
 
    .equ SPI1_TXCRC, SPI1_BASE + 0x44 @ (Transmitter CRC Register) 
        .equ SPI1_TXCRC_TXCRC_Shift, 0   @ bitWidth 32 (CRC register for  transmitter)  
 
    .equ SPI1_RXCRC, SPI1_BASE + 0x48 @ (Receiver CRC Register) 
        .equ SPI1_RXCRC_RXCRC_Shift, 0   @ bitWidth 32 (CRC register for receiver)  
 
    .equ SPI1_UDRDR, SPI1_BASE + 0x4C @ (Underrun Data Register) 
        .equ SPI1_UDRDR_UDRDR_Shift, 0   @ bitWidth 32 (Data at slave underrun  condition)  
 
    .equ SPI1_CGFR, SPI1_BASE + 0x50 @ (configuration register) 
        .equ SPI1_CGFR_MCKOE, 1 << 25   @ bitWidth 1 (Master clock output enable)  
        .equ SPI1_CGFR_ODD, 1 << 24   @ bitWidth 1 (Odd factor for the  prescaler)  
        .equ SPI1_CGFR_I2SDIV_Shift, 16   @ bitWidth 8 (I2S linear prescaler)  
        .equ SPI1_CGFR_DATFMT, 1 << 14   @ bitWidth 1 (Data format)  
        .equ SPI1_CGFR_WSINV, 1 << 13   @ bitWidth 1 (Fixed channel length in  SLAVE)  
        .equ SPI1_CGFR_FIXCH, 1 << 12   @ bitWidth 1 (Word select inversion)  
        .equ SPI1_CGFR_CKPOL, 1 << 11   @ bitWidth 1 (Serial audio clock  polarity)  
        .equ SPI1_CGFR_CHLEN, 1 << 10   @ bitWidth 1 (Channel length number of bits per audio  channel)  
        .equ SPI1_CGFR_DATLEN_Shift, 8   @ bitWidth 2 (Data length to be  transferred)  
        .equ SPI1_CGFR_PCMSYNC, 1 << 7   @ bitWidth 1 (PCM frame synchronization)  
        .equ SPI1_CGFR_I2SSTD_Shift, 4   @ bitWidth 2 (I2S standard selection)  
        .equ SPI1_CGFR_I2SCFG_Shift, 1   @ bitWidth 3 (I2S configuration mode)  
        .equ SPI1_CGFR_I2SMOD, 1 << 0   @ bitWidth 1 (I2S mode selection)  
 

@=========================== SPI2 ===========================@
.equ SPI2_BASE, 0x40003800 @ (Serial peripheral interface) 
    .equ SPI2_CR1, SPI2_BASE + 0x0 @ (control register 1) 
        .equ SPI2_CR1_IOLOCK, 1 << 16   @ bitWidth 1 (Locking the AF configuration of  associated IOs)  
        .equ SPI2_CR1_TCRCI, 1 << 15   @ bitWidth 1 (CRC calculation initialization pattern  control for transmitter)  
        .equ SPI2_CR1_RCRCI, 1 << 14   @ bitWidth 1 (CRC calculation initialization pattern  control for receiver)  
        .equ SPI2_CR1_CRC33_17, 1 << 13   @ bitWidth 1 (32-bit CRC polynomial  configuration)  
        .equ SPI2_CR1_SSI, 1 << 12   @ bitWidth 1 (Internal SS signal input  level)  
        .equ SPI2_CR1_HDDIR, 1 << 11   @ bitWidth 1 (Rx/Tx direction at Half-duplex  mode)  
        .equ SPI2_CR1_CSUSP, 1 << 10   @ bitWidth 1 (Master SUSPend request)  
        .equ SPI2_CR1_CSTART, 1 << 9   @ bitWidth 1 (Master transfer start)  
        .equ SPI2_CR1_MASRX, 1 << 8   @ bitWidth 1 (Master automatic SUSP in Receive  mode)  
        .equ SPI2_CR1_SPE, 1 << 0   @ bitWidth 1 (Serial Peripheral Enable)  
 
    .equ SPI2_CR2, SPI2_BASE + 0x4 @ (control register 2) 
        .equ SPI2_CR2_TSER_Shift, 16   @ bitWidth 16 (Number of data transfer extension to be  reload into TSIZE just when a previous)  
        .equ SPI2_CR2_TSIZE_Shift, 0   @ bitWidth 16 (Number of data at current  transfer)  
 
    .equ SPI2_CFG1, SPI2_BASE + 0x8 @ (configuration register 1) 
        .equ SPI2_CFG1_MBR_Shift, 28   @ bitWidth 3 (Master baud rate)  
        .equ SPI2_CFG1_CRCEN, 1 << 22   @ bitWidth 1 (Hardware CRC computation  enable)  
        .equ SPI2_CFG1_CRCSIZE_Shift, 16   @ bitWidth 5 (Length of CRC frame to be transacted and  compared)  
        .equ SPI2_CFG1_TXDMAEN, 1 << 15   @ bitWidth 1 (Tx DMA stream enable)  
        .equ SPI2_CFG1_RXDMAEN, 1 << 14   @ bitWidth 1 (Rx DMA stream enable)  
        .equ SPI2_CFG1_UDRDET_Shift, 11   @ bitWidth 2 (Detection of underrun condition at slave  transmitter)  
        .equ SPI2_CFG1_UDRCFG_Shift, 9   @ bitWidth 2 (Behavior of slave transmitter at  underrun condition)  
        .equ SPI2_CFG1_FTHVL_Shift, 5   @ bitWidth 4 (threshold level)  
        .equ SPI2_CFG1_DSIZE_Shift, 0   @ bitWidth 5 (Number of bits in at single SPI data  frame)  
 
    .equ SPI2_CFG2, SPI2_BASE + 0xC @ (configuration register 2) 
        .equ SPI2_CFG2_AFCNTR, 1 << 31   @ bitWidth 1 (Alternate function GPIOs  control)  
        .equ SPI2_CFG2_SSOM, 1 << 30   @ bitWidth 1 (SS output management in master  mode)  
        .equ SPI2_CFG2_SSOE, 1 << 29   @ bitWidth 1 (SS output enable)  
        .equ SPI2_CFG2_SSIOP, 1 << 28   @ bitWidth 1 (SS input/output polarity)  
        .equ SPI2_CFG2_SSM, 1 << 26   @ bitWidth 1 (Software management of SS signal  input)  
        .equ SPI2_CFG2_CPOL, 1 << 25   @ bitWidth 1 (Clock polarity)  
        .equ SPI2_CFG2_CPHA, 1 << 24   @ bitWidth 1 (Clock phase)  
        .equ SPI2_CFG2_LSBFRST, 1 << 23   @ bitWidth 1 (Data frame format)  
        .equ SPI2_CFG2_MASTER, 1 << 22   @ bitWidth 1 (SPI Master)  
        .equ SPI2_CFG2_SP_Shift, 19   @ bitWidth 3 (Serial Protocol)  
        .equ SPI2_CFG2_COMM_Shift, 17   @ bitWidth 2 (SPI Communication Mode)  
        .equ SPI2_CFG2_IOSWP, 1 << 15   @ bitWidth 1 (Swap functionality of MISO and MOSI  pins)  
        .equ SPI2_CFG2_MIDI_Shift, 4   @ bitWidth 4 (Master Inter-Data Idleness)  
        .equ SPI2_CFG2_MSSI_Shift, 0   @ bitWidth 4 (Master SS Idleness)  
 
    .equ SPI2_IER, SPI2_BASE + 0x10 @ (Interrupt Enable Register) 
        .equ SPI2_IER_TSERFIE, 1 << 10   @ bitWidth 1 (Additional number of transactions reload  interrupt enable)  
        .equ SPI2_IER_MODFIE, 1 << 9   @ bitWidth 1 (Mode Fault interrupt  enable)  
        .equ SPI2_IER_TIFREIE, 1 << 8   @ bitWidth 1 (TIFRE interrupt enable)  
        .equ SPI2_IER_CRCEIE, 1 << 7   @ bitWidth 1 (CRC Interrupt enable)  
        .equ SPI2_IER_OVRIE, 1 << 6   @ bitWidth 1 (OVR interrupt enable)  
        .equ SPI2_IER_UDRIE, 1 << 5   @ bitWidth 1 (UDR interrupt enable)  
        .equ SPI2_IER_TXTFIE, 1 << 4   @ bitWidth 1 (TXTFIE interrupt enable)  
        .equ SPI2_IER_EOTIE, 1 << 3   @ bitWidth 1 (EOT, SUSP and TXC interrupt  enable)  
        .equ SPI2_IER_DPXPIE, 1 << 2   @ bitWidth 1 (DXP interrupt enabled)  
        .equ SPI2_IER_TXPIE, 1 << 1   @ bitWidth 1 (TXP interrupt enable)  
        .equ SPI2_IER_RXPIE, 1 << 0   @ bitWidth 1 (RXP Interrupt Enable)  
 
    .equ SPI2_SR, SPI2_BASE + 0x14 @ (Status Register) 
        .equ SPI2_SR_CTSIZE_Shift, 16   @ bitWidth 16 (Number of data frames remaining in  current TSIZE session)  
        .equ SPI2_SR_RXWNE, 1 << 15   @ bitWidth 1 (RxFIFO Word Not Empty)  
        .equ SPI2_SR_RXPLVL_Shift, 13   @ bitWidth 2 (RxFIFO Packing LeVeL)  
        .equ SPI2_SR_TXC, 1 << 12   @ bitWidth 1 (TxFIFO transmission  complete)  
        .equ SPI2_SR_SUSP, 1 << 11   @ bitWidth 1 (SUSPend)  
        .equ SPI2_SR_TSERF, 1 << 10   @ bitWidth 1 (Additional number of SPI data to be  transacted was reload)  
        .equ SPI2_SR_MODF, 1 << 9   @ bitWidth 1 (Mode Fault)  
        .equ SPI2_SR_TIFRE, 1 << 8   @ bitWidth 1 (TI frame format error)  
        .equ SPI2_SR_CRCE, 1 << 7   @ bitWidth 1 (CRC Error)  
        .equ SPI2_SR_OVR, 1 << 6   @ bitWidth 1 (Overrun)  
        .equ SPI2_SR_UDR, 1 << 5   @ bitWidth 1 (Underrun at slave transmission  mode)  
        .equ SPI2_SR_TXTF, 1 << 4   @ bitWidth 1 (Transmission Transfer  Filled)  
        .equ SPI2_SR_EOT, 1 << 3   @ bitWidth 1 (End Of Transfer)  
        .equ SPI2_SR_DXP, 1 << 2   @ bitWidth 1 (Duplex Packet)  
        .equ SPI2_SR_TXP, 1 << 1   @ bitWidth 1 (Tx-Packet space available)  
        .equ SPI2_SR_RXP, 1 << 0   @ bitWidth 1 (Rx-Packet available)  
 
    .equ SPI2_IFCR, SPI2_BASE + 0x18 @ (Interrupt/Status Flags Clear  Register) 
        .equ SPI2_IFCR_SUSPC, 1 << 11   @ bitWidth 1 (SUSPend flag clear)  
        .equ SPI2_IFCR_TSERFC, 1 << 10   @ bitWidth 1 (TSERFC flag clear)  
        .equ SPI2_IFCR_MODFC, 1 << 9   @ bitWidth 1 (Mode Fault flag clear)  
        .equ SPI2_IFCR_TIFREC, 1 << 8   @ bitWidth 1 (TI frame format error flag  clear)  
        .equ SPI2_IFCR_CRCEC, 1 << 7   @ bitWidth 1 (CRC Error flag clear)  
        .equ SPI2_IFCR_OVRC, 1 << 6   @ bitWidth 1 (Overrun flag clear)  
        .equ SPI2_IFCR_UDRC, 1 << 5   @ bitWidth 1 (Underrun flag clear)  
        .equ SPI2_IFCR_TXTFC, 1 << 4   @ bitWidth 1 (Transmission Transfer Filled flag  clear)  
        .equ SPI2_IFCR_EOTC, 1 << 3   @ bitWidth 1 (End Of Transfer flag clear)  
 
    .equ SPI2_TXDR, SPI2_BASE + 0x20 @ (Transmit Data Register) 
        .equ SPI2_TXDR_TXDR_Shift, 0   @ bitWidth 32 (Transmit data register)  
 
    .equ SPI2_RXDR, SPI2_BASE + 0x30 @ (Receive Data Register) 
        .equ SPI2_RXDR_RXDR_Shift, 0   @ bitWidth 32 (Receive data register)  
 
    .equ SPI2_CRCPOLY, SPI2_BASE + 0x40 @ (Polynomial Register) 
        .equ SPI2_CRCPOLY_CRCPOLY_Shift, 0   @ bitWidth 32 (CRC polynomial register)  
 
    .equ SPI2_TXCRC, SPI2_BASE + 0x44 @ (Transmitter CRC Register) 
        .equ SPI2_TXCRC_TXCRC_Shift, 0   @ bitWidth 32 (CRC register for  transmitter)  
 
    .equ SPI2_RXCRC, SPI2_BASE + 0x48 @ (Receiver CRC Register) 
        .equ SPI2_RXCRC_RXCRC_Shift, 0   @ bitWidth 32 (CRC register for receiver)  
 
    .equ SPI2_UDRDR, SPI2_BASE + 0x4C @ (Underrun Data Register) 
        .equ SPI2_UDRDR_UDRDR_Shift, 0   @ bitWidth 32 (Data at slave underrun  condition)  
 
    .equ SPI2_CGFR, SPI2_BASE + 0x50 @ (configuration register) 
        .equ SPI2_CGFR_MCKOE, 1 << 25   @ bitWidth 1 (Master clock output enable)  
        .equ SPI2_CGFR_ODD, 1 << 24   @ bitWidth 1 (Odd factor for the  prescaler)  
        .equ SPI2_CGFR_I2SDIV_Shift, 16   @ bitWidth 8 (I2S linear prescaler)  
        .equ SPI2_CGFR_DATFMT, 1 << 14   @ bitWidth 1 (Data format)  
        .equ SPI2_CGFR_WSINV, 1 << 13   @ bitWidth 1 (Fixed channel length in  SLAVE)  
        .equ SPI2_CGFR_FIXCH, 1 << 12   @ bitWidth 1 (Word select inversion)  
        .equ SPI2_CGFR_CKPOL, 1 << 11   @ bitWidth 1 (Serial audio clock  polarity)  
        .equ SPI2_CGFR_CHLEN, 1 << 10   @ bitWidth 1 (Channel length number of bits per audio  channel)  
        .equ SPI2_CGFR_DATLEN_Shift, 8   @ bitWidth 2 (Data length to be  transferred)  
        .equ SPI2_CGFR_PCMSYNC, 1 << 7   @ bitWidth 1 (PCM frame synchronization)  
        .equ SPI2_CGFR_I2SSTD_Shift, 4   @ bitWidth 2 (I2S standard selection)  
        .equ SPI2_CGFR_I2SCFG_Shift, 1   @ bitWidth 3 (I2S configuration mode)  
        .equ SPI2_CGFR_I2SMOD, 1 << 0   @ bitWidth 1 (I2S mode selection)  
 

@=========================== SPI3 ===========================@
.equ SPI3_BASE, 0x40003C00 @ (Serial peripheral interface) 
    .equ SPI3_CR1, SPI3_BASE + 0x0 @ (control register 1) 
        .equ SPI3_CR1_IOLOCK, 1 << 16   @ bitWidth 1 (Locking the AF configuration of  associated IOs)  
        .equ SPI3_CR1_TCRCI, 1 << 15   @ bitWidth 1 (CRC calculation initialization pattern  control for transmitter)  
        .equ SPI3_CR1_RCRCI, 1 << 14   @ bitWidth 1 (CRC calculation initialization pattern  control for receiver)  
        .equ SPI3_CR1_CRC33_17, 1 << 13   @ bitWidth 1 (32-bit CRC polynomial  configuration)  
        .equ SPI3_CR1_SSI, 1 << 12   @ bitWidth 1 (Internal SS signal input  level)  
        .equ SPI3_CR1_HDDIR, 1 << 11   @ bitWidth 1 (Rx/Tx direction at Half-duplex  mode)  
        .equ SPI3_CR1_CSUSP, 1 << 10   @ bitWidth 1 (Master SUSPend request)  
        .equ SPI3_CR1_CSTART, 1 << 9   @ bitWidth 1 (Master transfer start)  
        .equ SPI3_CR1_MASRX, 1 << 8   @ bitWidth 1 (Master automatic SUSP in Receive  mode)  
        .equ SPI3_CR1_SPE, 1 << 0   @ bitWidth 1 (Serial Peripheral Enable)  
 
    .equ SPI3_CR2, SPI3_BASE + 0x4 @ (control register 2) 
        .equ SPI3_CR2_TSER_Shift, 16   @ bitWidth 16 (Number of data transfer extension to be  reload into TSIZE just when a previous)  
        .equ SPI3_CR2_TSIZE_Shift, 0   @ bitWidth 16 (Number of data at current  transfer)  
 
    .equ SPI3_CFG1, SPI3_BASE + 0x8 @ (configuration register 1) 
        .equ SPI3_CFG1_MBR_Shift, 28   @ bitWidth 3 (Master baud rate)  
        .equ SPI3_CFG1_CRCEN, 1 << 22   @ bitWidth 1 (Hardware CRC computation  enable)  
        .equ SPI3_CFG1_CRCSIZE_Shift, 16   @ bitWidth 5 (Length of CRC frame to be transacted and  compared)  
        .equ SPI3_CFG1_TXDMAEN, 1 << 15   @ bitWidth 1 (Tx DMA stream enable)  
        .equ SPI3_CFG1_RXDMAEN, 1 << 14   @ bitWidth 1 (Rx DMA stream enable)  
        .equ SPI3_CFG1_UDRDET_Shift, 11   @ bitWidth 2 (Detection of underrun condition at slave  transmitter)  
        .equ SPI3_CFG1_UDRCFG_Shift, 9   @ bitWidth 2 (Behavior of slave transmitter at  underrun condition)  
        .equ SPI3_CFG1_FTHVL_Shift, 5   @ bitWidth 4 (threshold level)  
        .equ SPI3_CFG1_DSIZE_Shift, 0   @ bitWidth 5 (Number of bits in at single SPI data  frame)  
 
    .equ SPI3_CFG2, SPI3_BASE + 0xC @ (configuration register 2) 
        .equ SPI3_CFG2_AFCNTR, 1 << 31   @ bitWidth 1 (Alternate function GPIOs  control)  
        .equ SPI3_CFG2_SSOM, 1 << 30   @ bitWidth 1 (SS output management in master  mode)  
        .equ SPI3_CFG2_SSOE, 1 << 29   @ bitWidth 1 (SS output enable)  
        .equ SPI3_CFG2_SSIOP, 1 << 28   @ bitWidth 1 (SS input/output polarity)  
        .equ SPI3_CFG2_SSM, 1 << 26   @ bitWidth 1 (Software management of SS signal  input)  
        .equ SPI3_CFG2_CPOL, 1 << 25   @ bitWidth 1 (Clock polarity)  
        .equ SPI3_CFG2_CPHA, 1 << 24   @ bitWidth 1 (Clock phase)  
        .equ SPI3_CFG2_LSBFRST, 1 << 23   @ bitWidth 1 (Data frame format)  
        .equ SPI3_CFG2_MASTER, 1 << 22   @ bitWidth 1 (SPI Master)  
        .equ SPI3_CFG2_SP_Shift, 19   @ bitWidth 3 (Serial Protocol)  
        .equ SPI3_CFG2_COMM_Shift, 17   @ bitWidth 2 (SPI Communication Mode)  
        .equ SPI3_CFG2_IOSWP, 1 << 15   @ bitWidth 1 (Swap functionality of MISO and MOSI  pins)  
        .equ SPI3_CFG2_MIDI_Shift, 4   @ bitWidth 4 (Master Inter-Data Idleness)  
        .equ SPI3_CFG2_MSSI_Shift, 0   @ bitWidth 4 (Master SS Idleness)  
 
    .equ SPI3_IER, SPI3_BASE + 0x10 @ (Interrupt Enable Register) 
        .equ SPI3_IER_TSERFIE, 1 << 10   @ bitWidth 1 (Additional number of transactions reload  interrupt enable)  
        .equ SPI3_IER_MODFIE, 1 << 9   @ bitWidth 1 (Mode Fault interrupt  enable)  
        .equ SPI3_IER_TIFREIE, 1 << 8   @ bitWidth 1 (TIFRE interrupt enable)  
        .equ SPI3_IER_CRCEIE, 1 << 7   @ bitWidth 1 (CRC Interrupt enable)  
        .equ SPI3_IER_OVRIE, 1 << 6   @ bitWidth 1 (OVR interrupt enable)  
        .equ SPI3_IER_UDRIE, 1 << 5   @ bitWidth 1 (UDR interrupt enable)  
        .equ SPI3_IER_TXTFIE, 1 << 4   @ bitWidth 1 (TXTFIE interrupt enable)  
        .equ SPI3_IER_EOTIE, 1 << 3   @ bitWidth 1 (EOT, SUSP and TXC interrupt  enable)  
        .equ SPI3_IER_DPXPIE, 1 << 2   @ bitWidth 1 (DXP interrupt enabled)  
        .equ SPI3_IER_TXPIE, 1 << 1   @ bitWidth 1 (TXP interrupt enable)  
        .equ SPI3_IER_RXPIE, 1 << 0   @ bitWidth 1 (RXP Interrupt Enable)  
 
    .equ SPI3_SR, SPI3_BASE + 0x14 @ (Status Register) 
        .equ SPI3_SR_CTSIZE_Shift, 16   @ bitWidth 16 (Number of data frames remaining in  current TSIZE session)  
        .equ SPI3_SR_RXWNE, 1 << 15   @ bitWidth 1 (RxFIFO Word Not Empty)  
        .equ SPI3_SR_RXPLVL_Shift, 13   @ bitWidth 2 (RxFIFO Packing LeVeL)  
        .equ SPI3_SR_TXC, 1 << 12   @ bitWidth 1 (TxFIFO transmission  complete)  
        .equ SPI3_SR_SUSP, 1 << 11   @ bitWidth 1 (SUSPend)  
        .equ SPI3_SR_TSERF, 1 << 10   @ bitWidth 1 (Additional number of SPI data to be  transacted was reload)  
        .equ SPI3_SR_MODF, 1 << 9   @ bitWidth 1 (Mode Fault)  
        .equ SPI3_SR_TIFRE, 1 << 8   @ bitWidth 1 (TI frame format error)  
        .equ SPI3_SR_CRCE, 1 << 7   @ bitWidth 1 (CRC Error)  
        .equ SPI3_SR_OVR, 1 << 6   @ bitWidth 1 (Overrun)  
        .equ SPI3_SR_UDR, 1 << 5   @ bitWidth 1 (Underrun at slave transmission  mode)  
        .equ SPI3_SR_TXTF, 1 << 4   @ bitWidth 1 (Transmission Transfer  Filled)  
        .equ SPI3_SR_EOT, 1 << 3   @ bitWidth 1 (End Of Transfer)  
        .equ SPI3_SR_DXP, 1 << 2   @ bitWidth 1 (Duplex Packet)  
        .equ SPI3_SR_TXP, 1 << 1   @ bitWidth 1 (Tx-Packet space available)  
        .equ SPI3_SR_RXP, 1 << 0   @ bitWidth 1 (Rx-Packet available)  
 
    .equ SPI3_IFCR, SPI3_BASE + 0x18 @ (Interrupt/Status Flags Clear  Register) 
        .equ SPI3_IFCR_SUSPC, 1 << 11   @ bitWidth 1 (SUSPend flag clear)  
        .equ SPI3_IFCR_TSERFC, 1 << 10   @ bitWidth 1 (TSERFC flag clear)  
        .equ SPI3_IFCR_MODFC, 1 << 9   @ bitWidth 1 (Mode Fault flag clear)  
        .equ SPI3_IFCR_TIFREC, 1 << 8   @ bitWidth 1 (TI frame format error flag  clear)  
        .equ SPI3_IFCR_CRCEC, 1 << 7   @ bitWidth 1 (CRC Error flag clear)  
        .equ SPI3_IFCR_OVRC, 1 << 6   @ bitWidth 1 (Overrun flag clear)  
        .equ SPI3_IFCR_UDRC, 1 << 5   @ bitWidth 1 (Underrun flag clear)  
        .equ SPI3_IFCR_TXTFC, 1 << 4   @ bitWidth 1 (Transmission Transfer Filled flag  clear)  
        .equ SPI3_IFCR_EOTC, 1 << 3   @ bitWidth 1 (End Of Transfer flag clear)  
 
    .equ SPI3_TXDR, SPI3_BASE + 0x20 @ (Transmit Data Register) 
        .equ SPI3_TXDR_TXDR_Shift, 0   @ bitWidth 32 (Transmit data register)  
 
    .equ SPI3_RXDR, SPI3_BASE + 0x30 @ (Receive Data Register) 
        .equ SPI3_RXDR_RXDR_Shift, 0   @ bitWidth 32 (Receive data register)  
 
    .equ SPI3_CRCPOLY, SPI3_BASE + 0x40 @ (Polynomial Register) 
        .equ SPI3_CRCPOLY_CRCPOLY_Shift, 0   @ bitWidth 32 (CRC polynomial register)  
 
    .equ SPI3_TXCRC, SPI3_BASE + 0x44 @ (Transmitter CRC Register) 
        .equ SPI3_TXCRC_TXCRC_Shift, 0   @ bitWidth 32 (CRC register for  transmitter)  
 
    .equ SPI3_RXCRC, SPI3_BASE + 0x48 @ (Receiver CRC Register) 
        .equ SPI3_RXCRC_RXCRC_Shift, 0   @ bitWidth 32 (CRC register for receiver)  
 
    .equ SPI3_UDRDR, SPI3_BASE + 0x4C @ (Underrun Data Register) 
        .equ SPI3_UDRDR_UDRDR_Shift, 0   @ bitWidth 32 (Data at slave underrun  condition)  
 
    .equ SPI3_CGFR, SPI3_BASE + 0x50 @ (configuration register) 
        .equ SPI3_CGFR_MCKOE, 1 << 25   @ bitWidth 1 (Master clock output enable)  
        .equ SPI3_CGFR_ODD, 1 << 24   @ bitWidth 1 (Odd factor for the  prescaler)  
        .equ SPI3_CGFR_I2SDIV_Shift, 16   @ bitWidth 8 (I2S linear prescaler)  
        .equ SPI3_CGFR_DATFMT, 1 << 14   @ bitWidth 1 (Data format)  
        .equ SPI3_CGFR_WSINV, 1 << 13   @ bitWidth 1 (Fixed channel length in  SLAVE)  
        .equ SPI3_CGFR_FIXCH, 1 << 12   @ bitWidth 1 (Word select inversion)  
        .equ SPI3_CGFR_CKPOL, 1 << 11   @ bitWidth 1 (Serial audio clock  polarity)  
        .equ SPI3_CGFR_CHLEN, 1 << 10   @ bitWidth 1 (Channel length number of bits per audio  channel)  
        .equ SPI3_CGFR_DATLEN_Shift, 8   @ bitWidth 2 (Data length to be  transferred)  
        .equ SPI3_CGFR_PCMSYNC, 1 << 7   @ bitWidth 1 (PCM frame synchronization)  
        .equ SPI3_CGFR_I2SSTD_Shift, 4   @ bitWidth 2 (I2S standard selection)  
        .equ SPI3_CGFR_I2SCFG_Shift, 1   @ bitWidth 3 (I2S configuration mode)  
        .equ SPI3_CGFR_I2SMOD, 1 << 0   @ bitWidth 1 (I2S mode selection)  
 

@=========================== SPI4 ===========================@
.equ SPI4_BASE, 0x40013400 @ (Serial peripheral interface) 
    .equ SPI4_CR1, SPI4_BASE + 0x0 @ (control register 1) 
        .equ SPI4_CR1_IOLOCK, 1 << 16   @ bitWidth 1 (Locking the AF configuration of  associated IOs)  
        .equ SPI4_CR1_TCRCI, 1 << 15   @ bitWidth 1 (CRC calculation initialization pattern  control for transmitter)  
        .equ SPI4_CR1_RCRCI, 1 << 14   @ bitWidth 1 (CRC calculation initialization pattern  control for receiver)  
        .equ SPI4_CR1_CRC33_17, 1 << 13   @ bitWidth 1 (32-bit CRC polynomial  configuration)  
        .equ SPI4_CR1_SSI, 1 << 12   @ bitWidth 1 (Internal SS signal input  level)  
        .equ SPI4_CR1_HDDIR, 1 << 11   @ bitWidth 1 (Rx/Tx direction at Half-duplex  mode)  
        .equ SPI4_CR1_CSUSP, 1 << 10   @ bitWidth 1 (Master SUSPend request)  
        .equ SPI4_CR1_CSTART, 1 << 9   @ bitWidth 1 (Master transfer start)  
        .equ SPI4_CR1_MASRX, 1 << 8   @ bitWidth 1 (Master automatic SUSP in Receive  mode)  
        .equ SPI4_CR1_SPE, 1 << 0   @ bitWidth 1 (Serial Peripheral Enable)  
 
    .equ SPI4_CR2, SPI4_BASE + 0x4 @ (control register 2) 
        .equ SPI4_CR2_TSER_Shift, 16   @ bitWidth 16 (Number of data transfer extension to be  reload into TSIZE just when a previous)  
        .equ SPI4_CR2_TSIZE_Shift, 0   @ bitWidth 16 (Number of data at current  transfer)  
 
    .equ SPI4_CFG1, SPI4_BASE + 0x8 @ (configuration register 1) 
        .equ SPI4_CFG1_MBR_Shift, 28   @ bitWidth 3 (Master baud rate)  
        .equ SPI4_CFG1_CRCEN, 1 << 22   @ bitWidth 1 (Hardware CRC computation  enable)  
        .equ SPI4_CFG1_CRCSIZE_Shift, 16   @ bitWidth 5 (Length of CRC frame to be transacted and  compared)  
        .equ SPI4_CFG1_TXDMAEN, 1 << 15   @ bitWidth 1 (Tx DMA stream enable)  
        .equ SPI4_CFG1_RXDMAEN, 1 << 14   @ bitWidth 1 (Rx DMA stream enable)  
        .equ SPI4_CFG1_UDRDET_Shift, 11   @ bitWidth 2 (Detection of underrun condition at slave  transmitter)  
        .equ SPI4_CFG1_UDRCFG_Shift, 9   @ bitWidth 2 (Behavior of slave transmitter at  underrun condition)  
        .equ SPI4_CFG1_FTHVL_Shift, 5   @ bitWidth 4 (threshold level)  
        .equ SPI4_CFG1_DSIZE_Shift, 0   @ bitWidth 5 (Number of bits in at single SPI data  frame)  
 
    .equ SPI4_CFG2, SPI4_BASE + 0xC @ (configuration register 2) 
        .equ SPI4_CFG2_AFCNTR, 1 << 31   @ bitWidth 1 (Alternate function GPIOs  control)  
        .equ SPI4_CFG2_SSOM, 1 << 30   @ bitWidth 1 (SS output management in master  mode)  
        .equ SPI4_CFG2_SSOE, 1 << 29   @ bitWidth 1 (SS output enable)  
        .equ SPI4_CFG2_SSIOP, 1 << 28   @ bitWidth 1 (SS input/output polarity)  
        .equ SPI4_CFG2_SSM, 1 << 26   @ bitWidth 1 (Software management of SS signal  input)  
        .equ SPI4_CFG2_CPOL, 1 << 25   @ bitWidth 1 (Clock polarity)  
        .equ SPI4_CFG2_CPHA, 1 << 24   @ bitWidth 1 (Clock phase)  
        .equ SPI4_CFG2_LSBFRST, 1 << 23   @ bitWidth 1 (Data frame format)  
        .equ SPI4_CFG2_MASTER, 1 << 22   @ bitWidth 1 (SPI Master)  
        .equ SPI4_CFG2_SP_Shift, 19   @ bitWidth 3 (Serial Protocol)  
        .equ SPI4_CFG2_COMM_Shift, 17   @ bitWidth 2 (SPI Communication Mode)  
        .equ SPI4_CFG2_IOSWP, 1 << 15   @ bitWidth 1 (Swap functionality of MISO and MOSI  pins)  
        .equ SPI4_CFG2_MIDI_Shift, 4   @ bitWidth 4 (Master Inter-Data Idleness)  
        .equ SPI4_CFG2_MSSI_Shift, 0   @ bitWidth 4 (Master SS Idleness)  
 
    .equ SPI4_IER, SPI4_BASE + 0x10 @ (Interrupt Enable Register) 
        .equ SPI4_IER_TSERFIE, 1 << 10   @ bitWidth 1 (Additional number of transactions reload  interrupt enable)  
        .equ SPI4_IER_MODFIE, 1 << 9   @ bitWidth 1 (Mode Fault interrupt  enable)  
        .equ SPI4_IER_TIFREIE, 1 << 8   @ bitWidth 1 (TIFRE interrupt enable)  
        .equ SPI4_IER_CRCEIE, 1 << 7   @ bitWidth 1 (CRC Interrupt enable)  
        .equ SPI4_IER_OVRIE, 1 << 6   @ bitWidth 1 (OVR interrupt enable)  
        .equ SPI4_IER_UDRIE, 1 << 5   @ bitWidth 1 (UDR interrupt enable)  
        .equ SPI4_IER_TXTFIE, 1 << 4   @ bitWidth 1 (TXTFIE interrupt enable)  
        .equ SPI4_IER_EOTIE, 1 << 3   @ bitWidth 1 (EOT, SUSP and TXC interrupt  enable)  
        .equ SPI4_IER_DPXPIE, 1 << 2   @ bitWidth 1 (DXP interrupt enabled)  
        .equ SPI4_IER_TXPIE, 1 << 1   @ bitWidth 1 (TXP interrupt enable)  
        .equ SPI4_IER_RXPIE, 1 << 0   @ bitWidth 1 (RXP Interrupt Enable)  
 
    .equ SPI4_SR, SPI4_BASE + 0x14 @ (Status Register) 
        .equ SPI4_SR_CTSIZE_Shift, 16   @ bitWidth 16 (Number of data frames remaining in  current TSIZE session)  
        .equ SPI4_SR_RXWNE, 1 << 15   @ bitWidth 1 (RxFIFO Word Not Empty)  
        .equ SPI4_SR_RXPLVL_Shift, 13   @ bitWidth 2 (RxFIFO Packing LeVeL)  
        .equ SPI4_SR_TXC, 1 << 12   @ bitWidth 1 (TxFIFO transmission  complete)  
        .equ SPI4_SR_SUSP, 1 << 11   @ bitWidth 1 (SUSPend)  
        .equ SPI4_SR_TSERF, 1 << 10   @ bitWidth 1 (Additional number of SPI data to be  transacted was reload)  
        .equ SPI4_SR_MODF, 1 << 9   @ bitWidth 1 (Mode Fault)  
        .equ SPI4_SR_TIFRE, 1 << 8   @ bitWidth 1 (TI frame format error)  
        .equ SPI4_SR_CRCE, 1 << 7   @ bitWidth 1 (CRC Error)  
        .equ SPI4_SR_OVR, 1 << 6   @ bitWidth 1 (Overrun)  
        .equ SPI4_SR_UDR, 1 << 5   @ bitWidth 1 (Underrun at slave transmission  mode)  
        .equ SPI4_SR_TXTF, 1 << 4   @ bitWidth 1 (Transmission Transfer  Filled)  
        .equ SPI4_SR_EOT, 1 << 3   @ bitWidth 1 (End Of Transfer)  
        .equ SPI4_SR_DXP, 1 << 2   @ bitWidth 1 (Duplex Packet)  
        .equ SPI4_SR_TXP, 1 << 1   @ bitWidth 1 (Tx-Packet space available)  
        .equ SPI4_SR_RXP, 1 << 0   @ bitWidth 1 (Rx-Packet available)  
 
    .equ SPI4_IFCR, SPI4_BASE + 0x18 @ (Interrupt/Status Flags Clear  Register) 
        .equ SPI4_IFCR_SUSPC, 1 << 11   @ bitWidth 1 (SUSPend flag clear)  
        .equ SPI4_IFCR_TSERFC, 1 << 10   @ bitWidth 1 (TSERFC flag clear)  
        .equ SPI4_IFCR_MODFC, 1 << 9   @ bitWidth 1 (Mode Fault flag clear)  
        .equ SPI4_IFCR_TIFREC, 1 << 8   @ bitWidth 1 (TI frame format error flag  clear)  
        .equ SPI4_IFCR_CRCEC, 1 << 7   @ bitWidth 1 (CRC Error flag clear)  
        .equ SPI4_IFCR_OVRC, 1 << 6   @ bitWidth 1 (Overrun flag clear)  
        .equ SPI4_IFCR_UDRC, 1 << 5   @ bitWidth 1 (Underrun flag clear)  
        .equ SPI4_IFCR_TXTFC, 1 << 4   @ bitWidth 1 (Transmission Transfer Filled flag  clear)  
        .equ SPI4_IFCR_EOTC, 1 << 3   @ bitWidth 1 (End Of Transfer flag clear)  
 
    .equ SPI4_TXDR, SPI4_BASE + 0x20 @ (Transmit Data Register) 
        .equ SPI4_TXDR_TXDR_Shift, 0   @ bitWidth 32 (Transmit data register)  
 
    .equ SPI4_RXDR, SPI4_BASE + 0x30 @ (Receive Data Register) 
        .equ SPI4_RXDR_RXDR_Shift, 0   @ bitWidth 32 (Receive data register)  
 
    .equ SPI4_CRCPOLY, SPI4_BASE + 0x40 @ (Polynomial Register) 
        .equ SPI4_CRCPOLY_CRCPOLY_Shift, 0   @ bitWidth 32 (CRC polynomial register)  
 
    .equ SPI4_TXCRC, SPI4_BASE + 0x44 @ (Transmitter CRC Register) 
        .equ SPI4_TXCRC_TXCRC_Shift, 0   @ bitWidth 32 (CRC register for  transmitter)  
 
    .equ SPI4_RXCRC, SPI4_BASE + 0x48 @ (Receiver CRC Register) 
        .equ SPI4_RXCRC_RXCRC_Shift, 0   @ bitWidth 32 (CRC register for receiver)  
 
    .equ SPI4_UDRDR, SPI4_BASE + 0x4C @ (Underrun Data Register) 
        .equ SPI4_UDRDR_UDRDR_Shift, 0   @ bitWidth 32 (Data at slave underrun  condition)  
 
    .equ SPI4_CGFR, SPI4_BASE + 0x50 @ (configuration register) 
        .equ SPI4_CGFR_MCKOE, 1 << 25   @ bitWidth 1 (Master clock output enable)  
        .equ SPI4_CGFR_ODD, 1 << 24   @ bitWidth 1 (Odd factor for the  prescaler)  
        .equ SPI4_CGFR_I2SDIV_Shift, 16   @ bitWidth 8 (I2S linear prescaler)  
        .equ SPI4_CGFR_DATFMT, 1 << 14   @ bitWidth 1 (Data format)  
        .equ SPI4_CGFR_WSINV, 1 << 13   @ bitWidth 1 (Fixed channel length in  SLAVE)  
        .equ SPI4_CGFR_FIXCH, 1 << 12   @ bitWidth 1 (Word select inversion)  
        .equ SPI4_CGFR_CKPOL, 1 << 11   @ bitWidth 1 (Serial audio clock  polarity)  
        .equ SPI4_CGFR_CHLEN, 1 << 10   @ bitWidth 1 (Channel length number of bits per audio  channel)  
        .equ SPI4_CGFR_DATLEN_Shift, 8   @ bitWidth 2 (Data length to be  transferred)  
        .equ SPI4_CGFR_PCMSYNC, 1 << 7   @ bitWidth 1 (PCM frame synchronization)  
        .equ SPI4_CGFR_I2SSTD_Shift, 4   @ bitWidth 2 (I2S standard selection)  
        .equ SPI4_CGFR_I2SCFG_Shift, 1   @ bitWidth 3 (I2S configuration mode)  
        .equ SPI4_CGFR_I2SMOD, 1 << 0   @ bitWidth 1 (I2S mode selection)  
 

@=========================== SPI5 ===========================@
.equ SPI5_BASE, 0x40015000 @ (Serial peripheral interface) 
    .equ SPI5_CR1, SPI5_BASE + 0x0 @ (control register 1) 
        .equ SPI5_CR1_IOLOCK, 1 << 16   @ bitWidth 1 (Locking the AF configuration of  associated IOs)  
        .equ SPI5_CR1_TCRCI, 1 << 15   @ bitWidth 1 (CRC calculation initialization pattern  control for transmitter)  
        .equ SPI5_CR1_RCRCI, 1 << 14   @ bitWidth 1 (CRC calculation initialization pattern  control for receiver)  
        .equ SPI5_CR1_CRC33_17, 1 << 13   @ bitWidth 1 (32-bit CRC polynomial  configuration)  
        .equ SPI5_CR1_SSI, 1 << 12   @ bitWidth 1 (Internal SS signal input  level)  
        .equ SPI5_CR1_HDDIR, 1 << 11   @ bitWidth 1 (Rx/Tx direction at Half-duplex  mode)  
        .equ SPI5_CR1_CSUSP, 1 << 10   @ bitWidth 1 (Master SUSPend request)  
        .equ SPI5_CR1_CSTART, 1 << 9   @ bitWidth 1 (Master transfer start)  
        .equ SPI5_CR1_MASRX, 1 << 8   @ bitWidth 1 (Master automatic SUSP in Receive  mode)  
        .equ SPI5_CR1_SPE, 1 << 0   @ bitWidth 1 (Serial Peripheral Enable)  
 
    .equ SPI5_CR2, SPI5_BASE + 0x4 @ (control register 2) 
        .equ SPI5_CR2_TSER_Shift, 16   @ bitWidth 16 (Number of data transfer extension to be  reload into TSIZE just when a previous)  
        .equ SPI5_CR2_TSIZE_Shift, 0   @ bitWidth 16 (Number of data at current  transfer)  
 
    .equ SPI5_CFG1, SPI5_BASE + 0x8 @ (configuration register 1) 
        .equ SPI5_CFG1_MBR_Shift, 28   @ bitWidth 3 (Master baud rate)  
        .equ SPI5_CFG1_CRCEN, 1 << 22   @ bitWidth 1 (Hardware CRC computation  enable)  
        .equ SPI5_CFG1_CRCSIZE_Shift, 16   @ bitWidth 5 (Length of CRC frame to be transacted and  compared)  
        .equ SPI5_CFG1_TXDMAEN, 1 << 15   @ bitWidth 1 (Tx DMA stream enable)  
        .equ SPI5_CFG1_RXDMAEN, 1 << 14   @ bitWidth 1 (Rx DMA stream enable)  
        .equ SPI5_CFG1_UDRDET_Shift, 11   @ bitWidth 2 (Detection of underrun condition at slave  transmitter)  
        .equ SPI5_CFG1_UDRCFG_Shift, 9   @ bitWidth 2 (Behavior of slave transmitter at  underrun condition)  
        .equ SPI5_CFG1_FTHVL_Shift, 5   @ bitWidth 4 (threshold level)  
        .equ SPI5_CFG1_DSIZE_Shift, 0   @ bitWidth 5 (Number of bits in at single SPI data  frame)  
 
    .equ SPI5_CFG2, SPI5_BASE + 0xC @ (configuration register 2) 
        .equ SPI5_CFG2_AFCNTR, 1 << 31   @ bitWidth 1 (Alternate function GPIOs  control)  
        .equ SPI5_CFG2_SSOM, 1 << 30   @ bitWidth 1 (SS output management in master  mode)  
        .equ SPI5_CFG2_SSOE, 1 << 29   @ bitWidth 1 (SS output enable)  
        .equ SPI5_CFG2_SSIOP, 1 << 28   @ bitWidth 1 (SS input/output polarity)  
        .equ SPI5_CFG2_SSM, 1 << 26   @ bitWidth 1 (Software management of SS signal  input)  
        .equ SPI5_CFG2_CPOL, 1 << 25   @ bitWidth 1 (Clock polarity)  
        .equ SPI5_CFG2_CPHA, 1 << 24   @ bitWidth 1 (Clock phase)  
        .equ SPI5_CFG2_LSBFRST, 1 << 23   @ bitWidth 1 (Data frame format)  
        .equ SPI5_CFG2_MASTER, 1 << 22   @ bitWidth 1 (SPI Master)  
        .equ SPI5_CFG2_SP_Shift, 19   @ bitWidth 3 (Serial Protocol)  
        .equ SPI5_CFG2_COMM_Shift, 17   @ bitWidth 2 (SPI Communication Mode)  
        .equ SPI5_CFG2_IOSWP, 1 << 15   @ bitWidth 1 (Swap functionality of MISO and MOSI  pins)  
        .equ SPI5_CFG2_MIDI_Shift, 4   @ bitWidth 4 (Master Inter-Data Idleness)  
        .equ SPI5_CFG2_MSSI_Shift, 0   @ bitWidth 4 (Master SS Idleness)  
 
    .equ SPI5_IER, SPI5_BASE + 0x10 @ (Interrupt Enable Register) 
        .equ SPI5_IER_TSERFIE, 1 << 10   @ bitWidth 1 (Additional number of transactions reload  interrupt enable)  
        .equ SPI5_IER_MODFIE, 1 << 9   @ bitWidth 1 (Mode Fault interrupt  enable)  
        .equ SPI5_IER_TIFREIE, 1 << 8   @ bitWidth 1 (TIFRE interrupt enable)  
        .equ SPI5_IER_CRCEIE, 1 << 7   @ bitWidth 1 (CRC Interrupt enable)  
        .equ SPI5_IER_OVRIE, 1 << 6   @ bitWidth 1 (OVR interrupt enable)  
        .equ SPI5_IER_UDRIE, 1 << 5   @ bitWidth 1 (UDR interrupt enable)  
        .equ SPI5_IER_TXTFIE, 1 << 4   @ bitWidth 1 (TXTFIE interrupt enable)  
        .equ SPI5_IER_EOTIE, 1 << 3   @ bitWidth 1 (EOT, SUSP and TXC interrupt  enable)  
        .equ SPI5_IER_DPXPIE, 1 << 2   @ bitWidth 1 (DXP interrupt enabled)  
        .equ SPI5_IER_TXPIE, 1 << 1   @ bitWidth 1 (TXP interrupt enable)  
        .equ SPI5_IER_RXPIE, 1 << 0   @ bitWidth 1 (RXP Interrupt Enable)  
 
    .equ SPI5_SR, SPI5_BASE + 0x14 @ (Status Register) 
        .equ SPI5_SR_CTSIZE_Shift, 16   @ bitWidth 16 (Number of data frames remaining in  current TSIZE session)  
        .equ SPI5_SR_RXWNE, 1 << 15   @ bitWidth 1 (RxFIFO Word Not Empty)  
        .equ SPI5_SR_RXPLVL_Shift, 13   @ bitWidth 2 (RxFIFO Packing LeVeL)  
        .equ SPI5_SR_TXC, 1 << 12   @ bitWidth 1 (TxFIFO transmission  complete)  
        .equ SPI5_SR_SUSP, 1 << 11   @ bitWidth 1 (SUSPend)  
        .equ SPI5_SR_TSERF, 1 << 10   @ bitWidth 1 (Additional number of SPI data to be  transacted was reload)  
        .equ SPI5_SR_MODF, 1 << 9   @ bitWidth 1 (Mode Fault)  
        .equ SPI5_SR_TIFRE, 1 << 8   @ bitWidth 1 (TI frame format error)  
        .equ SPI5_SR_CRCE, 1 << 7   @ bitWidth 1 (CRC Error)  
        .equ SPI5_SR_OVR, 1 << 6   @ bitWidth 1 (Overrun)  
        .equ SPI5_SR_UDR, 1 << 5   @ bitWidth 1 (Underrun at slave transmission  mode)  
        .equ SPI5_SR_TXTF, 1 << 4   @ bitWidth 1 (Transmission Transfer  Filled)  
        .equ SPI5_SR_EOT, 1 << 3   @ bitWidth 1 (End Of Transfer)  
        .equ SPI5_SR_DXP, 1 << 2   @ bitWidth 1 (Duplex Packet)  
        .equ SPI5_SR_TXP, 1 << 1   @ bitWidth 1 (Tx-Packet space available)  
        .equ SPI5_SR_RXP, 1 << 0   @ bitWidth 1 (Rx-Packet available)  
 
    .equ SPI5_IFCR, SPI5_BASE + 0x18 @ (Interrupt/Status Flags Clear  Register) 
        .equ SPI5_IFCR_SUSPC, 1 << 11   @ bitWidth 1 (SUSPend flag clear)  
        .equ SPI5_IFCR_TSERFC, 1 << 10   @ bitWidth 1 (TSERFC flag clear)  
        .equ SPI5_IFCR_MODFC, 1 << 9   @ bitWidth 1 (Mode Fault flag clear)  
        .equ SPI5_IFCR_TIFREC, 1 << 8   @ bitWidth 1 (TI frame format error flag  clear)  
        .equ SPI5_IFCR_CRCEC, 1 << 7   @ bitWidth 1 (CRC Error flag clear)  
        .equ SPI5_IFCR_OVRC, 1 << 6   @ bitWidth 1 (Overrun flag clear)  
        .equ SPI5_IFCR_UDRC, 1 << 5   @ bitWidth 1 (Underrun flag clear)  
        .equ SPI5_IFCR_TXTFC, 1 << 4   @ bitWidth 1 (Transmission Transfer Filled flag  clear)  
        .equ SPI5_IFCR_EOTC, 1 << 3   @ bitWidth 1 (End Of Transfer flag clear)  
 
    .equ SPI5_TXDR, SPI5_BASE + 0x20 @ (Transmit Data Register) 
        .equ SPI5_TXDR_TXDR_Shift, 0   @ bitWidth 32 (Transmit data register)  
 
    .equ SPI5_RXDR, SPI5_BASE + 0x30 @ (Receive Data Register) 
        .equ SPI5_RXDR_RXDR_Shift, 0   @ bitWidth 32 (Receive data register)  
 
    .equ SPI5_CRCPOLY, SPI5_BASE + 0x40 @ (Polynomial Register) 
        .equ SPI5_CRCPOLY_CRCPOLY_Shift, 0   @ bitWidth 32 (CRC polynomial register)  
 
    .equ SPI5_TXCRC, SPI5_BASE + 0x44 @ (Transmitter CRC Register) 
        .equ SPI5_TXCRC_TXCRC_Shift, 0   @ bitWidth 32 (CRC register for  transmitter)  
 
    .equ SPI5_RXCRC, SPI5_BASE + 0x48 @ (Receiver CRC Register) 
        .equ SPI5_RXCRC_RXCRC_Shift, 0   @ bitWidth 32 (CRC register for receiver)  
 
    .equ SPI5_UDRDR, SPI5_BASE + 0x4C @ (Underrun Data Register) 
        .equ SPI5_UDRDR_UDRDR_Shift, 0   @ bitWidth 32 (Data at slave underrun  condition)  
 
    .equ SPI5_CGFR, SPI5_BASE + 0x50 @ (configuration register) 
        .equ SPI5_CGFR_MCKOE, 1 << 25   @ bitWidth 1 (Master clock output enable)  
        .equ SPI5_CGFR_ODD, 1 << 24   @ bitWidth 1 (Odd factor for the  prescaler)  
        .equ SPI5_CGFR_I2SDIV_Shift, 16   @ bitWidth 8 (I2S linear prescaler)  
        .equ SPI5_CGFR_DATFMT, 1 << 14   @ bitWidth 1 (Data format)  
        .equ SPI5_CGFR_WSINV, 1 << 13   @ bitWidth 1 (Fixed channel length in  SLAVE)  
        .equ SPI5_CGFR_FIXCH, 1 << 12   @ bitWidth 1 (Word select inversion)  
        .equ SPI5_CGFR_CKPOL, 1 << 11   @ bitWidth 1 (Serial audio clock  polarity)  
        .equ SPI5_CGFR_CHLEN, 1 << 10   @ bitWidth 1 (Channel length number of bits per audio  channel)  
        .equ SPI5_CGFR_DATLEN_Shift, 8   @ bitWidth 2 (Data length to be  transferred)  
        .equ SPI5_CGFR_PCMSYNC, 1 << 7   @ bitWidth 1 (PCM frame synchronization)  
        .equ SPI5_CGFR_I2SSTD_Shift, 4   @ bitWidth 2 (I2S standard selection)  
        .equ SPI5_CGFR_I2SCFG_Shift, 1   @ bitWidth 3 (I2S configuration mode)  
        .equ SPI5_CGFR_I2SMOD, 1 << 0   @ bitWidth 1 (I2S mode selection)  
 

@=========================== SPI6 ===========================@
.equ SPI6_BASE, 0x58001400 @ (Serial peripheral interface) 
    .equ SPI6_CR1, SPI6_BASE + 0x0 @ (control register 1) 
        .equ SPI6_CR1_IOLOCK, 1 << 16   @ bitWidth 1 (Locking the AF configuration of  associated IOs)  
        .equ SPI6_CR1_TCRCI, 1 << 15   @ bitWidth 1 (CRC calculation initialization pattern  control for transmitter)  
        .equ SPI6_CR1_RCRCI, 1 << 14   @ bitWidth 1 (CRC calculation initialization pattern  control for receiver)  
        .equ SPI6_CR1_CRC33_17, 1 << 13   @ bitWidth 1 (32-bit CRC polynomial  configuration)  
        .equ SPI6_CR1_SSI, 1 << 12   @ bitWidth 1 (Internal SS signal input  level)  
        .equ SPI6_CR1_HDDIR, 1 << 11   @ bitWidth 1 (Rx/Tx direction at Half-duplex  mode)  
        .equ SPI6_CR1_CSUSP, 1 << 10   @ bitWidth 1 (Master SUSPend request)  
        .equ SPI6_CR1_CSTART, 1 << 9   @ bitWidth 1 (Master transfer start)  
        .equ SPI6_CR1_MASRX, 1 << 8   @ bitWidth 1 (Master automatic SUSP in Receive  mode)  
        .equ SPI6_CR1_SPE, 1 << 0   @ bitWidth 1 (Serial Peripheral Enable)  
 
    .equ SPI6_CR2, SPI6_BASE + 0x4 @ (control register 2) 
        .equ SPI6_CR2_TSER_Shift, 16   @ bitWidth 16 (Number of data transfer extension to be  reload into TSIZE just when a previous)  
        .equ SPI6_CR2_TSIZE_Shift, 0   @ bitWidth 16 (Number of data at current  transfer)  
 
    .equ SPI6_CFG1, SPI6_BASE + 0x8 @ (configuration register 1) 
        .equ SPI6_CFG1_MBR_Shift, 28   @ bitWidth 3 (Master baud rate)  
        .equ SPI6_CFG1_CRCEN, 1 << 22   @ bitWidth 1 (Hardware CRC computation  enable)  
        .equ SPI6_CFG1_CRCSIZE_Shift, 16   @ bitWidth 5 (Length of CRC frame to be transacted and  compared)  
        .equ SPI6_CFG1_TXDMAEN, 1 << 15   @ bitWidth 1 (Tx DMA stream enable)  
        .equ SPI6_CFG1_RXDMAEN, 1 << 14   @ bitWidth 1 (Rx DMA stream enable)  
        .equ SPI6_CFG1_UDRDET_Shift, 11   @ bitWidth 2 (Detection of underrun condition at slave  transmitter)  
        .equ SPI6_CFG1_UDRCFG_Shift, 9   @ bitWidth 2 (Behavior of slave transmitter at  underrun condition)  
        .equ SPI6_CFG1_FTHVL_Shift, 5   @ bitWidth 4 (threshold level)  
        .equ SPI6_CFG1_DSIZE_Shift, 0   @ bitWidth 5 (Number of bits in at single SPI data  frame)  
 
    .equ SPI6_CFG2, SPI6_BASE + 0xC @ (configuration register 2) 
        .equ SPI6_CFG2_AFCNTR, 1 << 31   @ bitWidth 1 (Alternate function GPIOs  control)  
        .equ SPI6_CFG2_SSOM, 1 << 30   @ bitWidth 1 (SS output management in master  mode)  
        .equ SPI6_CFG2_SSOE, 1 << 29   @ bitWidth 1 (SS output enable)  
        .equ SPI6_CFG2_SSIOP, 1 << 28   @ bitWidth 1 (SS input/output polarity)  
        .equ SPI6_CFG2_SSM, 1 << 26   @ bitWidth 1 (Software management of SS signal  input)  
        .equ SPI6_CFG2_CPOL, 1 << 25   @ bitWidth 1 (Clock polarity)  
        .equ SPI6_CFG2_CPHA, 1 << 24   @ bitWidth 1 (Clock phase)  
        .equ SPI6_CFG2_LSBFRST, 1 << 23   @ bitWidth 1 (Data frame format)  
        .equ SPI6_CFG2_MASTER, 1 << 22   @ bitWidth 1 (SPI Master)  
        .equ SPI6_CFG2_SP_Shift, 19   @ bitWidth 3 (Serial Protocol)  
        .equ SPI6_CFG2_COMM_Shift, 17   @ bitWidth 2 (SPI Communication Mode)  
        .equ SPI6_CFG2_IOSWP, 1 << 15   @ bitWidth 1 (Swap functionality of MISO and MOSI  pins)  
        .equ SPI6_CFG2_MIDI_Shift, 4   @ bitWidth 4 (Master Inter-Data Idleness)  
        .equ SPI6_CFG2_MSSI_Shift, 0   @ bitWidth 4 (Master SS Idleness)  
 
    .equ SPI6_IER, SPI6_BASE + 0x10 @ (Interrupt Enable Register) 
        .equ SPI6_IER_TSERFIE, 1 << 10   @ bitWidth 1 (Additional number of transactions reload  interrupt enable)  
        .equ SPI6_IER_MODFIE, 1 << 9   @ bitWidth 1 (Mode Fault interrupt  enable)  
        .equ SPI6_IER_TIFREIE, 1 << 8   @ bitWidth 1 (TIFRE interrupt enable)  
        .equ SPI6_IER_CRCEIE, 1 << 7   @ bitWidth 1 (CRC Interrupt enable)  
        .equ SPI6_IER_OVRIE, 1 << 6   @ bitWidth 1 (OVR interrupt enable)  
        .equ SPI6_IER_UDRIE, 1 << 5   @ bitWidth 1 (UDR interrupt enable)  
        .equ SPI6_IER_TXTFIE, 1 << 4   @ bitWidth 1 (TXTFIE interrupt enable)  
        .equ SPI6_IER_EOTIE, 1 << 3   @ bitWidth 1 (EOT, SUSP and TXC interrupt  enable)  
        .equ SPI6_IER_DPXPIE, 1 << 2   @ bitWidth 1 (DXP interrupt enabled)  
        .equ SPI6_IER_TXPIE, 1 << 1   @ bitWidth 1 (TXP interrupt enable)  
        .equ SPI6_IER_RXPIE, 1 << 0   @ bitWidth 1 (RXP Interrupt Enable)  
 
    .equ SPI6_SR, SPI6_BASE + 0x14 @ (Status Register) 
        .equ SPI6_SR_CTSIZE_Shift, 16   @ bitWidth 16 (Number of data frames remaining in  current TSIZE session)  
        .equ SPI6_SR_RXWNE, 1 << 15   @ bitWidth 1 (RxFIFO Word Not Empty)  
        .equ SPI6_SR_RXPLVL_Shift, 13   @ bitWidth 2 (RxFIFO Packing LeVeL)  
        .equ SPI6_SR_TXC, 1 << 12   @ bitWidth 1 (TxFIFO transmission  complete)  
        .equ SPI6_SR_SUSP, 1 << 11   @ bitWidth 1 (SUSPend)  
        .equ SPI6_SR_TSERF, 1 << 10   @ bitWidth 1 (Additional number of SPI data to be  transacted was reload)  
        .equ SPI6_SR_MODF, 1 << 9   @ bitWidth 1 (Mode Fault)  
        .equ SPI6_SR_TIFRE, 1 << 8   @ bitWidth 1 (TI frame format error)  
        .equ SPI6_SR_CRCE, 1 << 7   @ bitWidth 1 (CRC Error)  
        .equ SPI6_SR_OVR, 1 << 6   @ bitWidth 1 (Overrun)  
        .equ SPI6_SR_UDR, 1 << 5   @ bitWidth 1 (Underrun at slave transmission  mode)  
        .equ SPI6_SR_TXTF, 1 << 4   @ bitWidth 1 (Transmission Transfer  Filled)  
        .equ SPI6_SR_EOT, 1 << 3   @ bitWidth 1 (End Of Transfer)  
        .equ SPI6_SR_DXP, 1 << 2   @ bitWidth 1 (Duplex Packet)  
        .equ SPI6_SR_TXP, 1 << 1   @ bitWidth 1 (Tx-Packet space available)  
        .equ SPI6_SR_RXP, 1 << 0   @ bitWidth 1 (Rx-Packet available)  
 
    .equ SPI6_IFCR, SPI6_BASE + 0x18 @ (Interrupt/Status Flags Clear  Register) 
        .equ SPI6_IFCR_SUSPC, 1 << 11   @ bitWidth 1 (SUSPend flag clear)  
        .equ SPI6_IFCR_TSERFC, 1 << 10   @ bitWidth 1 (TSERFC flag clear)  
        .equ SPI6_IFCR_MODFC, 1 << 9   @ bitWidth 1 (Mode Fault flag clear)  
        .equ SPI6_IFCR_TIFREC, 1 << 8   @ bitWidth 1 (TI frame format error flag  clear)  
        .equ SPI6_IFCR_CRCEC, 1 << 7   @ bitWidth 1 (CRC Error flag clear)  
        .equ SPI6_IFCR_OVRC, 1 << 6   @ bitWidth 1 (Overrun flag clear)  
        .equ SPI6_IFCR_UDRC, 1 << 5   @ bitWidth 1 (Underrun flag clear)  
        .equ SPI6_IFCR_TXTFC, 1 << 4   @ bitWidth 1 (Transmission Transfer Filled flag  clear)  
        .equ SPI6_IFCR_EOTC, 1 << 3   @ bitWidth 1 (End Of Transfer flag clear)  
 
    .equ SPI6_TXDR, SPI6_BASE + 0x20 @ (Transmit Data Register) 
        .equ SPI6_TXDR_TXDR_Shift, 0   @ bitWidth 32 (Transmit data register)  
 
    .equ SPI6_RXDR, SPI6_BASE + 0x30 @ (Receive Data Register) 
        .equ SPI6_RXDR_RXDR_Shift, 0   @ bitWidth 32 (Receive data register)  
 
    .equ SPI6_CRCPOLY, SPI6_BASE + 0x40 @ (Polynomial Register) 
        .equ SPI6_CRCPOLY_CRCPOLY_Shift, 0   @ bitWidth 32 (CRC polynomial register)  
 
    .equ SPI6_TXCRC, SPI6_BASE + 0x44 @ (Transmitter CRC Register) 
        .equ SPI6_TXCRC_TXCRC_Shift, 0   @ bitWidth 32 (CRC register for  transmitter)  
 
    .equ SPI6_RXCRC, SPI6_BASE + 0x48 @ (Receiver CRC Register) 
        .equ SPI6_RXCRC_RXCRC_Shift, 0   @ bitWidth 32 (CRC register for receiver)  
 
    .equ SPI6_UDRDR, SPI6_BASE + 0x4C @ (Underrun Data Register) 
        .equ SPI6_UDRDR_UDRDR_Shift, 0   @ bitWidth 32 (Data at slave underrun  condition)  
 
    .equ SPI6_CGFR, SPI6_BASE + 0x50 @ (configuration register) 
        .equ SPI6_CGFR_MCKOE, 1 << 25   @ bitWidth 1 (Master clock output enable)  
        .equ SPI6_CGFR_ODD, 1 << 24   @ bitWidth 1 (Odd factor for the  prescaler)  
        .equ SPI6_CGFR_I2SDIV_Shift, 16   @ bitWidth 8 (I2S linear prescaler)  
        .equ SPI6_CGFR_DATFMT, 1 << 14   @ bitWidth 1 (Data format)  
        .equ SPI6_CGFR_WSINV, 1 << 13   @ bitWidth 1 (Fixed channel length in  SLAVE)  
        .equ SPI6_CGFR_FIXCH, 1 << 12   @ bitWidth 1 (Word select inversion)  
        .equ SPI6_CGFR_CKPOL, 1 << 11   @ bitWidth 1 (Serial audio clock  polarity)  
        .equ SPI6_CGFR_CHLEN, 1 << 10   @ bitWidth 1 (Channel length number of bits per audio  channel)  
        .equ SPI6_CGFR_DATLEN_Shift, 8   @ bitWidth 2 (Data length to be  transferred)  
        .equ SPI6_CGFR_PCMSYNC, 1 << 7   @ bitWidth 1 (PCM frame synchronization)  
        .equ SPI6_CGFR_I2SSTD_Shift, 4   @ bitWidth 2 (I2S standard selection)  
        .equ SPI6_CGFR_I2SCFG_Shift, 1   @ bitWidth 3 (I2S configuration mode)  
        .equ SPI6_CGFR_I2SMOD, 1 << 0   @ bitWidth 1 (I2S mode selection)  
 

@=========================== LTDC ===========================@
.equ LTDC_BASE, 0x50001000 @ (LCD-TFT Controller) 
    .equ LTDC_SSCR, LTDC_BASE + 0x8 @ (Synchronization Size Configuration  Register) 
        .equ LTDC_SSCR_HSW_Shift, 16   @ bitWidth 10 (Horizontal Synchronization Width in  units of pixel clock period)  
        .equ LTDC_SSCR_VSH_Shift, 0   @ bitWidth 11 (Vertical Synchronization Height in  units of horizontal scan line)  
 
    .equ LTDC_BPCR, LTDC_BASE + 0xC @ (Back Porch Configuration  Register) 
        .equ LTDC_BPCR_AHBP_Shift, 16   @ bitWidth 12 (Accumulated Horizontal back porch in  units of pixel clock period)  
        .equ LTDC_BPCR_AVBP_Shift, 0   @ bitWidth 11 (Accumulated Vertical back porch in  units of horizontal scan line)  
 
    .equ LTDC_AWCR, LTDC_BASE + 0x10 @ (Active Width Configuration  Register) 
        .equ LTDC_AWCR_AAV_Shift, 16   @ bitWidth 12 (AAV)  
        .equ LTDC_AWCR_AAH_Shift, 0   @ bitWidth 11 (Accumulated Active Height in units of  horizontal scan line)  
 
    .equ LTDC_TWCR, LTDC_BASE + 0x14 @ (Total Width Configuration  Register) 
        .equ LTDC_TWCR_TOTALW_Shift, 16   @ bitWidth 12 (Total Width in units of pixel clock  period)  
        .equ LTDC_TWCR_TOTALH_Shift, 0   @ bitWidth 11 (Total Height in units of horizontal  scan line)  
 
    .equ LTDC_GCR, LTDC_BASE + 0x18 @ (Global Control Register) 
        .equ LTDC_GCR_HSPOL, 1 << 31   @ bitWidth 1 (Horizontal Synchronization  Polarity)  
        .equ LTDC_GCR_VSPOL, 1 << 30   @ bitWidth 1 (Vertical Synchronization  Polarity)  
        .equ LTDC_GCR_DEPOL, 1 << 29   @ bitWidth 1 (Data Enable Polarity)  
        .equ LTDC_GCR_PCPOL, 1 << 28   @ bitWidth 1 (Pixel Clock Polarity)  
        .equ LTDC_GCR_DEN, 1 << 16   @ bitWidth 1 (Dither Enable)  
        .equ LTDC_GCR_DRW_Shift, 12   @ bitWidth 3 (Dither Red Width)  
        .equ LTDC_GCR_DGW_Shift, 8   @ bitWidth 3 (Dither Green Width)  
        .equ LTDC_GCR_DBW_Shift, 4   @ bitWidth 3 (Dither Blue Width)  
        .equ LTDC_GCR_LTDCEN, 1 << 0   @ bitWidth 1 (LCD-TFT controller enable  bit)  
 
    .equ LTDC_SRCR, LTDC_BASE + 0x24 @ (Shadow Reload Configuration  Register) 
        .equ LTDC_SRCR_VBR, 1 << 1   @ bitWidth 1 (Vertical Blanking Reload)  
        .equ LTDC_SRCR_IMR, 1 << 0   @ bitWidth 1 (Immediate Reload)  
 
    .equ LTDC_BCCR, LTDC_BASE + 0x2C @ (Background Color Configuration  Register) 
        .equ LTDC_BCCR_BCBLUE_Shift, 0   @ bitWidth 8 (Background Color Blue  value)  
        .equ LTDC_BCCR_BCGREEN_Shift, 8   @ bitWidth 8 (Background Color Green  value)  
        .equ LTDC_BCCR_BCRED_Shift, 16   @ bitWidth 8 (Background Color Red value)  
 
    .equ LTDC_IER, LTDC_BASE + 0x34 @ (Interrupt Enable Register) 
        .equ LTDC_IER_RRIE, 1 << 3   @ bitWidth 1 (Register Reload interrupt  enable)  
        .equ LTDC_IER_TERRIE, 1 << 2   @ bitWidth 1 (Transfer Error Interrupt  Enable)  
        .equ LTDC_IER_FUIE, 1 << 1   @ bitWidth 1 (FIFO Underrun Interrupt  Enable)  
        .equ LTDC_IER_LIE, 1 << 0   @ bitWidth 1 (Line Interrupt Enable)  
 
    .equ LTDC_ISR, LTDC_BASE + 0x38 @ (Interrupt Status Register) 
        .equ LTDC_ISR_RRIF, 1 << 3   @ bitWidth 1 (Register Reload Interrupt  Flag)  
        .equ LTDC_ISR_TERRIF, 1 << 2   @ bitWidth 1 (Transfer Error interrupt  flag)  
        .equ LTDC_ISR_FUIF, 1 << 1   @ bitWidth 1 (FIFO Underrun Interrupt  flag)  
        .equ LTDC_ISR_LIF, 1 << 0   @ bitWidth 1 (Line Interrupt flag)  
 
    .equ LTDC_ICR, LTDC_BASE + 0x3C @ (Interrupt Clear Register) 
        .equ LTDC_ICR_CRRIF, 1 << 3   @ bitWidth 1 (Clears Register Reload Interrupt  Flag)  
        .equ LTDC_ICR_CTERRIF, 1 << 2   @ bitWidth 1 (Clears the Transfer Error Interrupt  Flag)  
        .equ LTDC_ICR_CFUIF, 1 << 1   @ bitWidth 1 (Clears the FIFO Underrun Interrupt  flag)  
        .equ LTDC_ICR_CLIF, 1 << 0   @ bitWidth 1 (Clears the Line Interrupt  Flag)  
 
    .equ LTDC_LIPCR, LTDC_BASE + 0x40 @ (Line Interrupt Position Configuration  Register) 
        .equ LTDC_LIPCR_LIPOS_Shift, 0   @ bitWidth 11 (Line Interrupt Position)  
 
    .equ LTDC_CPSR, LTDC_BASE + 0x44 @ (Current Position Status  Register) 
        .equ LTDC_CPSR_CXPOS_Shift, 16   @ bitWidth 16 (Current X Position)  
        .equ LTDC_CPSR_CYPOS_Shift, 0   @ bitWidth 16 (Current Y Position)  
 
    .equ LTDC_CDSR, LTDC_BASE + 0x48 @ (Current Display Status  Register) 
        .equ LTDC_CDSR_HSYNCS, 1 << 3   @ bitWidth 1 (Horizontal Synchronization display  Status)  
        .equ LTDC_CDSR_VSYNCS, 1 << 2   @ bitWidth 1 (Vertical Synchronization display  Status)  
        .equ LTDC_CDSR_HDES, 1 << 1   @ bitWidth 1 (Horizontal Data Enable display  Status)  
        .equ LTDC_CDSR_VDES, 1 << 0   @ bitWidth 1 (Vertical Data Enable display  Status)  
 
    .equ LTDC_L1CR, LTDC_BASE + 0x84 @ (Layerx Control Register) 
        .equ LTDC_L1CR_CLUTEN, 1 << 4   @ bitWidth 1 (Color Look-Up Table Enable)  
        .equ LTDC_L1CR_COLKEN, 1 << 1   @ bitWidth 1 (Color Keying Enable)  
        .equ LTDC_L1CR_LEN, 1 << 0   @ bitWidth 1 (Layer Enable)  
 
    .equ LTDC_L1WHPCR, LTDC_BASE + 0x88 @ (Layerx Window Horizontal Position  Configuration Register) 
        .equ LTDC_L1WHPCR_WHSPPOS_Shift, 16   @ bitWidth 12 (Window Horizontal Stop  Position)  
        .equ LTDC_L1WHPCR_WHSTPOS_Shift, 0   @ bitWidth 12 (Window Horizontal Start  Position)  
 
    .equ LTDC_L1WVPCR, LTDC_BASE + 0x8C @ (Layerx Window Vertical Position  Configuration Register) 
        .equ LTDC_L1WVPCR_WVSPPOS_Shift, 16   @ bitWidth 11 (Window Vertical Stop  Position)  
        .equ LTDC_L1WVPCR_WVSTPOS_Shift, 0   @ bitWidth 11 (Window Vertical Start  Position)  
 
    .equ LTDC_L1CKCR, LTDC_BASE + 0x90 @ (Layerx Color Keying Configuration  Register) 
        .equ LTDC_L1CKCR_CKRED_Shift, 16   @ bitWidth 8 (Color Key Red value)  
        .equ LTDC_L1CKCR_CKGREEN_Shift, 8   @ bitWidth 8 (Color Key Green value)  
        .equ LTDC_L1CKCR_CKBLUE_Shift, 0   @ bitWidth 8 (Color Key Blue value)  
 
    .equ LTDC_L1PFCR, LTDC_BASE + 0x94 @ (Layerx Pixel Format Configuration  Register) 
        .equ LTDC_L1PFCR_PF_Shift, 0   @ bitWidth 3 (Pixel Format)  
 
    .equ LTDC_L1CACR, LTDC_BASE + 0x98 @ (Layerx Constant Alpha Configuration  Register) 
        .equ LTDC_L1CACR_CONSTA_Shift, 0   @ bitWidth 8 (Constant Alpha)  
 
    .equ LTDC_L1DCCR, LTDC_BASE + 0x9C @ (Layerx Default Color Configuration  Register) 
        .equ LTDC_L1DCCR_DCALPHA_Shift, 24   @ bitWidth 8 (Default Color Alpha)  
        .equ LTDC_L1DCCR_DCRED_Shift, 16   @ bitWidth 8 (Default Color Red)  
        .equ LTDC_L1DCCR_DCGREEN_Shift, 8   @ bitWidth 8 (Default Color Green)  
        .equ LTDC_L1DCCR_DCBLUE_Shift, 0   @ bitWidth 8 (Default Color Blue)  
 
    .equ LTDC_L1BFCR, LTDC_BASE + 0xA0 @ (Layerx Blending Factors Configuration  Register) 
        .equ LTDC_L1BFCR_BF1_Shift, 8   @ bitWidth 3 (Blending Factor 1)  
        .equ LTDC_L1BFCR_BF2_Shift, 0   @ bitWidth 3 (Blending Factor 2)  
 
    .equ LTDC_L1CFBAR, LTDC_BASE + 0xAC @ (Layerx Color Frame Buffer Address  Register) 
        .equ LTDC_L1CFBAR_CFBADD_Shift, 0   @ bitWidth 32 (Color Frame Buffer Start  Address)  
 
    .equ LTDC_L1CFBLR, LTDC_BASE + 0xB0 @ (Layerx Color Frame Buffer Length  Register) 
        .equ LTDC_L1CFBLR_CFBP_Shift, 16   @ bitWidth 13 (Color Frame Buffer Pitch in  bytes)  
        .equ LTDC_L1CFBLR_CFBLL_Shift, 0   @ bitWidth 13 (Color Frame Buffer Line  Length)  
 
    .equ LTDC_L1CFBLNR, LTDC_BASE + 0xB4 @ (Layerx ColorFrame Buffer Line Number  Register) 
        .equ LTDC_L1CFBLNR_CFBLNBR_Shift, 0   @ bitWidth 11 (Frame Buffer Line Number)  
 
    .equ LTDC_L1CLUTWR, LTDC_BASE + 0xC4 @ (Layerx CLUT Write Register) 
        .equ LTDC_L1CLUTWR_CLUTADD_Shift, 24   @ bitWidth 8 (CLUT Address)  
        .equ LTDC_L1CLUTWR_RED_Shift, 16   @ bitWidth 8 (Red value)  
        .equ LTDC_L1CLUTWR_GREEN_Shift, 8   @ bitWidth 8 (Green value)  
        .equ LTDC_L1CLUTWR_BLUE_Shift, 0   @ bitWidth 8 (Blue value)  
 
    .equ LTDC_L2CR, LTDC_BASE + 0x104 @ (Layerx Control Register) 
        .equ LTDC_L2CR_CLUTEN, 1 << 4   @ bitWidth 1 (Color Look-Up Table Enable)  
        .equ LTDC_L2CR_COLKEN, 1 << 1   @ bitWidth 1 (Color Keying Enable)  
        .equ LTDC_L2CR_LEN, 1 << 0   @ bitWidth 1 (Layer Enable)  
 
    .equ LTDC_L2WHPCR, LTDC_BASE + 0x108 @ (Layerx Window Horizontal Position  Configuration Register) 
        .equ LTDC_L2WHPCR_WHSPPOS_Shift, 16   @ bitWidth 12 (Window Horizontal Stop  Position)  
        .equ LTDC_L2WHPCR_WHSTPOS_Shift, 0   @ bitWidth 12 (Window Horizontal Start  Position)  
 
    .equ LTDC_L2WVPCR, LTDC_BASE + 0x10C @ (Layerx Window Vertical Position  Configuration Register) 
        .equ LTDC_L2WVPCR_WVSPPOS_Shift, 16   @ bitWidth 11 (Window Vertical Stop  Position)  
        .equ LTDC_L2WVPCR_WVSTPOS_Shift, 0   @ bitWidth 11 (Window Vertical Start  Position)  
 
    .equ LTDC_L2CKCR, LTDC_BASE + 0x110 @ (Layerx Color Keying Configuration  Register) 
        .equ LTDC_L2CKCR_CKRED_Shift, 16   @ bitWidth 8 (Color Key Red value)  
        .equ LTDC_L2CKCR_CKGREEN_Shift, 8   @ bitWidth 8 (Color Key Green value)  
        .equ LTDC_L2CKCR_CKBLUE_Shift, 0   @ bitWidth 8 (Color Key Blue value)  
 
    .equ LTDC_L2PFCR, LTDC_BASE + 0x114 @ (Layerx Pixel Format Configuration  Register) 
        .equ LTDC_L2PFCR_PF_Shift, 0   @ bitWidth 3 (Pixel Format)  
 
    .equ LTDC_L2CACR, LTDC_BASE + 0x118 @ (Layerx Constant Alpha Configuration  Register) 
        .equ LTDC_L2CACR_CONSTA_Shift, 0   @ bitWidth 8 (Constant Alpha)  
 
    .equ LTDC_L2DCCR, LTDC_BASE + 0x11C @ (Layerx Default Color Configuration  Register) 
        .equ LTDC_L2DCCR_DCALPHA_Shift, 24   @ bitWidth 8 (Default Color Alpha)  
        .equ LTDC_L2DCCR_DCRED_Shift, 16   @ bitWidth 8 (Default Color Red)  
        .equ LTDC_L2DCCR_DCGREEN_Shift, 8   @ bitWidth 8 (Default Color Green)  
        .equ LTDC_L2DCCR_DCBLUE_Shift, 0   @ bitWidth 8 (Default Color Blue)  
 
    .equ LTDC_L2BFCR, LTDC_BASE + 0x120 @ (Layerx Blending Factors Configuration  Register) 
        .equ LTDC_L2BFCR_BF1_Shift, 8   @ bitWidth 3 (Blending Factor 1)  
        .equ LTDC_L2BFCR_BF2_Shift, 0   @ bitWidth 3 (Blending Factor 2)  
 
    .equ LTDC_L2CFBAR, LTDC_BASE + 0x12C @ (Layerx Color Frame Buffer Address  Register) 
        .equ LTDC_L2CFBAR_CFBADD_Shift, 0   @ bitWidth 32 (Color Frame Buffer Start  Address)  
 
    .equ LTDC_L2CFBLR, LTDC_BASE + 0x130 @ (Layerx Color Frame Buffer Length  Register) 
        .equ LTDC_L2CFBLR_CFBP_Shift, 16   @ bitWidth 13 (Color Frame Buffer Pitch in  bytes)  
        .equ LTDC_L2CFBLR_CFBLL_Shift, 0   @ bitWidth 13 (Color Frame Buffer Line  Length)  
 
    .equ LTDC_L2CFBLNR, LTDC_BASE + 0x134 @ (Layerx ColorFrame Buffer Line Number  Register) 
        .equ LTDC_L2CFBLNR_CFBLNBR_Shift, 0   @ bitWidth 11 (Frame Buffer Line Number)  
 
    .equ LTDC_L2CLUTWR, LTDC_BASE + 0x144 @ (Layerx CLUT Write Register) 
        .equ LTDC_L2CLUTWR_CLUTADD_Shift, 24   @ bitWidth 8 (CLUT Address)  
        .equ LTDC_L2CLUTWR_RED_Shift, 16   @ bitWidth 8 (Red value)  
        .equ LTDC_L2CLUTWR_GREEN_Shift, 8   @ bitWidth 8 (Green value)  
        .equ LTDC_L2CLUTWR_BLUE_Shift, 0   @ bitWidth 8 (Blue value)  
 

@=========================== SPDIFRX ===========================@
.equ SPDIFRX_BASE, 0x40004000 @ (Receiver Interface) 
    .equ SPDIFRX_CR, SPDIFRX_BASE + 0x0 @ (Control register) 
        .equ SPDIFRX_CR_SPDIFRXEN_Shift, 0   @ bitWidth 2 (Peripheral Block Enable)  
        .equ SPDIFRX_CR_RXDMAEN, 1 << 2   @ bitWidth 1 (Receiver DMA ENable for data  flow)  
        .equ SPDIFRX_CR_RXSTEO, 1 << 3   @ bitWidth 1 (STerEO Mode)  
        .equ SPDIFRX_CR_DRFMT_Shift, 4   @ bitWidth 2 (RX Data format)  
        .equ SPDIFRX_CR_PMSK, 1 << 6   @ bitWidth 1 (Mask Parity error bit)  
        .equ SPDIFRX_CR_VMSK, 1 << 7   @ bitWidth 1 (Mask of Validity bit)  
        .equ SPDIFRX_CR_CUMSK, 1 << 8   @ bitWidth 1 (Mask of channel status and user  bits)  
        .equ SPDIFRX_CR_PTMSK, 1 << 9   @ bitWidth 1 (Mask of Preamble Type bits)  
        .equ SPDIFRX_CR_CBDMAEN, 1 << 10   @ bitWidth 1 (Control Buffer DMA ENable for control  flow)  
        .equ SPDIFRX_CR_CHSEL, 1 << 11   @ bitWidth 1 (Channel Selection)  
        .equ SPDIFRX_CR_NBTR_Shift, 12   @ bitWidth 2 (Maximum allowed re-tries during  synchronization phase)  
        .equ SPDIFRX_CR_WFA, 1 << 14   @ bitWidth 1 (Wait For Activity)  
        .equ SPDIFRX_CR_INSEL_Shift, 16   @ bitWidth 3 (input selection)  
        .equ SPDIFRX_CR_CKSEN, 1 << 20   @ bitWidth 1 (Symbol Clock Enable)  
        .equ SPDIFRX_CR_CKSBKPEN, 1 << 21   @ bitWidth 1 (Backup Symbol Clock Enable)  
 
    .equ SPDIFRX_IMR, SPDIFRX_BASE + 0x4 @ (Interrupt mask register) 
        .equ SPDIFRX_IMR_RXNEIE, 1 << 0   @ bitWidth 1 (RXNE interrupt enable)  
        .equ SPDIFRX_IMR_CSRNEIE, 1 << 1   @ bitWidth 1 (Control Buffer Ready Interrupt  Enable)  
        .equ SPDIFRX_IMR_PERRIE, 1 << 2   @ bitWidth 1 (Parity error interrupt  enable)  
        .equ SPDIFRX_IMR_OVRIE, 1 << 3   @ bitWidth 1 (Overrun error Interrupt  Enable)  
        .equ SPDIFRX_IMR_SBLKIE, 1 << 4   @ bitWidth 1 (Synchronization Block Detected Interrupt  Enable)  
        .equ SPDIFRX_IMR_SYNCDIE, 1 << 5   @ bitWidth 1 (Synchronization Done)  
        .equ SPDIFRX_IMR_IFEIE, 1 << 6   @ bitWidth 1 (Serial Interface Error Interrupt  Enable)  
 
    .equ SPDIFRX_SR, SPDIFRX_BASE + 0x8 @ (Status register) 
        .equ SPDIFRX_SR_RXNE, 1 << 0   @ bitWidth 1 (Read data register not  empty)  
        .equ SPDIFRX_SR_CSRNE, 1 << 1   @ bitWidth 1 (Control Buffer register is not  empty)  
        .equ SPDIFRX_SR_PERR, 1 << 2   @ bitWidth 1 (Parity error)  
        .equ SPDIFRX_SR_OVR, 1 << 3   @ bitWidth 1 (Overrun error)  
        .equ SPDIFRX_SR_SBD, 1 << 4   @ bitWidth 1 (Synchronization Block  Detected)  
        .equ SPDIFRX_SR_SYNCD, 1 << 5   @ bitWidth 1 (Synchronization Done)  
        .equ SPDIFRX_SR_FERR, 1 << 6   @ bitWidth 1 (Framing error)  
        .equ SPDIFRX_SR_SERR, 1 << 7   @ bitWidth 1 (Synchronization error)  
        .equ SPDIFRX_SR_TERR, 1 << 8   @ bitWidth 1 (Time-out error)  
        .equ SPDIFRX_SR_WIDTH5_Shift, 16   @ bitWidth 15 (Duration of 5 symbols counted with  SPDIF_CLK)  
 
    .equ SPDIFRX_IFCR, SPDIFRX_BASE + 0xC @ (Interrupt Flag Clear register) 
        .equ SPDIFRX_IFCR_PERRCF, 1 << 2   @ bitWidth 1 (Clears the Parity error  flag)  
        .equ SPDIFRX_IFCR_OVRCF, 1 << 3   @ bitWidth 1 (Clears the Overrun error  flag)  
        .equ SPDIFRX_IFCR_SBDCF, 1 << 4   @ bitWidth 1 (Clears the Synchronization Block  Detected flag)  
        .equ SPDIFRX_IFCR_SYNCDCF, 1 << 5   @ bitWidth 1 (Clears the Synchronization Done  flag)  
 
    .equ SPDIFRX_DR_00, SPDIFRX_BASE + 0x10 @ (Data input register) 
        .equ SPDIFRX_DR_00_DR_Shift, 0   @ bitWidth 24 (Parity Error bit)  
        .equ SPDIFRX_DR_00_PE, 1 << 24   @ bitWidth 1 (Parity Error bit)  
        .equ SPDIFRX_DR_00_V, 1 << 25   @ bitWidth 1 (Validity bit)  
        .equ SPDIFRX_DR_00_U, 1 << 26   @ bitWidth 1 (User bit)  
        .equ SPDIFRX_DR_00_C, 1 << 27   @ bitWidth 1 (Channel Status bit)  
        .equ SPDIFRX_DR_00_PT_Shift, 28   @ bitWidth 2 (Preamble Type)  
 
    .equ SPDIFRX_CSR, SPDIFRX_BASE + 0x14 @ (Channel Status register) 
        .equ SPDIFRX_CSR_USR_Shift, 0   @ bitWidth 16 (User data information)  
        .equ SPDIFRX_CSR_CS_Shift, 16   @ bitWidth 8 (Channel A status  information)  
        .equ SPDIFRX_CSR_SOB, 1 << 24   @ bitWidth 1 (Start Of Block)  
 
    .equ SPDIFRX_DIR, SPDIFRX_BASE + 0x18 @ (Debug Information register) 
        .equ SPDIFRX_DIR_THI_Shift, 0   @ bitWidth 13 (Threshold HIGH)  
        .equ SPDIFRX_DIR_TLO_Shift, 16   @ bitWidth 13 (Threshold LOW)  
 
    .equ SPDIFRX_VERR, SPDIFRX_BASE + 0x3F4 @ (SPDIFRX version register) 
        .equ SPDIFRX_VERR_MINREV_Shift, 0   @ bitWidth 4 (Minor revision)  
        .equ SPDIFRX_VERR_MAJREV_Shift, 4   @ bitWidth 4 (Major revision)  
 
    .equ SPDIFRX_IDR, SPDIFRX_BASE + 0x3F8 @ (SPDIFRX identification  register) 
        .equ SPDIFRX_IDR_ID_Shift, 0   @ bitWidth 32 (SPDIFRX identifier)  
 
    .equ SPDIFRX_SIDR, SPDIFRX_BASE + 0x3FC @ (SPDIFRX size identification  register) 
        .equ SPDIFRX_SIDR_SID_Shift, 0   @ bitWidth 32 (Size identification)  
 
    .equ SPDIFRX_DR_01, SPDIFRX_BASE + 0x10 @ (Data input register) 
        .equ SPDIFRX_DR_01_PE, 1 << 0   @ bitWidth 1 (Parity Error bit)  
        .equ SPDIFRX_DR_01_V, 1 << 1   @ bitWidth 1 (Validity bit)  
        .equ SPDIFRX_DR_01_U, 1 << 2   @ bitWidth 1 (User bit)  
        .equ SPDIFRX_DR_01_C, 1 << 3   @ bitWidth 1 (Channel Status bit)  
        .equ SPDIFRX_DR_01_PT_Shift, 4   @ bitWidth 2 (Preamble Type)  
        .equ SPDIFRX_DR_01_DR_Shift, 8   @ bitWidth 24 (Data value)  
 
    .equ SPDIFRX_DR_10, SPDIFRX_BASE + 0x10 @ (Data input register) 
        .equ SPDIFRX_DR_10_DRNL1_Shift, 0   @ bitWidth 16 (Data value)  
        .equ SPDIFRX_DR_10_DRNL2_Shift, 16   @ bitWidth 16 (Data value)  
 

@=========================== ADC3 ===========================@
.equ ADC3_BASE, 0x58026000 @ (Analog to Digital Converter) 
    .equ ADC3_ISR, ADC3_BASE + 0x0 @ (ADC interrupt and status  register) 
        .equ ADC3_ISR_JQOVF, 1 << 10   @ bitWidth 1 (ADC group injected contexts queue  overflow flag)  
        .equ ADC3_ISR_AWD3, 1 << 9   @ bitWidth 1 (ADC analog watchdog 3 flag)  
        .equ ADC3_ISR_AWD2, 1 << 8   @ bitWidth 1 (ADC analog watchdog 2 flag)  
        .equ ADC3_ISR_AWD1, 1 << 7   @ bitWidth 1 (ADC analog watchdog 1 flag)  
        .equ ADC3_ISR_JEOS, 1 << 6   @ bitWidth 1 (ADC group injected end of sequence  conversions flag)  
        .equ ADC3_ISR_JEOC, 1 << 5   @ bitWidth 1 (ADC group injected end of unitary  conversion flag)  
        .equ ADC3_ISR_OVR, 1 << 4   @ bitWidth 1 (ADC group regular overrun  flag)  
        .equ ADC3_ISR_EOS, 1 << 3   @ bitWidth 1 (ADC group regular end of sequence  conversions flag)  
        .equ ADC3_ISR_EOC, 1 << 2   @ bitWidth 1 (ADC group regular end of unitary  conversion flag)  
        .equ ADC3_ISR_EOSMP, 1 << 1   @ bitWidth 1 (ADC group regular end of sampling  flag)  
        .equ ADC3_ISR_ADRDY, 1 << 0   @ bitWidth 1 (ADC ready flag)  
 
    .equ ADC3_IER, ADC3_BASE + 0x4 @ (ADC interrupt enable register) 
        .equ ADC3_IER_JQOVFIE, 1 << 10   @ bitWidth 1 (ADC group injected contexts queue  overflow interrupt)  
        .equ ADC3_IER_AWD3IE, 1 << 9   @ bitWidth 1 (ADC analog watchdog 3  interrupt)  
        .equ ADC3_IER_AWD2IE, 1 << 8   @ bitWidth 1 (ADC analog watchdog 2  interrupt)  
        .equ ADC3_IER_AWD1IE, 1 << 7   @ bitWidth 1 (ADC analog watchdog 1  interrupt)  
        .equ ADC3_IER_JEOSIE, 1 << 6   @ bitWidth 1 (ADC group injected end of sequence  conversions interrupt)  
        .equ ADC3_IER_JEOCIE, 1 << 5   @ bitWidth 1 (ADC group injected end of unitary  conversion interrupt)  
        .equ ADC3_IER_OVRIE, 1 << 4   @ bitWidth 1 (ADC group regular overrun  interrupt)  
        .equ ADC3_IER_EOSIE, 1 << 3   @ bitWidth 1 (ADC group regular end of sequence  conversions interrupt)  
        .equ ADC3_IER_EOCIE, 1 << 2   @ bitWidth 1 (ADC group regular end of unitary  conversion interrupt)  
        .equ ADC3_IER_EOSMPIE, 1 << 1   @ bitWidth 1 (ADC group regular end of sampling  interrupt)  
        .equ ADC3_IER_ADRDYIE, 1 << 0   @ bitWidth 1 (ADC ready interrupt)  
 
    .equ ADC3_CR, ADC3_BASE + 0x8 @ (ADC control register) 
        .equ ADC3_CR_ADCAL, 1 << 31   @ bitWidth 1 (ADC calibration)  
        .equ ADC3_CR_ADCALDIF, 1 << 30   @ bitWidth 1 (ADC differential mode for  calibration)  
        .equ ADC3_CR_DEEPPWD, 1 << 29   @ bitWidth 1 (ADC deep power down enable)  
        .equ ADC3_CR_ADVREGEN, 1 << 28   @ bitWidth 1 (ADC voltage regulator  enable)  
        .equ ADC3_CR_LINCALRDYW6, 1 << 27   @ bitWidth 1 (Linearity calibration ready Word  6)  
        .equ ADC3_CR_LINCALRDYW5, 1 << 26   @ bitWidth 1 (Linearity calibration ready Word  5)  
        .equ ADC3_CR_LINCALRDYW4, 1 << 25   @ bitWidth 1 (Linearity calibration ready Word  4)  
        .equ ADC3_CR_LINCALRDYW3, 1 << 24   @ bitWidth 1 (Linearity calibration ready Word  3)  
        .equ ADC3_CR_LINCALRDYW2, 1 << 23   @ bitWidth 1 (Linearity calibration ready Word  2)  
        .equ ADC3_CR_LINCALRDYW1, 1 << 22   @ bitWidth 1 (Linearity calibration ready Word  1)  
        .equ ADC3_CR_ADCALLIN, 1 << 16   @ bitWidth 1 (Linearity calibration)  
        .equ ADC3_CR_BOOST, 1 << 8   @ bitWidth 1 (Boost mode control)  
        .equ ADC3_CR_JADSTP, 1 << 5   @ bitWidth 1 (ADC group injected conversion  stop)  
        .equ ADC3_CR_ADSTP, 1 << 4   @ bitWidth 1 (ADC group regular conversion  stop)  
        .equ ADC3_CR_JADSTART, 1 << 3   @ bitWidth 1 (ADC group injected conversion  start)  
        .equ ADC3_CR_ADSTART, 1 << 2   @ bitWidth 1 (ADC group regular conversion  start)  
        .equ ADC3_CR_ADDIS, 1 << 1   @ bitWidth 1 (ADC disable)  
        .equ ADC3_CR_ADEN, 1 << 0   @ bitWidth 1 (ADC enable)  
 
    .equ ADC3_CFGR, ADC3_BASE + 0xC @ (ADC configuration register 1) 
        .equ ADC3_CFGR_JQDIS, 1 << 31   @ bitWidth 1 (ADC group injected contexts queue  disable)  
        .equ ADC3_CFGR_AWDCH1CH_Shift, 26   @ bitWidth 5 (ADC analog watchdog 1 monitored channel  selection)  
        .equ ADC3_CFGR_JAUTO, 1 << 25   @ bitWidth 1 (ADC group injected automatic trigger  mode)  
        .equ ADC3_CFGR_JAWD1EN, 1 << 24   @ bitWidth 1 (ADC analog watchdog 1 enable on scope  ADC group injected)  
        .equ ADC3_CFGR_AWD1EN, 1 << 23   @ bitWidth 1 (ADC analog watchdog 1 enable on scope  ADC group regular)  
        .equ ADC3_CFGR_AWD1SGL, 1 << 22   @ bitWidth 1 (ADC analog watchdog 1 monitoring a  single channel or all channels)  
        .equ ADC3_CFGR_JQM, 1 << 21   @ bitWidth 1 (ADC group injected contexts queue  mode)  
        .equ ADC3_CFGR_JDISCEN, 1 << 20   @ bitWidth 1 (ADC group injected sequencer  discontinuous mode)  
        .equ ADC3_CFGR_DISCNUM_Shift, 17   @ bitWidth 3 (ADC group regular sequencer  discontinuous number of ranks)  
        .equ ADC3_CFGR_DISCEN, 1 << 16   @ bitWidth 1 (ADC group regular sequencer  discontinuous mode)  
        .equ ADC3_CFGR_AUTDLY, 1 << 14   @ bitWidth 1 (ADC low power auto wait)  
        .equ ADC3_CFGR_CONT, 1 << 13   @ bitWidth 1 (ADC group regular continuous conversion  mode)  
        .equ ADC3_CFGR_OVRMOD, 1 << 12   @ bitWidth 1 (ADC group regular overrun  configuration)  
        .equ ADC3_CFGR_EXTEN_Shift, 10   @ bitWidth 2 (ADC group regular external trigger  polarity)  
        .equ ADC3_CFGR_EXTSEL_Shift, 5   @ bitWidth 5 (ADC group regular external trigger  source)  
        .equ ADC3_CFGR_RES_Shift, 2   @ bitWidth 3 (ADC data resolution)  
        .equ ADC3_CFGR_DMNGT_Shift, 0   @ bitWidth 2 (ADC DMA transfer enable)  
 
    .equ ADC3_CFGR2, ADC3_BASE + 0x10 @ (ADC configuration register 2) 
        .equ ADC3_CFGR2_ROVSE, 1 << 0   @ bitWidth 1 (ADC oversampler enable on scope ADC  group regular)  
        .equ ADC3_CFGR2_JOVSE, 1 << 1   @ bitWidth 1 (ADC oversampler enable on scope ADC  group injected)  
        .equ ADC3_CFGR2_OVSS_Shift, 5   @ bitWidth 4 (ADC oversampling shift)  
        .equ ADC3_CFGR2_TROVS, 1 << 9   @ bitWidth 1 (ADC oversampling discontinuous mode  triggered mode for ADC group regular)  
        .equ ADC3_CFGR2_ROVSM, 1 << 10   @ bitWidth 1 (Regular Oversampling mode)  
        .equ ADC3_CFGR2_RSHIFT1, 1 << 11   @ bitWidth 1 (Right-shift data after Offset 1  correction)  
        .equ ADC3_CFGR2_RSHIFT2, 1 << 12   @ bitWidth 1 (Right-shift data after Offset 2  correction)  
        .equ ADC3_CFGR2_RSHIFT3, 1 << 13   @ bitWidth 1 (Right-shift data after Offset 3  correction)  
        .equ ADC3_CFGR2_RSHIFT4, 1 << 14   @ bitWidth 1 (Right-shift data after Offset 4  correction)  
        .equ ADC3_CFGR2_OSR_Shift, 16   @ bitWidth 10 (Oversampling ratio)  
        .equ ADC3_CFGR2_LSHIFT_Shift, 28   @ bitWidth 4 (Left shift factor)  
 
    .equ ADC3_SMPR1, ADC3_BASE + 0x14 @ (ADC sampling time register 1) 
        .equ ADC3_SMPR1_SMP9_Shift, 27   @ bitWidth 3 (ADC channel 9 sampling time  selection)  
        .equ ADC3_SMPR1_SMP8_Shift, 24   @ bitWidth 3 (ADC channel 8 sampling time  selection)  
        .equ ADC3_SMPR1_SMP7_Shift, 21   @ bitWidth 3 (ADC channel 7 sampling time  selection)  
        .equ ADC3_SMPR1_SMP6_Shift, 18   @ bitWidth 3 (ADC channel 6 sampling time  selection)  
        .equ ADC3_SMPR1_SMP5_Shift, 15   @ bitWidth 3 (ADC channel 5 sampling time  selection)  
        .equ ADC3_SMPR1_SMP4_Shift, 12   @ bitWidth 3 (ADC channel 4 sampling time  selection)  
        .equ ADC3_SMPR1_SMP3_Shift, 9   @ bitWidth 3 (ADC channel 3 sampling time  selection)  
        .equ ADC3_SMPR1_SMP2_Shift, 6   @ bitWidth 3 (ADC channel 2 sampling time  selection)  
        .equ ADC3_SMPR1_SMP1_Shift, 3   @ bitWidth 3 (ADC channel 1 sampling time  selection)  
 
    .equ ADC3_SMPR2, ADC3_BASE + 0x18 @ (ADC sampling time register 2) 
        .equ ADC3_SMPR2_SMP19_Shift, 27   @ bitWidth 3 (ADC channel 18 sampling time  selection)  
        .equ ADC3_SMPR2_SMP18_Shift, 24   @ bitWidth 3 (ADC channel 18 sampling time  selection)  
        .equ ADC3_SMPR2_SMP17_Shift, 21   @ bitWidth 3 (ADC channel 17 sampling time  selection)  
        .equ ADC3_SMPR2_SMP16_Shift, 18   @ bitWidth 3 (ADC channel 16 sampling time  selection)  
        .equ ADC3_SMPR2_SMP15_Shift, 15   @ bitWidth 3 (ADC channel 15 sampling time  selection)  
        .equ ADC3_SMPR2_SMP14_Shift, 12   @ bitWidth 3 (ADC channel 14 sampling time  selection)  
        .equ ADC3_SMPR2_SMP13_Shift, 9   @ bitWidth 3 (ADC channel 13 sampling time  selection)  
        .equ ADC3_SMPR2_SMP12_Shift, 6   @ bitWidth 3 (ADC channel 12 sampling time  selection)  
        .equ ADC3_SMPR2_SMP11_Shift, 3   @ bitWidth 3 (ADC channel 11 sampling time  selection)  
        .equ ADC3_SMPR2_SMP10_Shift, 0   @ bitWidth 3 (ADC channel 10 sampling time  selection)  
 
    .equ ADC3_LTR1, ADC3_BASE + 0x20 @ (ADC analog watchdog 1 threshold  register) 
        .equ ADC3_LTR1_LTR1_Shift, 0   @ bitWidth 26 (ADC analog watchdog 1 threshold  low)  
 
    .equ ADC3_LHTR1, ADC3_BASE + 0x24 @ (ADC analog watchdog 2 threshold  register) 
        .equ ADC3_LHTR1_LHTR1_Shift, 0   @ bitWidth 26 (ADC analog watchdog 2 threshold  low)  
 
    .equ ADC3_SQR1, ADC3_BASE + 0x30 @ (ADC group regular sequencer ranks register  1) 
        .equ ADC3_SQR1_SQ4_Shift, 24   @ bitWidth 5 (ADC group regular sequencer rank  4)  
        .equ ADC3_SQR1_SQ3_Shift, 18   @ bitWidth 5 (ADC group regular sequencer rank  3)  
        .equ ADC3_SQR1_SQ2_Shift, 12   @ bitWidth 5 (ADC group regular sequencer rank  2)  
        .equ ADC3_SQR1_SQ1_Shift, 6   @ bitWidth 5 (ADC group regular sequencer rank  1)  
        .equ ADC3_SQR1_L3_Shift, 0   @ bitWidth 4 (L3)  
 
    .equ ADC3_SQR2, ADC3_BASE + 0x34 @ (ADC group regular sequencer ranks register  2) 
        .equ ADC3_SQR2_SQ9_Shift, 24   @ bitWidth 5 (ADC group regular sequencer rank  9)  
        .equ ADC3_SQR2_SQ8_Shift, 18   @ bitWidth 5 (ADC group regular sequencer rank  8)  
        .equ ADC3_SQR2_SQ7_Shift, 12   @ bitWidth 5 (ADC group regular sequencer rank  7)  
        .equ ADC3_SQR2_SQ6_Shift, 6   @ bitWidth 5 (ADC group regular sequencer rank  6)  
        .equ ADC3_SQR2_SQ5_Shift, 0   @ bitWidth 5 (ADC group regular sequencer rank  5)  
 
    .equ ADC3_SQR3, ADC3_BASE + 0x38 @ (ADC group regular sequencer ranks register  3) 
        .equ ADC3_SQR3_SQ14_Shift, 24   @ bitWidth 5 (ADC group regular sequencer rank  14)  
        .equ ADC3_SQR3_SQ13_Shift, 18   @ bitWidth 5 (ADC group regular sequencer rank  13)  
        .equ ADC3_SQR3_SQ12_Shift, 12   @ bitWidth 5 (ADC group regular sequencer rank  12)  
        .equ ADC3_SQR3_SQ11_Shift, 6   @ bitWidth 5 (ADC group regular sequencer rank  11)  
        .equ ADC3_SQR3_SQ10_Shift, 0   @ bitWidth 5 (ADC group regular sequencer rank  10)  
 
    .equ ADC3_SQR4, ADC3_BASE + 0x3C @ (ADC group regular sequencer ranks register  4) 
        .equ ADC3_SQR4_SQ16_Shift, 6   @ bitWidth 5 (ADC group regular sequencer rank  16)  
        .equ ADC3_SQR4_SQ15_Shift, 0   @ bitWidth 5 (ADC group regular sequencer rank  15)  
 
    .equ ADC3_DR, ADC3_BASE + 0x40 @ (ADC group regular conversion data  register) 
        .equ ADC3_DR_RDATA_Shift, 0   @ bitWidth 16 (ADC group regular conversion  data)  
 
    .equ ADC3_JSQR, ADC3_BASE + 0x4C @ (ADC group injected sequencer  register) 
        .equ ADC3_JSQR_JSQ4_Shift, 27   @ bitWidth 5 (ADC group injected sequencer rank  4)  
        .equ ADC3_JSQR_JSQ3_Shift, 21   @ bitWidth 5 (ADC group injected sequencer rank  3)  
        .equ ADC3_JSQR_JSQ2_Shift, 15   @ bitWidth 5 (ADC group injected sequencer rank  2)  
        .equ ADC3_JSQR_JSQ1_Shift, 9   @ bitWidth 5 (ADC group injected sequencer rank  1)  
        .equ ADC3_JSQR_JEXTEN_Shift, 7   @ bitWidth 2 (ADC group injected external trigger  polarity)  
        .equ ADC3_JSQR_JEXTSEL_Shift, 2   @ bitWidth 5 (ADC group injected external trigger  source)  
        .equ ADC3_JSQR_JL_Shift, 0   @ bitWidth 2 (ADC group injected sequencer scan  length)  
 
    .equ ADC3_OFR1, ADC3_BASE + 0x60 @ (ADC offset number 1 register) 
        .equ ADC3_OFR1_SSATE, 1 << 31   @ bitWidth 1 (ADC offset number 1 enable)  
        .equ ADC3_OFR1_OFFSET1_CH_Shift, 26   @ bitWidth 5 (ADC offset number 1 channel  selection)  
        .equ ADC3_OFR1_OFFSET1_Shift, 0   @ bitWidth 26 (ADC offset number 1 offset  level)  
 
    .equ ADC3_OFR2, ADC3_BASE + 0x64 @ (ADC offset number 2 register) 
        .equ ADC3_OFR2_SSATE, 1 << 31   @ bitWidth 1 (ADC offset number 1 enable)  
        .equ ADC3_OFR2_OFFSET1_CH_Shift, 26   @ bitWidth 5 (ADC offset number 1 channel  selection)  
        .equ ADC3_OFR2_OFFSET1_Shift, 0   @ bitWidth 26 (ADC offset number 1 offset  level)  
 
    .equ ADC3_OFR3, ADC3_BASE + 0x68 @ (ADC offset number 3 register) 
        .equ ADC3_OFR3_SSATE, 1 << 31   @ bitWidth 1 (ADC offset number 1 enable)  
        .equ ADC3_OFR3_OFFSET1_CH_Shift, 26   @ bitWidth 5 (ADC offset number 1 channel  selection)  
        .equ ADC3_OFR3_OFFSET1_Shift, 0   @ bitWidth 26 (ADC offset number 1 offset  level)  
 
    .equ ADC3_OFR4, ADC3_BASE + 0x6C @ (ADC offset number 4 register) 
        .equ ADC3_OFR4_SSATE, 1 << 31   @ bitWidth 1 (ADC offset number 1 enable)  
        .equ ADC3_OFR4_OFFSET1_CH_Shift, 26   @ bitWidth 5 (ADC offset number 1 channel  selection)  
        .equ ADC3_OFR4_OFFSET1_Shift, 0   @ bitWidth 26 (ADC offset number 1 offset  level)  
 
    .equ ADC3_JDR1, ADC3_BASE + 0x80 @ (ADC group injected sequencer rank 1  register) 
        .equ ADC3_JDR1_JDATA1_Shift, 0   @ bitWidth 32 (ADC group injected sequencer rank 1  conversion data)  
 
    .equ ADC3_JDR2, ADC3_BASE + 0x84 @ (ADC group injected sequencer rank 2  register) 
        .equ ADC3_JDR2_JDATA2_Shift, 0   @ bitWidth 32 (ADC group injected sequencer rank 2  conversion data)  
 
    .equ ADC3_JDR3, ADC3_BASE + 0x88 @ (ADC group injected sequencer rank 3  register) 
        .equ ADC3_JDR3_JDATA3_Shift, 0   @ bitWidth 32 (ADC group injected sequencer rank 3  conversion data)  
 
    .equ ADC3_JDR4, ADC3_BASE + 0x8C @ (ADC group injected sequencer rank 4  register) 
        .equ ADC3_JDR4_JDATA4_Shift, 0   @ bitWidth 32 (ADC group injected sequencer rank 4  conversion data)  
 
    .equ ADC3_AWD2CR, ADC3_BASE + 0xA0 @ (ADC analog watchdog 2 configuration  register) 
        .equ ADC3_AWD2CR_AWD2CH_Shift, 0   @ bitWidth 20 (ADC analog watchdog 2 monitored channel  selection)  
 
    .equ ADC3_AWD3CR, ADC3_BASE + 0xA4 @ (ADC analog watchdog 3 configuration  register) 
        .equ ADC3_AWD3CR_AWD3CH_Shift, 1   @ bitWidth 20 (ADC analog watchdog 3 monitored channel  selection)  
 
    .equ ADC3_DIFSEL, ADC3_BASE + 0xC0 @ (ADC channel differential or single-ended  mode selection register) 
        .equ ADC3_DIFSEL_DIFSEL_Shift, 0   @ bitWidth 20 (ADC channel differential or single-ended  mode for channel)  
 
    .equ ADC3_CALFACT, ADC3_BASE + 0xC4 @ (ADC calibration factors  register) 
        .equ ADC3_CALFACT_CALFACT_D_Shift, 16   @ bitWidth 11 (ADC calibration factor in differential  mode)  
        .equ ADC3_CALFACT_CALFACT_S_Shift, 0   @ bitWidth 11 (ADC calibration factor in single-ended  mode)  
 
    .equ ADC3_PCSEL, ADC3_BASE + 0x1C @ (ADC pre channel selection  register) 
        .equ ADC3_PCSEL_PCSEL_Shift, 0   @ bitWidth 20 (Channel x VINP[i] pre  selection)  
 
    .equ ADC3_LTR2, ADC3_BASE + 0xB0 @ (ADC watchdog lower threshold register  2) 
        .equ ADC3_LTR2_LTR2_Shift, 0   @ bitWidth 26 (Analog watchdog 2 lower  threshold)  
 
    .equ ADC3_HTR2, ADC3_BASE + 0xB4 @ (ADC watchdog higher threshold register  2) 
        .equ ADC3_HTR2_HTR2_Shift, 0   @ bitWidth 26 (Analog watchdog 2 higher  threshold)  
 
    .equ ADC3_LTR3, ADC3_BASE + 0xB8 @ (ADC watchdog lower threshold register  3) 
        .equ ADC3_LTR3_LTR3_Shift, 0   @ bitWidth 26 (Analog watchdog 3 lower  threshold)  
 
    .equ ADC3_HTR3, ADC3_BASE + 0xBC @ (ADC watchdog higher threshold register  3) 
        .equ ADC3_HTR3_HTR3_Shift, 0   @ bitWidth 26 (Analog watchdog 3 higher  threshold)  
 
    .equ ADC3_CALFACT2, ADC3_BASE + 0xC8 @ (ADC Calibration Factor register  2) 
        .equ ADC3_CALFACT2_LINCALFACT_Shift, 0   @ bitWidth 30 (Linearity Calibration  Factor)  
 

@=========================== ADC1 ===========================@
.equ ADC1_BASE, 0x40022000 @ (Analog to Digital Converter) 
    .equ ADC1_ISR, ADC1_BASE + 0x0 @ (ADC interrupt and status  register) 
        .equ ADC1_ISR_JQOVF, 1 << 10   @ bitWidth 1 (ADC group injected contexts queue  overflow flag)  
        .equ ADC1_ISR_AWD3, 1 << 9   @ bitWidth 1 (ADC analog watchdog 3 flag)  
        .equ ADC1_ISR_AWD2, 1 << 8   @ bitWidth 1 (ADC analog watchdog 2 flag)  
        .equ ADC1_ISR_AWD1, 1 << 7   @ bitWidth 1 (ADC analog watchdog 1 flag)  
        .equ ADC1_ISR_JEOS, 1 << 6   @ bitWidth 1 (ADC group injected end of sequence  conversions flag)  
        .equ ADC1_ISR_JEOC, 1 << 5   @ bitWidth 1 (ADC group injected end of unitary  conversion flag)  
        .equ ADC1_ISR_OVR, 1 << 4   @ bitWidth 1 (ADC group regular overrun  flag)  
        .equ ADC1_ISR_EOS, 1 << 3   @ bitWidth 1 (ADC group regular end of sequence  conversions flag)  
        .equ ADC1_ISR_EOC, 1 << 2   @ bitWidth 1 (ADC group regular end of unitary  conversion flag)  
        .equ ADC1_ISR_EOSMP, 1 << 1   @ bitWidth 1 (ADC group regular end of sampling  flag)  
        .equ ADC1_ISR_ADRDY, 1 << 0   @ bitWidth 1 (ADC ready flag)  
 
    .equ ADC1_IER, ADC1_BASE + 0x4 @ (ADC interrupt enable register) 
        .equ ADC1_IER_JQOVFIE, 1 << 10   @ bitWidth 1 (ADC group injected contexts queue  overflow interrupt)  
        .equ ADC1_IER_AWD3IE, 1 << 9   @ bitWidth 1 (ADC analog watchdog 3  interrupt)  
        .equ ADC1_IER_AWD2IE, 1 << 8   @ bitWidth 1 (ADC analog watchdog 2  interrupt)  
        .equ ADC1_IER_AWD1IE, 1 << 7   @ bitWidth 1 (ADC analog watchdog 1  interrupt)  
        .equ ADC1_IER_JEOSIE, 1 << 6   @ bitWidth 1 (ADC group injected end of sequence  conversions interrupt)  
        .equ ADC1_IER_JEOCIE, 1 << 5   @ bitWidth 1 (ADC group injected end of unitary  conversion interrupt)  
        .equ ADC1_IER_OVRIE, 1 << 4   @ bitWidth 1 (ADC group regular overrun  interrupt)  
        .equ ADC1_IER_EOSIE, 1 << 3   @ bitWidth 1 (ADC group regular end of sequence  conversions interrupt)  
        .equ ADC1_IER_EOCIE, 1 << 2   @ bitWidth 1 (ADC group regular end of unitary  conversion interrupt)  
        .equ ADC1_IER_EOSMPIE, 1 << 1   @ bitWidth 1 (ADC group regular end of sampling  interrupt)  
        .equ ADC1_IER_ADRDYIE, 1 << 0   @ bitWidth 1 (ADC ready interrupt)  
 
    .equ ADC1_CR, ADC1_BASE + 0x8 @ (ADC control register) 
        .equ ADC1_CR_ADCAL, 1 << 31   @ bitWidth 1 (ADC calibration)  
        .equ ADC1_CR_ADCALDIF, 1 << 30   @ bitWidth 1 (ADC differential mode for  calibration)  
        .equ ADC1_CR_DEEPPWD, 1 << 29   @ bitWidth 1 (ADC deep power down enable)  
        .equ ADC1_CR_ADVREGEN, 1 << 28   @ bitWidth 1 (ADC voltage regulator  enable)  
        .equ ADC1_CR_LINCALRDYW6, 1 << 27   @ bitWidth 1 (Linearity calibration ready Word  6)  
        .equ ADC1_CR_LINCALRDYW5, 1 << 26   @ bitWidth 1 (Linearity calibration ready Word  5)  
        .equ ADC1_CR_LINCALRDYW4, 1 << 25   @ bitWidth 1 (Linearity calibration ready Word  4)  
        .equ ADC1_CR_LINCALRDYW3, 1 << 24   @ bitWidth 1 (Linearity calibration ready Word  3)  
        .equ ADC1_CR_LINCALRDYW2, 1 << 23   @ bitWidth 1 (Linearity calibration ready Word  2)  
        .equ ADC1_CR_LINCALRDYW1, 1 << 22   @ bitWidth 1 (Linearity calibration ready Word  1)  
        .equ ADC1_CR_ADCALLIN, 1 << 16   @ bitWidth 1 (Linearity calibration)  
        .equ ADC1_CR_BOOST, 1 << 8   @ bitWidth 1 (Boost mode control)  
        .equ ADC1_CR_JADSTP, 1 << 5   @ bitWidth 1 (ADC group injected conversion  stop)  
        .equ ADC1_CR_ADSTP, 1 << 4   @ bitWidth 1 (ADC group regular conversion  stop)  
        .equ ADC1_CR_JADSTART, 1 << 3   @ bitWidth 1 (ADC group injected conversion  start)  
        .equ ADC1_CR_ADSTART, 1 << 2   @ bitWidth 1 (ADC group regular conversion  start)  
        .equ ADC1_CR_ADDIS, 1 << 1   @ bitWidth 1 (ADC disable)  
        .equ ADC1_CR_ADEN, 1 << 0   @ bitWidth 1 (ADC enable)  
 
    .equ ADC1_CFGR, ADC1_BASE + 0xC @ (ADC configuration register 1) 
        .equ ADC1_CFGR_JQDIS, 1 << 31   @ bitWidth 1 (ADC group injected contexts queue  disable)  
        .equ ADC1_CFGR_AWDCH1CH_Shift, 26   @ bitWidth 5 (ADC analog watchdog 1 monitored channel  selection)  
        .equ ADC1_CFGR_JAUTO, 1 << 25   @ bitWidth 1 (ADC group injected automatic trigger  mode)  
        .equ ADC1_CFGR_JAWD1EN, 1 << 24   @ bitWidth 1 (ADC analog watchdog 1 enable on scope  ADC group injected)  
        .equ ADC1_CFGR_AWD1EN, 1 << 23   @ bitWidth 1 (ADC analog watchdog 1 enable on scope  ADC group regular)  
        .equ ADC1_CFGR_AWD1SGL, 1 << 22   @ bitWidth 1 (ADC analog watchdog 1 monitoring a  single channel or all channels)  
        .equ ADC1_CFGR_JQM, 1 << 21   @ bitWidth 1 (ADC group injected contexts queue  mode)  
        .equ ADC1_CFGR_JDISCEN, 1 << 20   @ bitWidth 1 (ADC group injected sequencer  discontinuous mode)  
        .equ ADC1_CFGR_DISCNUM_Shift, 17   @ bitWidth 3 (ADC group regular sequencer  discontinuous number of ranks)  
        .equ ADC1_CFGR_DISCEN, 1 << 16   @ bitWidth 1 (ADC group regular sequencer  discontinuous mode)  
        .equ ADC1_CFGR_AUTDLY, 1 << 14   @ bitWidth 1 (ADC low power auto wait)  
        .equ ADC1_CFGR_CONT, 1 << 13   @ bitWidth 1 (ADC group regular continuous conversion  mode)  
        .equ ADC1_CFGR_OVRMOD, 1 << 12   @ bitWidth 1 (ADC group regular overrun  configuration)  
        .equ ADC1_CFGR_EXTEN_Shift, 10   @ bitWidth 2 (ADC group regular external trigger  polarity)  
        .equ ADC1_CFGR_EXTSEL_Shift, 5   @ bitWidth 5 (ADC group regular external trigger  source)  
        .equ ADC1_CFGR_RES_Shift, 2   @ bitWidth 3 (ADC data resolution)  
        .equ ADC1_CFGR_DMNGT_Shift, 0   @ bitWidth 2 (ADC DMA transfer enable)  
 
    .equ ADC1_CFGR2, ADC1_BASE + 0x10 @ (ADC configuration register 2) 
        .equ ADC1_CFGR2_ROVSE, 1 << 0   @ bitWidth 1 (ADC oversampler enable on scope ADC  group regular)  
        .equ ADC1_CFGR2_JOVSE, 1 << 1   @ bitWidth 1 (ADC oversampler enable on scope ADC  group injected)  
        .equ ADC1_CFGR2_OVSS_Shift, 5   @ bitWidth 4 (ADC oversampling shift)  
        .equ ADC1_CFGR2_TROVS, 1 << 9   @ bitWidth 1 (ADC oversampling discontinuous mode  triggered mode for ADC group regular)  
        .equ ADC1_CFGR2_ROVSM, 1 << 10   @ bitWidth 1 (Regular Oversampling mode)  
        .equ ADC1_CFGR2_RSHIFT1, 1 << 11   @ bitWidth 1 (Right-shift data after Offset 1  correction)  
        .equ ADC1_CFGR2_RSHIFT2, 1 << 12   @ bitWidth 1 (Right-shift data after Offset 2  correction)  
        .equ ADC1_CFGR2_RSHIFT3, 1 << 13   @ bitWidth 1 (Right-shift data after Offset 3  correction)  
        .equ ADC1_CFGR2_RSHIFT4, 1 << 14   @ bitWidth 1 (Right-shift data after Offset 4  correction)  
        .equ ADC1_CFGR2_OSR_Shift, 16   @ bitWidth 10 (Oversampling ratio)  
        .equ ADC1_CFGR2_LSHIFT_Shift, 28   @ bitWidth 4 (Left shift factor)  
 
    .equ ADC1_SMPR1, ADC1_BASE + 0x14 @ (ADC sampling time register 1) 
        .equ ADC1_SMPR1_SMP9_Shift, 27   @ bitWidth 3 (ADC channel 9 sampling time  selection)  
        .equ ADC1_SMPR1_SMP8_Shift, 24   @ bitWidth 3 (ADC channel 8 sampling time  selection)  
        .equ ADC1_SMPR1_SMP7_Shift, 21   @ bitWidth 3 (ADC channel 7 sampling time  selection)  
        .equ ADC1_SMPR1_SMP6_Shift, 18   @ bitWidth 3 (ADC channel 6 sampling time  selection)  
        .equ ADC1_SMPR1_SMP5_Shift, 15   @ bitWidth 3 (ADC channel 5 sampling time  selection)  
        .equ ADC1_SMPR1_SMP4_Shift, 12   @ bitWidth 3 (ADC channel 4 sampling time  selection)  
        .equ ADC1_SMPR1_SMP3_Shift, 9   @ bitWidth 3 (ADC channel 3 sampling time  selection)  
        .equ ADC1_SMPR1_SMP2_Shift, 6   @ bitWidth 3 (ADC channel 2 sampling time  selection)  
        .equ ADC1_SMPR1_SMP1_Shift, 3   @ bitWidth 3 (ADC channel 1 sampling time  selection)  
 
    .equ ADC1_SMPR2, ADC1_BASE + 0x18 @ (ADC sampling time register 2) 
        .equ ADC1_SMPR2_SMP19_Shift, 27   @ bitWidth 3 (ADC channel 18 sampling time  selection)  
        .equ ADC1_SMPR2_SMP18_Shift, 24   @ bitWidth 3 (ADC channel 18 sampling time  selection)  
        .equ ADC1_SMPR2_SMP17_Shift, 21   @ bitWidth 3 (ADC channel 17 sampling time  selection)  
        .equ ADC1_SMPR2_SMP16_Shift, 18   @ bitWidth 3 (ADC channel 16 sampling time  selection)  
        .equ ADC1_SMPR2_SMP15_Shift, 15   @ bitWidth 3 (ADC channel 15 sampling time  selection)  
        .equ ADC1_SMPR2_SMP14_Shift, 12   @ bitWidth 3 (ADC channel 14 sampling time  selection)  
        .equ ADC1_SMPR2_SMP13_Shift, 9   @ bitWidth 3 (ADC channel 13 sampling time  selection)  
        .equ ADC1_SMPR2_SMP12_Shift, 6   @ bitWidth 3 (ADC channel 12 sampling time  selection)  
        .equ ADC1_SMPR2_SMP11_Shift, 3   @ bitWidth 3 (ADC channel 11 sampling time  selection)  
        .equ ADC1_SMPR2_SMP10_Shift, 0   @ bitWidth 3 (ADC channel 10 sampling time  selection)  
 
    .equ ADC1_LTR1, ADC1_BASE + 0x20 @ (ADC analog watchdog 1 threshold  register) 
        .equ ADC1_LTR1_LTR1_Shift, 0   @ bitWidth 26 (ADC analog watchdog 1 threshold  low)  
 
    .equ ADC1_LHTR1, ADC1_BASE + 0x24 @ (ADC analog watchdog 2 threshold  register) 
        .equ ADC1_LHTR1_LHTR1_Shift, 0   @ bitWidth 26 (ADC analog watchdog 2 threshold  low)  
 
    .equ ADC1_SQR1, ADC1_BASE + 0x30 @ (ADC group regular sequencer ranks register  1) 
        .equ ADC1_SQR1_SQ4_Shift, 24   @ bitWidth 5 (ADC group regular sequencer rank  4)  
        .equ ADC1_SQR1_SQ3_Shift, 18   @ bitWidth 5 (ADC group regular sequencer rank  3)  
        .equ ADC1_SQR1_SQ2_Shift, 12   @ bitWidth 5 (ADC group regular sequencer rank  2)  
        .equ ADC1_SQR1_SQ1_Shift, 6   @ bitWidth 5 (ADC group regular sequencer rank  1)  
        .equ ADC1_SQR1_L3_Shift, 0   @ bitWidth 4 (L3)  
 
    .equ ADC1_SQR2, ADC1_BASE + 0x34 @ (ADC group regular sequencer ranks register  2) 
        .equ ADC1_SQR2_SQ9_Shift, 24   @ bitWidth 5 (ADC group regular sequencer rank  9)  
        .equ ADC1_SQR2_SQ8_Shift, 18   @ bitWidth 5 (ADC group regular sequencer rank  8)  
        .equ ADC1_SQR2_SQ7_Shift, 12   @ bitWidth 5 (ADC group regular sequencer rank  7)  
        .equ ADC1_SQR2_SQ6_Shift, 6   @ bitWidth 5 (ADC group regular sequencer rank  6)  
        .equ ADC1_SQR2_SQ5_Shift, 0   @ bitWidth 5 (ADC group regular sequencer rank  5)  
 
    .equ ADC1_SQR3, ADC1_BASE + 0x38 @ (ADC group regular sequencer ranks register  3) 
        .equ ADC1_SQR3_SQ14_Shift, 24   @ bitWidth 5 (ADC group regular sequencer rank  14)  
        .equ ADC1_SQR3_SQ13_Shift, 18   @ bitWidth 5 (ADC group regular sequencer rank  13)  
        .equ ADC1_SQR3_SQ12_Shift, 12   @ bitWidth 5 (ADC group regular sequencer rank  12)  
        .equ ADC1_SQR3_SQ11_Shift, 6   @ bitWidth 5 (ADC group regular sequencer rank  11)  
        .equ ADC1_SQR3_SQ10_Shift, 0   @ bitWidth 5 (ADC group regular sequencer rank  10)  
 
    .equ ADC1_SQR4, ADC1_BASE + 0x3C @ (ADC group regular sequencer ranks register  4) 
        .equ ADC1_SQR4_SQ16_Shift, 6   @ bitWidth 5 (ADC group regular sequencer rank  16)  
        .equ ADC1_SQR4_SQ15_Shift, 0   @ bitWidth 5 (ADC group regular sequencer rank  15)  
 
    .equ ADC1_DR, ADC1_BASE + 0x40 @ (ADC group regular conversion data  register) 
        .equ ADC1_DR_RDATA_Shift, 0   @ bitWidth 16 (ADC group regular conversion  data)  
 
    .equ ADC1_JSQR, ADC1_BASE + 0x4C @ (ADC group injected sequencer  register) 
        .equ ADC1_JSQR_JSQ4_Shift, 27   @ bitWidth 5 (ADC group injected sequencer rank  4)  
        .equ ADC1_JSQR_JSQ3_Shift, 21   @ bitWidth 5 (ADC group injected sequencer rank  3)  
        .equ ADC1_JSQR_JSQ2_Shift, 15   @ bitWidth 5 (ADC group injected sequencer rank  2)  
        .equ ADC1_JSQR_JSQ1_Shift, 9   @ bitWidth 5 (ADC group injected sequencer rank  1)  
        .equ ADC1_JSQR_JEXTEN_Shift, 7   @ bitWidth 2 (ADC group injected external trigger  polarity)  
        .equ ADC1_JSQR_JEXTSEL_Shift, 2   @ bitWidth 5 (ADC group injected external trigger  source)  
        .equ ADC1_JSQR_JL_Shift, 0   @ bitWidth 2 (ADC group injected sequencer scan  length)  
 
    .equ ADC1_OFR1, ADC1_BASE + 0x60 @ (ADC offset number 1 register) 
        .equ ADC1_OFR1_SSATE, 1 << 31   @ bitWidth 1 (ADC offset number 1 enable)  
        .equ ADC1_OFR1_OFFSET1_CH_Shift, 26   @ bitWidth 5 (ADC offset number 1 channel  selection)  
        .equ ADC1_OFR1_OFFSET1_Shift, 0   @ bitWidth 26 (ADC offset number 1 offset  level)  
 
    .equ ADC1_OFR2, ADC1_BASE + 0x64 @ (ADC offset number 2 register) 
        .equ ADC1_OFR2_SSATE, 1 << 31   @ bitWidth 1 (ADC offset number 1 enable)  
        .equ ADC1_OFR2_OFFSET1_CH_Shift, 26   @ bitWidth 5 (ADC offset number 1 channel  selection)  
        .equ ADC1_OFR2_OFFSET1_Shift, 0   @ bitWidth 26 (ADC offset number 1 offset  level)  
 
    .equ ADC1_OFR3, ADC1_BASE + 0x68 @ (ADC offset number 3 register) 
        .equ ADC1_OFR3_SSATE, 1 << 31   @ bitWidth 1 (ADC offset number 1 enable)  
        .equ ADC1_OFR3_OFFSET1_CH_Shift, 26   @ bitWidth 5 (ADC offset number 1 channel  selection)  
        .equ ADC1_OFR3_OFFSET1_Shift, 0   @ bitWidth 26 (ADC offset number 1 offset  level)  
 
    .equ ADC1_OFR4, ADC1_BASE + 0x6C @ (ADC offset number 4 register) 
        .equ ADC1_OFR4_SSATE, 1 << 31   @ bitWidth 1 (ADC offset number 1 enable)  
        .equ ADC1_OFR4_OFFSET1_CH_Shift, 26   @ bitWidth 5 (ADC offset number 1 channel  selection)  
        .equ ADC1_OFR4_OFFSET1_Shift, 0   @ bitWidth 26 (ADC offset number 1 offset  level)  
 
    .equ ADC1_JDR1, ADC1_BASE + 0x80 @ (ADC group injected sequencer rank 1  register) 
        .equ ADC1_JDR1_JDATA1_Shift, 0   @ bitWidth 32 (ADC group injected sequencer rank 1  conversion data)  
 
    .equ ADC1_JDR2, ADC1_BASE + 0x84 @ (ADC group injected sequencer rank 2  register) 
        .equ ADC1_JDR2_JDATA2_Shift, 0   @ bitWidth 32 (ADC group injected sequencer rank 2  conversion data)  
 
    .equ ADC1_JDR3, ADC1_BASE + 0x88 @ (ADC group injected sequencer rank 3  register) 
        .equ ADC1_JDR3_JDATA3_Shift, 0   @ bitWidth 32 (ADC group injected sequencer rank 3  conversion data)  
 
    .equ ADC1_JDR4, ADC1_BASE + 0x8C @ (ADC group injected sequencer rank 4  register) 
        .equ ADC1_JDR4_JDATA4_Shift, 0   @ bitWidth 32 (ADC group injected sequencer rank 4  conversion data)  
 
    .equ ADC1_AWD2CR, ADC1_BASE + 0xA0 @ (ADC analog watchdog 2 configuration  register) 
        .equ ADC1_AWD2CR_AWD2CH_Shift, 0   @ bitWidth 20 (ADC analog watchdog 2 monitored channel  selection)  
 
    .equ ADC1_AWD3CR, ADC1_BASE + 0xA4 @ (ADC analog watchdog 3 configuration  register) 
        .equ ADC1_AWD3CR_AWD3CH_Shift, 1   @ bitWidth 20 (ADC analog watchdog 3 monitored channel  selection)  
 
    .equ ADC1_DIFSEL, ADC1_BASE + 0xC0 @ (ADC channel differential or single-ended  mode selection register) 
        .equ ADC1_DIFSEL_DIFSEL_Shift, 0   @ bitWidth 20 (ADC channel differential or single-ended  mode for channel)  
 
    .equ ADC1_CALFACT, ADC1_BASE + 0xC4 @ (ADC calibration factors  register) 
        .equ ADC1_CALFACT_CALFACT_D_Shift, 16   @ bitWidth 11 (ADC calibration factor in differential  mode)  
        .equ ADC1_CALFACT_CALFACT_S_Shift, 0   @ bitWidth 11 (ADC calibration factor in single-ended  mode)  
 
    .equ ADC1_PCSEL, ADC1_BASE + 0x1C @ (ADC pre channel selection  register) 
        .equ ADC1_PCSEL_PCSEL_Shift, 0   @ bitWidth 20 (Channel x VINP[i] pre  selection)  
 
    .equ ADC1_LTR2, ADC1_BASE + 0xB0 @ (ADC watchdog lower threshold register  2) 
        .equ ADC1_LTR2_LTR2_Shift, 0   @ bitWidth 26 (Analog watchdog 2 lower  threshold)  
 
    .equ ADC1_HTR2, ADC1_BASE + 0xB4 @ (ADC watchdog higher threshold register  2) 
        .equ ADC1_HTR2_HTR2_Shift, 0   @ bitWidth 26 (Analog watchdog 2 higher  threshold)  
 
    .equ ADC1_LTR3, ADC1_BASE + 0xB8 @ (ADC watchdog lower threshold register  3) 
        .equ ADC1_LTR3_LTR3_Shift, 0   @ bitWidth 26 (Analog watchdog 3 lower  threshold)  
 
    .equ ADC1_HTR3, ADC1_BASE + 0xBC @ (ADC watchdog higher threshold register  3) 
        .equ ADC1_HTR3_HTR3_Shift, 0   @ bitWidth 26 (Analog watchdog 3 higher  threshold)  
 
    .equ ADC1_CALFACT2, ADC1_BASE + 0xC8 @ (ADC Calibration Factor register  2) 
        .equ ADC1_CALFACT2_LINCALFACT_Shift, 0   @ bitWidth 30 (Linearity Calibration  Factor)  
 

@=========================== ADC2 ===========================@
.equ ADC2_BASE, 0x40022100 @ (Analog to Digital Converter) 
    .equ ADC2_ISR, ADC2_BASE + 0x0 @ (ADC interrupt and status  register) 
        .equ ADC2_ISR_JQOVF, 1 << 10   @ bitWidth 1 (ADC group injected contexts queue  overflow flag)  
        .equ ADC2_ISR_AWD3, 1 << 9   @ bitWidth 1 (ADC analog watchdog 3 flag)  
        .equ ADC2_ISR_AWD2, 1 << 8   @ bitWidth 1 (ADC analog watchdog 2 flag)  
        .equ ADC2_ISR_AWD1, 1 << 7   @ bitWidth 1 (ADC analog watchdog 1 flag)  
        .equ ADC2_ISR_JEOS, 1 << 6   @ bitWidth 1 (ADC group injected end of sequence  conversions flag)  
        .equ ADC2_ISR_JEOC, 1 << 5   @ bitWidth 1 (ADC group injected end of unitary  conversion flag)  
        .equ ADC2_ISR_OVR, 1 << 4   @ bitWidth 1 (ADC group regular overrun  flag)  
        .equ ADC2_ISR_EOS, 1 << 3   @ bitWidth 1 (ADC group regular end of sequence  conversions flag)  
        .equ ADC2_ISR_EOC, 1 << 2   @ bitWidth 1 (ADC group regular end of unitary  conversion flag)  
        .equ ADC2_ISR_EOSMP, 1 << 1   @ bitWidth 1 (ADC group regular end of sampling  flag)  
        .equ ADC2_ISR_ADRDY, 1 << 0   @ bitWidth 1 (ADC ready flag)  
 
    .equ ADC2_IER, ADC2_BASE + 0x4 @ (ADC interrupt enable register) 
        .equ ADC2_IER_JQOVFIE, 1 << 10   @ bitWidth 1 (ADC group injected contexts queue  overflow interrupt)  
        .equ ADC2_IER_AWD3IE, 1 << 9   @ bitWidth 1 (ADC analog watchdog 3  interrupt)  
        .equ ADC2_IER_AWD2IE, 1 << 8   @ bitWidth 1 (ADC analog watchdog 2  interrupt)  
        .equ ADC2_IER_AWD1IE, 1 << 7   @ bitWidth 1 (ADC analog watchdog 1  interrupt)  
        .equ ADC2_IER_JEOSIE, 1 << 6   @ bitWidth 1 (ADC group injected end of sequence  conversions interrupt)  
        .equ ADC2_IER_JEOCIE, 1 << 5   @ bitWidth 1 (ADC group injected end of unitary  conversion interrupt)  
        .equ ADC2_IER_OVRIE, 1 << 4   @ bitWidth 1 (ADC group regular overrun  interrupt)  
        .equ ADC2_IER_EOSIE, 1 << 3   @ bitWidth 1 (ADC group regular end of sequence  conversions interrupt)  
        .equ ADC2_IER_EOCIE, 1 << 2   @ bitWidth 1 (ADC group regular end of unitary  conversion interrupt)  
        .equ ADC2_IER_EOSMPIE, 1 << 1   @ bitWidth 1 (ADC group regular end of sampling  interrupt)  
        .equ ADC2_IER_ADRDYIE, 1 << 0   @ bitWidth 1 (ADC ready interrupt)  
 
    .equ ADC2_CR, ADC2_BASE + 0x8 @ (ADC control register) 
        .equ ADC2_CR_ADCAL, 1 << 31   @ bitWidth 1 (ADC calibration)  
        .equ ADC2_CR_ADCALDIF, 1 << 30   @ bitWidth 1 (ADC differential mode for  calibration)  
        .equ ADC2_CR_DEEPPWD, 1 << 29   @ bitWidth 1 (ADC deep power down enable)  
        .equ ADC2_CR_ADVREGEN, 1 << 28   @ bitWidth 1 (ADC voltage regulator  enable)  
        .equ ADC2_CR_LINCALRDYW6, 1 << 27   @ bitWidth 1 (Linearity calibration ready Word  6)  
        .equ ADC2_CR_LINCALRDYW5, 1 << 26   @ bitWidth 1 (Linearity calibration ready Word  5)  
        .equ ADC2_CR_LINCALRDYW4, 1 << 25   @ bitWidth 1 (Linearity calibration ready Word  4)  
        .equ ADC2_CR_LINCALRDYW3, 1 << 24   @ bitWidth 1 (Linearity calibration ready Word  3)  
        .equ ADC2_CR_LINCALRDYW2, 1 << 23   @ bitWidth 1 (Linearity calibration ready Word  2)  
        .equ ADC2_CR_LINCALRDYW1, 1 << 22   @ bitWidth 1 (Linearity calibration ready Word  1)  
        .equ ADC2_CR_ADCALLIN, 1 << 16   @ bitWidth 1 (Linearity calibration)  
        .equ ADC2_CR_BOOST, 1 << 8   @ bitWidth 1 (Boost mode control)  
        .equ ADC2_CR_JADSTP, 1 << 5   @ bitWidth 1 (ADC group injected conversion  stop)  
        .equ ADC2_CR_ADSTP, 1 << 4   @ bitWidth 1 (ADC group regular conversion  stop)  
        .equ ADC2_CR_JADSTART, 1 << 3   @ bitWidth 1 (ADC group injected conversion  start)  
        .equ ADC2_CR_ADSTART, 1 << 2   @ bitWidth 1 (ADC group regular conversion  start)  
        .equ ADC2_CR_ADDIS, 1 << 1   @ bitWidth 1 (ADC disable)  
        .equ ADC2_CR_ADEN, 1 << 0   @ bitWidth 1 (ADC enable)  
 
    .equ ADC2_CFGR, ADC2_BASE + 0xC @ (ADC configuration register 1) 
        .equ ADC2_CFGR_JQDIS, 1 << 31   @ bitWidth 1 (ADC group injected contexts queue  disable)  
        .equ ADC2_CFGR_AWDCH1CH_Shift, 26   @ bitWidth 5 (ADC analog watchdog 1 monitored channel  selection)  
        .equ ADC2_CFGR_JAUTO, 1 << 25   @ bitWidth 1 (ADC group injected automatic trigger  mode)  
        .equ ADC2_CFGR_JAWD1EN, 1 << 24   @ bitWidth 1 (ADC analog watchdog 1 enable on scope  ADC group injected)  
        .equ ADC2_CFGR_AWD1EN, 1 << 23   @ bitWidth 1 (ADC analog watchdog 1 enable on scope  ADC group regular)  
        .equ ADC2_CFGR_AWD1SGL, 1 << 22   @ bitWidth 1 (ADC analog watchdog 1 monitoring a  single channel or all channels)  
        .equ ADC2_CFGR_JQM, 1 << 21   @ bitWidth 1 (ADC group injected contexts queue  mode)  
        .equ ADC2_CFGR_JDISCEN, 1 << 20   @ bitWidth 1 (ADC group injected sequencer  discontinuous mode)  
        .equ ADC2_CFGR_DISCNUM_Shift, 17   @ bitWidth 3 (ADC group regular sequencer  discontinuous number of ranks)  
        .equ ADC2_CFGR_DISCEN, 1 << 16   @ bitWidth 1 (ADC group regular sequencer  discontinuous mode)  
        .equ ADC2_CFGR_AUTDLY, 1 << 14   @ bitWidth 1 (ADC low power auto wait)  
        .equ ADC2_CFGR_CONT, 1 << 13   @ bitWidth 1 (ADC group regular continuous conversion  mode)  
        .equ ADC2_CFGR_OVRMOD, 1 << 12   @ bitWidth 1 (ADC group regular overrun  configuration)  
        .equ ADC2_CFGR_EXTEN_Shift, 10   @ bitWidth 2 (ADC group regular external trigger  polarity)  
        .equ ADC2_CFGR_EXTSEL_Shift, 5   @ bitWidth 5 (ADC group regular external trigger  source)  
        .equ ADC2_CFGR_RES_Shift, 2   @ bitWidth 3 (ADC data resolution)  
        .equ ADC2_CFGR_DMNGT_Shift, 0   @ bitWidth 2 (ADC DMA transfer enable)  
 
    .equ ADC2_CFGR2, ADC2_BASE + 0x10 @ (ADC configuration register 2) 
        .equ ADC2_CFGR2_ROVSE, 1 << 0   @ bitWidth 1 (ADC oversampler enable on scope ADC  group regular)  
        .equ ADC2_CFGR2_JOVSE, 1 << 1   @ bitWidth 1 (ADC oversampler enable on scope ADC  group injected)  
        .equ ADC2_CFGR2_OVSS_Shift, 5   @ bitWidth 4 (ADC oversampling shift)  
        .equ ADC2_CFGR2_TROVS, 1 << 9   @ bitWidth 1 (ADC oversampling discontinuous mode  triggered mode for ADC group regular)  
        .equ ADC2_CFGR2_ROVSM, 1 << 10   @ bitWidth 1 (Regular Oversampling mode)  
        .equ ADC2_CFGR2_RSHIFT1, 1 << 11   @ bitWidth 1 (Right-shift data after Offset 1  correction)  
        .equ ADC2_CFGR2_RSHIFT2, 1 << 12   @ bitWidth 1 (Right-shift data after Offset 2  correction)  
        .equ ADC2_CFGR2_RSHIFT3, 1 << 13   @ bitWidth 1 (Right-shift data after Offset 3  correction)  
        .equ ADC2_CFGR2_RSHIFT4, 1 << 14   @ bitWidth 1 (Right-shift data after Offset 4  correction)  
        .equ ADC2_CFGR2_OSR_Shift, 16   @ bitWidth 10 (Oversampling ratio)  
        .equ ADC2_CFGR2_LSHIFT_Shift, 28   @ bitWidth 4 (Left shift factor)  
 
    .equ ADC2_SMPR1, ADC2_BASE + 0x14 @ (ADC sampling time register 1) 
        .equ ADC2_SMPR1_SMP9_Shift, 27   @ bitWidth 3 (ADC channel 9 sampling time  selection)  
        .equ ADC2_SMPR1_SMP8_Shift, 24   @ bitWidth 3 (ADC channel 8 sampling time  selection)  
        .equ ADC2_SMPR1_SMP7_Shift, 21   @ bitWidth 3 (ADC channel 7 sampling time  selection)  
        .equ ADC2_SMPR1_SMP6_Shift, 18   @ bitWidth 3 (ADC channel 6 sampling time  selection)  
        .equ ADC2_SMPR1_SMP5_Shift, 15   @ bitWidth 3 (ADC channel 5 sampling time  selection)  
        .equ ADC2_SMPR1_SMP4_Shift, 12   @ bitWidth 3 (ADC channel 4 sampling time  selection)  
        .equ ADC2_SMPR1_SMP3_Shift, 9   @ bitWidth 3 (ADC channel 3 sampling time  selection)  
        .equ ADC2_SMPR1_SMP2_Shift, 6   @ bitWidth 3 (ADC channel 2 sampling time  selection)  
        .equ ADC2_SMPR1_SMP1_Shift, 3   @ bitWidth 3 (ADC channel 1 sampling time  selection)  
 
    .equ ADC2_SMPR2, ADC2_BASE + 0x18 @ (ADC sampling time register 2) 
        .equ ADC2_SMPR2_SMP19_Shift, 27   @ bitWidth 3 (ADC channel 18 sampling time  selection)  
        .equ ADC2_SMPR2_SMP18_Shift, 24   @ bitWidth 3 (ADC channel 18 sampling time  selection)  
        .equ ADC2_SMPR2_SMP17_Shift, 21   @ bitWidth 3 (ADC channel 17 sampling time  selection)  
        .equ ADC2_SMPR2_SMP16_Shift, 18   @ bitWidth 3 (ADC channel 16 sampling time  selection)  
        .equ ADC2_SMPR2_SMP15_Shift, 15   @ bitWidth 3 (ADC channel 15 sampling time  selection)  
        .equ ADC2_SMPR2_SMP14_Shift, 12   @ bitWidth 3 (ADC channel 14 sampling time  selection)  
        .equ ADC2_SMPR2_SMP13_Shift, 9   @ bitWidth 3 (ADC channel 13 sampling time  selection)  
        .equ ADC2_SMPR2_SMP12_Shift, 6   @ bitWidth 3 (ADC channel 12 sampling time  selection)  
        .equ ADC2_SMPR2_SMP11_Shift, 3   @ bitWidth 3 (ADC channel 11 sampling time  selection)  
        .equ ADC2_SMPR2_SMP10_Shift, 0   @ bitWidth 3 (ADC channel 10 sampling time  selection)  
 
    .equ ADC2_LTR1, ADC2_BASE + 0x20 @ (ADC analog watchdog 1 threshold  register) 
        .equ ADC2_LTR1_LTR1_Shift, 0   @ bitWidth 26 (ADC analog watchdog 1 threshold  low)  
 
    .equ ADC2_LHTR1, ADC2_BASE + 0x24 @ (ADC analog watchdog 2 threshold  register) 
        .equ ADC2_LHTR1_LHTR1_Shift, 0   @ bitWidth 26 (ADC analog watchdog 2 threshold  low)  
 
    .equ ADC2_SQR1, ADC2_BASE + 0x30 @ (ADC group regular sequencer ranks register  1) 
        .equ ADC2_SQR1_SQ4_Shift, 24   @ bitWidth 5 (ADC group regular sequencer rank  4)  
        .equ ADC2_SQR1_SQ3_Shift, 18   @ bitWidth 5 (ADC group regular sequencer rank  3)  
        .equ ADC2_SQR1_SQ2_Shift, 12   @ bitWidth 5 (ADC group regular sequencer rank  2)  
        .equ ADC2_SQR1_SQ1_Shift, 6   @ bitWidth 5 (ADC group regular sequencer rank  1)  
        .equ ADC2_SQR1_L3_Shift, 0   @ bitWidth 4 (L3)  
 
    .equ ADC2_SQR2, ADC2_BASE + 0x34 @ (ADC group regular sequencer ranks register  2) 
        .equ ADC2_SQR2_SQ9_Shift, 24   @ bitWidth 5 (ADC group regular sequencer rank  9)  
        .equ ADC2_SQR2_SQ8_Shift, 18   @ bitWidth 5 (ADC group regular sequencer rank  8)  
        .equ ADC2_SQR2_SQ7_Shift, 12   @ bitWidth 5 (ADC group regular sequencer rank  7)  
        .equ ADC2_SQR2_SQ6_Shift, 6   @ bitWidth 5 (ADC group regular sequencer rank  6)  
        .equ ADC2_SQR2_SQ5_Shift, 0   @ bitWidth 5 (ADC group regular sequencer rank  5)  
 
    .equ ADC2_SQR3, ADC2_BASE + 0x38 @ (ADC group regular sequencer ranks register  3) 
        .equ ADC2_SQR3_SQ14_Shift, 24   @ bitWidth 5 (ADC group regular sequencer rank  14)  
        .equ ADC2_SQR3_SQ13_Shift, 18   @ bitWidth 5 (ADC group regular sequencer rank  13)  
        .equ ADC2_SQR3_SQ12_Shift, 12   @ bitWidth 5 (ADC group regular sequencer rank  12)  
        .equ ADC2_SQR3_SQ11_Shift, 6   @ bitWidth 5 (ADC group regular sequencer rank  11)  
        .equ ADC2_SQR3_SQ10_Shift, 0   @ bitWidth 5 (ADC group regular sequencer rank  10)  
 
    .equ ADC2_SQR4, ADC2_BASE + 0x3C @ (ADC group regular sequencer ranks register  4) 
        .equ ADC2_SQR4_SQ16_Shift, 6   @ bitWidth 5 (ADC group regular sequencer rank  16)  
        .equ ADC2_SQR4_SQ15_Shift, 0   @ bitWidth 5 (ADC group regular sequencer rank  15)  
 
    .equ ADC2_DR, ADC2_BASE + 0x40 @ (ADC group regular conversion data  register) 
        .equ ADC2_DR_RDATA_Shift, 0   @ bitWidth 16 (ADC group regular conversion  data)  
 
    .equ ADC2_JSQR, ADC2_BASE + 0x4C @ (ADC group injected sequencer  register) 
        .equ ADC2_JSQR_JSQ4_Shift, 27   @ bitWidth 5 (ADC group injected sequencer rank  4)  
        .equ ADC2_JSQR_JSQ3_Shift, 21   @ bitWidth 5 (ADC group injected sequencer rank  3)  
        .equ ADC2_JSQR_JSQ2_Shift, 15   @ bitWidth 5 (ADC group injected sequencer rank  2)  
        .equ ADC2_JSQR_JSQ1_Shift, 9   @ bitWidth 5 (ADC group injected sequencer rank  1)  
        .equ ADC2_JSQR_JEXTEN_Shift, 7   @ bitWidth 2 (ADC group injected external trigger  polarity)  
        .equ ADC2_JSQR_JEXTSEL_Shift, 2   @ bitWidth 5 (ADC group injected external trigger  source)  
        .equ ADC2_JSQR_JL_Shift, 0   @ bitWidth 2 (ADC group injected sequencer scan  length)  
 
    .equ ADC2_OFR1, ADC2_BASE + 0x60 @ (ADC offset number 1 register) 
        .equ ADC2_OFR1_SSATE, 1 << 31   @ bitWidth 1 (ADC offset number 1 enable)  
        .equ ADC2_OFR1_OFFSET1_CH_Shift, 26   @ bitWidth 5 (ADC offset number 1 channel  selection)  
        .equ ADC2_OFR1_OFFSET1_Shift, 0   @ bitWidth 26 (ADC offset number 1 offset  level)  
 
    .equ ADC2_OFR2, ADC2_BASE + 0x64 @ (ADC offset number 2 register) 
        .equ ADC2_OFR2_SSATE, 1 << 31   @ bitWidth 1 (ADC offset number 1 enable)  
        .equ ADC2_OFR2_OFFSET1_CH_Shift, 26   @ bitWidth 5 (ADC offset number 1 channel  selection)  
        .equ ADC2_OFR2_OFFSET1_Shift, 0   @ bitWidth 26 (ADC offset number 1 offset  level)  
 
    .equ ADC2_OFR3, ADC2_BASE + 0x68 @ (ADC offset number 3 register) 
        .equ ADC2_OFR3_SSATE, 1 << 31   @ bitWidth 1 (ADC offset number 1 enable)  
        .equ ADC2_OFR3_OFFSET1_CH_Shift, 26   @ bitWidth 5 (ADC offset number 1 channel  selection)  
        .equ ADC2_OFR3_OFFSET1_Shift, 0   @ bitWidth 26 (ADC offset number 1 offset  level)  
 
    .equ ADC2_OFR4, ADC2_BASE + 0x6C @ (ADC offset number 4 register) 
        .equ ADC2_OFR4_SSATE, 1 << 31   @ bitWidth 1 (ADC offset number 1 enable)  
        .equ ADC2_OFR4_OFFSET1_CH_Shift, 26   @ bitWidth 5 (ADC offset number 1 channel  selection)  
        .equ ADC2_OFR4_OFFSET1_Shift, 0   @ bitWidth 26 (ADC offset number 1 offset  level)  
 
    .equ ADC2_JDR1, ADC2_BASE + 0x80 @ (ADC group injected sequencer rank 1  register) 
        .equ ADC2_JDR1_JDATA1_Shift, 0   @ bitWidth 32 (ADC group injected sequencer rank 1  conversion data)  
 
    .equ ADC2_JDR2, ADC2_BASE + 0x84 @ (ADC group injected sequencer rank 2  register) 
        .equ ADC2_JDR2_JDATA2_Shift, 0   @ bitWidth 32 (ADC group injected sequencer rank 2  conversion data)  
 
    .equ ADC2_JDR3, ADC2_BASE + 0x88 @ (ADC group injected sequencer rank 3  register) 
        .equ ADC2_JDR3_JDATA3_Shift, 0   @ bitWidth 32 (ADC group injected sequencer rank 3  conversion data)  
 
    .equ ADC2_JDR4, ADC2_BASE + 0x8C @ (ADC group injected sequencer rank 4  register) 
        .equ ADC2_JDR4_JDATA4_Shift, 0   @ bitWidth 32 (ADC group injected sequencer rank 4  conversion data)  
 
    .equ ADC2_AWD2CR, ADC2_BASE + 0xA0 @ (ADC analog watchdog 2 configuration  register) 
        .equ ADC2_AWD2CR_AWD2CH_Shift, 0   @ bitWidth 20 (ADC analog watchdog 2 monitored channel  selection)  
 
    .equ ADC2_AWD3CR, ADC2_BASE + 0xA4 @ (ADC analog watchdog 3 configuration  register) 
        .equ ADC2_AWD3CR_AWD3CH_Shift, 1   @ bitWidth 20 (ADC analog watchdog 3 monitored channel  selection)  
 
    .equ ADC2_DIFSEL, ADC2_BASE + 0xC0 @ (ADC channel differential or single-ended  mode selection register) 
        .equ ADC2_DIFSEL_DIFSEL_Shift, 0   @ bitWidth 20 (ADC channel differential or single-ended  mode for channel)  
 
    .equ ADC2_CALFACT, ADC2_BASE + 0xC4 @ (ADC calibration factors  register) 
        .equ ADC2_CALFACT_CALFACT_D_Shift, 16   @ bitWidth 11 (ADC calibration factor in differential  mode)  
        .equ ADC2_CALFACT_CALFACT_S_Shift, 0   @ bitWidth 11 (ADC calibration factor in single-ended  mode)  
 
    .equ ADC2_PCSEL, ADC2_BASE + 0x1C @ (ADC pre channel selection  register) 
        .equ ADC2_PCSEL_PCSEL_Shift, 0   @ bitWidth 20 (Channel x VINP[i] pre  selection)  
 
    .equ ADC2_LTR2, ADC2_BASE + 0xB0 @ (ADC watchdog lower threshold register  2) 
        .equ ADC2_LTR2_LTR2_Shift, 0   @ bitWidth 26 (Analog watchdog 2 lower  threshold)  
 
    .equ ADC2_HTR2, ADC2_BASE + 0xB4 @ (ADC watchdog higher threshold register  2) 
        .equ ADC2_HTR2_HTR2_Shift, 0   @ bitWidth 26 (Analog watchdog 2 higher  threshold)  
 
    .equ ADC2_LTR3, ADC2_BASE + 0xB8 @ (ADC watchdog lower threshold register  3) 
        .equ ADC2_LTR3_LTR3_Shift, 0   @ bitWidth 26 (Analog watchdog 3 lower  threshold)  
 
    .equ ADC2_HTR3, ADC2_BASE + 0xBC @ (ADC watchdog higher threshold register  3) 
        .equ ADC2_HTR3_HTR3_Shift, 0   @ bitWidth 26 (Analog watchdog 3 higher  threshold)  
 
    .equ ADC2_CALFACT2, ADC2_BASE + 0xC8 @ (ADC Calibration Factor register  2) 
        .equ ADC2_CALFACT2_LINCALFACT_Shift, 0   @ bitWidth 30 (Linearity Calibration  Factor)  
 

@=========================== ADC3_Common ===========================@
.equ ADC3_Common_BASE, 0x58026300 @ (Analog-to-Digital Converter) 
    .equ ADC3_Common_CSR, ADC3_Common_BASE + 0x0 @ (ADC Common status register) 
        .equ ADC3_Common_CSR_ADRDY_MST, 1 << 0   @ bitWidth 1 (Master ADC ready)  
        .equ ADC3_Common_CSR_EOSMP_MST, 1 << 1   @ bitWidth 1 (End of Sampling phase flag of the master  ADC)  
        .equ ADC3_Common_CSR_EOC_MST, 1 << 2   @ bitWidth 1 (End of regular conversion of the master  ADC)  
        .equ ADC3_Common_CSR_EOS_MST, 1 << 3   @ bitWidth 1 (End of regular sequence flag of the  master ADC)  
        .equ ADC3_Common_CSR_OVR_MST, 1 << 4   @ bitWidth 1 (Overrun flag of the master  ADC)  
        .equ ADC3_Common_CSR_JEOC_MST, 1 << 5   @ bitWidth 1 (End of injected conversion flag of the  master ADC)  
        .equ ADC3_Common_CSR_JEOS_MST, 1 << 6   @ bitWidth 1 (End of injected sequence flag of the  master ADC)  
        .equ ADC3_Common_CSR_AWD1_MST, 1 << 7   @ bitWidth 1 (Analog watchdog 1 flag of the master  ADC)  
        .equ ADC3_Common_CSR_AWD2_MST, 1 << 8   @ bitWidth 1 (Analog watchdog 2 flag of the master  ADC)  
        .equ ADC3_Common_CSR_AWD3_MST, 1 << 9   @ bitWidth 1 (Analog watchdog 3 flag of the master  ADC)  
        .equ ADC3_Common_CSR_JQOVF_MST, 1 << 10   @ bitWidth 1 (Injected Context Queue Overflow flag of  the master ADC)  
        .equ ADC3_Common_CSR_ADRDY_SLV, 1 << 16   @ bitWidth 1 (Slave ADC ready)  
        .equ ADC3_Common_CSR_EOSMP_SLV, 1 << 17   @ bitWidth 1 (End of Sampling phase flag of the slave  ADC)  
        .equ ADC3_Common_CSR_EOC_SLV, 1 << 18   @ bitWidth 1 (End of regular conversion of the slave  ADC)  
        .equ ADC3_Common_CSR_EOS_SLV, 1 << 19   @ bitWidth 1 (End of regular sequence flag of the  slave ADC)  
        .equ ADC3_Common_CSR_OVR_SLV, 1 << 20   @ bitWidth 1 (Overrun flag of the slave  ADC)  
        .equ ADC3_Common_CSR_JEOC_SLV, 1 << 21   @ bitWidth 1 (End of injected conversion flag of the  slave ADC)  
        .equ ADC3_Common_CSR_JEOS_SLV, 1 << 22   @ bitWidth 1 (End of injected sequence flag of the  slave ADC)  
        .equ ADC3_Common_CSR_AWD1_SLV, 1 << 23   @ bitWidth 1 (Analog watchdog 1 flag of the slave  ADC)  
        .equ ADC3_Common_CSR_AWD2_SLV, 1 << 24   @ bitWidth 1 (Analog watchdog 2 flag of the slave  ADC)  
        .equ ADC3_Common_CSR_AWD3_SLV, 1 << 25   @ bitWidth 1 (Analog watchdog 3 flag of the slave  ADC)  
        .equ ADC3_Common_CSR_JQOVF_SLV, 1 << 26   @ bitWidth 1 (Injected Context Queue Overflow flag of  the slave ADC)  
 
    .equ ADC3_Common_CCR, ADC3_Common_BASE + 0x8 @ (ADC common control register) 
        .equ ADC3_Common_CCR_DUAL_Shift, 0   @ bitWidth 5 (Dual ADC mode selection)  
        .equ ADC3_Common_CCR_DELAY_Shift, 8   @ bitWidth 4 (Delay between 2 sampling  phases)  
        .equ ADC3_Common_CCR_DAMDF_Shift, 14   @ bitWidth 2 (Dual ADC Mode Data Format)  
        .equ ADC3_Common_CCR_CKMODE_Shift, 16   @ bitWidth 2 (ADC clock mode)  
        .equ ADC3_Common_CCR_PRESC_Shift, 18   @ bitWidth 4 (ADC prescaler)  
        .equ ADC3_Common_CCR_VREFEN, 1 << 22   @ bitWidth 1 (VREFINT enable)  
        .equ ADC3_Common_CCR_TSEN, 1 << 23   @ bitWidth 1 (Temperature sensor enable)  
        .equ ADC3_Common_CCR_VBATEN, 1 << 24   @ bitWidth 1 (VBAT enable)  
 
    .equ ADC3_Common_CDR, ADC3_Common_BASE + 0xC @ (ADC common regular data register for dual  and triple modes) 
        .equ ADC3_Common_CDR_RDATA_SLV_Shift, 16   @ bitWidth 16 (Regular data of the slave  ADC)  
        .equ ADC3_Common_CDR_RDATA_MST_Shift, 0   @ bitWidth 16 (Regular data of the master  ADC)  
 
    .equ ADC3_Common_CDR2, ADC3_Common_BASE + 0x10 @ (ADC x common regular data register for  32-bit dual mode) 
        .equ ADC3_Common_CDR2_RDATA_ALT_Shift, 0   @ bitWidth 32 (Regular data of the master/slave  alternated ADCs)  
 

@=========================== ADC12_Common ===========================@
.equ ADC12_Common_BASE, 0x40022300 @ (Analog-to-Digital Converter) 
    .equ ADC12_Common_CSR, ADC12_Common_BASE + 0x0 @ (ADC Common status register) 
        .equ ADC12_Common_CSR_ADRDY_MST, 1 << 0   @ bitWidth 1 (Master ADC ready)  
        .equ ADC12_Common_CSR_EOSMP_MST, 1 << 1   @ bitWidth 1 (End of Sampling phase flag of the master  ADC)  
        .equ ADC12_Common_CSR_EOC_MST, 1 << 2   @ bitWidth 1 (End of regular conversion of the master  ADC)  
        .equ ADC12_Common_CSR_EOS_MST, 1 << 3   @ bitWidth 1 (End of regular sequence flag of the  master ADC)  
        .equ ADC12_Common_CSR_OVR_MST, 1 << 4   @ bitWidth 1 (Overrun flag of the master  ADC)  
        .equ ADC12_Common_CSR_JEOC_MST, 1 << 5   @ bitWidth 1 (End of injected conversion flag of the  master ADC)  
        .equ ADC12_Common_CSR_JEOS_MST, 1 << 6   @ bitWidth 1 (End of injected sequence flag of the  master ADC)  
        .equ ADC12_Common_CSR_AWD1_MST, 1 << 7   @ bitWidth 1 (Analog watchdog 1 flag of the master  ADC)  
        .equ ADC12_Common_CSR_AWD2_MST, 1 << 8   @ bitWidth 1 (Analog watchdog 2 flag of the master  ADC)  
        .equ ADC12_Common_CSR_AWD3_MST, 1 << 9   @ bitWidth 1 (Analog watchdog 3 flag of the master  ADC)  
        .equ ADC12_Common_CSR_JQOVF_MST, 1 << 10   @ bitWidth 1 (Injected Context Queue Overflow flag of  the master ADC)  
        .equ ADC12_Common_CSR_ADRDY_SLV, 1 << 16   @ bitWidth 1 (Slave ADC ready)  
        .equ ADC12_Common_CSR_EOSMP_SLV, 1 << 17   @ bitWidth 1 (End of Sampling phase flag of the slave  ADC)  
        .equ ADC12_Common_CSR_EOC_SLV, 1 << 18   @ bitWidth 1 (End of regular conversion of the slave  ADC)  
        .equ ADC12_Common_CSR_EOS_SLV, 1 << 19   @ bitWidth 1 (End of regular sequence flag of the  slave ADC)  
        .equ ADC12_Common_CSR_OVR_SLV, 1 << 20   @ bitWidth 1 (Overrun flag of the slave  ADC)  
        .equ ADC12_Common_CSR_JEOC_SLV, 1 << 21   @ bitWidth 1 (End of injected conversion flag of the  slave ADC)  
        .equ ADC12_Common_CSR_JEOS_SLV, 1 << 22   @ bitWidth 1 (End of injected sequence flag of the  slave ADC)  
        .equ ADC12_Common_CSR_AWD1_SLV, 1 << 23   @ bitWidth 1 (Analog watchdog 1 flag of the slave  ADC)  
        .equ ADC12_Common_CSR_AWD2_SLV, 1 << 24   @ bitWidth 1 (Analog watchdog 2 flag of the slave  ADC)  
        .equ ADC12_Common_CSR_AWD3_SLV, 1 << 25   @ bitWidth 1 (Analog watchdog 3 flag of the slave  ADC)  
        .equ ADC12_Common_CSR_JQOVF_SLV, 1 << 26   @ bitWidth 1 (Injected Context Queue Overflow flag of  the slave ADC)  
 
    .equ ADC12_Common_CCR, ADC12_Common_BASE + 0x8 @ (ADC common control register) 
        .equ ADC12_Common_CCR_DUAL_Shift, 0   @ bitWidth 5 (Dual ADC mode selection)  
        .equ ADC12_Common_CCR_DELAY_Shift, 8   @ bitWidth 4 (Delay between 2 sampling  phases)  
        .equ ADC12_Common_CCR_DAMDF_Shift, 14   @ bitWidth 2 (Dual ADC Mode Data Format)  
        .equ ADC12_Common_CCR_CKMODE_Shift, 16   @ bitWidth 2 (ADC clock mode)  
        .equ ADC12_Common_CCR_PRESC_Shift, 18   @ bitWidth 4 (ADC prescaler)  
        .equ ADC12_Common_CCR_VREFEN, 1 << 22   @ bitWidth 1 (VREFINT enable)  
        .equ ADC12_Common_CCR_TSEN, 1 << 23   @ bitWidth 1 (Temperature sensor enable)  
        .equ ADC12_Common_CCR_VBATEN, 1 << 24   @ bitWidth 1 (VBAT enable)  
 
    .equ ADC12_Common_CDR, ADC12_Common_BASE + 0xC @ (ADC common regular data register for dual  and triple modes) 
        .equ ADC12_Common_CDR_RDATA_SLV_Shift, 16   @ bitWidth 16 (Regular data of the slave  ADC)  
        .equ ADC12_Common_CDR_RDATA_MST_Shift, 0   @ bitWidth 16 (Regular data of the master  ADC)  
 
    .equ ADC12_Common_CDR2, ADC12_Common_BASE + 0x10 @ (ADC x common regular data register for  32-bit dual mode) 
        .equ ADC12_Common_CDR2_RDATA_ALT_Shift, 0   @ bitWidth 32 (Regular data of the master/slave  alternated ADCs)  
 

@=========================== DMAMUX1 ===========================@
.equ DMAMUX1_BASE, 0x40020800 @ (DMAMUX) 
    .equ DMAMUX1_C0CR, DMAMUX1_BASE + 0x0 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX1_C0CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX1_C0CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX1_C0CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX1_C0CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX1_C0CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX1_C0CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX1_C0CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX1_C1CR, DMAMUX1_BASE + 0x4 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX1_C1CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX1_C1CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX1_C1CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX1_C1CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX1_C1CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX1_C1CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX1_C1CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX1_C2CR, DMAMUX1_BASE + 0x8 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX1_C2CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX1_C2CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX1_C2CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX1_C2CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX1_C2CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX1_C2CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX1_C2CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX1_C3CR, DMAMUX1_BASE + 0xC @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX1_C3CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX1_C3CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX1_C3CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX1_C3CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX1_C3CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX1_C3CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX1_C3CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX1_C4CR, DMAMUX1_BASE + 0x10 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX1_C4CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX1_C4CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX1_C4CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX1_C4CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX1_C4CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX1_C4CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX1_C4CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX1_C5CR, DMAMUX1_BASE + 0x14 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX1_C5CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX1_C5CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX1_C5CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX1_C5CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX1_C5CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX1_C5CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX1_C5CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX1_C6CR, DMAMUX1_BASE + 0x18 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX1_C6CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX1_C6CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX1_C6CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX1_C6CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX1_C6CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX1_C6CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX1_C6CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX1_C7CR, DMAMUX1_BASE + 0x1C @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX1_C7CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX1_C7CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX1_C7CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX1_C7CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX1_C7CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX1_C7CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX1_C7CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX1_C8CR, DMAMUX1_BASE + 0x20 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX1_C8CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX1_C8CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX1_C8CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX1_C8CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX1_C8CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX1_C8CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX1_C8CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX1_C9CR, DMAMUX1_BASE + 0x24 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX1_C9CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX1_C9CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX1_C9CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX1_C9CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX1_C9CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX1_C9CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX1_C9CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX1_C10CR, DMAMUX1_BASE + 0x28 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX1_C10CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX1_C10CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX1_C10CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX1_C10CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX1_C10CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX1_C10CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX1_C10CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX1_C11CR, DMAMUX1_BASE + 0x2C @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX1_C11CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX1_C11CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX1_C11CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX1_C11CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX1_C11CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX1_C11CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX1_C11CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX1_C12CR, DMAMUX1_BASE + 0x30 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX1_C12CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX1_C12CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX1_C12CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX1_C12CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX1_C12CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX1_C12CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX1_C12CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX1_C13CR, DMAMUX1_BASE + 0x34 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX1_C13CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX1_C13CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX1_C13CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX1_C13CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX1_C13CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX1_C13CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX1_C13CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX1_C14CR, DMAMUX1_BASE + 0x38 @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX1_C14CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX1_C14CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX1_C14CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX1_C14CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX1_C14CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX1_C14CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX1_C14CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX1_C15CR, DMAMUX1_BASE + 0x3C @ (DMAMux - DMA request line multiplexer  channel x control register) 
        .equ DMAMUX1_C15CR_DMAREQ_ID_Shift, 0   @ bitWidth 8 (Input DMA request line  selected)  
        .equ DMAMUX1_C15CR_SOIE, 1 << 8   @ bitWidth 1 (Interrupt enable at synchronization  event overrun)  
        .equ DMAMUX1_C15CR_EGE, 1 << 9   @ bitWidth 1 (Event generation  enable/disable)  
        .equ DMAMUX1_C15CR_SE, 1 << 16   @ bitWidth 1 (Synchronous operating mode  enable/disable)  
        .equ DMAMUX1_C15CR_SPOL_Shift, 17   @ bitWidth 2 (Synchronization event type selector  Defines the synchronization event on the selected  synchronization input:)  
        .equ DMAMUX1_C15CR_NBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to forward  Defines the number of DMA requests forwarded before  output event is generated. In synchronous mode, it  also defines the number of DMA requests to forward  after a synchronization event, then stop forwarding.  The actual number of DMA requests forwarded is  NBREQ+1. Note: This field can only be written when  both SE and EGE bits are reset.)  
        .equ DMAMUX1_C15CR_SYNC_ID_Shift, 24   @ bitWidth 5 (Synchronization input  selected)  
 
    .equ DMAMUX1_RG0CR, DMAMUX1_BASE + 0x100 @ (DMAMux - DMA request generator channel x  control register) 
        .equ DMAMUX1_RG0CR_SIG_ID_Shift, 0   @ bitWidth 5 (DMA request trigger input  selected)  
        .equ DMAMUX1_RG0CR_OIE, 1 << 8   @ bitWidth 1 (Interrupt enable at trigger event  overrun)  
        .equ DMAMUX1_RG0CR_GE, 1 << 16   @ bitWidth 1 (DMA request generator channel  enable/disable)  
        .equ DMAMUX1_RG0CR_GPOL_Shift, 17   @ bitWidth 2 (DMA request generator trigger event type  selection Defines the trigger event on the selected  DMA request trigger input)  
        .equ DMAMUX1_RG0CR_GNBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to generate  Defines the number of DMA requests generated after a  trigger event, then stop generating. The actual  number of generated DMA requests is GNBREQ+1. Note:  This field can only be written when GE bit is  reset.)  
 
    .equ DMAMUX1_RG1CR, DMAMUX1_BASE + 0x104 @ (DMAMux - DMA request generator channel x  control register) 
        .equ DMAMUX1_RG1CR_SIG_ID_Shift, 0   @ bitWidth 5 (DMA request trigger input  selected)  
        .equ DMAMUX1_RG1CR_OIE, 1 << 8   @ bitWidth 1 (Interrupt enable at trigger event  overrun)  
        .equ DMAMUX1_RG1CR_GE, 1 << 16   @ bitWidth 1 (DMA request generator channel  enable/disable)  
        .equ DMAMUX1_RG1CR_GPOL_Shift, 17   @ bitWidth 2 (DMA request generator trigger event type  selection Defines the trigger event on the selected  DMA request trigger input)  
        .equ DMAMUX1_RG1CR_GNBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to generate  Defines the number of DMA requests generated after a  trigger event, then stop generating. The actual  number of generated DMA requests is GNBREQ+1. Note:  This field can only be written when GE bit is  reset.)  
 
    .equ DMAMUX1_RG2CR, DMAMUX1_BASE + 0x108 @ (DMAMux - DMA request generator channel x  control register) 
        .equ DMAMUX1_RG2CR_SIG_ID_Shift, 0   @ bitWidth 5 (DMA request trigger input  selected)  
        .equ DMAMUX1_RG2CR_OIE, 1 << 8   @ bitWidth 1 (Interrupt enable at trigger event  overrun)  
        .equ DMAMUX1_RG2CR_GE, 1 << 16   @ bitWidth 1 (DMA request generator channel  enable/disable)  
        .equ DMAMUX1_RG2CR_GPOL_Shift, 17   @ bitWidth 2 (DMA request generator trigger event type  selection Defines the trigger event on the selected  DMA request trigger input)  
        .equ DMAMUX1_RG2CR_GNBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to generate  Defines the number of DMA requests generated after a  trigger event, then stop generating. The actual  number of generated DMA requests is GNBREQ+1. Note:  This field can only be written when GE bit is  reset.)  
 
    .equ DMAMUX1_RG3CR, DMAMUX1_BASE + 0x10C @ (DMAMux - DMA request generator channel x  control register) 
        .equ DMAMUX1_RG3CR_SIG_ID_Shift, 0   @ bitWidth 5 (DMA request trigger input  selected)  
        .equ DMAMUX1_RG3CR_OIE, 1 << 8   @ bitWidth 1 (Interrupt enable at trigger event  overrun)  
        .equ DMAMUX1_RG3CR_GE, 1 << 16   @ bitWidth 1 (DMA request generator channel  enable/disable)  
        .equ DMAMUX1_RG3CR_GPOL_Shift, 17   @ bitWidth 2 (DMA request generator trigger event type  selection Defines the trigger event on the selected  DMA request trigger input)  
        .equ DMAMUX1_RG3CR_GNBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to generate  Defines the number of DMA requests generated after a  trigger event, then stop generating. The actual  number of generated DMA requests is GNBREQ+1. Note:  This field can only be written when GE bit is  reset.)  
 
    .equ DMAMUX1_RG4CR, DMAMUX1_BASE + 0x110 @ (DMAMux - DMA request generator channel x  control register) 
        .equ DMAMUX1_RG4CR_SIG_ID_Shift, 0   @ bitWidth 5 (DMA request trigger input  selected)  
        .equ DMAMUX1_RG4CR_OIE, 1 << 8   @ bitWidth 1 (Interrupt enable at trigger event  overrun)  
        .equ DMAMUX1_RG4CR_GE, 1 << 16   @ bitWidth 1 (DMA request generator channel  enable/disable)  
        .equ DMAMUX1_RG4CR_GPOL_Shift, 17   @ bitWidth 2 (DMA request generator trigger event type  selection Defines the trigger event on the selected  DMA request trigger input)  
        .equ DMAMUX1_RG4CR_GNBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to generate  Defines the number of DMA requests generated after a  trigger event, then stop generating. The actual  number of generated DMA requests is GNBREQ+1. Note:  This field can only be written when GE bit is  reset.)  
 
    .equ DMAMUX1_RG5CR, DMAMUX1_BASE + 0x114 @ (DMAMux - DMA request generator channel x  control register) 
        .equ DMAMUX1_RG5CR_SIG_ID_Shift, 0   @ bitWidth 5 (DMA request trigger input  selected)  
        .equ DMAMUX1_RG5CR_OIE, 1 << 8   @ bitWidth 1 (Interrupt enable at trigger event  overrun)  
        .equ DMAMUX1_RG5CR_GE, 1 << 16   @ bitWidth 1 (DMA request generator channel  enable/disable)  
        .equ DMAMUX1_RG5CR_GPOL_Shift, 17   @ bitWidth 2 (DMA request generator trigger event type  selection Defines the trigger event on the selected  DMA request trigger input)  
        .equ DMAMUX1_RG5CR_GNBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to generate  Defines the number of DMA requests generated after a  trigger event, then stop generating. The actual  number of generated DMA requests is GNBREQ+1. Note:  This field can only be written when GE bit is  reset.)  
 
    .equ DMAMUX1_RG6CR, DMAMUX1_BASE + 0x118 @ (DMAMux - DMA request generator channel x  control register) 
        .equ DMAMUX1_RG6CR_SIG_ID_Shift, 0   @ bitWidth 5 (DMA request trigger input  selected)  
        .equ DMAMUX1_RG6CR_OIE, 1 << 8   @ bitWidth 1 (Interrupt enable at trigger event  overrun)  
        .equ DMAMUX1_RG6CR_GE, 1 << 16   @ bitWidth 1 (DMA request generator channel  enable/disable)  
        .equ DMAMUX1_RG6CR_GPOL_Shift, 17   @ bitWidth 2 (DMA request generator trigger event type  selection Defines the trigger event on the selected  DMA request trigger input)  
        .equ DMAMUX1_RG6CR_GNBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to generate  Defines the number of DMA requests generated after a  trigger event, then stop generating. The actual  number of generated DMA requests is GNBREQ+1. Note:  This field can only be written when GE bit is  reset.)  
 
    .equ DMAMUX1_RG7CR, DMAMUX1_BASE + 0x11C @ (DMAMux - DMA request generator channel x  control register) 
        .equ DMAMUX1_RG7CR_SIG_ID_Shift, 0   @ bitWidth 5 (DMA request trigger input  selected)  
        .equ DMAMUX1_RG7CR_OIE, 1 << 8   @ bitWidth 1 (Interrupt enable at trigger event  overrun)  
        .equ DMAMUX1_RG7CR_GE, 1 << 16   @ bitWidth 1 (DMA request generator channel  enable/disable)  
        .equ DMAMUX1_RG7CR_GPOL_Shift, 17   @ bitWidth 2 (DMA request generator trigger event type  selection Defines the trigger event on the selected  DMA request trigger input)  
        .equ DMAMUX1_RG7CR_GNBREQ_Shift, 19   @ bitWidth 5 (Number of DMA requests to generate  Defines the number of DMA requests generated after a  trigger event, then stop generating. The actual  number of generated DMA requests is GNBREQ+1. Note:  This field can only be written when GE bit is  reset.)  
 
    .equ DMAMUX1_RGSR, DMAMUX1_BASE + 0x140 @ (DMAMux - DMA request generator status  register) 
        .equ DMAMUX1_RGSR_OF_Shift, 0   @ bitWidth 8 (Trigger event overrun flag The flag is  set when a trigger event occurs on DMA request  generator channel x, while the DMA request generator  counter value is lower than GNBREQ. The flag is  cleared by writing 1 to the corresponding COFx bit in  DMAMUX_RGCFR register.)  
 
    .equ DMAMUX1_RGCFR, DMAMUX1_BASE + 0x144 @ (DMAMux - DMA request generator clear flag  register) 
        .equ DMAMUX1_RGCFR_COF_Shift, 0   @ bitWidth 8 (Clear trigger event overrun flag Upon  setting, this bit clears the corresponding overrun  flag OFx in the DMAMUX_RGCSR register.)  
 
    .equ DMAMUX1_CSR, DMAMUX1_BASE + 0x80 @ (DMAMUX request line multiplexer interrupt  channel status register) 
        .equ DMAMUX1_CSR_SOF_Shift, 0   @ bitWidth 16 (Synchronization overrun event  flag)  
 
    .equ DMAMUX1_CFR, DMAMUX1_BASE + 0x84 @ (DMAMUX request line multiplexer interrupt  clear flag register) 
        .equ DMAMUX1_CFR_CSOF_Shift, 0   @ bitWidth 16 (Clear synchronization overrun event  flag)  
 

@=========================== CRC ===========================@
.equ CRC_BASE, 0x58024C00 @ (Cryptographic processor) 
    .equ CRC_DR, CRC_BASE + 0x0 @ (Data register) 
        .equ CRC_DR_DR_Shift, 0   @ bitWidth 32 (Data Register)  
 
    .equ CRC_IDR, CRC_BASE + 0x4 @ (Independent Data register) 
        .equ CRC_IDR_IDR_Shift, 0   @ bitWidth 32 (Independent Data register)  
 
    .equ CRC_CR, CRC_BASE + 0x8 @ (Control register) 
        .equ CRC_CR_RESET, 1 << 0   @ bitWidth 1 (RESET bit)  
        .equ CRC_CR_POLYSIZE_Shift, 3   @ bitWidth 2 (Polynomial size)  
        .equ CRC_CR_REV_IN_Shift, 5   @ bitWidth 2 (Reverse input data)  
        .equ CRC_CR_REV_OUT, 1 << 7   @ bitWidth 1 (Reverse output data)  
 
    .equ CRC_INIT, CRC_BASE + 0xC @ (Initial CRC value) 
        .equ CRC_INIT_CRC_INIT_Shift, 0   @ bitWidth 32 (Programmable initial CRC  value)  
 
    .equ CRC_POL, CRC_BASE + 0x10 @ (CRC polynomial) 
        .equ CRC_POL_POL_Shift, 0   @ bitWidth 32 (Programmable polynomial)  
 

@=========================== RCC ===========================@
.equ RCC_BASE, 0x58024400 @ (Reset and clock control) 
    .equ RCC_CR, RCC_BASE + 0x0 @ (clock control register) 
        .equ RCC_CR_HSION, 1 << 0   @ bitWidth 1 (Internal high-speed clock  enable)  
        .equ RCC_CR_HSIKERON, 1 << 1   @ bitWidth 1 (High Speed Internal clock enable in Stop  mode)  
        .equ RCC_CR_HSIRDY, 1 << 2   @ bitWidth 1 (HSI clock ready flag)  
        .equ RCC_CR_HSIDIV_Shift, 3   @ bitWidth 2 (HSI clock divider)  
        .equ RCC_CR_HSIDIVF, 1 << 5   @ bitWidth 1 (HSI divider flag)  
        .equ RCC_CR_CSION, 1 << 7   @ bitWidth 1 (CSI clock enable)  
        .equ RCC_CR_CSIRDY, 1 << 8   @ bitWidth 1 (CSI clock ready flag)  
        .equ RCC_CR_CSIKERON, 1 << 9   @ bitWidth 1 (CSI clock enable in Stop  mode)  
        .equ RCC_CR_RC48ON, 1 << 12   @ bitWidth 1 (RC48 clock enable)  
        .equ RCC_CR_RC48RDY, 1 << 13   @ bitWidth 1 (RC48 clock ready flag)  
        .equ RCC_CR_D1CKRDY, 1 << 14   @ bitWidth 1 (D1 domain clocks ready  flag)  
        .equ RCC_CR_D2CKRDY, 1 << 15   @ bitWidth 1 (D2 domain clocks ready  flag)  
        .equ RCC_CR_HSEON, 1 << 16   @ bitWidth 1 (HSE clock enable)  
        .equ RCC_CR_HSERDY, 1 << 17   @ bitWidth 1 (HSE clock ready flag)  
        .equ RCC_CR_HSEBYP, 1 << 18   @ bitWidth 1 (HSE clock bypass)  
        .equ RCC_CR_HSECSSON, 1 << 19   @ bitWidth 1 (HSE Clock Security System  enable)  
        .equ RCC_CR_PLL1ON, 1 << 24   @ bitWidth 1 (PLL1 enable)  
        .equ RCC_CR_PLL1RDY, 1 << 25   @ bitWidth 1 (PLL1 clock ready flag)  
        .equ RCC_CR_PLL2ON, 1 << 26   @ bitWidth 1 (PLL2 enable)  
        .equ RCC_CR_PLL2RDY, 1 << 27   @ bitWidth 1 (PLL2 clock ready flag)  
        .equ RCC_CR_PLL3ON, 1 << 28   @ bitWidth 1 (PLL3 enable)  
        .equ RCC_CR_PLL3RDY, 1 << 29   @ bitWidth 1 (PLL3 clock ready flag)  
 
    .equ RCC_ICSCR, RCC_BASE + 0x4 @ (RCC Internal Clock Source Calibration  Register) 
        .equ RCC_ICSCR_HSICAL_Shift, 0   @ bitWidth 12 (HSI clock calibration)  
        .equ RCC_ICSCR_HSITRIM_Shift, 12   @ bitWidth 6 (HSI clock trimming)  
        .equ RCC_ICSCR_CSICAL_Shift, 18   @ bitWidth 8 (CSI clock calibration)  
        .equ RCC_ICSCR_CSITRIM_Shift, 26   @ bitWidth 5 (CSI clock trimming)  
 
    .equ RCC_CRRCR, RCC_BASE + 0x8 @ (RCC Clock Recovery RC Register) 
        .equ RCC_CRRCR_RC48CAL_Shift, 0   @ bitWidth 10 (Internal RC 48 MHz clock  calibration)  
 
    .equ RCC_CFGR, RCC_BASE + 0x10 @ (RCC Clock Configuration  Register) 
        .equ RCC_CFGR_SW_Shift, 0   @ bitWidth 3 (System clock switch)  
        .equ RCC_CFGR_SWS_Shift, 3   @ bitWidth 3 (System clock switch status)  
        .equ RCC_CFGR_STOPWUCK, 1 << 6   @ bitWidth 1 (System clock selection after a wake up  from system Stop)  
        .equ RCC_CFGR_STOPKERWUCK, 1 << 7   @ bitWidth 1 (Kernel clock selection after a wake up  from system Stop)  
        .equ RCC_CFGR_RTCPRE_Shift, 8   @ bitWidth 6 (HSE division factor for RTC  clock)  
        .equ RCC_CFGR_HRTIMSEL, 1 << 14   @ bitWidth 1 (High Resolution Timer clock prescaler  selection)  
        .equ RCC_CFGR_TIMPRE, 1 << 15   @ bitWidth 1 (Timers clocks prescaler  selection)  
        .equ RCC_CFGR_MCO1PRE_Shift, 18   @ bitWidth 4 (MCO1 prescaler)  
        .equ RCC_CFGR_MCO1SEL_Shift, 22   @ bitWidth 3 (Micro-controller clock output  1)  
        .equ RCC_CFGR_MCO2PRE_Shift, 25   @ bitWidth 4 (MCO2 prescaler)  
        .equ RCC_CFGR_MCO2SEL_Shift, 29   @ bitWidth 3 (Micro-controller clock output  2)  
 
    .equ RCC_D1CFGR, RCC_BASE + 0x18 @ (RCC Domain 1 Clock Configuration  Register) 
        .equ RCC_D1CFGR_HPRE_Shift, 0   @ bitWidth 4 (D1 domain AHB prescaler)  
        .equ RCC_D1CFGR_D1PPRE_Shift, 4   @ bitWidth 3 (D1 domain APB3 prescaler)  
        .equ RCC_D1CFGR_D1CPRE_Shift, 8   @ bitWidth 4 (D1 domain Core prescaler)  
 
    .equ RCC_D2CFGR, RCC_BASE + 0x1C @ (RCC Domain 2 Clock Configuration  Register) 
        .equ RCC_D2CFGR_D2PPRE1_Shift, 4   @ bitWidth 3 (D2 domain APB1 prescaler)  
        .equ RCC_D2CFGR_D2PPRE2_Shift, 8   @ bitWidth 3 (D2 domain APB2 prescaler)  
 
    .equ RCC_D3CFGR, RCC_BASE + 0x20 @ (RCC Domain 3 Clock Configuration  Register) 
        .equ RCC_D3CFGR_D3PPRE_Shift, 4   @ bitWidth 3 (D3 domain APB4 prescaler)  
 
    .equ RCC_PLLCKSELR, RCC_BASE + 0x28 @ (RCC PLLs Clock Source Selection  Register) 
        .equ RCC_PLLCKSELR_PLLSRC_Shift, 0   @ bitWidth 2 (DIVMx and PLLs clock source  selection)  
        .equ RCC_PLLCKSELR_DIVM1_Shift, 4   @ bitWidth 6 (Prescaler for PLL1)  
        .equ RCC_PLLCKSELR_DIVM2_Shift, 12   @ bitWidth 6 (Prescaler for PLL2)  
        .equ RCC_PLLCKSELR_DIVM3_Shift, 20   @ bitWidth 6 (Prescaler for PLL3)  
 
    .equ RCC_PLLCFGR, RCC_BASE + 0x2C @ (RCC PLLs Configuration  Register) 
        .equ RCC_PLLCFGR_PLL1FRACEN, 1 << 0   @ bitWidth 1 (PLL1 fractional latch  enable)  
        .equ RCC_PLLCFGR_PLL1VCOSEL, 1 << 1   @ bitWidth 1 (PLL1 VCO selection)  
        .equ RCC_PLLCFGR_PLL1RGE_Shift, 2   @ bitWidth 2 (PLL1 input frequency range)  
        .equ RCC_PLLCFGR_PLL2FRACEN, 1 << 4   @ bitWidth 1 (PLL2 fractional latch  enable)  
        .equ RCC_PLLCFGR_PLL2VCOSEL, 1 << 5   @ bitWidth 1 (PLL2 VCO selection)  
        .equ RCC_PLLCFGR_PLL2RGE_Shift, 6   @ bitWidth 2 (PLL2 input frequency range)  
        .equ RCC_PLLCFGR_PLL3FRACEN, 1 << 8   @ bitWidth 1 (PLL3 fractional latch  enable)  
        .equ RCC_PLLCFGR_PLL3VCOSEL, 1 << 9   @ bitWidth 1 (PLL3 VCO selection)  
        .equ RCC_PLLCFGR_PLL3RGE_Shift, 10   @ bitWidth 2 (PLL3 input frequency range)  
        .equ RCC_PLLCFGR_DIVP1EN, 1 << 16   @ bitWidth 1 (PLL1 DIVP divider output  enable)  
        .equ RCC_PLLCFGR_DIVQ1EN, 1 << 17   @ bitWidth 1 (PLL1 DIVQ divider output  enable)  
        .equ RCC_PLLCFGR_DIVR1EN, 1 << 18   @ bitWidth 1 (PLL1 DIVR divider output  enable)  
        .equ RCC_PLLCFGR_DIVP2EN, 1 << 19   @ bitWidth 1 (PLL2 DIVP divider output  enable)  
        .equ RCC_PLLCFGR_DIVQ2EN, 1 << 20   @ bitWidth 1 (PLL2 DIVQ divider output  enable)  
        .equ RCC_PLLCFGR_DIVR2EN, 1 << 21   @ bitWidth 1 (PLL2 DIVR divider output  enable)  
        .equ RCC_PLLCFGR_DIVP3EN, 1 << 22   @ bitWidth 1 (PLL3 DIVP divider output  enable)  
        .equ RCC_PLLCFGR_DIVQ3EN, 1 << 23   @ bitWidth 1 (PLL3 DIVQ divider output  enable)  
        .equ RCC_PLLCFGR_DIVR3EN, 1 << 24   @ bitWidth 1 (PLL3 DIVR divider output  enable)  
 
    .equ RCC_PLL1DIVR, RCC_BASE + 0x30 @ (RCC PLL1 Dividers Configuration  Register) 
        .equ RCC_PLL1DIVR_DIVN1_Shift, 0   @ bitWidth 9 (Multiplication factor for PLL1  VCO)  
        .equ RCC_PLL1DIVR_DIVP1_Shift, 9   @ bitWidth 7 (PLL1 DIVP division factor)  
        .equ RCC_PLL1DIVR_DIVQ1_Shift, 16   @ bitWidth 7 (PLL1 DIVQ division factor)  
        .equ RCC_PLL1DIVR_DIVR1_Shift, 24   @ bitWidth 7 (PLL1 DIVR division factor)  
 
    .equ RCC_PLL1FRACR, RCC_BASE + 0x34 @ (RCC PLL1 Fractional Divider  Register) 
        .equ RCC_PLL1FRACR_FRACN1_Shift, 3   @ bitWidth 13 (Fractional part of the multiplication  factor for PLL1 VCO)  
 
    .equ RCC_PLL2DIVR, RCC_BASE + 0x38 @ (RCC PLL2 Dividers Configuration  Register) 
        .equ RCC_PLL2DIVR_DIVN1_Shift, 0   @ bitWidth 9 (Multiplication factor for PLL1  VCO)  
        .equ RCC_PLL2DIVR_DIVP1_Shift, 9   @ bitWidth 7 (PLL1 DIVP division factor)  
        .equ RCC_PLL2DIVR_DIVQ1_Shift, 16   @ bitWidth 7 (PLL1 DIVQ division factor)  
        .equ RCC_PLL2DIVR_DIVR1_Shift, 24   @ bitWidth 7 (PLL1 DIVR division factor)  
 
    .equ RCC_PLL2FRACR, RCC_BASE + 0x3C @ (RCC PLL2 Fractional Divider  Register) 
        .equ RCC_PLL2FRACR_FRACN2_Shift, 3   @ bitWidth 13 (Fractional part of the multiplication  factor for PLL VCO)  
 
    .equ RCC_PLL3DIVR, RCC_BASE + 0x40 @ (RCC PLL3 Dividers Configuration  Register) 
        .equ RCC_PLL3DIVR_DIVN3_Shift, 0   @ bitWidth 9 (Multiplication factor for PLL1  VCO)  
        .equ RCC_PLL3DIVR_DIVP3_Shift, 9   @ bitWidth 7 (PLL DIVP division factor)  
        .equ RCC_PLL3DIVR_DIVQ3_Shift, 16   @ bitWidth 7 (PLL DIVQ division factor)  
        .equ RCC_PLL3DIVR_DIVR3_Shift, 24   @ bitWidth 7 (PLL DIVR division factor)  
 
    .equ RCC_PLL3FRACR, RCC_BASE + 0x44 @ (RCC PLL3 Fractional Divider  Register) 
        .equ RCC_PLL3FRACR_FRACN3_Shift, 3   @ bitWidth 13 (Fractional part of the multiplication  factor for PLL3 VCO)  
 
    .equ RCC_D1CCIPR, RCC_BASE + 0x4C @ (RCC Domain 1 Kernel Clock Configuration  Register) 
        .equ RCC_D1CCIPR_FMCSRC_Shift, 0   @ bitWidth 2 (FMC kernel clock source  selection)  
        .equ RCC_D1CCIPR_QSPISRC_Shift, 4   @ bitWidth 2 (QUADSPI kernel clock source  selection)  
        .equ RCC_D1CCIPR_SDMMCSRC, 1 << 16   @ bitWidth 1 (SDMMC kernel clock source  selection)  
        .equ RCC_D1CCIPR_CKPERSRC_Shift, 28   @ bitWidth 2 (per_ck clock source  selection)  
 
    .equ RCC_D2CCIP1R, RCC_BASE + 0x50 @ (RCC Domain 2 Kernel Clock Configuration  Register) 
        .equ RCC_D2CCIP1R_SAI1SRC_Shift, 0   @ bitWidth 3 (SAI1 and DFSDM1 kernel Aclk clock source  selection)  
        .equ RCC_D2CCIP1R_SAI23SRC_Shift, 6   @ bitWidth 3 (SAI2 and SAI3 kernel clock source  selection)  
        .equ RCC_D2CCIP1R_SPI123SRC_Shift, 12   @ bitWidth 3 (SPI/I2S1,2 and 3 kernel clock source  selection)  
        .equ RCC_D2CCIP1R_SPI45SRC_Shift, 16   @ bitWidth 3 (SPI4 and 5 kernel clock source  selection)  
        .equ RCC_D2CCIP1R_SPDIFSRC_Shift, 20   @ bitWidth 2 (SPDIFRX kernel clock source  selection)  
        .equ RCC_D2CCIP1R_DFSDM1SRC, 1 << 24   @ bitWidth 1 (DFSDM1 kernel Clk clock source  selection)  
        .equ RCC_D2CCIP1R_FDCANSRC_Shift, 28   @ bitWidth 2 (FDCAN kernel clock source  selection)  
        .equ RCC_D2CCIP1R_SWPSRC, 1 << 31   @ bitWidth 1 (SWPMI kernel clock source  selection)  
 
    .equ RCC_D2CCIP2R, RCC_BASE + 0x54 @ (RCC Domain 2 Kernel Clock Configuration  Register) 
        .equ RCC_D2CCIP2R_USART234578SRC_Shift, 0   @ bitWidth 3 (USART2/3, UART4,5, 7/8 APB1 kernel  clock source selection)  
        .equ RCC_D2CCIP2R_USART16SRC_Shift, 3   @ bitWidth 3 (USART1 and 6 kernel clock source  selection)  
        .equ RCC_D2CCIP2R_RNGSRC_Shift, 8   @ bitWidth 2 (RNG kernel clock source  selection)  
        .equ RCC_D2CCIP2R_I2C123SRC_Shift, 12   @ bitWidth 2 (I2C1,2,3 kernel clock source  selection)  
        .equ RCC_D2CCIP2R_USBSRC_Shift, 20   @ bitWidth 2 (USBOTG 1 and 2 kernel clock source  selection)  
        .equ RCC_D2CCIP2R_CECSRC_Shift, 22   @ bitWidth 2 (HDMI-CEC kernel clock source  selection)  
        .equ RCC_D2CCIP2R_LPTIM1SRC_Shift, 28   @ bitWidth 3 (LPTIM1 kernel clock source  selection)  
 
    .equ RCC_D3CCIPR, RCC_BASE + 0x58 @ (RCC Domain 3 Kernel Clock Configuration  Register) 
        .equ RCC_D3CCIPR_LPUART1SRC_Shift, 0   @ bitWidth 3 (LPUART1 kernel clock source  selection)  
        .equ RCC_D3CCIPR_I2C4SRC_Shift, 8   @ bitWidth 2 (I2C4 kernel clock source  selection)  
        .equ RCC_D3CCIPR_LPTIM2SRC_Shift, 10   @ bitWidth 3 (LPTIM2 kernel clock source  selection)  
        .equ RCC_D3CCIPR_LPTIM345SRC_Shift, 13   @ bitWidth 3 (LPTIM3,4,5 kernel clock source  selection)  
        .equ RCC_D3CCIPR_ADCSRC_Shift, 16   @ bitWidth 2 (SAR ADC kernel clock source  selection)  
        .equ RCC_D3CCIPR_SAI4ASRC_Shift, 21   @ bitWidth 3 (Sub-Block A of SAI4 kernel clock source  selection)  
        .equ RCC_D3CCIPR_SAI4BSRC_Shift, 24   @ bitWidth 3 (Sub-Block B of SAI4 kernel clock source  selection)  
        .equ RCC_D3CCIPR_SPI6SRC_Shift, 28   @ bitWidth 3 (SPI6 kernel clock source  selection)  
 
    .equ RCC_CIER, RCC_BASE + 0x60 @ (RCC Clock Source Interrupt Enable  Register) 
        .equ RCC_CIER_LSIRDYIE, 1 << 0   @ bitWidth 1 (LSI ready Interrupt Enable)  
        .equ RCC_CIER_LSERDYIE, 1 << 1   @ bitWidth 1 (LSE ready Interrupt Enable)  
        .equ RCC_CIER_HSIRDYIE, 1 << 2   @ bitWidth 1 (HSI ready Interrupt Enable)  
        .equ RCC_CIER_HSERDYIE, 1 << 3   @ bitWidth 1 (HSE ready Interrupt Enable)  
        .equ RCC_CIER_CSIRDYIE, 1 << 4   @ bitWidth 1 (CSI ready Interrupt Enable)  
        .equ RCC_CIER_RC48RDYIE, 1 << 5   @ bitWidth 1 (RC48 ready Interrupt  Enable)  
        .equ RCC_CIER_PLL1RDYIE, 1 << 6   @ bitWidth 1 (PLL1 ready Interrupt  Enable)  
        .equ RCC_CIER_PLL2RDYIE, 1 << 7   @ bitWidth 1 (PLL2 ready Interrupt  Enable)  
        .equ RCC_CIER_PLL3RDYIE, 1 << 8   @ bitWidth 1 (PLL3 ready Interrupt  Enable)  
        .equ RCC_CIER_LSECSSIE, 1 << 9   @ bitWidth 1 (LSE clock security system Interrupt  Enable)  
 
    .equ RCC_CIFR, RCC_BASE + 0x64 @ (RCC Clock Source Interrupt Flag  Register) 
        .equ RCC_CIFR_LSIRDYF, 1 << 0   @ bitWidth 1 (LSI ready Interrupt Flag)  
        .equ RCC_CIFR_LSERDYF, 1 << 1   @ bitWidth 1 (LSE ready Interrupt Flag)  
        .equ RCC_CIFR_HSIRDYF, 1 << 2   @ bitWidth 1 (HSI ready Interrupt Flag)  
        .equ RCC_CIFR_HSERDYF, 1 << 3   @ bitWidth 1 (HSE ready Interrupt Flag)  
        .equ RCC_CIFR_CSIRDY, 1 << 4   @ bitWidth 1 (CSI ready Interrupt Flag)  
        .equ RCC_CIFR_RC48RDYF, 1 << 5   @ bitWidth 1 (RC48 ready Interrupt Flag)  
        .equ RCC_CIFR_PLL1RDYF, 1 << 6   @ bitWidth 1 (PLL1 ready Interrupt Flag)  
        .equ RCC_CIFR_PLL2RDYF, 1 << 7   @ bitWidth 1 (PLL2 ready Interrupt Flag)  
        .equ RCC_CIFR_PLL3RDYF, 1 << 8   @ bitWidth 1 (PLL3 ready Interrupt Flag)  
        .equ RCC_CIFR_LSECSSF, 1 << 9   @ bitWidth 1 (LSE clock security system Interrupt  Flag)  
        .equ RCC_CIFR_HSECSSF, 1 << 10   @ bitWidth 1 (HSE clock security system Interrupt  Flag)  
 
    .equ RCC_CICR, RCC_BASE + 0x68 @ (RCC Clock Source Interrupt Clear  Register) 
        .equ RCC_CICR_LSIRDYC, 1 << 0   @ bitWidth 1 (LSI ready Interrupt Clear)  
        .equ RCC_CICR_LSERDYC, 1 << 1   @ bitWidth 1 (LSE ready Interrupt Clear)  
        .equ RCC_CICR_HSIRDYC, 1 << 2   @ bitWidth 1 (HSI ready Interrupt Clear)  
        .equ RCC_CICR_HSERDYC, 1 << 3   @ bitWidth 1 (HSE ready Interrupt Clear)  
        .equ RCC_CICR_HSE_ready_Interrupt_Clear, 1 << 4   @ bitWidth 1 (CSI ready Interrupt Clear)  
        .equ RCC_CICR_RC48RDYC, 1 << 5   @ bitWidth 1 (RC48 ready Interrupt Clear)  
        .equ RCC_CICR_PLL1RDYC, 1 << 6   @ bitWidth 1 (PLL1 ready Interrupt Clear)  
        .equ RCC_CICR_PLL2RDYC, 1 << 7   @ bitWidth 1 (PLL2 ready Interrupt Clear)  
        .equ RCC_CICR_PLL3RDYC, 1 << 8   @ bitWidth 1 (PLL3 ready Interrupt Clear)  
        .equ RCC_CICR_LSECSSC, 1 << 9   @ bitWidth 1 (LSE clock security system Interrupt  Clear)  
        .equ RCC_CICR_HSECSSC, 1 << 10   @ bitWidth 1 (HSE clock security system Interrupt  Clear)  
 
    .equ RCC_BDCR, RCC_BASE + 0x70 @ (RCC Backup Domain Control  Register) 
        .equ RCC_BDCR_LSEON, 1 << 0   @ bitWidth 1 (LSE oscillator enabled)  
        .equ RCC_BDCR_LSERDY, 1 << 1   @ bitWidth 1 (LSE oscillator ready)  
        .equ RCC_BDCR_LSEBYP, 1 << 2   @ bitWidth 1 (LSE oscillator bypass)  
        .equ RCC_BDCR_LSEDRV_Shift, 3   @ bitWidth 2 (LSE oscillator driving  capability)  
        .equ RCC_BDCR_LSECSSON, 1 << 5   @ bitWidth 1 (LSE clock security system  enable)  
        .equ RCC_BDCR_LSECSSD, 1 << 6   @ bitWidth 1 (LSE clock security system failure  detection)  
        .equ RCC_BDCR_RTCSRC_Shift, 8   @ bitWidth 2 (RTC clock source selection)  
        .equ RCC_BDCR_RTCEN, 1 << 15   @ bitWidth 1 (RTC clock enable)  
        .equ RCC_BDCR_VSWRST, 1 << 16   @ bitWidth 1 (VSwitch domain software  reset)  
 
    .equ RCC_CSR, RCC_BASE + 0x74 @ (RCC Clock Control and Status  Register) 
        .equ RCC_CSR_LSION, 1 << 0   @ bitWidth 1 (LSI oscillator enable)  
        .equ RCC_CSR_LSIRDY, 1 << 1   @ bitWidth 1 (LSI oscillator ready)  
 
    .equ RCC_AHB3RSTR, RCC_BASE + 0x7C @ (RCC AHB3 Reset Register) 
        .equ RCC_AHB3RSTR_MDMARST, 1 << 0   @ bitWidth 1 (MDMA block reset)  
        .equ RCC_AHB3RSTR_DMA2DRST, 1 << 4   @ bitWidth 1 (DMA2D block reset)  
        .equ RCC_AHB3RSTR_JPGDECRST, 1 << 5   @ bitWidth 1 (JPGDEC block reset)  
        .equ RCC_AHB3RSTR_FMCRST, 1 << 12   @ bitWidth 1 (FMC block reset)  
        .equ RCC_AHB3RSTR_QSPIRST, 1 << 14   @ bitWidth 1 (QUADSPI and QUADSPI delay block  reset)  
        .equ RCC_AHB3RSTR_SDMMC1RST, 1 << 16   @ bitWidth 1 (SDMMC1 and SDMMC1 delay block  reset)  
        .equ RCC_AHB3RSTR_CPURST, 1 << 31   @ bitWidth 1 (CPU reset)  
 
    .equ RCC_AHB1RSTR, RCC_BASE + 0x80 @ (RCC AHB1 Peripheral Reset  Register) 
        .equ RCC_AHB1RSTR_DMA1RST, 1 << 0   @ bitWidth 1 (DMA1 block reset)  
        .equ RCC_AHB1RSTR_DMA2RST, 1 << 1   @ bitWidth 1 (DMA2 block reset)  
        .equ RCC_AHB1RSTR_ADC12RST, 1 << 5   @ bitWidth 1 (ADC1&2 block reset)  
        .equ RCC_AHB1RSTR_ETH1MACRST, 1 << 15   @ bitWidth 1 (ETH1MAC block reset)  
        .equ RCC_AHB1RSTR_USB1OTGRST, 1 << 25   @ bitWidth 1 (USB1OTG block reset)  
        .equ RCC_AHB1RSTR_USB2OTGRST, 1 << 27   @ bitWidth 1 (USB2OTG block reset)  
 
    .equ RCC_AHB2RSTR, RCC_BASE + 0x84 @ (RCC AHB2 Peripheral Reset  Register) 
        .equ RCC_AHB2RSTR_CAMITFRST, 1 << 0   @ bitWidth 1 (CAMITF block reset)  
        .equ RCC_AHB2RSTR_CRYPTRST, 1 << 4   @ bitWidth 1 (Cryptography block reset)  
        .equ RCC_AHB2RSTR_HASHRST, 1 << 5   @ bitWidth 1 (Hash block reset)  
        .equ RCC_AHB2RSTR_RNGRST, 1 << 6   @ bitWidth 1 (Random Number Generator block  reset)  
        .equ RCC_AHB2RSTR_SDMMC2RST, 1 << 9   @ bitWidth 1 (SDMMC2 and SDMMC2 Delay block  reset)  
 
    .equ RCC_AHB4RSTR, RCC_BASE + 0x88 @ (RCC AHB4 Peripheral Reset  Register) 
        .equ RCC_AHB4RSTR_GPIOARST, 1 << 0   @ bitWidth 1 (GPIO block reset)  
        .equ RCC_AHB4RSTR_GPIOBRST, 1 << 1   @ bitWidth 1 (GPIO block reset)  
        .equ RCC_AHB4RSTR_GPIOCRST, 1 << 2   @ bitWidth 1 (GPIO block reset)  
        .equ RCC_AHB4RSTR_GPIODRST, 1 << 3   @ bitWidth 1 (GPIO block reset)  
        .equ RCC_AHB4RSTR_GPIOERST, 1 << 4   @ bitWidth 1 (GPIO block reset)  
        .equ RCC_AHB4RSTR_GPIOFRST, 1 << 5   @ bitWidth 1 (GPIO block reset)  
        .equ RCC_AHB4RSTR_GPIOGRST, 1 << 6   @ bitWidth 1 (GPIO block reset)  
        .equ RCC_AHB4RSTR_GPIOHRST, 1 << 7   @ bitWidth 1 (GPIO block reset)  
        .equ RCC_AHB4RSTR_GPIOIRST, 1 << 8   @ bitWidth 1 (GPIO block reset)  
        .equ RCC_AHB4RSTR_GPIOJRST, 1 << 9   @ bitWidth 1 (GPIO block reset)  
        .equ RCC_AHB4RSTR_GPIOKRST, 1 << 10   @ bitWidth 1 (GPIO block reset)  
        .equ RCC_AHB4RSTR_CRCRST, 1 << 19   @ bitWidth 1 (CRC block reset)  
        .equ RCC_AHB4RSTR_BDMARST, 1 << 21   @ bitWidth 1 (BDMA block reset)  
        .equ RCC_AHB4RSTR_ADC3RST, 1 << 24   @ bitWidth 1 (ADC3 block reset)  
        .equ RCC_AHB4RSTR_HSEMRST, 1 << 25   @ bitWidth 1 (HSEM block reset)  
 
    .equ RCC_APB3RSTR, RCC_BASE + 0x8C @ (RCC APB3 Peripheral Reset  Register) 
        .equ RCC_APB3RSTR_LTDCRST, 1 << 3   @ bitWidth 1 (LTDC block reset)  
 
    .equ RCC_APB1LRSTR, RCC_BASE + 0x90 @ (RCC APB1 Peripheral Reset  Register) 
        .equ RCC_APB1LRSTR_TIM2RST, 1 << 0   @ bitWidth 1 (TIM block reset)  
        .equ RCC_APB1LRSTR_TIM3RST, 1 << 1   @ bitWidth 1 (TIM block reset)  
        .equ RCC_APB1LRSTR_TIM4RST, 1 << 2   @ bitWidth 1 (TIM block reset)  
        .equ RCC_APB1LRSTR_TIM5RST, 1 << 3   @ bitWidth 1 (TIM block reset)  
        .equ RCC_APB1LRSTR_TIM6RST, 1 << 4   @ bitWidth 1 (TIM block reset)  
        .equ RCC_APB1LRSTR_TIM7RST, 1 << 5   @ bitWidth 1 (TIM block reset)  
        .equ RCC_APB1LRSTR_TIM12RST, 1 << 6   @ bitWidth 1 (TIM block reset)  
        .equ RCC_APB1LRSTR_TIM13RST, 1 << 7   @ bitWidth 1 (TIM block reset)  
        .equ RCC_APB1LRSTR_TIM14RST, 1 << 8   @ bitWidth 1 (TIM block reset)  
        .equ RCC_APB1LRSTR_LPTIM1RST, 1 << 9   @ bitWidth 1 (TIM block reset)  
        .equ RCC_APB1LRSTR_SPI2RST, 1 << 14   @ bitWidth 1 (SPI2 block reset)  
        .equ RCC_APB1LRSTR_SPI3RST, 1 << 15   @ bitWidth 1 (SPI3 block reset)  
        .equ RCC_APB1LRSTR_SPDIFRXRST, 1 << 16   @ bitWidth 1 (SPDIFRX block reset)  
        .equ RCC_APB1LRSTR_USART2RST, 1 << 17   @ bitWidth 1 (USART2 block reset)  
        .equ RCC_APB1LRSTR_USART3RST, 1 << 18   @ bitWidth 1 (USART3 block reset)  
        .equ RCC_APB1LRSTR_UART4RST, 1 << 19   @ bitWidth 1 (UART4 block reset)  
        .equ RCC_APB1LRSTR_UART5RST, 1 << 20   @ bitWidth 1 (UART5 block reset)  
        .equ RCC_APB1LRSTR_I2C1RST, 1 << 21   @ bitWidth 1 (I2C1 block reset)  
        .equ RCC_APB1LRSTR_I2C2RST, 1 << 22   @ bitWidth 1 (I2C2 block reset)  
        .equ RCC_APB1LRSTR_I2C3RST, 1 << 23   @ bitWidth 1 (I2C3 block reset)  
        .equ RCC_APB1LRSTR_CECRST, 1 << 27   @ bitWidth 1 (HDMI-CEC block reset)  
        .equ RCC_APB1LRSTR_DAC12RST, 1 << 29   @ bitWidth 1 (DAC1 and 2 Blocks Reset)  
        .equ RCC_APB1LRSTR_USART7RST, 1 << 30   @ bitWidth 1 (USART7 block reset)  
        .equ RCC_APB1LRSTR_USART8RST, 1 << 31   @ bitWidth 1 (USART8 block reset)  
 
    .equ RCC_APB1HRSTR, RCC_BASE + 0x94 @ (RCC APB1 Peripheral Reset  Register) 
        .equ RCC_APB1HRSTR_CRSRST, 1 << 1   @ bitWidth 1 (Clock Recovery System  reset)  
        .equ RCC_APB1HRSTR_SWPRST, 1 << 2   @ bitWidth 1 (SWPMI block reset)  
        .equ RCC_APB1HRSTR_OPAMPRST, 1 << 4   @ bitWidth 1 (OPAMP block reset)  
        .equ RCC_APB1HRSTR_MDIOSRST, 1 << 5   @ bitWidth 1 (MDIOS block reset)  
        .equ RCC_APB1HRSTR_FDCANRST, 1 << 8   @ bitWidth 1 (FDCAN block reset)  
 
    .equ RCC_APB2RSTR, RCC_BASE + 0x98 @ (RCC APB2 Peripheral Reset  Register) 
        .equ RCC_APB2RSTR_TIM1RST, 1 << 0   @ bitWidth 1 (TIM1 block reset)  
        .equ RCC_APB2RSTR_TIM8RST, 1 << 1   @ bitWidth 1 (TIM8 block reset)  
        .equ RCC_APB2RSTR_USART1RST, 1 << 4   @ bitWidth 1 (USART1 block reset)  
        .equ RCC_APB2RSTR_USART6RST, 1 << 5   @ bitWidth 1 (USART6 block reset)  
        .equ RCC_APB2RSTR_SPI1RST, 1 << 12   @ bitWidth 1 (SPI1 block reset)  
        .equ RCC_APB2RSTR_SPI4RST, 1 << 13   @ bitWidth 1 (SPI4 block reset)  
        .equ RCC_APB2RSTR_TIM15RST, 1 << 16   @ bitWidth 1 (TIM15 block reset)  
        .equ RCC_APB2RSTR_TIM16RST, 1 << 17   @ bitWidth 1 (TIM16 block reset)  
        .equ RCC_APB2RSTR_TIM17RST, 1 << 18   @ bitWidth 1 (TIM17 block reset)  
        .equ RCC_APB2RSTR_SPI5RST, 1 << 20   @ bitWidth 1 (SPI5 block reset)  
        .equ RCC_APB2RSTR_SAI1RST, 1 << 22   @ bitWidth 1 (SAI1 block reset)  
        .equ RCC_APB2RSTR_SAI2RST, 1 << 23   @ bitWidth 1 (SAI2 block reset)  
        .equ RCC_APB2RSTR_SAI3RST, 1 << 24   @ bitWidth 1 (SAI3 block reset)  
        .equ RCC_APB2RSTR_DFSDM1RST, 1 << 28   @ bitWidth 1 (DFSDM1 block reset)  
        .equ RCC_APB2RSTR_HRTIMRST, 1 << 29   @ bitWidth 1 (HRTIM block reset)  
 
    .equ RCC_APB4RSTR, RCC_BASE + 0x9C @ (RCC APB4 Peripheral Reset  Register) 
        .equ RCC_APB4RSTR_SYSCFGRST, 1 << 1   @ bitWidth 1 (SYSCFG block reset)  
        .equ RCC_APB4RSTR_LPUART1RST, 1 << 3   @ bitWidth 1 (LPUART1 block reset)  
        .equ RCC_APB4RSTR_SPI6RST, 1 << 5   @ bitWidth 1 (SPI6 block reset)  
        .equ RCC_APB4RSTR_I2C4RST, 1 << 7   @ bitWidth 1 (I2C4 block reset)  
        .equ RCC_APB4RSTR_LPTIM2RST, 1 << 9   @ bitWidth 1 (LPTIM2 block reset)  
        .equ RCC_APB4RSTR_LPTIM3RST, 1 << 10   @ bitWidth 1 (LPTIM3 block reset)  
        .equ RCC_APB4RSTR_LPTIM4RST, 1 << 11   @ bitWidth 1 (LPTIM4 block reset)  
        .equ RCC_APB4RSTR_LPTIM5RST, 1 << 12   @ bitWidth 1 (LPTIM5 block reset)  
        .equ RCC_APB4RSTR_COMP12RST, 1 << 14   @ bitWidth 1 (COMP12 Blocks Reset)  
        .equ RCC_APB4RSTR_VREFRST, 1 << 15   @ bitWidth 1 (VREF block reset)  
        .equ RCC_APB4RSTR_SAI4RST, 1 << 21   @ bitWidth 1 (SAI4 block reset)  
 
    .equ RCC_GCR, RCC_BASE + 0xA0 @ (RCC Global Control Register) 
        .equ RCC_GCR_WW1RSC, 1 << 0   @ bitWidth 1 (WWDG1 reset scope control)  
 
    .equ RCC_D3AMR, RCC_BASE + 0xA8 @ (RCC D3 Autonomous mode  Register) 
        .equ RCC_D3AMR_BDMAAMEN, 1 << 0   @ bitWidth 1 (BDMA and DMAMUX Autonomous mode  enable)  
        .equ RCC_D3AMR_LPUART1AMEN, 1 << 3   @ bitWidth 1 (LPUART1 Autonomous mode  enable)  
        .equ RCC_D3AMR_SPI6AMEN, 1 << 5   @ bitWidth 1 (SPI6 Autonomous mode  enable)  
        .equ RCC_D3AMR_I2C4AMEN, 1 << 7   @ bitWidth 1 (I2C4 Autonomous mode  enable)  
        .equ RCC_D3AMR_LPTIM2AMEN, 1 << 9   @ bitWidth 1 (LPTIM2 Autonomous mode  enable)  
        .equ RCC_D3AMR_LPTIM3AMEN, 1 << 10   @ bitWidth 1 (LPTIM3 Autonomous mode  enable)  
        .equ RCC_D3AMR_LPTIM4AMEN, 1 << 11   @ bitWidth 1 (LPTIM4 Autonomous mode  enable)  
        .equ RCC_D3AMR_LPTIM5AMEN, 1 << 12   @ bitWidth 1 (LPTIM5 Autonomous mode  enable)  
        .equ RCC_D3AMR_COMP12AMEN, 1 << 14   @ bitWidth 1 (COMP12 Autonomous mode  enable)  
        .equ RCC_D3AMR_VREFAMEN, 1 << 15   @ bitWidth 1 (VREF Autonomous mode  enable)  
        .equ RCC_D3AMR_RTCAMEN, 1 << 16   @ bitWidth 1 (RTC Autonomous mode enable)  
        .equ RCC_D3AMR_CRCAMEN, 1 << 19   @ bitWidth 1 (CRC Autonomous mode enable)  
        .equ RCC_D3AMR_SAI4AMEN, 1 << 21   @ bitWidth 1 (SAI4 Autonomous mode  enable)  
        .equ RCC_D3AMR_ADC3AMEN, 1 << 24   @ bitWidth 1 (ADC3 Autonomous mode  enable)  
        .equ RCC_D3AMR_BKPRAMAMEN, 1 << 28   @ bitWidth 1 (Backup RAM Autonomous mode  enable)  
        .equ RCC_D3AMR_SRAM4AMEN, 1 << 29   @ bitWidth 1 (SRAM4 Autonomous mode  enable)  
 
    .equ RCC_RSR, RCC_BASE + 0xD0 @ (RCC Reset Status Register) 
        .equ RCC_RSR_RMVF, 1 << 16   @ bitWidth 1 (Remove reset flag)  
        .equ RCC_RSR_CPURSTF, 1 << 17   @ bitWidth 1 (CPU reset flag)  
        .equ RCC_RSR_D1RSTF, 1 << 19   @ bitWidth 1 (D1 domain power switch reset  flag)  
        .equ RCC_RSR_D2RSTF, 1 << 20   @ bitWidth 1 (D2 domain power switch reset  flag)  
        .equ RCC_RSR_BORRSTF, 1 << 21   @ bitWidth 1 (BOR reset flag)  
        .equ RCC_RSR_PINRSTF, 1 << 22   @ bitWidth 1 (Pin reset flag NRST)  
        .equ RCC_RSR_PORRSTF, 1 << 23   @ bitWidth 1 (POR/PDR reset flag)  
        .equ RCC_RSR_SFTRSTF, 1 << 24   @ bitWidth 1 (System reset from CPU reset  flag)  
        .equ RCC_RSR_IWDG1RSTF, 1 << 26   @ bitWidth 1 (Independent Watchdog reset  flag)  
        .equ RCC_RSR_WWDG1RSTF, 1 << 28   @ bitWidth 1 (Window Watchdog reset flag)  
        .equ RCC_RSR_LPWRRSTF, 1 << 30   @ bitWidth 1 (Reset due to illegal D1 DStandby or CPU  CStop flag)  
 
    .equ RCC_C1_RSR, RCC_BASE + 0x130 @ (RCC Reset Status Register) 
        .equ RCC_C1_RSR_RMVF, 1 << 16   @ bitWidth 1 (Remove reset flag)  
        .equ RCC_C1_RSR_CPURSTF, 1 << 17   @ bitWidth 1 (CPU reset flag)  
        .equ RCC_C1_RSR_D1RSTF, 1 << 19   @ bitWidth 1 (D1 domain power switch reset  flag)  
        .equ RCC_C1_RSR_D2RSTF, 1 << 20   @ bitWidth 1 (D2 domain power switch reset  flag)  
        .equ RCC_C1_RSR_BORRSTF, 1 << 21   @ bitWidth 1 (BOR reset flag)  
        .equ RCC_C1_RSR_PINRSTF, 1 << 22   @ bitWidth 1 (Pin reset flag NRST)  
        .equ RCC_C1_RSR_PORRSTF, 1 << 23   @ bitWidth 1 (POR/PDR reset flag)  
        .equ RCC_C1_RSR_SFTRSTF, 1 << 24   @ bitWidth 1 (System reset from CPU reset  flag)  
        .equ RCC_C1_RSR_IWDG1RSTF, 1 << 26   @ bitWidth 1 (Independent Watchdog reset  flag)  
        .equ RCC_C1_RSR_WWDG1RSTF, 1 << 28   @ bitWidth 1 (Window Watchdog reset flag)  
        .equ RCC_C1_RSR_LPWRRSTF, 1 << 30   @ bitWidth 1 (Reset due to illegal D1 DStandby or CPU  CStop flag)  
 
    .equ RCC_C1_AHB3ENR, RCC_BASE + 0x134 @ (RCC AHB3 Clock Register) 
        .equ RCC_C1_AHB3ENR_MDMAEN, 1 << 0   @ bitWidth 1 (MDMA Peripheral Clock  Enable)  
        .equ RCC_C1_AHB3ENR_DMA2DEN, 1 << 4   @ bitWidth 1 (DMA2D Peripheral Clock  Enable)  
        .equ RCC_C1_AHB3ENR_JPGDECEN, 1 << 5   @ bitWidth 1 (JPGDEC Peripheral Clock  Enable)  
        .equ RCC_C1_AHB3ENR_FMCEN, 1 << 12   @ bitWidth 1 (FMC Peripheral Clocks  Enable)  
        .equ RCC_C1_AHB3ENR_QSPIEN, 1 << 14   @ bitWidth 1 (QUADSPI and QUADSPI Delay Clock  Enable)  
        .equ RCC_C1_AHB3ENR_SDMMC1EN, 1 << 16   @ bitWidth 1 (SDMMC1 and SDMMC1 Delay Clock  Enable)  
 
    .equ RCC_AHB3ENR, RCC_BASE + 0xD4 @ (RCC AHB3 Clock Register) 
        .equ RCC_AHB3ENR_MDMAEN, 1 << 0   @ bitWidth 1 (MDMA Peripheral Clock  Enable)  
        .equ RCC_AHB3ENR_DMA2DEN, 1 << 4   @ bitWidth 1 (DMA2D Peripheral Clock  Enable)  
        .equ RCC_AHB3ENR_JPGDECEN, 1 << 5   @ bitWidth 1 (JPGDEC Peripheral Clock  Enable)  
        .equ RCC_AHB3ENR_FMCEN, 1 << 12   @ bitWidth 1 (FMC Peripheral Clocks  Enable)  
        .equ RCC_AHB3ENR_QSPIEN, 1 << 14   @ bitWidth 1 (QUADSPI and QUADSPI Delay Clock  Enable)  
        .equ RCC_AHB3ENR_SDMMC1EN, 1 << 16   @ bitWidth 1 (SDMMC1 and SDMMC1 Delay Clock  Enable)  
 
    .equ RCC_AHB1ENR, RCC_BASE + 0xD8 @ (RCC AHB1 Clock Register) 
        .equ RCC_AHB1ENR_DMA1EN, 1 << 0   @ bitWidth 1 (DMA1 Clock Enable)  
        .equ RCC_AHB1ENR_DMA2EN, 1 << 1   @ bitWidth 1 (DMA2 Clock Enable)  
        .equ RCC_AHB1ENR_ADC12EN, 1 << 5   @ bitWidth 1 (ADC1/2 Peripheral Clocks  Enable)  
        .equ RCC_AHB1ENR_ETH1MACEN, 1 << 15   @ bitWidth 1 (Ethernet MAC bus interface Clock  Enable)  
        .equ RCC_AHB1ENR_ETH1TXEN, 1 << 16   @ bitWidth 1 (Ethernet Transmission Clock  Enable)  
        .equ RCC_AHB1ENR_ETH1RXEN, 1 << 17   @ bitWidth 1 (Ethernet Reception Clock  Enable)  
        .equ RCC_AHB1ENR_USB2OTGHSULPIEN, 1 << 18   @ bitWidth 1 ( Enable USB_PHY2 clocks )  
        .equ RCC_AHB1ENR_USB1OTGEN, 1 << 25   @ bitWidth 1 (USB1OTG Peripheral Clocks  Enable)  
        .equ RCC_AHB1ENR_USB1ULPIEN, 1 << 26   @ bitWidth 1 (USB_PHY1 Clocks Enable)  
        .equ RCC_AHB1ENR_USB2OTGEN, 1 << 27   @ bitWidth 1 (USB2OTG Peripheral Clocks  Enable)  
        .equ RCC_AHB1ENR_USB2ULPIEN, 1 << 28   @ bitWidth 1 (USB_PHY2 Clocks Enable)  
 
    .equ RCC_C1_AHB1ENR, RCC_BASE + 0x138 @ (RCC AHB1 Clock Register) 
        .equ RCC_C1_AHB1ENR_DMA1EN, 1 << 0   @ bitWidth 1 (DMA1 Clock Enable)  
        .equ RCC_C1_AHB1ENR_DMA2EN, 1 << 1   @ bitWidth 1 (DMA2 Clock Enable)  
        .equ RCC_C1_AHB1ENR_ADC12EN, 1 << 5   @ bitWidth 1 (ADC1/2 Peripheral Clocks  Enable)  
        .equ RCC_C1_AHB1ENR_ETH1MACEN, 1 << 15   @ bitWidth 1 (Ethernet MAC bus interface Clock  Enable)  
        .equ RCC_C1_AHB1ENR_ETH1TXEN, 1 << 16   @ bitWidth 1 (Ethernet Transmission Clock  Enable)  
        .equ RCC_C1_AHB1ENR_ETH1RXEN, 1 << 17   @ bitWidth 1 (Ethernet Reception Clock  Enable)  
        .equ RCC_C1_AHB1ENR_USB1OTGEN, 1 << 25   @ bitWidth 1 (USB1OTG Peripheral Clocks  Enable)  
        .equ RCC_C1_AHB1ENR_USB1ULPIEN, 1 << 26   @ bitWidth 1 (USB_PHY1 Clocks Enable)  
        .equ RCC_C1_AHB1ENR_USB2OTGEN, 1 << 27   @ bitWidth 1 (USB2OTG Peripheral Clocks  Enable)  
        .equ RCC_C1_AHB1ENR_USB2ULPIEN, 1 << 28   @ bitWidth 1 (USB_PHY2 Clocks Enable)  
 
    .equ RCC_C1_AHB2ENR, RCC_BASE + 0x13C @ (RCC AHB2 Clock Register) 
        .equ RCC_C1_AHB2ENR_CAMITFEN, 1 << 0   @ bitWidth 1 (CAMITF peripheral clock  enable)  
        .equ RCC_C1_AHB2ENR_CRYPTEN, 1 << 4   @ bitWidth 1 (CRYPT peripheral clock  enable)  
        .equ RCC_C1_AHB2ENR_HASHEN, 1 << 5   @ bitWidth 1 (HASH peripheral clock  enable)  
        .equ RCC_C1_AHB2ENR_RNGEN, 1 << 6   @ bitWidth 1 (RNG peripheral clocks  enable)  
        .equ RCC_C1_AHB2ENR_SDMMC2EN, 1 << 9   @ bitWidth 1 (SDMMC2 and SDMMC2 delay clock  enable)  
        .equ RCC_C1_AHB2ENR_SRAM1EN, 1 << 29   @ bitWidth 1 (SRAM1 block enable)  
        .equ RCC_C1_AHB2ENR_SRAM2EN, 1 << 30   @ bitWidth 1 (SRAM2 block enable)  
        .equ RCC_C1_AHB2ENR_SRAM3EN, 1 << 31   @ bitWidth 1 (SRAM3 block enable)  
 
    .equ RCC_AHB2ENR, RCC_BASE + 0xDC @ (RCC AHB2 Clock Register) 
        .equ RCC_AHB2ENR_CAMITFEN, 1 << 0   @ bitWidth 1 (CAMITF peripheral clock  enable)  
        .equ RCC_AHB2ENR_CRYPTEN, 1 << 4   @ bitWidth 1 (CRYPT peripheral clock  enable)  
        .equ RCC_AHB2ENR_HASHEN, 1 << 5   @ bitWidth 1 (HASH peripheral clock  enable)  
        .equ RCC_AHB2ENR_RNGEN, 1 << 6   @ bitWidth 1 (RNG peripheral clocks  enable)  
        .equ RCC_AHB2ENR_SDMMC2EN, 1 << 9   @ bitWidth 1 (SDMMC2 and SDMMC2 delay clock  enable)  
        .equ RCC_AHB2ENR_SRAM1EN, 1 << 29   @ bitWidth 1 (SRAM1 block enable)  
        .equ RCC_AHB2ENR_SRAM2EN, 1 << 30   @ bitWidth 1 (SRAM2 block enable)  
        .equ RCC_AHB2ENR_SRAM3EN, 1 << 31   @ bitWidth 1 (SRAM3 block enable)  
 
    .equ RCC_AHB4ENR, RCC_BASE + 0xE0 @ (RCC AHB4 Clock Register) 
        .equ RCC_AHB4ENR_GPIOAEN, 1 << 0   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_AHB4ENR_GPIOBEN, 1 << 1   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_AHB4ENR_GPIOCEN, 1 << 2   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_AHB4ENR_GPIODEN, 1 << 3   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_AHB4ENR_GPIOEEN, 1 << 4   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_AHB4ENR_GPIOFEN, 1 << 5   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_AHB4ENR_GPIOGEN, 1 << 6   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_AHB4ENR_GPIOHEN, 1 << 7   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_AHB4ENR_GPIOIEN, 1 << 8   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_AHB4ENR_GPIOJEN, 1 << 9   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_AHB4ENR_GPIOKEN, 1 << 10   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_AHB4ENR_CRCEN, 1 << 19   @ bitWidth 1 (CRC peripheral clock  enable)  
        .equ RCC_AHB4ENR_BDMAEN, 1 << 21   @ bitWidth 1 (BDMA and DMAMUX2 Clock  Enable)  
        .equ RCC_AHB4ENR_ADC3EN, 1 << 24   @ bitWidth 1 (ADC3 Peripheral Clocks  Enable)  
        .equ RCC_AHB4ENR_HSEMEN, 1 << 25   @ bitWidth 1 (HSEM peripheral clock  enable)  
        .equ RCC_AHB4ENR_BKPRAMEN, 1 << 28   @ bitWidth 1 (Backup RAM Clock Enable)  
 
    .equ RCC_C1_AHB4ENR, RCC_BASE + 0x140 @ (RCC AHB4 Clock Register) 
        .equ RCC_C1_AHB4ENR_GPIOAEN, 1 << 0   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_C1_AHB4ENR_GPIOBEN, 1 << 1   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_C1_AHB4ENR_GPIOCEN, 1 << 2   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_C1_AHB4ENR_GPIODEN, 1 << 3   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_C1_AHB4ENR_GPIOEEN, 1 << 4   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_C1_AHB4ENR_GPIOFEN, 1 << 5   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_C1_AHB4ENR_GPIOGEN, 1 << 6   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_C1_AHB4ENR_GPIOHEN, 1 << 7   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_C1_AHB4ENR_GPIOIEN, 1 << 8   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_C1_AHB4ENR_GPIOJEN, 1 << 9   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_C1_AHB4ENR_GPIOKEN, 1 << 10   @ bitWidth 1 (0GPIO peripheral clock  enable)  
        .equ RCC_C1_AHB4ENR_CRCEN, 1 << 19   @ bitWidth 1 (CRC peripheral clock  enable)  
        .equ RCC_C1_AHB4ENR_BDMAEN, 1 << 21   @ bitWidth 1 (BDMA and DMAMUX2 Clock  Enable)  
        .equ RCC_C1_AHB4ENR_ADC3EN, 1 << 24   @ bitWidth 1 (ADC3 Peripheral Clocks  Enable)  
        .equ RCC_C1_AHB4ENR_HSEMEN, 1 << 25   @ bitWidth 1 (HSEM peripheral clock  enable)  
        .equ RCC_C1_AHB4ENR_BKPRAMEN, 1 << 28   @ bitWidth 1 (Backup RAM Clock Enable)  
 
    .equ RCC_C1_APB3ENR, RCC_BASE + 0x144 @ (RCC APB3 Clock Register) 
        .equ RCC_C1_APB3ENR_LTDCEN, 1 << 3   @ bitWidth 1 (LTDC peripheral clock  enable)  
        .equ RCC_C1_APB3ENR_WWDG1EN, 1 << 6   @ bitWidth 1 (WWDG1 Clock Enable)  
 
    .equ RCC_APB3ENR, RCC_BASE + 0xE4 @ (RCC APB3 Clock Register) 
        .equ RCC_APB3ENR_LTDCEN, 1 << 3   @ bitWidth 1 (LTDC peripheral clock  enable)  
        .equ RCC_APB3ENR_WWDG1EN, 1 << 6   @ bitWidth 1 (WWDG1 Clock Enable)  
 
    .equ RCC_APB1LENR, RCC_BASE + 0xE8 @ (RCC APB1 Clock Register) 
        .equ RCC_APB1LENR_TIM2EN, 1 << 0   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_APB1LENR_TIM3EN, 1 << 1   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_APB1LENR_TIM4EN, 1 << 2   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_APB1LENR_TIM5EN, 1 << 3   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_APB1LENR_TIM6EN, 1 << 4   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_APB1LENR_TIM7EN, 1 << 5   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_APB1LENR_TIM12EN, 1 << 6   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_APB1LENR_TIM13EN, 1 << 7   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_APB1LENR_TIM14EN, 1 << 8   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_APB1LENR_LPTIM1EN, 1 << 9   @ bitWidth 1 (LPTIM1 Peripheral Clocks  Enable)  
        .equ RCC_APB1LENR_SPI2EN, 1 << 14   @ bitWidth 1 (SPI2 Peripheral Clocks  Enable)  
        .equ RCC_APB1LENR_SPI3EN, 1 << 15   @ bitWidth 1 (SPI3 Peripheral Clocks  Enable)  
        .equ RCC_APB1LENR_SPDIFRXEN, 1 << 16   @ bitWidth 1 (SPDIFRX Peripheral Clocks  Enable)  
        .equ RCC_APB1LENR_USART2EN, 1 << 17   @ bitWidth 1 (USART2 Peripheral Clocks  Enable)  
        .equ RCC_APB1LENR_USART3EN, 1 << 18   @ bitWidth 1 (USART3 Peripheral Clocks  Enable)  
        .equ RCC_APB1LENR_UART4EN, 1 << 19   @ bitWidth 1 (UART4 Peripheral Clocks  Enable)  
        .equ RCC_APB1LENR_UART5EN, 1 << 20   @ bitWidth 1 (UART5 Peripheral Clocks  Enable)  
        .equ RCC_APB1LENR_I2C1EN, 1 << 21   @ bitWidth 1 (I2C1 Peripheral Clocks  Enable)  
        .equ RCC_APB1LENR_I2C2EN, 1 << 22   @ bitWidth 1 (I2C2 Peripheral Clocks  Enable)  
        .equ RCC_APB1LENR_I2C3EN, 1 << 23   @ bitWidth 1 (I2C3 Peripheral Clocks  Enable)  
        .equ RCC_APB1LENR_CECEN, 1 << 27   @ bitWidth 1 (HDMI-CEC peripheral clock  enable)  
        .equ RCC_APB1LENR_DAC12EN, 1 << 29   @ bitWidth 1 (DAC1&2 peripheral clock  enable)  
        .equ RCC_APB1LENR_USART7EN, 1 << 30   @ bitWidth 1 (USART7 Peripheral Clocks  Enable)  
        .equ RCC_APB1LENR_USART8EN, 1 << 31   @ bitWidth 1 (USART8 Peripheral Clocks  Enable)  
 
    .equ RCC_C1_APB1LENR, RCC_BASE + 0x148 @ (RCC APB1 Clock Register) 
        .equ RCC_C1_APB1LENR_TIM2EN, 1 << 0   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_C1_APB1LENR_TIM3EN, 1 << 1   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_C1_APB1LENR_TIM4EN, 1 << 2   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_C1_APB1LENR_TIM5EN, 1 << 3   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_C1_APB1LENR_TIM6EN, 1 << 4   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_C1_APB1LENR_TIM7EN, 1 << 5   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_C1_APB1LENR_TIM12EN, 1 << 6   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_C1_APB1LENR_TIM13EN, 1 << 7   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_C1_APB1LENR_TIM14EN, 1 << 8   @ bitWidth 1 (TIM peripheral clock  enable)  
        .equ RCC_C1_APB1LENR_LPTIM1EN, 1 << 9   @ bitWidth 1 (LPTIM1 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB1LENR_SPI2EN, 1 << 14   @ bitWidth 1 (SPI2 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB1LENR_SPI3EN, 1 << 15   @ bitWidth 1 (SPI3 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB1LENR_SPDIFRXEN, 1 << 16   @ bitWidth 1 (SPDIFRX Peripheral Clocks  Enable)  
        .equ RCC_C1_APB1LENR_USART2EN, 1 << 17   @ bitWidth 1 (USART2 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB1LENR_USART3EN, 1 << 18   @ bitWidth 1 (USART3 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB1LENR_UART4EN, 1 << 19   @ bitWidth 1 (UART4 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB1LENR_UART5EN, 1 << 20   @ bitWidth 1 (UART5 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB1LENR_I2C1EN, 1 << 21   @ bitWidth 1 (I2C1 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB1LENR_I2C2EN, 1 << 22   @ bitWidth 1 (I2C2 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB1LENR_I2C3EN, 1 << 23   @ bitWidth 1 (I2C3 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB1LENR_HDMICECEN, 1 << 27   @ bitWidth 1 (HDMI-CEC peripheral clock  enable)  
        .equ RCC_C1_APB1LENR_DAC12EN, 1 << 29   @ bitWidth 1 (DAC1&2 peripheral clock  enable)  
        .equ RCC_C1_APB1LENR_USART7EN, 1 << 30   @ bitWidth 1 (USART7 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB1LENR_USART8EN, 1 << 31   @ bitWidth 1 (USART8 Peripheral Clocks  Enable)  
 
    .equ RCC_APB1HENR, RCC_BASE + 0xEC @ (RCC APB1 Clock Register) 
        .equ RCC_APB1HENR_CRSEN, 1 << 1   @ bitWidth 1 (Clock Recovery System peripheral clock  enable)  
        .equ RCC_APB1HENR_SWPEN, 1 << 2   @ bitWidth 1 (SWPMI Peripheral Clocks  Enable)  
        .equ RCC_APB1HENR_OPAMPEN, 1 << 4   @ bitWidth 1 (OPAMP peripheral clock  enable)  
        .equ RCC_APB1HENR_MDIOSEN, 1 << 5   @ bitWidth 1 (MDIOS peripheral clock  enable)  
        .equ RCC_APB1HENR_FDCANEN, 1 << 8   @ bitWidth 1 (FDCAN Peripheral Clocks  Enable)  
 
    .equ RCC_C1_APB1HENR, RCC_BASE + 0x14C @ (RCC APB1 Clock Register) 
        .equ RCC_C1_APB1HENR_CRSEN, 1 << 1   @ bitWidth 1 (Clock Recovery System peripheral clock  enable)  
        .equ RCC_C1_APB1HENR_SWPEN, 1 << 2   @ bitWidth 1 (SWPMI Peripheral Clocks  Enable)  
        .equ RCC_C1_APB1HENR_OPAMPEN, 1 << 4   @ bitWidth 1 (OPAMP peripheral clock  enable)  
        .equ RCC_C1_APB1HENR_MDIOSEN, 1 << 5   @ bitWidth 1 (MDIOS peripheral clock  enable)  
        .equ RCC_C1_APB1HENR_FDCANEN, 1 << 8   @ bitWidth 1 (FDCAN Peripheral Clocks  Enable)  
 
    .equ RCC_C1_APB2ENR, RCC_BASE + 0x150 @ (RCC APB2 Clock Register) 
        .equ RCC_C1_APB2ENR_TIM1EN, 1 << 0   @ bitWidth 1 (TIM1 peripheral clock  enable)  
        .equ RCC_C1_APB2ENR_TIM8EN, 1 << 1   @ bitWidth 1 (TIM8 peripheral clock  enable)  
        .equ RCC_C1_APB2ENR_USART1EN, 1 << 4   @ bitWidth 1 (USART1 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB2ENR_USART6EN, 1 << 5   @ bitWidth 1 (USART6 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB2ENR_SPI1EN, 1 << 12   @ bitWidth 1 (SPI1 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB2ENR_SPI4EN, 1 << 13   @ bitWidth 1 (SPI4 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB2ENR_TIM16EN, 1 << 17   @ bitWidth 1 (TIM16 peripheral clock  enable)  
        .equ RCC_C1_APB2ENR_TIM15EN, 1 << 16   @ bitWidth 1 (TIM15 peripheral clock  enable)  
        .equ RCC_C1_APB2ENR_TIM17EN, 1 << 18   @ bitWidth 1 (TIM17 peripheral clock  enable)  
        .equ RCC_C1_APB2ENR_SPI5EN, 1 << 20   @ bitWidth 1 (SPI5 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB2ENR_SAI1EN, 1 << 22   @ bitWidth 1 (SAI1 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB2ENR_SAI2EN, 1 << 23   @ bitWidth 1 (SAI2 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB2ENR_SAI3EN, 1 << 24   @ bitWidth 1 (SAI3 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB2ENR_DFSDM1EN, 1 << 28   @ bitWidth 1 (DFSDM1 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB2ENR_HRTIMEN, 1 << 29   @ bitWidth 1 (HRTIM peripheral clock  enable)  
 
    .equ RCC_APB2ENR, RCC_BASE + 0xF0 @ (RCC APB2 Clock Register) 
        .equ RCC_APB2ENR_TIM1EN, 1 << 0   @ bitWidth 1 (TIM1 peripheral clock  enable)  
        .equ RCC_APB2ENR_TIM8EN, 1 << 1   @ bitWidth 1 (TIM8 peripheral clock  enable)  
        .equ RCC_APB2ENR_USART1EN, 1 << 4   @ bitWidth 1 (USART1 Peripheral Clocks  Enable)  
        .equ RCC_APB2ENR_USART6EN, 1 << 5   @ bitWidth 1 (USART6 Peripheral Clocks  Enable)  
        .equ RCC_APB2ENR_SPI1EN, 1 << 12   @ bitWidth 1 (SPI1 Peripheral Clocks  Enable)  
        .equ RCC_APB2ENR_SPI4EN, 1 << 13   @ bitWidth 1 (SPI4 Peripheral Clocks  Enable)  
        .equ RCC_APB2ENR_TIM16EN, 1 << 17   @ bitWidth 1 (TIM16 peripheral clock  enable)  
        .equ RCC_APB2ENR_TIM15EN, 1 << 16   @ bitWidth 1 (TIM15 peripheral clock  enable)  
        .equ RCC_APB2ENR_TIM17EN, 1 << 18   @ bitWidth 1 (TIM17 peripheral clock  enable)  
        .equ RCC_APB2ENR_SPI5EN, 1 << 20   @ bitWidth 1 (SPI5 Peripheral Clocks  Enable)  
        .equ RCC_APB2ENR_SAI1EN, 1 << 22   @ bitWidth 1 (SAI1 Peripheral Clocks  Enable)  
        .equ RCC_APB2ENR_SAI2EN, 1 << 23   @ bitWidth 1 (SAI2 Peripheral Clocks  Enable)  
        .equ RCC_APB2ENR_SAI3EN, 1 << 24   @ bitWidth 1 (SAI3 Peripheral Clocks  Enable)  
        .equ RCC_APB2ENR_DFSDM1EN, 1 << 28   @ bitWidth 1 (DFSDM1 Peripheral Clocks  Enable)  
        .equ RCC_APB2ENR_HRTIMEN, 1 << 29   @ bitWidth 1 (HRTIM peripheral clock  enable)  
 
    .equ RCC_APB4ENR, RCC_BASE + 0xF4 @ (RCC APB4 Clock Register) 
        .equ RCC_APB4ENR_SYSCFGEN, 1 << 1   @ bitWidth 1 (SYSCFG peripheral clock  enable)  
        .equ RCC_APB4ENR_LPUART1EN, 1 << 3   @ bitWidth 1 (LPUART1 Peripheral Clocks  Enable)  
        .equ RCC_APB4ENR_SPI6EN, 1 << 5   @ bitWidth 1 (SPI6 Peripheral Clocks  Enable)  
        .equ RCC_APB4ENR_I2C4EN, 1 << 7   @ bitWidth 1 (I2C4 Peripheral Clocks  Enable)  
        .equ RCC_APB4ENR_LPTIM2EN, 1 << 9   @ bitWidth 1 (LPTIM2 Peripheral Clocks  Enable)  
        .equ RCC_APB4ENR_LPTIM3EN, 1 << 10   @ bitWidth 1 (LPTIM3 Peripheral Clocks  Enable)  
        .equ RCC_APB4ENR_LPTIM4EN, 1 << 11   @ bitWidth 1 (LPTIM4 Peripheral Clocks  Enable)  
        .equ RCC_APB4ENR_LPTIM5EN, 1 << 12   @ bitWidth 1 (LPTIM5 Peripheral Clocks  Enable)  
        .equ RCC_APB4ENR_COMP12EN, 1 << 14   @ bitWidth 1 (COMP1/2 peripheral clock  enable)  
        .equ RCC_APB4ENR_VREFEN, 1 << 15   @ bitWidth 1 (VREF peripheral clock  enable)  
        .equ RCC_APB4ENR_RTCAPBEN, 1 << 16   @ bitWidth 1 (RTC APB Clock Enable)  
        .equ RCC_APB4ENR_SAI4EN, 1 << 21   @ bitWidth 1 (SAI4 Peripheral Clocks  Enable)  
 
    .equ RCC_C1_APB4ENR, RCC_BASE + 0x154 @ (RCC APB4 Clock Register) 
        .equ RCC_C1_APB4ENR_SYSCFGEN, 1 << 1   @ bitWidth 1 (SYSCFG peripheral clock  enable)  
        .equ RCC_C1_APB4ENR_LPUART1EN, 1 << 3   @ bitWidth 1 (LPUART1 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB4ENR_SPI6EN, 1 << 5   @ bitWidth 1 (SPI6 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB4ENR_I2C4EN, 1 << 7   @ bitWidth 1 (I2C4 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB4ENR_LPTIM2EN, 1 << 9   @ bitWidth 1 (LPTIM2 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB4ENR_LPTIM3EN, 1 << 10   @ bitWidth 1 (LPTIM3 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB4ENR_LPTIM4EN, 1 << 11   @ bitWidth 1 (LPTIM4 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB4ENR_LPTIM5EN, 1 << 12   @ bitWidth 1 (LPTIM5 Peripheral Clocks  Enable)  
        .equ RCC_C1_APB4ENR_COMP12EN, 1 << 14   @ bitWidth 1 (COMP1/2 peripheral clock  enable)  
        .equ RCC_C1_APB4ENR_VREFEN, 1 << 15   @ bitWidth 1 (VREF peripheral clock  enable)  
        .equ RCC_C1_APB4ENR_RTCAPBEN, 1 << 16   @ bitWidth 1 (RTC APB Clock Enable)  
        .equ RCC_C1_APB4ENR_SAI4EN, 1 << 21   @ bitWidth 1 (SAI4 Peripheral Clocks  Enable)  
 
    .equ RCC_C1_AHB3LPENR, RCC_BASE + 0x15C @ (RCC AHB3 Sleep Clock Register) 
        .equ RCC_C1_AHB3LPENR_MDMALPEN, 1 << 0   @ bitWidth 1 (MDMA Clock Enable During CSleep  Mode)  
        .equ RCC_C1_AHB3LPENR_DMA2DLPEN, 1 << 4   @ bitWidth 1 (DMA2D Clock Enable During CSleep  Mode)  
        .equ RCC_C1_AHB3LPENR_JPGDECLPEN, 1 << 5   @ bitWidth 1 (JPGDEC Clock Enable During CSleep  Mode)  
        .equ RCC_C1_AHB3LPENR_FLITFLPEN, 1 << 8   @ bitWidth 1 (FLITF Clock Enable During CSleep  Mode)  
        .equ RCC_C1_AHB3LPENR_FMCLPEN, 1 << 12   @ bitWidth 1 (FMC Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_AHB3LPENR_QSPILPEN, 1 << 14   @ bitWidth 1 (QUADSPI and QUADSPI Delay Clock Enable  During CSleep Mode)  
        .equ RCC_C1_AHB3LPENR_SDMMC1LPEN, 1 << 16   @ bitWidth 1 (SDMMC1 and SDMMC1 Delay Clock Enable  During CSleep Mode)  
        .equ RCC_C1_AHB3LPENR_D1DTCM1LPEN, 1 << 28   @ bitWidth 1 (D1DTCM1 Block Clock Enable During CSleep  mode)  
        .equ RCC_C1_AHB3LPENR_DTCM2LPEN, 1 << 29   @ bitWidth 1 (D1 DTCM2 Block Clock Enable During  CSleep mode)  
        .equ RCC_C1_AHB3LPENR_ITCMLPEN, 1 << 30   @ bitWidth 1 (D1ITCM Block Clock Enable During CSleep  mode)  
        .equ RCC_C1_AHB3LPENR_AXISRAMLPEN, 1 << 31   @ bitWidth 1 (AXISRAM Block Clock Enable During CSleep  mode)  
 
    .equ RCC_AHB3LPENR, RCC_BASE + 0xFC @ (RCC AHB3 Sleep Clock Register) 
        .equ RCC_AHB3LPENR_MDMALPEN, 1 << 0   @ bitWidth 1 (MDMA Clock Enable During CSleep  Mode)  
        .equ RCC_AHB3LPENR_DMA2DLPEN, 1 << 4   @ bitWidth 1 (DMA2D Clock Enable During CSleep  Mode)  
        .equ RCC_AHB3LPENR_JPGDECLPEN, 1 << 5   @ bitWidth 1 (JPGDEC Clock Enable During CSleep  Mode)  
        .equ RCC_AHB3LPENR_FLASHLPEN, 1 << 8   @ bitWidth 1 (FLITF Clock Enable During CSleep  Mode)  
        .equ RCC_AHB3LPENR_FMCLPEN, 1 << 12   @ bitWidth 1 (FMC Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_AHB3LPENR_QSPILPEN, 1 << 14   @ bitWidth 1 (QUADSPI and QUADSPI Delay Clock Enable  During CSleep Mode)  
        .equ RCC_AHB3LPENR_SDMMC1LPEN, 1 << 16   @ bitWidth 1 (SDMMC1 and SDMMC1 Delay Clock Enable  During CSleep Mode)  
        .equ RCC_AHB3LPENR_D1DTCM1LPEN, 1 << 28   @ bitWidth 1 (D1DTCM1 Block Clock Enable During CSleep  mode)  
        .equ RCC_AHB3LPENR_DTCM2LPEN, 1 << 29   @ bitWidth 1 (D1 DTCM2 Block Clock Enable During  CSleep mode)  
        .equ RCC_AHB3LPENR_ITCMLPEN, 1 << 30   @ bitWidth 1 (D1ITCM Block Clock Enable During CSleep  mode)  
        .equ RCC_AHB3LPENR_AXISRAMLPEN, 1 << 31   @ bitWidth 1 (AXISRAM Block Clock Enable During CSleep  mode)  
 
    .equ RCC_AHB1LPENR, RCC_BASE + 0x100 @ (RCC AHB1 Sleep Clock Register) 
        .equ RCC_AHB1LPENR_DMA1LPEN, 1 << 0   @ bitWidth 1 (DMA1 Clock Enable During CSleep  Mode)  
        .equ RCC_AHB1LPENR_DMA2LPEN, 1 << 1   @ bitWidth 1 (DMA2 Clock Enable During CSleep  Mode)  
        .equ RCC_AHB1LPENR_ADC12LPEN, 1 << 5   @ bitWidth 1 (ADC1/2 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_AHB1LPENR_ETH1MACLPEN, 1 << 15   @ bitWidth 1 (Ethernet MAC bus interface Clock Enable  During CSleep Mode)  
        .equ RCC_AHB1LPENR_ETH1TXLPEN, 1 << 16   @ bitWidth 1 (Ethernet Transmission Clock Enable  During CSleep Mode)  
        .equ RCC_AHB1LPENR_ETH1RXLPEN, 1 << 17   @ bitWidth 1 (Ethernet Reception Clock Enable During  CSleep Mode)  
        .equ RCC_AHB1LPENR_USB1OTGHSLPEN, 1 << 25   @ bitWidth 1 (USB1OTG peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB1LPENR_USB1OTGHSULPILPEN, 1 << 26   @ bitWidth 1 (USB_PHY1 clock enable during CSleep  mode)  
        .equ RCC_AHB1LPENR_USB2OTGHSLPEN, 1 << 27   @ bitWidth 1 (USB2OTG peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB1LPENR_USB2OTGHSULPILPEN, 1 << 28   @ bitWidth 1 (USB_PHY2 clocks enable during CSleep  mode)  
 
    .equ RCC_C1_AHB1LPENR, RCC_BASE + 0x160 @ (RCC AHB1 Sleep Clock Register) 
        .equ RCC_C1_AHB1LPENR_DMA1LPEN, 1 << 0   @ bitWidth 1 (DMA1 Clock Enable During CSleep  Mode)  
        .equ RCC_C1_AHB1LPENR_DMA2LPEN, 1 << 1   @ bitWidth 1 (DMA2 Clock Enable During CSleep  Mode)  
        .equ RCC_C1_AHB1LPENR_ADC12LPEN, 1 << 5   @ bitWidth 1 (ADC1/2 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_AHB1LPENR_ETH1MACLPEN, 1 << 15   @ bitWidth 1 (Ethernet MAC bus interface Clock Enable  During CSleep Mode)  
        .equ RCC_C1_AHB1LPENR_ETH1TXLPEN, 1 << 16   @ bitWidth 1 (Ethernet Transmission Clock Enable  During CSleep Mode)  
        .equ RCC_C1_AHB1LPENR_ETH1RXLPEN, 1 << 17   @ bitWidth 1 (Ethernet Reception Clock Enable During  CSleep Mode)  
        .equ RCC_C1_AHB1LPENR_USB1OTGLPEN, 1 << 25   @ bitWidth 1 (USB1OTG peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB1LPENR_USB1ULPILPEN, 1 << 26   @ bitWidth 1 (USB_PHY1 clock enable during CSleep  mode)  
        .equ RCC_C1_AHB1LPENR_USB2OTGLPEN, 1 << 27   @ bitWidth 1 (USB2OTG peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB1LPENR_USB2ULPILPEN, 1 << 28   @ bitWidth 1 (USB_PHY2 clocks enable during CSleep  mode)  
 
    .equ RCC_C1_AHB2LPENR, RCC_BASE + 0x164 @ (RCC AHB2 Sleep Clock Register) 
        .equ RCC_C1_AHB2LPENR_CAMITFLPEN, 1 << 0   @ bitWidth 1 (CAMITF peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB2LPENR_CRYPTLPEN, 1 << 4   @ bitWidth 1 (CRYPT peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB2LPENR_HASHLPEN, 1 << 5   @ bitWidth 1 (HASH peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB2LPENR_SDMMC2LPEN, 1 << 9   @ bitWidth 1 (SDMMC2 and SDMMC2 Delay Clock Enable  During CSleep Mode)  
        .equ RCC_C1_AHB2LPENR_RNGLPEN, 1 << 6   @ bitWidth 1 (RNG peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB2LPENR_SRAM1LPEN, 1 << 29   @ bitWidth 1 (SRAM1 Clock Enable During CSleep  Mode)  
        .equ RCC_C1_AHB2LPENR_SRAM2LPEN, 1 << 30   @ bitWidth 1 (SRAM2 Clock Enable During CSleep  Mode)  
        .equ RCC_C1_AHB2LPENR_SRAM3LPEN, 1 << 31   @ bitWidth 1 (SRAM3 Clock Enable During CSleep  Mode)  
 
    .equ RCC_AHB2LPENR, RCC_BASE + 0x104 @ (RCC AHB2 Sleep Clock Register) 
        .equ RCC_AHB2LPENR_CAMITFLPEN, 1 << 0   @ bitWidth 1 (CAMITF peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB2LPENR_CRYPTLPEN, 1 << 4   @ bitWidth 1 (CRYPT peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB2LPENR_HASHLPEN, 1 << 5   @ bitWidth 1 (HASH peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB2LPENR_SDMMC2LPEN, 1 << 9   @ bitWidth 1 (SDMMC2 and SDMMC2 Delay Clock Enable  During CSleep Mode)  
        .equ RCC_AHB2LPENR_RNGLPEN, 1 << 6   @ bitWidth 1 (RNG peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB2LPENR_SRAM1LPEN, 1 << 29   @ bitWidth 1 (SRAM1 Clock Enable During CSleep  Mode)  
        .equ RCC_AHB2LPENR_SRAM2LPEN, 1 << 30   @ bitWidth 1 (SRAM2 Clock Enable During CSleep  Mode)  
        .equ RCC_AHB2LPENR_SRAM3LPEN, 1 << 31   @ bitWidth 1 (SRAM3 Clock Enable During CSleep  Mode)  
 
    .equ RCC_AHB4LPENR, RCC_BASE + 0x108 @ (RCC AHB4 Sleep Clock Register) 
        .equ RCC_AHB4LPENR_GPIOALPEN, 1 << 0   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB4LPENR_GPIOBLPEN, 1 << 1   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB4LPENR_GPIOCLPEN, 1 << 2   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB4LPENR_GPIODLPEN, 1 << 3   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB4LPENR_GPIOELPEN, 1 << 4   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB4LPENR_GPIOFLPEN, 1 << 5   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB4LPENR_GPIOGLPEN, 1 << 6   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB4LPENR_GPIOHLPEN, 1 << 7   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB4LPENR_GPIOILPEN, 1 << 8   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB4LPENR_GPIOJLPEN, 1 << 9   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB4LPENR_GPIOKLPEN, 1 << 10   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB4LPENR_CRCLPEN, 1 << 19   @ bitWidth 1 (CRC peripheral clock enable during  CSleep mode)  
        .equ RCC_AHB4LPENR_BDMALPEN, 1 << 21   @ bitWidth 1 (BDMA Clock Enable During CSleep  Mode)  
        .equ RCC_AHB4LPENR_ADC3LPEN, 1 << 24   @ bitWidth 1 (ADC3 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_AHB4LPENR_BKPRAMLPEN, 1 << 28   @ bitWidth 1 (Backup RAM Clock Enable During CSleep  Mode)  
        .equ RCC_AHB4LPENR_SRAM4LPEN, 1 << 29   @ bitWidth 1 (SRAM4 Clock Enable During CSleep  Mode)  
 
    .equ RCC_C1_AHB4LPENR, RCC_BASE + 0x168 @ (RCC AHB4 Sleep Clock Register) 
        .equ RCC_C1_AHB4LPENR_GPIOALPEN, 1 << 0   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB4LPENR_GPIOBLPEN, 1 << 1   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB4LPENR_GPIOCLPEN, 1 << 2   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB4LPENR_GPIODLPEN, 1 << 3   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB4LPENR_GPIOELPEN, 1 << 4   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB4LPENR_GPIOFLPEN, 1 << 5   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB4LPENR_GPIOGLPEN, 1 << 6   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB4LPENR_GPIOHLPEN, 1 << 7   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB4LPENR_GPIOILPEN, 1 << 8   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB4LPENR_GPIOJLPEN, 1 << 9   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB4LPENR_GPIOKLPEN, 1 << 10   @ bitWidth 1 (GPIO peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB4LPENR_CRCLPEN, 1 << 19   @ bitWidth 1 (CRC peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_AHB4LPENR_BDMALPEN, 1 << 21   @ bitWidth 1 (BDMA Clock Enable During CSleep  Mode)  
        .equ RCC_C1_AHB4LPENR_ADC3LPEN, 1 << 24   @ bitWidth 1 (ADC3 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_AHB4LPENR_BKPRAMLPEN, 1 << 28   @ bitWidth 1 (Backup RAM Clock Enable During CSleep  Mode)  
        .equ RCC_C1_AHB4LPENR_SRAM4LPEN, 1 << 29   @ bitWidth 1 (SRAM4 Clock Enable During CSleep  Mode)  
 
    .equ RCC_C1_APB3LPENR, RCC_BASE + 0x16C @ (RCC APB3 Sleep Clock Register) 
        .equ RCC_C1_APB3LPENR_LTDCLPEN, 1 << 3   @ bitWidth 1 (LTDC peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB3LPENR_WWDG1LPEN, 1 << 6   @ bitWidth 1 (WWDG1 Clock Enable During CSleep  Mode)  
 
    .equ RCC_APB3LPENR, RCC_BASE + 0x10C @ (RCC APB3 Sleep Clock Register) 
        .equ RCC_APB3LPENR_LTDCLPEN, 1 << 3   @ bitWidth 1 (LTDC peripheral clock enable during  CSleep mode)  
        .equ RCC_APB3LPENR_WWDG1LPEN, 1 << 6   @ bitWidth 1 (WWDG1 Clock Enable During CSleep  Mode)  
 
    .equ RCC_APB1LLPENR, RCC_BASE + 0x110 @ (RCC APB1 Low Sleep Clock  Register) 
        .equ RCC_APB1LLPENR_TIM2LPEN, 1 << 0   @ bitWidth 1 (TIM2 peripheral clock enable during  CSleep mode)  
        .equ RCC_APB1LLPENR_TIM3LPEN, 1 << 1   @ bitWidth 1 (TIM3 peripheral clock enable during  CSleep mode)  
        .equ RCC_APB1LLPENR_TIM4LPEN, 1 << 2   @ bitWidth 1 (TIM4 peripheral clock enable during  CSleep mode)  
        .equ RCC_APB1LLPENR_TIM5LPEN, 1 << 3   @ bitWidth 1 (TIM5 peripheral clock enable during  CSleep mode)  
        .equ RCC_APB1LLPENR_TIM6LPEN, 1 << 4   @ bitWidth 1 (TIM6 peripheral clock enable during  CSleep mode)  
        .equ RCC_APB1LLPENR_TIM7LPEN, 1 << 5   @ bitWidth 1 (TIM7 peripheral clock enable during  CSleep mode)  
        .equ RCC_APB1LLPENR_TIM12LPEN, 1 << 6   @ bitWidth 1 (TIM12 peripheral clock enable during  CSleep mode)  
        .equ RCC_APB1LLPENR_TIM13LPEN, 1 << 7   @ bitWidth 1 (TIM13 peripheral clock enable during  CSleep mode)  
        .equ RCC_APB1LLPENR_TIM14LPEN, 1 << 8   @ bitWidth 1 (TIM14 peripheral clock enable during  CSleep mode)  
        .equ RCC_APB1LLPENR_LPTIM1LPEN, 1 << 9   @ bitWidth 1 (LPTIM1 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB1LLPENR_SPI2LPEN, 1 << 14   @ bitWidth 1 (SPI2 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB1LLPENR_SPI3LPEN, 1 << 15   @ bitWidth 1 (SPI3 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB1LLPENR_SPDIFRXLPEN, 1 << 16   @ bitWidth 1 (SPDIFRX Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB1LLPENR_USART2LPEN, 1 << 17   @ bitWidth 1 (USART2 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB1LLPENR_USART3LPEN, 1 << 18   @ bitWidth 1 (USART3 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB1LLPENR_UART4LPEN, 1 << 19   @ bitWidth 1 (UART4 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB1LLPENR_UART5LPEN, 1 << 20   @ bitWidth 1 (UART5 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB1LLPENR_I2C1LPEN, 1 << 21   @ bitWidth 1 (I2C1 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB1LLPENR_I2C2LPEN, 1 << 22   @ bitWidth 1 (I2C2 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB1LLPENR_I2C3LPEN, 1 << 23   @ bitWidth 1 (I2C3 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB1LLPENR_HDMICECLPEN, 1 << 27   @ bitWidth 1 (HDMI-CEC Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB1LLPENR_DAC12LPEN, 1 << 29   @ bitWidth 1 (DAC1/2 peripheral clock enable during  CSleep mode)  
        .equ RCC_APB1LLPENR_USART7LPEN, 1 << 30   @ bitWidth 1 (USART7 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB1LLPENR_USART8LPEN, 1 << 31   @ bitWidth 1 (USART8 Peripheral Clocks Enable During  CSleep Mode)  
 
    .equ RCC_C1_APB1LLPENR, RCC_BASE + 0x170 @ (RCC APB1 Low Sleep Clock  Register) 
        .equ RCC_C1_APB1LLPENR_TIM2LPEN, 1 << 0   @ bitWidth 1 (TIM2 peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB1LLPENR_TIM3LPEN, 1 << 1   @ bitWidth 1 (TIM3 peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB1LLPENR_TIM4LPEN, 1 << 2   @ bitWidth 1 (TIM4 peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB1LLPENR_TIM5LPEN, 1 << 3   @ bitWidth 1 (TIM5 peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB1LLPENR_TIM6LPEN, 1 << 4   @ bitWidth 1 (TIM6 peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB1LLPENR_TIM7LPEN, 1 << 5   @ bitWidth 1 (TIM7 peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB1LLPENR_TIM12LPEN, 1 << 6   @ bitWidth 1 (TIM12 peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB1LLPENR_TIM13LPEN, 1 << 7   @ bitWidth 1 (TIM13 peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB1LLPENR_TIM14LPEN, 1 << 8   @ bitWidth 1 (TIM14 peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB1LLPENR_LPTIM1LPEN, 1 << 9   @ bitWidth 1 (LPTIM1 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB1LLPENR_SPI2LPEN, 1 << 14   @ bitWidth 1 (SPI2 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB1LLPENR_SPI3LPEN, 1 << 15   @ bitWidth 1 (SPI3 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB1LLPENR_SPDIFRXLPEN, 1 << 16   @ bitWidth 1 (SPDIFRX Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB1LLPENR_USART2LPEN, 1 << 17   @ bitWidth 1 (USART2 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB1LLPENR_USART3LPEN, 1 << 18   @ bitWidth 1 (USART3 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB1LLPENR_UART4LPEN, 1 << 19   @ bitWidth 1 (UART4 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB1LLPENR_UART5LPEN, 1 << 20   @ bitWidth 1 (UART5 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB1LLPENR_I2C1LPEN, 1 << 21   @ bitWidth 1 (I2C1 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB1LLPENR_I2C2LPEN, 1 << 22   @ bitWidth 1 (I2C2 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB1LLPENR_I2C3LPEN, 1 << 23   @ bitWidth 1 (I2C3 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB1LLPENR_HDMICECLPEN, 1 << 27   @ bitWidth 1 (HDMI-CEC Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB1LLPENR_DAC12LPEN, 1 << 29   @ bitWidth 1 (DAC1/2 peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB1LLPENR_USART7LPEN, 1 << 30   @ bitWidth 1 (USART7 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB1LLPENR_USART8LPEN, 1 << 31   @ bitWidth 1 (USART8 Peripheral Clocks Enable During  CSleep Mode)  
 
    .equ RCC_C1_APB1HLPENR, RCC_BASE + 0x174 @ (RCC APB1 High Sleep Clock  Register) 
        .equ RCC_C1_APB1HLPENR_CRSLPEN, 1 << 1   @ bitWidth 1 (Clock Recovery System peripheral clock  enable during CSleep mode)  
        .equ RCC_C1_APB1HLPENR_SWPLPEN, 1 << 2   @ bitWidth 1 (SWPMI Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB1HLPENR_OPAMPLPEN, 1 << 4   @ bitWidth 1 (OPAMP peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB1HLPENR_MDIOSLPEN, 1 << 5   @ bitWidth 1 (MDIOS peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB1HLPENR_FDCANLPEN, 1 << 8   @ bitWidth 1 (FDCAN Peripheral Clocks Enable During  CSleep Mode)  
 
    .equ RCC_APB1HLPENR, RCC_BASE + 0x114 @ (RCC APB1 High Sleep Clock  Register) 
        .equ RCC_APB1HLPENR_CRSLPEN, 1 << 1   @ bitWidth 1 (Clock Recovery System peripheral clock  enable during CSleep mode)  
        .equ RCC_APB1HLPENR_SWPLPEN, 1 << 2   @ bitWidth 1 (SWPMI Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB1HLPENR_OPAMPLPEN, 1 << 4   @ bitWidth 1 (OPAMP peripheral clock enable during  CSleep mode)  
        .equ RCC_APB1HLPENR_MDIOSLPEN, 1 << 5   @ bitWidth 1 (MDIOS peripheral clock enable during  CSleep mode)  
        .equ RCC_APB1HLPENR_FDCANLPEN, 1 << 8   @ bitWidth 1 (FDCAN Peripheral Clocks Enable During  CSleep Mode)  
 
    .equ RCC_APB2LPENR, RCC_BASE + 0x118 @ (RCC APB2 Sleep Clock Register) 
        .equ RCC_APB2LPENR_TIM1LPEN, 1 << 0   @ bitWidth 1 (TIM1 peripheral clock enable during  CSleep mode)  
        .equ RCC_APB2LPENR_TIM8LPEN, 1 << 1   @ bitWidth 1 (TIM8 peripheral clock enable during  CSleep mode)  
        .equ RCC_APB2LPENR_USART1LPEN, 1 << 4   @ bitWidth 1 (USART1 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB2LPENR_USART6LPEN, 1 << 5   @ bitWidth 1 (USART6 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB2LPENR_SPI1LPEN, 1 << 12   @ bitWidth 1 (SPI1 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB2LPENR_SPI4LPEN, 1 << 13   @ bitWidth 1 (SPI4 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB2LPENR_TIM15LPEN, 1 << 16   @ bitWidth 1 (TIM15 peripheral clock enable during  CSleep mode)  
        .equ RCC_APB2LPENR_TIM16LPEN, 1 << 17   @ bitWidth 1 (TIM16 peripheral clock enable during  CSleep mode)  
        .equ RCC_APB2LPENR_TIM17LPEN, 1 << 18   @ bitWidth 1 (TIM17 peripheral clock enable during  CSleep mode)  
        .equ RCC_APB2LPENR_SPI5LPEN, 1 << 20   @ bitWidth 1 (SPI5 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB2LPENR_SAI1LPEN, 1 << 22   @ bitWidth 1 (SAI1 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB2LPENR_SAI2LPEN, 1 << 23   @ bitWidth 1 (SAI2 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB2LPENR_SAI3LPEN, 1 << 24   @ bitWidth 1 (SAI3 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB2LPENR_DFSDM1LPEN, 1 << 28   @ bitWidth 1 (DFSDM1 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB2LPENR_HRTIMLPEN, 1 << 29   @ bitWidth 1 (HRTIM peripheral clock enable during  CSleep mode)  
 
    .equ RCC_C1_APB2LPENR, RCC_BASE + 0x178 @ (RCC APB2 Sleep Clock Register) 
        .equ RCC_C1_APB2LPENR_TIM1LPEN, 1 << 0   @ bitWidth 1 (TIM1 peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB2LPENR_TIM8LPEN, 1 << 1   @ bitWidth 1 (TIM8 peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB2LPENR_USART1LPEN, 1 << 4   @ bitWidth 1 (USART1 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB2LPENR_USART6LPEN, 1 << 5   @ bitWidth 1 (USART6 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB2LPENR_SPI1LPEN, 1 << 12   @ bitWidth 1 (SPI1 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB2LPENR_SPI4LPEN, 1 << 13   @ bitWidth 1 (SPI4 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB2LPENR_TIM15LPEN, 1 << 16   @ bitWidth 1 (TIM15 peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB2LPENR_TIM16LPEN, 1 << 17   @ bitWidth 1 (TIM16 peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB2LPENR_TIM17LPEN, 1 << 18   @ bitWidth 1 (TIM17 peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB2LPENR_SPI5LPEN, 1 << 20   @ bitWidth 1 (SPI5 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB2LPENR_SAI1LPEN, 1 << 22   @ bitWidth 1 (SAI1 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB2LPENR_SAI2LPEN, 1 << 23   @ bitWidth 1 (SAI2 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB2LPENR_SAI3LPEN, 1 << 24   @ bitWidth 1 (SAI3 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB2LPENR_DFSDM1LPEN, 1 << 28   @ bitWidth 1 (DFSDM1 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB2LPENR_HRTIMLPEN, 1 << 29   @ bitWidth 1 (HRTIM peripheral clock enable during  CSleep mode)  
 
    .equ RCC_C1_APB4LPENR, RCC_BASE + 0x17C @ (RCC APB4 Sleep Clock Register) 
        .equ RCC_C1_APB4LPENR_SYSCFGLPEN, 1 << 1   @ bitWidth 1 (SYSCFG peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB4LPENR_LPUART1LPEN, 1 << 3   @ bitWidth 1 (LPUART1 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB4LPENR_SPI6LPEN, 1 << 5   @ bitWidth 1 (SPI6 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB4LPENR_I2C4LPEN, 1 << 7   @ bitWidth 1 (I2C4 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB4LPENR_LPTIM2LPEN, 1 << 9   @ bitWidth 1 (LPTIM2 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB4LPENR_LPTIM3LPEN, 1 << 10   @ bitWidth 1 (LPTIM3 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB4LPENR_LPTIM4LPEN, 1 << 11   @ bitWidth 1 (LPTIM4 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB4LPENR_LPTIM5LPEN, 1 << 12   @ bitWidth 1 (LPTIM5 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_C1_APB4LPENR_COMP12LPEN, 1 << 14   @ bitWidth 1 (COMP1/2 peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB4LPENR_VREFLPEN, 1 << 15   @ bitWidth 1 (VREF peripheral clock enable during  CSleep mode)  
        .equ RCC_C1_APB4LPENR_RTCAPBLPEN, 1 << 16   @ bitWidth 1 (RTC APB Clock Enable During CSleep  Mode)  
        .equ RCC_C1_APB4LPENR_SAI4LPEN, 1 << 21   @ bitWidth 1 (SAI4 Peripheral Clocks Enable During  CSleep Mode)  
 
    .equ RCC_APB4LPENR, RCC_BASE + 0x11C @ (RCC APB4 Sleep Clock Register) 
        .equ RCC_APB4LPENR_SYSCFGLPEN, 1 << 1   @ bitWidth 1 (SYSCFG peripheral clock enable during  CSleep mode)  
        .equ RCC_APB4LPENR_LPUART1LPEN, 1 << 3   @ bitWidth 1 (LPUART1 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB4LPENR_SPI6LPEN, 1 << 5   @ bitWidth 1 (SPI6 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB4LPENR_I2C4LPEN, 1 << 7   @ bitWidth 1 (I2C4 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB4LPENR_LPTIM2LPEN, 1 << 9   @ bitWidth 1 (LPTIM2 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB4LPENR_LPTIM3LPEN, 1 << 10   @ bitWidth 1 (LPTIM3 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB4LPENR_LPTIM4LPEN, 1 << 11   @ bitWidth 1 (LPTIM4 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB4LPENR_LPTIM5LPEN, 1 << 12   @ bitWidth 1 (LPTIM5 Peripheral Clocks Enable During  CSleep Mode)  
        .equ RCC_APB4LPENR_COMP12LPEN, 1 << 14   @ bitWidth 1 (COMP1/2 peripheral clock enable during  CSleep mode)  
        .equ RCC_APB4LPENR_VREFLPEN, 1 << 15   @ bitWidth 1 (VREF peripheral clock enable during  CSleep mode)  
        .equ RCC_APB4LPENR_RTCAPBLPEN, 1 << 16   @ bitWidth 1 (RTC APB Clock Enable During CSleep  Mode)  
        .equ RCC_APB4LPENR_SAI4LPEN, 1 << 21   @ bitWidth 1 (SAI4 Peripheral Clocks Enable During  CSleep Mode)  
 

@=========================== LPTIM1 ===========================@
.equ LPTIM1_BASE, 0x40002400 @ (Low power timer) 
    .equ LPTIM1_ISR, LPTIM1_BASE + 0x0 @ (Interrupt and Status Register) 
        .equ LPTIM1_ISR_DOWN, 1 << 6   @ bitWidth 1 (Counter direction change up to  down)  
        .equ LPTIM1_ISR_UP, 1 << 5   @ bitWidth 1 (Counter direction change down to  up)  
        .equ LPTIM1_ISR_ARROK, 1 << 4   @ bitWidth 1 (Autoreload register update  OK)  
        .equ LPTIM1_ISR_CMPOK, 1 << 3   @ bitWidth 1 (Compare register update OK)  
        .equ LPTIM1_ISR_EXTTRIG, 1 << 2   @ bitWidth 1 (External trigger edge  event)  
        .equ LPTIM1_ISR_ARRM, 1 << 1   @ bitWidth 1 (Autoreload match)  
        .equ LPTIM1_ISR_CMPM, 1 << 0   @ bitWidth 1 (Compare match)  
 
    .equ LPTIM1_ICR, LPTIM1_BASE + 0x4 @ (Interrupt Clear Register) 
        .equ LPTIM1_ICR_DOWNCF, 1 << 6   @ bitWidth 1 (Direction change to down Clear  Flag)  
        .equ LPTIM1_ICR_UPCF, 1 << 5   @ bitWidth 1 (Direction change to UP Clear  Flag)  
        .equ LPTIM1_ICR_ARROKCF, 1 << 4   @ bitWidth 1 (Autoreload register update OK Clear  Flag)  
        .equ LPTIM1_ICR_CMPOKCF, 1 << 3   @ bitWidth 1 (Compare register update OK Clear  Flag)  
        .equ LPTIM1_ICR_EXTTRIGCF, 1 << 2   @ bitWidth 1 (External trigger valid edge Clear  Flag)  
        .equ LPTIM1_ICR_ARRMCF, 1 << 1   @ bitWidth 1 (Autoreload match Clear  Flag)  
        .equ LPTIM1_ICR_CMPMCF, 1 << 0   @ bitWidth 1 (compare match Clear Flag)  
 
    .equ LPTIM1_IER, LPTIM1_BASE + 0x8 @ (Interrupt Enable Register) 
        .equ LPTIM1_IER_DOWNIE, 1 << 6   @ bitWidth 1 (Direction change to down Interrupt  Enable)  
        .equ LPTIM1_IER_UPIE, 1 << 5   @ bitWidth 1 (Direction change to UP Interrupt  Enable)  
        .equ LPTIM1_IER_ARROKIE, 1 << 4   @ bitWidth 1 (Autoreload register update OK Interrupt  Enable)  
        .equ LPTIM1_IER_CMPOKIE, 1 << 3   @ bitWidth 1 (Compare register update OK Interrupt  Enable)  
        .equ LPTIM1_IER_EXTTRIGIE, 1 << 2   @ bitWidth 1 (External trigger valid edge Interrupt  Enable)  
        .equ LPTIM1_IER_ARRMIE, 1 << 1   @ bitWidth 1 (Autoreload match Interrupt  Enable)  
        .equ LPTIM1_IER_CMPMIE, 1 << 0   @ bitWidth 1 (Compare match Interrupt  Enable)  
 
    .equ LPTIM1_CFGR, LPTIM1_BASE + 0xC @ (Configuration Register) 
        .equ LPTIM1_CFGR_ENC, 1 << 24   @ bitWidth 1 (Encoder mode enable)  
        .equ LPTIM1_CFGR_COUNTMODE, 1 << 23   @ bitWidth 1 (counter mode enabled)  
        .equ LPTIM1_CFGR_PRELOAD, 1 << 22   @ bitWidth 1 (Registers update mode)  
        .equ LPTIM1_CFGR_WAVPOL, 1 << 21   @ bitWidth 1 (Waveform shape polarity)  
        .equ LPTIM1_CFGR_WAVE, 1 << 20   @ bitWidth 1 (Waveform shape)  
        .equ LPTIM1_CFGR_TIMOUT, 1 << 19   @ bitWidth 1 (Timeout enable)  
        .equ LPTIM1_CFGR_TRIGEN_Shift, 17   @ bitWidth 2 (Trigger enable and  polarity)  
        .equ LPTIM1_CFGR_TRIGSEL_Shift, 13   @ bitWidth 3 (Trigger selector)  
        .equ LPTIM1_CFGR_PRESC_Shift, 9   @ bitWidth 3 (Clock prescaler)  
        .equ LPTIM1_CFGR_TRGFLT_Shift, 6   @ bitWidth 2 (Configurable digital filter for  trigger)  
        .equ LPTIM1_CFGR_CKFLT_Shift, 3   @ bitWidth 2 (Configurable digital filter for external  clock)  
        .equ LPTIM1_CFGR_CKPOL_Shift, 1   @ bitWidth 2 (Clock Polarity)  
        .equ LPTIM1_CFGR_CKSEL, 1 << 0   @ bitWidth 1 (Clock selector)  
 
    .equ LPTIM1_CR, LPTIM1_BASE + 0x10 @ (Control Register) 
        .equ LPTIM1_CR_ENABLE, 1 << 0   @ bitWidth 1 (LPTIM Enable)  
        .equ LPTIM1_CR_SNGSTRT, 1 << 1   @ bitWidth 1 (LPTIM start in single mode)  
        .equ LPTIM1_CR_CNTSTRT, 1 << 2   @ bitWidth 1 (Timer start in continuous  mode)  
        .equ LPTIM1_CR_COUNTRST, 1 << 3   @ bitWidth 1 (Counter reset)  
        .equ LPTIM1_CR_RSTARE, 1 << 4   @ bitWidth 1 (Reset after read enable)  
 
    .equ LPTIM1_CMP, LPTIM1_BASE + 0x14 @ (Compare Register) 
        .equ LPTIM1_CMP_CMP_Shift, 0   @ bitWidth 16 (Compare value)  
 
    .equ LPTIM1_ARR, LPTIM1_BASE + 0x18 @ (Autoreload Register) 
        .equ LPTIM1_ARR_ARR_Shift, 0   @ bitWidth 16 (Auto reload value)  
 
    .equ LPTIM1_CNT, LPTIM1_BASE + 0x1C @ (Counter Register) 
        .equ LPTIM1_CNT_CNT_Shift, 0   @ bitWidth 16 (Counter value)  
 
    .equ LPTIM1_CFGR2, LPTIM1_BASE + 0x24 @ (LPTIM configuration register 2) 
        .equ LPTIM1_CFGR2_IN1SEL_Shift, 0   @ bitWidth 2 (LPTIM Input 1 selection)  
        .equ LPTIM1_CFGR2_IN2SEL_Shift, 4   @ bitWidth 2 (LPTIM Input 2 selection)  
 

@=========================== LPTIM2 ===========================@
.equ LPTIM2_BASE, 0x58002400 @ (Low power timer) 
    .equ LPTIM2_ISR, LPTIM2_BASE + 0x0 @ (Interrupt and Status Register) 
        .equ LPTIM2_ISR_DOWN, 1 << 6   @ bitWidth 1 (Counter direction change up to  down)  
        .equ LPTIM2_ISR_UP, 1 << 5   @ bitWidth 1 (Counter direction change down to  up)  
        .equ LPTIM2_ISR_ARROK, 1 << 4   @ bitWidth 1 (Autoreload register update  OK)  
        .equ LPTIM2_ISR_CMPOK, 1 << 3   @ bitWidth 1 (Compare register update OK)  
        .equ LPTIM2_ISR_EXTTRIG, 1 << 2   @ bitWidth 1 (External trigger edge  event)  
        .equ LPTIM2_ISR_ARRM, 1 << 1   @ bitWidth 1 (Autoreload match)  
        .equ LPTIM2_ISR_CMPM, 1 << 0   @ bitWidth 1 (Compare match)  
 
    .equ LPTIM2_ICR, LPTIM2_BASE + 0x4 @ (Interrupt Clear Register) 
        .equ LPTIM2_ICR_DOWNCF, 1 << 6   @ bitWidth 1 (Direction change to down Clear  Flag)  
        .equ LPTIM2_ICR_UPCF, 1 << 5   @ bitWidth 1 (Direction change to UP Clear  Flag)  
        .equ LPTIM2_ICR_ARROKCF, 1 << 4   @ bitWidth 1 (Autoreload register update OK Clear  Flag)  
        .equ LPTIM2_ICR_CMPOKCF, 1 << 3   @ bitWidth 1 (Compare register update OK Clear  Flag)  
        .equ LPTIM2_ICR_EXTTRIGCF, 1 << 2   @ bitWidth 1 (External trigger valid edge Clear  Flag)  
        .equ LPTIM2_ICR_ARRMCF, 1 << 1   @ bitWidth 1 (Autoreload match Clear  Flag)  
        .equ LPTIM2_ICR_CMPMCF, 1 << 0   @ bitWidth 1 (compare match Clear Flag)  
 
    .equ LPTIM2_IER, LPTIM2_BASE + 0x8 @ (Interrupt Enable Register) 
        .equ LPTIM2_IER_DOWNIE, 1 << 6   @ bitWidth 1 (Direction change to down Interrupt  Enable)  
        .equ LPTIM2_IER_UPIE, 1 << 5   @ bitWidth 1 (Direction change to UP Interrupt  Enable)  
        .equ LPTIM2_IER_ARROKIE, 1 << 4   @ bitWidth 1 (Autoreload register update OK Interrupt  Enable)  
        .equ LPTIM2_IER_CMPOKIE, 1 << 3   @ bitWidth 1 (Compare register update OK Interrupt  Enable)  
        .equ LPTIM2_IER_EXTTRIGIE, 1 << 2   @ bitWidth 1 (External trigger valid edge Interrupt  Enable)  
        .equ LPTIM2_IER_ARRMIE, 1 << 1   @ bitWidth 1 (Autoreload match Interrupt  Enable)  
        .equ LPTIM2_IER_CMPMIE, 1 << 0   @ bitWidth 1 (Compare match Interrupt  Enable)  
 
    .equ LPTIM2_CFGR, LPTIM2_BASE + 0xC @ (Configuration Register) 
        .equ LPTIM2_CFGR_ENC, 1 << 24   @ bitWidth 1 (Encoder mode enable)  
        .equ LPTIM2_CFGR_COUNTMODE, 1 << 23   @ bitWidth 1 (counter mode enabled)  
        .equ LPTIM2_CFGR_PRELOAD, 1 << 22   @ bitWidth 1 (Registers update mode)  
        .equ LPTIM2_CFGR_WAVPOL, 1 << 21   @ bitWidth 1 (Waveform shape polarity)  
        .equ LPTIM2_CFGR_WAVE, 1 << 20   @ bitWidth 1 (Waveform shape)  
        .equ LPTIM2_CFGR_TIMOUT, 1 << 19   @ bitWidth 1 (Timeout enable)  
        .equ LPTIM2_CFGR_TRIGEN_Shift, 17   @ bitWidth 2 (Trigger enable and  polarity)  
        .equ LPTIM2_CFGR_TRIGSEL_Shift, 13   @ bitWidth 3 (Trigger selector)  
        .equ LPTIM2_CFGR_PRESC_Shift, 9   @ bitWidth 3 (Clock prescaler)  
        .equ LPTIM2_CFGR_TRGFLT_Shift, 6   @ bitWidth 2 (Configurable digital filter for  trigger)  
        .equ LPTIM2_CFGR_CKFLT_Shift, 3   @ bitWidth 2 (Configurable digital filter for external  clock)  
        .equ LPTIM2_CFGR_CKPOL_Shift, 1   @ bitWidth 2 (Clock Polarity)  
        .equ LPTIM2_CFGR_CKSEL, 1 << 0   @ bitWidth 1 (Clock selector)  
 
    .equ LPTIM2_CR, LPTIM2_BASE + 0x10 @ (Control Register) 
        .equ LPTIM2_CR_ENABLE, 1 << 0   @ bitWidth 1 (LPTIM Enable)  
        .equ LPTIM2_CR_SNGSTRT, 1 << 1   @ bitWidth 1 (LPTIM start in single mode)  
        .equ LPTIM2_CR_CNTSTRT, 1 << 2   @ bitWidth 1 (Timer start in continuous  mode)  
        .equ LPTIM2_CR_COUNTRST, 1 << 3   @ bitWidth 1 (Counter reset)  
        .equ LPTIM2_CR_RSTARE, 1 << 4   @ bitWidth 1 (Reset after read enable)  
 
    .equ LPTIM2_CMP, LPTIM2_BASE + 0x14 @ (Compare Register) 
        .equ LPTIM2_CMP_CMP_Shift, 0   @ bitWidth 16 (Compare value)  
 
    .equ LPTIM2_ARR, LPTIM2_BASE + 0x18 @ (Autoreload Register) 
        .equ LPTIM2_ARR_ARR_Shift, 0   @ bitWidth 16 (Auto reload value)  
 
    .equ LPTIM2_CNT, LPTIM2_BASE + 0x1C @ (Counter Register) 
        .equ LPTIM2_CNT_CNT_Shift, 0   @ bitWidth 16 (Counter value)  
 
    .equ LPTIM2_CFGR2, LPTIM2_BASE + 0x24 @ (LPTIM configuration register 2) 
        .equ LPTIM2_CFGR2_IN1SEL_Shift, 0   @ bitWidth 2 (LPTIM Input 1 selection)  
        .equ LPTIM2_CFGR2_IN2SEL_Shift, 4   @ bitWidth 2 (LPTIM Input 2 selection)  
 

@=========================== LPTIM3 ===========================@
.equ LPTIM3_BASE, 0x58002800 @ (Low power timer) 
    .equ LPTIM3_ISR, LPTIM3_BASE + 0x0 @ (Interrupt and Status Register) 
        .equ LPTIM3_ISR_DOWN, 1 << 6   @ bitWidth 1 (Counter direction change up to  down)  
        .equ LPTIM3_ISR_UP, 1 << 5   @ bitWidth 1 (Counter direction change down to  up)  
        .equ LPTIM3_ISR_ARROK, 1 << 4   @ bitWidth 1 (Autoreload register update  OK)  
        .equ LPTIM3_ISR_CMPOK, 1 << 3   @ bitWidth 1 (Compare register update OK)  
        .equ LPTIM3_ISR_EXTTRIG, 1 << 2   @ bitWidth 1 (External trigger edge  event)  
        .equ LPTIM3_ISR_ARRM, 1 << 1   @ bitWidth 1 (Autoreload match)  
        .equ LPTIM3_ISR_CMPM, 1 << 0   @ bitWidth 1 (Compare match)  
 
    .equ LPTIM3_ICR, LPTIM3_BASE + 0x4 @ (Interrupt Clear Register) 
        .equ LPTIM3_ICR_DOWNCF, 1 << 6   @ bitWidth 1 (Direction change to down Clear  Flag)  
        .equ LPTIM3_ICR_UPCF, 1 << 5   @ bitWidth 1 (Direction change to UP Clear  Flag)  
        .equ LPTIM3_ICR_ARROKCF, 1 << 4   @ bitWidth 1 (Autoreload register update OK Clear  Flag)  
        .equ LPTIM3_ICR_CMPOKCF, 1 << 3   @ bitWidth 1 (Compare register update OK Clear  Flag)  
        .equ LPTIM3_ICR_EXTTRIGCF, 1 << 2   @ bitWidth 1 (External trigger valid edge Clear  Flag)  
        .equ LPTIM3_ICR_ARRMCF, 1 << 1   @ bitWidth 1 (Autoreload match Clear  Flag)  
        .equ LPTIM3_ICR_CMPMCF, 1 << 0   @ bitWidth 1 (compare match Clear Flag)  
 
    .equ LPTIM3_IER, LPTIM3_BASE + 0x8 @ (Interrupt Enable Register) 
        .equ LPTIM3_IER_DOWNIE, 1 << 6   @ bitWidth 1 (Direction change to down Interrupt  Enable)  
        .equ LPTIM3_IER_UPIE, 1 << 5   @ bitWidth 1 (Direction change to UP Interrupt  Enable)  
        .equ LPTIM3_IER_ARROKIE, 1 << 4   @ bitWidth 1 (Autoreload register update OK Interrupt  Enable)  
        .equ LPTIM3_IER_CMPOKIE, 1 << 3   @ bitWidth 1 (Compare register update OK Interrupt  Enable)  
        .equ LPTIM3_IER_EXTTRIGIE, 1 << 2   @ bitWidth 1 (External trigger valid edge Interrupt  Enable)  
        .equ LPTIM3_IER_ARRMIE, 1 << 1   @ bitWidth 1 (Autoreload match Interrupt  Enable)  
        .equ LPTIM3_IER_CMPMIE, 1 << 0   @ bitWidth 1 (Compare match Interrupt  Enable)  
 
    .equ LPTIM3_CFGR, LPTIM3_BASE + 0xC @ (Configuration Register) 
        .equ LPTIM3_CFGR_ENC, 1 << 24   @ bitWidth 1 (Encoder mode enable)  
        .equ LPTIM3_CFGR_COUNTMODE, 1 << 23   @ bitWidth 1 (counter mode enabled)  
        .equ LPTIM3_CFGR_PRELOAD, 1 << 22   @ bitWidth 1 (Registers update mode)  
        .equ LPTIM3_CFGR_WAVPOL, 1 << 21   @ bitWidth 1 (Waveform shape polarity)  
        .equ LPTIM3_CFGR_WAVE, 1 << 20   @ bitWidth 1 (Waveform shape)  
        .equ LPTIM3_CFGR_TIMOUT, 1 << 19   @ bitWidth 1 (Timeout enable)  
        .equ LPTIM3_CFGR_TRIGEN_Shift, 17   @ bitWidth 2 (Trigger enable and  polarity)  
        .equ LPTIM3_CFGR_TRIGSEL_Shift, 13   @ bitWidth 3 (Trigger selector)  
        .equ LPTIM3_CFGR_PRESC_Shift, 9   @ bitWidth 3 (Clock prescaler)  
        .equ LPTIM3_CFGR_TRGFLT_Shift, 6   @ bitWidth 2 (Configurable digital filter for  trigger)  
        .equ LPTIM3_CFGR_CKFLT_Shift, 3   @ bitWidth 2 (Configurable digital filter for external  clock)  
        .equ LPTIM3_CFGR_CKPOL_Shift, 1   @ bitWidth 2 (Clock Polarity)  
        .equ LPTIM3_CFGR_CKSEL, 1 << 0   @ bitWidth 1 (Clock selector)  
 
    .equ LPTIM3_CR, LPTIM3_BASE + 0x10 @ (Control Register) 
        .equ LPTIM3_CR_ENABLE, 1 << 0   @ bitWidth 1 (LPTIM Enable)  
        .equ LPTIM3_CR_SNGSTRT, 1 << 1   @ bitWidth 1 (LPTIM start in single mode)  
        .equ LPTIM3_CR_CNTSTRT, 1 << 2   @ bitWidth 1 (Timer start in continuous  mode)  
        .equ LPTIM3_CR_COUNTRST, 1 << 3   @ bitWidth 1 (Counter reset)  
        .equ LPTIM3_CR_RSTARE, 1 << 4   @ bitWidth 1 (Reset after read enable)  
 
    .equ LPTIM3_CMP, LPTIM3_BASE + 0x14 @ (Compare Register) 
        .equ LPTIM3_CMP_CMP_Shift, 0   @ bitWidth 16 (Compare value)  
 
    .equ LPTIM3_ARR, LPTIM3_BASE + 0x18 @ (Autoreload Register) 
        .equ LPTIM3_ARR_ARR_Shift, 0   @ bitWidth 16 (Auto reload value)  
 
    .equ LPTIM3_CNT, LPTIM3_BASE + 0x1C @ (Counter Register) 
        .equ LPTIM3_CNT_CNT_Shift, 0   @ bitWidth 16 (Counter value)  
 
    .equ LPTIM3_CFGR2, LPTIM3_BASE + 0x24 @ (LPTIM configuration register 2) 
        .equ LPTIM3_CFGR2_IN1SEL_Shift, 0   @ bitWidth 2 (LPTIM Input 1 selection)  
 

@=========================== LPTIM4 ===========================@
.equ LPTIM4_BASE, 0x58002C00 @ (Low power timer) 
    .equ LPTIM4_ISR, LPTIM4_BASE + 0x0 @ (Interrupt and Status Register) 
        .equ LPTIM4_ISR_DOWN, 1 << 6   @ bitWidth 1 (Counter direction change up to  down)  
        .equ LPTIM4_ISR_UP, 1 << 5   @ bitWidth 1 (Counter direction change down to  up)  
        .equ LPTIM4_ISR_ARROK, 1 << 4   @ bitWidth 1 (Autoreload register update  OK)  
        .equ LPTIM4_ISR_CMPOK, 1 << 3   @ bitWidth 1 (Compare register update OK)  
        .equ LPTIM4_ISR_EXTTRIG, 1 << 2   @ bitWidth 1 (External trigger edge  event)  
        .equ LPTIM4_ISR_ARRM, 1 << 1   @ bitWidth 1 (Autoreload match)  
        .equ LPTIM4_ISR_CMPM, 1 << 0   @ bitWidth 1 (Compare match)  
 
    .equ LPTIM4_ICR, LPTIM4_BASE + 0x4 @ (Interrupt Clear Register) 
        .equ LPTIM4_ICR_DOWNCF, 1 << 6   @ bitWidth 1 (Direction change to down Clear  Flag)  
        .equ LPTIM4_ICR_UPCF, 1 << 5   @ bitWidth 1 (Direction change to UP Clear  Flag)  
        .equ LPTIM4_ICR_ARROKCF, 1 << 4   @ bitWidth 1 (Autoreload register update OK Clear  Flag)  
        .equ LPTIM4_ICR_CMPOKCF, 1 << 3   @ bitWidth 1 (Compare register update OK Clear  Flag)  
        .equ LPTIM4_ICR_EXTTRIGCF, 1 << 2   @ bitWidth 1 (External trigger valid edge Clear  Flag)  
        .equ LPTIM4_ICR_ARRMCF, 1 << 1   @ bitWidth 1 (Autoreload match Clear  Flag)  
        .equ LPTIM4_ICR_CMPMCF, 1 << 0   @ bitWidth 1 (compare match Clear Flag)  
 
    .equ LPTIM4_IER, LPTIM4_BASE + 0x8 @ (Interrupt Enable Register) 
        .equ LPTIM4_IER_DOWNIE, 1 << 6   @ bitWidth 1 (Direction change to down Interrupt  Enable)  
        .equ LPTIM4_IER_UPIE, 1 << 5   @ bitWidth 1 (Direction change to UP Interrupt  Enable)  
        .equ LPTIM4_IER_ARROKIE, 1 << 4   @ bitWidth 1 (Autoreload register update OK Interrupt  Enable)  
        .equ LPTIM4_IER_CMPOKIE, 1 << 3   @ bitWidth 1 (Compare register update OK Interrupt  Enable)  
        .equ LPTIM4_IER_EXTTRIGIE, 1 << 2   @ bitWidth 1 (External trigger valid edge Interrupt  Enable)  
        .equ LPTIM4_IER_ARRMIE, 1 << 1   @ bitWidth 1 (Autoreload match Interrupt  Enable)  
        .equ LPTIM4_IER_CMPMIE, 1 << 0   @ bitWidth 1 (Compare match Interrupt  Enable)  
 
    .equ LPTIM4_CFGR, LPTIM4_BASE + 0xC @ (Configuration Register) 
        .equ LPTIM4_CFGR_ENC, 1 << 24   @ bitWidth 1 (Encoder mode enable)  
        .equ LPTIM4_CFGR_COUNTMODE, 1 << 23   @ bitWidth 1 (counter mode enabled)  
        .equ LPTIM4_CFGR_PRELOAD, 1 << 22   @ bitWidth 1 (Registers update mode)  
        .equ LPTIM4_CFGR_WAVPOL, 1 << 21   @ bitWidth 1 (Waveform shape polarity)  
        .equ LPTIM4_CFGR_WAVE, 1 << 20   @ bitWidth 1 (Waveform shape)  
        .equ LPTIM4_CFGR_TIMOUT, 1 << 19   @ bitWidth 1 (Timeout enable)  
        .equ LPTIM4_CFGR_TRIGEN_Shift, 17   @ bitWidth 2 (Trigger enable and  polarity)  
        .equ LPTIM4_CFGR_TRIGSEL_Shift, 13   @ bitWidth 3 (Trigger selector)  
        .equ LPTIM4_CFGR_PRESC_Shift, 9   @ bitWidth 3 (Clock prescaler)  
        .equ LPTIM4_CFGR_TRGFLT_Shift, 6   @ bitWidth 2 (Configurable digital filter for  trigger)  
        .equ LPTIM4_CFGR_CKFLT_Shift, 3   @ bitWidth 2 (Configurable digital filter for external  clock)  
        .equ LPTIM4_CFGR_CKPOL_Shift, 1   @ bitWidth 2 (Clock Polarity)  
        .equ LPTIM4_CFGR_CKSEL, 1 << 0   @ bitWidth 1 (Clock selector)  
 
    .equ LPTIM4_CR, LPTIM4_BASE + 0x10 @ (Control Register) 
        .equ LPTIM4_CR_ENABLE, 1 << 0   @ bitWidth 1 (LPTIM Enable)  
        .equ LPTIM4_CR_SNGSTRT, 1 << 1   @ bitWidth 1 (LPTIM start in single mode)  
        .equ LPTIM4_CR_CNTSTRT, 1 << 2   @ bitWidth 1 (Timer start in continuous  mode)  
        .equ LPTIM4_CR_COUNTRST, 1 << 3   @ bitWidth 1 (Counter reset)  
        .equ LPTIM4_CR_RSTARE, 1 << 4   @ bitWidth 1 (Reset after read enable)  
 
    .equ LPTIM4_CMP, LPTIM4_BASE + 0x14 @ (Compare Register) 
        .equ LPTIM4_CMP_CMP_Shift, 0   @ bitWidth 16 (Compare value)  
 
    .equ LPTIM4_ARR, LPTIM4_BASE + 0x18 @ (Autoreload Register) 
        .equ LPTIM4_ARR_ARR_Shift, 0   @ bitWidth 16 (Auto reload value)  
 
    .equ LPTIM4_CNT, LPTIM4_BASE + 0x1C @ (Counter Register) 
        .equ LPTIM4_CNT_CNT_Shift, 0   @ bitWidth 16 (Counter value)  
 
    .equ LPTIM4_CFGR2, LPTIM4_BASE + 0x24 @ (LPTIM configuration register 2) 
        .equ LPTIM4_CFGR2_IN1SEL_Shift, 0   @ bitWidth 2 (LPTIM Input 1 selection)  
 

@=========================== LPTIM5 ===========================@
.equ LPTIM5_BASE, 0x58003000 @ (Low power timer) 
    .equ LPTIM5_ISR, LPTIM5_BASE + 0x0 @ (Interrupt and Status Register) 
        .equ LPTIM5_ISR_DOWN, 1 << 6   @ bitWidth 1 (Counter direction change up to  down)  
        .equ LPTIM5_ISR_UP, 1 << 5   @ bitWidth 1 (Counter direction change down to  up)  
        .equ LPTIM5_ISR_ARROK, 1 << 4   @ bitWidth 1 (Autoreload register update  OK)  
        .equ LPTIM5_ISR_CMPOK, 1 << 3   @ bitWidth 1 (Compare register update OK)  
        .equ LPTIM5_ISR_EXTTRIG, 1 << 2   @ bitWidth 1 (External trigger edge  event)  
        .equ LPTIM5_ISR_ARRM, 1 << 1   @ bitWidth 1 (Autoreload match)  
        .equ LPTIM5_ISR_CMPM, 1 << 0   @ bitWidth 1 (Compare match)  
 
    .equ LPTIM5_ICR, LPTIM5_BASE + 0x4 @ (Interrupt Clear Register) 
        .equ LPTIM5_ICR_DOWNCF, 1 << 6   @ bitWidth 1 (Direction change to down Clear  Flag)  
        .equ LPTIM5_ICR_UPCF, 1 << 5   @ bitWidth 1 (Direction change to UP Clear  Flag)  
        .equ LPTIM5_ICR_ARROKCF, 1 << 4   @ bitWidth 1 (Autoreload register update OK Clear  Flag)  
        .equ LPTIM5_ICR_CMPOKCF, 1 << 3   @ bitWidth 1 (Compare register update OK Clear  Flag)  
        .equ LPTIM5_ICR_EXTTRIGCF, 1 << 2   @ bitWidth 1 (External trigger valid edge Clear  Flag)  
        .equ LPTIM5_ICR_ARRMCF, 1 << 1   @ bitWidth 1 (Autoreload match Clear  Flag)  
        .equ LPTIM5_ICR_CMPMCF, 1 << 0   @ bitWidth 1 (compare match Clear Flag)  
 
    .equ LPTIM5_IER, LPTIM5_BASE + 0x8 @ (Interrupt Enable Register) 
        .equ LPTIM5_IER_DOWNIE, 1 << 6   @ bitWidth 1 (Direction change to down Interrupt  Enable)  
        .equ LPTIM5_IER_UPIE, 1 << 5   @ bitWidth 1 (Direction change to UP Interrupt  Enable)  
        .equ LPTIM5_IER_ARROKIE, 1 << 4   @ bitWidth 1 (Autoreload register update OK Interrupt  Enable)  
        .equ LPTIM5_IER_CMPOKIE, 1 << 3   @ bitWidth 1 (Compare register update OK Interrupt  Enable)  
        .equ LPTIM5_IER_EXTTRIGIE, 1 << 2   @ bitWidth 1 (External trigger valid edge Interrupt  Enable)  
        .equ LPTIM5_IER_ARRMIE, 1 << 1   @ bitWidth 1 (Autoreload match Interrupt  Enable)  
        .equ LPTIM5_IER_CMPMIE, 1 << 0   @ bitWidth 1 (Compare match Interrupt  Enable)  
 
    .equ LPTIM5_CFGR, LPTIM5_BASE + 0xC @ (Configuration Register) 
        .equ LPTIM5_CFGR_ENC, 1 << 24   @ bitWidth 1 (Encoder mode enable)  
        .equ LPTIM5_CFGR_COUNTMODE, 1 << 23   @ bitWidth 1 (counter mode enabled)  
        .equ LPTIM5_CFGR_PRELOAD, 1 << 22   @ bitWidth 1 (Registers update mode)  
        .equ LPTIM5_CFGR_WAVPOL, 1 << 21   @ bitWidth 1 (Waveform shape polarity)  
        .equ LPTIM5_CFGR_WAVE, 1 << 20   @ bitWidth 1 (Waveform shape)  
        .equ LPTIM5_CFGR_TIMOUT, 1 << 19   @ bitWidth 1 (Timeout enable)  
        .equ LPTIM5_CFGR_TRIGEN_Shift, 17   @ bitWidth 2 (Trigger enable and  polarity)  
        .equ LPTIM5_CFGR_TRIGSEL_Shift, 13   @ bitWidth 3 (Trigger selector)  
        .equ LPTIM5_CFGR_PRESC_Shift, 9   @ bitWidth 3 (Clock prescaler)  
        .equ LPTIM5_CFGR_TRGFLT_Shift, 6   @ bitWidth 2 (Configurable digital filter for  trigger)  
        .equ LPTIM5_CFGR_CKFLT_Shift, 3   @ bitWidth 2 (Configurable digital filter for external  clock)  
        .equ LPTIM5_CFGR_CKPOL_Shift, 1   @ bitWidth 2 (Clock Polarity)  
        .equ LPTIM5_CFGR_CKSEL, 1 << 0   @ bitWidth 1 (Clock selector)  
 
    .equ LPTIM5_CR, LPTIM5_BASE + 0x10 @ (Control Register) 
        .equ LPTIM5_CR_ENABLE, 1 << 0   @ bitWidth 1 (LPTIM Enable)  
        .equ LPTIM5_CR_SNGSTRT, 1 << 1   @ bitWidth 1 (LPTIM start in single mode)  
        .equ LPTIM5_CR_CNTSTRT, 1 << 2   @ bitWidth 1 (Timer start in continuous  mode)  
        .equ LPTIM5_CR_COUNTRST, 1 << 3   @ bitWidth 1 (Counter reset)  
        .equ LPTIM5_CR_RSTARE, 1 << 4   @ bitWidth 1 (Reset after read enable)  
 
    .equ LPTIM5_CMP, LPTIM5_BASE + 0x14 @ (Compare Register) 
        .equ LPTIM5_CMP_CMP_Shift, 0   @ bitWidth 16 (Compare value)  
 
    .equ LPTIM5_ARR, LPTIM5_BASE + 0x18 @ (Autoreload Register) 
        .equ LPTIM5_ARR_ARR_Shift, 0   @ bitWidth 16 (Auto reload value)  
 
    .equ LPTIM5_CNT, LPTIM5_BASE + 0x1C @ (Counter Register) 
        .equ LPTIM5_CNT_CNT_Shift, 0   @ bitWidth 16 (Counter value)  
 
    .equ LPTIM5_CFGR2, LPTIM5_BASE + 0x24 @ (LPTIM configuration register 2) 
        .equ LPTIM5_CFGR2_IN1SEL_Shift, 0   @ bitWidth 2 (LPTIM Input 1 selection)  
 

@=========================== LPUART1 ===========================@
.equ LPUART1_BASE, 0x58000C00 @ (LPUART1) 
    .equ LPUART1_CR1, LPUART1_BASE + 0x0 @ (Control register 1) 
        .equ LPUART1_CR1_RXFFIE, 1 << 31   @ bitWidth 1 (RXFIFO Full interrupt  enable)  
        .equ LPUART1_CR1_TXFEIE, 1 << 30   @ bitWidth 1 (TXFIFO empty interrupt  enable)  
        .equ LPUART1_CR1_FIFOEN, 1 << 29   @ bitWidth 1 (FIFO mode enable)  
        .equ LPUART1_CR1_M1, 1 << 28   @ bitWidth 1 (Word length)  
        .equ LPUART1_CR1_DEAT_Shift, 21   @ bitWidth 5 (Driver Enable assertion  time)  
        .equ LPUART1_CR1_DEDT_Shift, 16   @ bitWidth 5 (Driver Enable deassertion  time)  
        .equ LPUART1_CR1_CMIE, 1 << 14   @ bitWidth 1 (Character match interrupt  enable)  
        .equ LPUART1_CR1_MME, 1 << 13   @ bitWidth 1 (Mute mode enable)  
        .equ LPUART1_CR1_M0, 1 << 12   @ bitWidth 1 (Word length)  
        .equ LPUART1_CR1_WAKE, 1 << 11   @ bitWidth 1 (Receiver wakeup method)  
        .equ LPUART1_CR1_PCE, 1 << 10   @ bitWidth 1 (Parity control enable)  
        .equ LPUART1_CR1_PS, 1 << 9   @ bitWidth 1 (Parity selection)  
        .equ LPUART1_CR1_PEIE, 1 << 8   @ bitWidth 1 (PE interrupt enable)  
        .equ LPUART1_CR1_TXEIE, 1 << 7   @ bitWidth 1 (interrupt enable)  
        .equ LPUART1_CR1_TCIE, 1 << 6   @ bitWidth 1 (Transmission complete interrupt  enable)  
        .equ LPUART1_CR1_RXNEIE, 1 << 5   @ bitWidth 1 (RXNE interrupt enable)  
        .equ LPUART1_CR1_IDLEIE, 1 << 4   @ bitWidth 1 (IDLE interrupt enable)  
        .equ LPUART1_CR1_TE, 1 << 3   @ bitWidth 1 (Transmitter enable)  
        .equ LPUART1_CR1_RE, 1 << 2   @ bitWidth 1 (Receiver enable)  
        .equ LPUART1_CR1_UESM, 1 << 1   @ bitWidth 1 (USART enable in Stop mode)  
        .equ LPUART1_CR1_UE, 1 << 0   @ bitWidth 1 (USART enable)  
 
    .equ LPUART1_CR2, LPUART1_BASE + 0x4 @ (Control register 2) 
        .equ LPUART1_CR2_ADD_Shift, 24   @ bitWidth 8 (Address of the USART node)  
        .equ LPUART1_CR2_MSBFIRST, 1 << 19   @ bitWidth 1 (Most significant bit first)  
        .equ LPUART1_CR2_DATAINV, 1 << 18   @ bitWidth 1 (Binary data inversion)  
        .equ LPUART1_CR2_TXINV, 1 << 17   @ bitWidth 1 (TX pin active level  inversion)  
        .equ LPUART1_CR2_RXINV, 1 << 16   @ bitWidth 1 (RX pin active level  inversion)  
        .equ LPUART1_CR2_SWAP, 1 << 15   @ bitWidth 1 (Swap TX/RX pins)  
        .equ LPUART1_CR2_STOP_Shift, 12   @ bitWidth 2 (STOP bits)  
        .equ LPUART1_CR2_ADDM7, 1 << 4   @ bitWidth 1 (7-bit Address Detection/4-bit Address  Detection)  
 
    .equ LPUART1_CR3, LPUART1_BASE + 0x8 @ (Control register 3) 
        .equ LPUART1_CR3_TXFTCFG_Shift, 29   @ bitWidth 3 (TXFIFO threshold  configuration)  
        .equ LPUART1_CR3_RXFTIE, 1 << 28   @ bitWidth 1 (RXFIFO threshold interrupt  enable)  
        .equ LPUART1_CR3_RXFTCFG_Shift, 25   @ bitWidth 3 (Receive FIFO threshold  configuration)  
        .equ LPUART1_CR3_TXFTIE, 1 << 23   @ bitWidth 1 (TXFIFO threshold interrupt  enable)  
        .equ LPUART1_CR3_WUFIE, 1 << 22   @ bitWidth 1 (Wakeup from Stop mode interrupt  enable)  
        .equ LPUART1_CR3_WUS_Shift, 20   @ bitWidth 2 (Wakeup from Stop mode interrupt flag  selection)  
        .equ LPUART1_CR3_DEP, 1 << 15   @ bitWidth 1 (Driver enable polarity  selection)  
        .equ LPUART1_CR3_DEM, 1 << 14   @ bitWidth 1 (Driver enable mode)  
        .equ LPUART1_CR3_DDRE, 1 << 13   @ bitWidth 1 (DMA Disable on Reception  Error)  
        .equ LPUART1_CR3_OVRDIS, 1 << 12   @ bitWidth 1 (Overrun Disable)  
        .equ LPUART1_CR3_CTSIE, 1 << 10   @ bitWidth 1 (CTS interrupt enable)  
        .equ LPUART1_CR3_CTSE, 1 << 9   @ bitWidth 1 (CTS enable)  
        .equ LPUART1_CR3_RTSE, 1 << 8   @ bitWidth 1 (RTS enable)  
        .equ LPUART1_CR3_DMAT, 1 << 7   @ bitWidth 1 (DMA enable transmitter)  
        .equ LPUART1_CR3_DMAR, 1 << 6   @ bitWidth 1 (DMA enable receiver)  
        .equ LPUART1_CR3_HDSEL, 1 << 3   @ bitWidth 1 (Half-duplex selection)  
        .equ LPUART1_CR3_EIE, 1 << 0   @ bitWidth 1 (Error interrupt enable)  
 
    .equ LPUART1_BRR, LPUART1_BASE + 0xC @ (Baud rate register) 
        .equ LPUART1_BRR_BRR_Shift, 0   @ bitWidth 20 (BRR)  
 
    .equ LPUART1_GTPR, LPUART1_BASE + 0x10 @ (Guard time and prescaler  register) 
        .equ LPUART1_GTPR_GT_Shift, 8   @ bitWidth 8 (Guard time value)  
        .equ LPUART1_GTPR_PSC_Shift, 0   @ bitWidth 8 (Prescaler value)  
 
    .equ LPUART1_RTOR, LPUART1_BASE + 0x14 @ (Receiver timeout register) 
        .equ LPUART1_RTOR_BLEN_Shift, 24   @ bitWidth 8 (Block Length)  
        .equ LPUART1_RTOR_RTO_Shift, 0   @ bitWidth 24 (Receiver timeout value)  
 
    .equ LPUART1_RQR, LPUART1_BASE + 0x18 @ (Request register) 
        .equ LPUART1_RQR_TXFRQ, 1 << 4   @ bitWidth 1 (Transmit data flush  request)  
        .equ LPUART1_RQR_RXFRQ, 1 << 3   @ bitWidth 1 (Receive data flush request)  
        .equ LPUART1_RQR_MMRQ, 1 << 2   @ bitWidth 1 (Mute mode request)  
        .equ LPUART1_RQR_SBKRQ, 1 << 1   @ bitWidth 1 (Send break request)  
        .equ LPUART1_RQR_ABRRQ, 1 << 0   @ bitWidth 1 (Auto baud rate request)  
 
    .equ LPUART1_ISR, LPUART1_BASE + 0x1C @ (Interrupt & status  register) 
        .equ LPUART1_ISR_TXFT, 1 << 27   @ bitWidth 1 (TXFIFO threshold flag)  
        .equ LPUART1_ISR_RXFT, 1 << 26   @ bitWidth 1 (RXFIFO threshold flag)  
        .equ LPUART1_ISR_RXFF, 1 << 24   @ bitWidth 1 (RXFIFO Full)  
        .equ LPUART1_ISR_TXFE, 1 << 23   @ bitWidth 1 (TXFIFO Empty)  
        .equ LPUART1_ISR_REACK, 1 << 22   @ bitWidth 1 (REACK)  
        .equ LPUART1_ISR_TEACK, 1 << 21   @ bitWidth 1 (TEACK)  
        .equ LPUART1_ISR_WUF, 1 << 20   @ bitWidth 1 (WUF)  
        .equ LPUART1_ISR_RWU, 1 << 19   @ bitWidth 1 (RWU)  
        .equ LPUART1_ISR_SBKF, 1 << 18   @ bitWidth 1 (SBKF)  
        .equ LPUART1_ISR_CMF, 1 << 17   @ bitWidth 1 (CMF)  
        .equ LPUART1_ISR_BUSY, 1 << 16   @ bitWidth 1 (BUSY)  
        .equ LPUART1_ISR_CTS, 1 << 10   @ bitWidth 1 (CTS)  
        .equ LPUART1_ISR_CTSIF, 1 << 9   @ bitWidth 1 (CTSIF)  
        .equ LPUART1_ISR_TXE, 1 << 7   @ bitWidth 1 (TXE)  
        .equ LPUART1_ISR_TC, 1 << 6   @ bitWidth 1 (TC)  
        .equ LPUART1_ISR_RXNE, 1 << 5   @ bitWidth 1 (RXNE)  
        .equ LPUART1_ISR_IDLE, 1 << 4   @ bitWidth 1 (IDLE)  
        .equ LPUART1_ISR_ORE, 1 << 3   @ bitWidth 1 (ORE)  
        .equ LPUART1_ISR_NE, 1 << 2   @ bitWidth 1 (NE)  
        .equ LPUART1_ISR_FE, 1 << 1   @ bitWidth 1 (FE)  
        .equ LPUART1_ISR_PE, 1 << 0   @ bitWidth 1 (PE)  
 
    .equ LPUART1_ICR, LPUART1_BASE + 0x20 @ (Interrupt flag clear register) 
        .equ LPUART1_ICR_WUCF, 1 << 20   @ bitWidth 1 (Wakeup from Stop mode clear  flag)  
        .equ LPUART1_ICR_CMCF, 1 << 17   @ bitWidth 1 (Character match clear flag)  
        .equ LPUART1_ICR_CTSCF, 1 << 9   @ bitWidth 1 (CTS clear flag)  
        .equ LPUART1_ICR_TCCF, 1 << 6   @ bitWidth 1 (Transmission complete clear  flag)  
        .equ LPUART1_ICR_IDLECF, 1 << 4   @ bitWidth 1 (Idle line detected clear  flag)  
        .equ LPUART1_ICR_ORECF, 1 << 3   @ bitWidth 1 (Overrun error clear flag)  
        .equ LPUART1_ICR_NCF, 1 << 2   @ bitWidth 1 (Noise detected clear flag)  
        .equ LPUART1_ICR_FECF, 1 << 1   @ bitWidth 1 (Framing error clear flag)  
        .equ LPUART1_ICR_PECF, 1 << 0   @ bitWidth 1 (Parity error clear flag)  
 
    .equ LPUART1_RDR, LPUART1_BASE + 0x24 @ (Receive data register) 
        .equ LPUART1_RDR_RDR_Shift, 0   @ bitWidth 9 (Receive data value)  
 
    .equ LPUART1_TDR, LPUART1_BASE + 0x28 @ (Transmit data register) 
        .equ LPUART1_TDR_TDR_Shift, 0   @ bitWidth 9 (Transmit data value)  
 
    .equ LPUART1_PRESC, LPUART1_BASE + 0x2C @ (Prescaler register) 
        .equ LPUART1_PRESC_PRESCALER_Shift, 0   @ bitWidth 4 (Clock prescaler)  
 

@=========================== SYSCFG ===========================@
.equ SYSCFG_BASE, 0x58000400 @ (System configuration controller) 
    .equ SYSCFG_PMCR, SYSCFG_BASE + 0x4 @ (peripheral mode configuration  register) 
        .equ SYSCFG_PMCR_I2C1FMP, 1 << 0   @ bitWidth 1 (I2C1 Fm+)  
        .equ SYSCFG_PMCR_I2C2FMP, 1 << 1   @ bitWidth 1 (I2C2 Fm+)  
        .equ SYSCFG_PMCR_I2C3FMP, 1 << 2   @ bitWidth 1 (I2C3 Fm+)  
        .equ SYSCFG_PMCR_I2C4FMP, 1 << 3   @ bitWidth 1 (I2C4 Fm+)  
        .equ SYSCFG_PMCR_PB6FMP, 1 << 4   @ bitWidth 1 (PB6 Fm+)  
        .equ SYSCFG_PMCR_PB7FMP, 1 << 5   @ bitWidth 1 (PB7 Fast Mode Plus)  
        .equ SYSCFG_PMCR_PB8FMP, 1 << 6   @ bitWidth 1 (PB8 Fast Mode Plus)  
        .equ SYSCFG_PMCR_PB9FMP, 1 << 7   @ bitWidth 1 (PB9 Fm+)  
        .equ SYSCFG_PMCR_BOOSTE, 1 << 8   @ bitWidth 1 (Booster Enable)  
        .equ SYSCFG_PMCR_BOOSTVDDSEL, 1 << 9   @ bitWidth 1 (Analog switch supply voltage selection)  
        .equ SYSCFG_PMCR_EPIS_Shift, 21   @ bitWidth 3 (Ethernet PHY Interface  Selection)  
        .equ SYSCFG_PMCR_PA0SO, 1 << 24   @ bitWidth 1 (PA0 Switch Open)  
        .equ SYSCFG_PMCR_PA1SO, 1 << 25   @ bitWidth 1 (PA1 Switch Open)  
        .equ SYSCFG_PMCR_PC2SO, 1 << 26   @ bitWidth 1 (PC2 Switch Open)  
        .equ SYSCFG_PMCR_PC3SO, 1 << 27   @ bitWidth 1 (PC3 Switch Open)  
 
    .equ SYSCFG_EXTICR1, SYSCFG_BASE + 0x8 @ (external interrupt configuration register  1) 
        .equ SYSCFG_EXTICR1_EXTI3_Shift, 12   @ bitWidth 4 (EXTI x configuration x = 0 to  3)  
        .equ SYSCFG_EXTICR1_EXTI2_Shift, 8   @ bitWidth 4 (EXTI x configuration x = 0 to  3)  
        .equ SYSCFG_EXTICR1_EXTI1_Shift, 4   @ bitWidth 4 (EXTI x configuration x = 0 to  3)  
        .equ SYSCFG_EXTICR1_EXTI0_Shift, 0   @ bitWidth 4 (EXTI x configuration x = 0 to  3)  
 
    .equ SYSCFG_EXTICR2, SYSCFG_BASE + 0xC @ (external interrupt configuration register  2) 
        .equ SYSCFG_EXTICR2_EXTI7_Shift, 12   @ bitWidth 4 (EXTI x configuration x = 4 to  7)  
        .equ SYSCFG_EXTICR2_EXTI6_Shift, 8   @ bitWidth 4 (EXTI x configuration x = 4 to  7)  
        .equ SYSCFG_EXTICR2_EXTI5_Shift, 4   @ bitWidth 4 (EXTI x configuration x = 4 to  7)  
        .equ SYSCFG_EXTICR2_EXTI4_Shift, 0   @ bitWidth 4 (EXTI x configuration x = 4 to  7)  
 
    .equ SYSCFG_EXTICR3, SYSCFG_BASE + 0x10 @ (external interrupt configuration register  3) 
        .equ SYSCFG_EXTICR3_EXTI11_Shift, 12   @ bitWidth 4 (EXTI x configuration x = 8 to  11)  
        .equ SYSCFG_EXTICR3_EXTI10_Shift, 8   @ bitWidth 4 (EXTI10)  
        .equ SYSCFG_EXTICR3_EXTI9_Shift, 4   @ bitWidth 4 (EXTI x configuration x = 8 to  11)  
        .equ SYSCFG_EXTICR3_EXTI8_Shift, 0   @ bitWidth 4 (EXTI x configuration x = 8 to  11)  
 
    .equ SYSCFG_EXTICR4, SYSCFG_BASE + 0x14 @ (external interrupt configuration register  4) 
        .equ SYSCFG_EXTICR4_EXTI15_Shift, 12   @ bitWidth 4 (EXTI x configuration x = 12 to  15)  
        .equ SYSCFG_EXTICR4_EXTI14_Shift, 8   @ bitWidth 4 (EXTI x configuration x = 12 to  15)  
        .equ SYSCFG_EXTICR4_EXTI13_Shift, 4   @ bitWidth 4 (EXTI x configuration x = 12 to  15)  
        .equ SYSCFG_EXTICR4_EXTI12_Shift, 0   @ bitWidth 4 (EXTI x configuration x = 12 to  15)  
 
    .equ SYSCFG_CCCSR, SYSCFG_BASE + 0x20 @ (compensation cell control/status  register) 
        .equ SYSCFG_CCCSR_EN, 1 << 0   @ bitWidth 1 (enable)  
        .equ SYSCFG_CCCSR_CS, 1 << 1   @ bitWidth 1 (Code selection)  
        .equ SYSCFG_CCCSR_READY, 1 << 8   @ bitWidth 1 (Compensation cell ready  flag)  
        .equ SYSCFG_CCCSR_HSLV, 1 << 16   @ bitWidth 1 (High-speed at low-voltage)  
 
    .equ SYSCFG_CCVR, SYSCFG_BASE + 0x24 @ (SYSCFG compensation cell value  register) 
        .equ SYSCFG_CCVR_NCV_Shift, 0   @ bitWidth 4 (NMOS compensation value)  
        .equ SYSCFG_CCVR_PCV_Shift, 4   @ bitWidth 4 (PMOS compensation value)  
 
    .equ SYSCFG_CCCR, SYSCFG_BASE + 0x28 @ (SYSCFG compensation cell code  register) 
        .equ SYSCFG_CCCR_NCC_Shift, 0   @ bitWidth 4 (NMOS compensation code)  
        .equ SYSCFG_CCCR_PCC_Shift, 4   @ bitWidth 4 (PMOS compensation code)  
 
    .equ SYSCFG_PWRCR, SYSCFG_BASE + 0x2C @ (SYSCFG power control register) 
        .equ SYSCFG_PWRCR_ODEN_Shift, 0   @ bitWidth 4 ( Overdrive enable)  
 
    .equ SYSCFG_PKGR, SYSCFG_BASE + 0x124 @ (SYSCFG package register) 
        .equ SYSCFG_PKGR_PKG_Shift, 0   @ bitWidth 4 (Package)  
 
    .equ SYSCFG_UR0, SYSCFG_BASE + 0x300 @ (SYSCFG user register 0) 
        .equ SYSCFG_UR0_BKS, 1 << 0   @ bitWidth 1 (Bank Swap)  
        .equ SYSCFG_UR0_RDP_Shift, 16   @ bitWidth 8 (Readout protection)  
 
    .equ SYSCFG_UR2, SYSCFG_BASE + 0x308 @ (SYSCFG user register 2) 
        .equ SYSCFG_UR2_BORH_Shift, 0   @ bitWidth 2 (BOR_LVL Brownout Reset Threshold  Level)  
        .equ SYSCFG_UR2_BOOT_ADD0_Shift, 16   @ bitWidth 16 (Boot Address 0)  
 
    .equ SYSCFG_UR3, SYSCFG_BASE + 0x30C @ (SYSCFG user register 3) 
        .equ SYSCFG_UR3_BOOT_ADD1_Shift, 16   @ bitWidth 16 (Boot Address 1)  
 
    .equ SYSCFG_UR4, SYSCFG_BASE + 0x310 @ (SYSCFG user register 4) 
        .equ SYSCFG_UR4_MEPAD_1, 1 << 16   @ bitWidth 1 (Mass Erase Protected Area Disabled for  bank 1)  
 
    .equ SYSCFG_UR5, SYSCFG_BASE + 0x314 @ (SYSCFG user register 5) 
        .equ SYSCFG_UR5_MESAD_1, 1 << 0   @ bitWidth 1 (Mass erase secured area disabled for  bank 1)  
        .equ SYSCFG_UR5_WRPN_1_Shift, 16   @ bitWidth 8 (Write protection for flash bank  1)  
 
    .equ SYSCFG_UR6, SYSCFG_BASE + 0x318 @ (SYSCFG user register 6) 
        .equ SYSCFG_UR6_PA_BEG_1_Shift, 0   @ bitWidth 12 (Protected area start address for bank  1)  
        .equ SYSCFG_UR6_PA_END_1_Shift, 16   @ bitWidth 12 (Protected area end address for bank  1)  
 
    .equ SYSCFG_UR7, SYSCFG_BASE + 0x31C @ (SYSCFG user register 7) 
        .equ SYSCFG_UR7_SA_BEG_1_Shift, 0   @ bitWidth 12 (Secured area start address for bank  1)  
        .equ SYSCFG_UR7_SA_END_1_Shift, 16   @ bitWidth 12 (Secured area end address for bank  1)  
 
    .equ SYSCFG_UR8, SYSCFG_BASE + 0x320 @ (SYSCFG user register 8) 
        .equ SYSCFG_UR8_MEPAD_2, 1 << 0   @ bitWidth 1 (Mass erase protected area disabled for  bank 2)  
        .equ SYSCFG_UR8_MESAD_2, 1 << 16   @ bitWidth 1 (Mass erase secured area disabled for  bank 2)  
 
    .equ SYSCFG_UR9, SYSCFG_BASE + 0x324 @ (SYSCFG user register 9) 
        .equ SYSCFG_UR9_WRPN_2_Shift, 0   @ bitWidth 8 (Write protection for flash bank  2)  
        .equ SYSCFG_UR9_PA_BEG_2_Shift, 16   @ bitWidth 12 (Protected area start address for bank  2)  
 
    .equ SYSCFG_UR10, SYSCFG_BASE + 0x328 @ (SYSCFG user register 10) 
        .equ SYSCFG_UR10_PA_END_2_Shift, 0   @ bitWidth 12 (Protected area end address for bank  2)  
        .equ SYSCFG_UR10_SA_BEG_2_Shift, 16   @ bitWidth 12 (Secured area start address for bank  2)  
 
    .equ SYSCFG_UR11, SYSCFG_BASE + 0x32C @ (SYSCFG user register 11) 
        .equ SYSCFG_UR11_SA_END_2_Shift, 0   @ bitWidth 12 (Secured area end address for bank  2)  
        .equ SYSCFG_UR11_IWDG1M, 1 << 16   @ bitWidth 1 (Independent Watchdog 1  mode)  
 
    .equ SYSCFG_UR12, SYSCFG_BASE + 0x330 @ (SYSCFG user register 12) 
        .equ SYSCFG_UR12_SECURE, 1 << 16   @ bitWidth 1 (Secure mode)  
 
    .equ SYSCFG_UR13, SYSCFG_BASE + 0x334 @ (SYSCFG user register 13) 
        .equ SYSCFG_UR13_SDRS_Shift, 0   @ bitWidth 2 (Secured DTCM RAM Size)  
        .equ SYSCFG_UR13_D1SBRST, 1 << 16   @ bitWidth 1 (D1 Standby reset)  
 
    .equ SYSCFG_UR14, SYSCFG_BASE + 0x338 @ (SYSCFG user register 14) 
        .equ SYSCFG_UR14_D1STPRST, 1 << 0   @ bitWidth 1 (D1 Stop Reset)  
 
    .equ SYSCFG_UR15, SYSCFG_BASE + 0x33C @ (SYSCFG user register 15) 
        .equ SYSCFG_UR15_FZIWDGSTB, 1 << 16   @ bitWidth 1 (Freeze independent watchdog in Standby  mode)  
 
    .equ SYSCFG_UR16, SYSCFG_BASE + 0x340 @ (SYSCFG user register 16) 
        .equ SYSCFG_UR16_FZIWDGSTP, 1 << 0   @ bitWidth 1 (Freeze independent watchdog in Stop  mode)  
        .equ SYSCFG_UR16_PKP, 1 << 16   @ bitWidth 1 (Private key programmed)  
 
    .equ SYSCFG_UR17, SYSCFG_BASE + 0x344 @ (SYSCFG user register 17) 
        .equ SYSCFG_UR17_IO_HSLV, 1 << 0   @ bitWidth 1 (I/O high speed / low  voltage)  
 

@=========================== EXTI ===========================@
.equ EXTI_BASE, 0x58000000 @ (External interrupt/event  controller) 
    .equ EXTI_RTSR1, EXTI_BASE + 0x0 @ (EXTI rising trigger selection  register) 
        .equ EXTI_RTSR1_TR0, 1 << 0   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR1, 1 << 1   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR2, 1 << 2   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR3, 1 << 3   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR4, 1 << 4   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR5, 1 << 5   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR6, 1 << 6   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR7, 1 << 7   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR8, 1 << 8   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR9, 1 << 9   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR10, 1 << 10   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR11, 1 << 11   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR12, 1 << 12   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR13, 1 << 13   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR14, 1 << 14   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR15, 1 << 15   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR16, 1 << 16   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR17, 1 << 17   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR18, 1 << 18   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR19, 1 << 19   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR20, 1 << 20   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_RTSR1_TR21, 1 << 21   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
 
    .equ EXTI_FTSR1, EXTI_BASE + 0x4 @ (EXTI falling trigger selection  register) 
        .equ EXTI_FTSR1_TR0, 1 << 0   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR1, 1 << 1   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR2, 1 << 2   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR3, 1 << 3   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR4, 1 << 4   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR5, 1 << 5   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR6, 1 << 6   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR7, 1 << 7   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR8, 1 << 8   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR9, 1 << 9   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR10, 1 << 10   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR11, 1 << 11   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR12, 1 << 12   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR13, 1 << 13   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR14, 1 << 14   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR15, 1 << 15   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR16, 1 << 16   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR17, 1 << 17   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR18, 1 << 18   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR19, 1 << 19   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR20, 1 << 20   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_FTSR1_TR21, 1 << 21   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
 
    .equ EXTI_SWIER1, EXTI_BASE + 0x8 @ (EXTI software interrupt event  register) 
        .equ EXTI_SWIER1_SWIER0, 1 << 0   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER1, 1 << 1   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER2, 1 << 2   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER3, 1 << 3   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER4, 1 << 4   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER5, 1 << 5   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER6, 1 << 6   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER7, 1 << 7   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER8, 1 << 8   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER9, 1 << 9   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER10, 1 << 10   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER11, 1 << 11   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER12, 1 << 12   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER13, 1 << 13   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER14, 1 << 14   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER15, 1 << 15   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER16, 1 << 16   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER17, 1 << 17   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER18, 1 << 18   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER19, 1 << 19   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER20, 1 << 20   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_SWIER1_SWIER21, 1 << 21   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
 
    .equ EXTI_D3PMR1, EXTI_BASE + 0xC @ (EXTI D3 pending mask register) 
        .equ EXTI_D3PMR1_MR0, 1 << 0   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR1, 1 << 1   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR2, 1 << 2   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR3, 1 << 3   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR4, 1 << 4   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR5, 1 << 5   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR6, 1 << 6   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR7, 1 << 7   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR8, 1 << 8   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR9, 1 << 9   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR10, 1 << 10   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR11, 1 << 11   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR12, 1 << 12   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR13, 1 << 13   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR14, 1 << 14   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR15, 1 << 15   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR19, 1 << 19   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR20, 1 << 20   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR21, 1 << 21   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_D3PMR1_MR25, 1 << 25   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
 
    .equ EXTI_D3PCR1L, EXTI_BASE + 0x10 @ (EXTI D3 pending clear selection register  low) 
        .equ EXTI_D3PCR1L_PCS0_Shift, 0   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n/2)  
        .equ EXTI_D3PCR1L_PCS1_Shift, 2   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n/2)  
        .equ EXTI_D3PCR1L_PCS2_Shift, 4   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n/2)  
        .equ EXTI_D3PCR1L_PCS3_Shift, 6   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n/2)  
        .equ EXTI_D3PCR1L_PCS4_Shift, 8   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n/2)  
        .equ EXTI_D3PCR1L_PCS5_Shift, 10   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n/2)  
        .equ EXTI_D3PCR1L_PCS6_Shift, 12   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n/2)  
        .equ EXTI_D3PCR1L_PCS7_Shift, 14   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n/2)  
        .equ EXTI_D3PCR1L_PCS8_Shift, 16   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n/2)  
        .equ EXTI_D3PCR1L_PCS9_Shift, 18   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n/2)  
        .equ EXTI_D3PCR1L_PCS10_Shift, 20   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n/2)  
        .equ EXTI_D3PCR1L_PCS11_Shift, 22   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n/2)  
        .equ EXTI_D3PCR1L_PCS12_Shift, 24   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n/2)  
        .equ EXTI_D3PCR1L_PCS13_Shift, 26   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n/2)  
        .equ EXTI_D3PCR1L_PCS14_Shift, 28   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n/2)  
        .equ EXTI_D3PCR1L_PCS15_Shift, 30   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n/2)  
 
    .equ EXTI_D3PCR1H, EXTI_BASE + 0x14 @ (EXTI D3 pending clear selection register  high) 
        .equ EXTI_D3PCR1H_PCS19_Shift, 6   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n+32/2)  
        .equ EXTI_D3PCR1H_PCS20_Shift, 8   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n+32/2)  
        .equ EXTI_D3PCR1H_PCS21_Shift, 10   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n+32/2)  
        .equ EXTI_D3PCR1H_PCS25_Shift, 18   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n+32/2)  
 
    .equ EXTI_RTSR2, EXTI_BASE + 0x20 @ (EXTI rising trigger selection  register) 
        .equ EXTI_RTSR2_TR49, 1 << 17   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input x+32)  
        .equ EXTI_RTSR2_TR51, 1 << 19   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input x+32)  
 
    .equ EXTI_FTSR2, EXTI_BASE + 0x24 @ (EXTI falling trigger selection  register) 
        .equ EXTI_FTSR2_TR49, 1 << 17   @ bitWidth 1 (Falling trigger event configuration bit  of Configurable Event input x+32)  
        .equ EXTI_FTSR2_TR51, 1 << 19   @ bitWidth 1 (Falling trigger event configuration bit  of Configurable Event input x+32)  
 
    .equ EXTI_SWIER2, EXTI_BASE + 0x28 @ (EXTI software interrupt event  register) 
        .equ EXTI_SWIER2_SWIER49, 1 << 17   @ bitWidth 1 (Software interrupt on line  x+32)  
        .equ EXTI_SWIER2_SWIER51, 1 << 19   @ bitWidth 1 (Software interrupt on line  x+32)  
 
    .equ EXTI_D3PMR2, EXTI_BASE + 0x2C @ (EXTI D3 pending mask register) 
        .equ EXTI_D3PMR2_MR34, 1 << 2   @ bitWidth 1 (D3 Pending Mask on Event input  x+32)  
        .equ EXTI_D3PMR2_MR35, 1 << 3   @ bitWidth 1 (D3 Pending Mask on Event input  x+32)  
        .equ EXTI_D3PMR2_MR41, 1 << 9   @ bitWidth 1 (D3 Pending Mask on Event input  x+32)  
        .equ EXTI_D3PMR2_MR48, 1 << 16   @ bitWidth 1 (D3 Pending Mask on Event input  x+32)  
        .equ EXTI_D3PMR2_MR49, 1 << 17   @ bitWidth 1 (D3 Pending Mask on Event input  x+32)  
        .equ EXTI_D3PMR2_MR50, 1 << 18   @ bitWidth 1 (D3 Pending Mask on Event input  x+32)  
        .equ EXTI_D3PMR2_MR51, 1 << 19   @ bitWidth 1 (D3 Pending Mask on Event input  x+32)  
        .equ EXTI_D3PMR2_MR52, 1 << 20   @ bitWidth 1 (D3 Pending Mask on Event input  x+32)  
        .equ EXTI_D3PMR2_MR53, 1 << 21   @ bitWidth 1 (D3 Pending Mask on Event input  x+32)  
 
    .equ EXTI_D3PCR2L, EXTI_BASE + 0x30 @ (EXTI D3 pending clear selection register  low) 
        .equ EXTI_D3PCR2L_PCS35_Shift, 6   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n+64/2)  
        .equ EXTI_D3PCR2L_PCS34_Shift, 4   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n+64/2)  
        .equ EXTI_D3PCR2L_PCS41_Shift, 18   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x = truncate  n+64/2)  
 
    .equ EXTI_D3PCR2H, EXTI_BASE + 0x34 @ (EXTI D3 pending clear selection register  high) 
        .equ EXTI_D3PCR2H_PCS48_Shift, 0   @ bitWidth 2 (Pending request clear input signal  selection on Event input x= truncate  n+96/2)  
        .equ EXTI_D3PCR2H_PCS49_Shift, 2   @ bitWidth 2 (Pending request clear input signal  selection on Event input x= truncate  n+96/2)  
        .equ EXTI_D3PCR2H_PCS50_Shift, 4   @ bitWidth 2 (Pending request clear input signal  selection on Event input x= truncate  n+96/2)  
        .equ EXTI_D3PCR2H_PCS51_Shift, 6   @ bitWidth 2 (Pending request clear input signal  selection on Event input x= truncate  n+96/2)  
        .equ EXTI_D3PCR2H_PCS52_Shift, 8   @ bitWidth 2 (Pending request clear input signal  selection on Event input x= truncate  n+96/2)  
        .equ EXTI_D3PCR2H_PCS53_Shift, 10   @ bitWidth 2 (Pending request clear input signal  selection on Event input x= truncate  n+96/2)  
 
    .equ EXTI_RTSR3, EXTI_BASE + 0x40 @ (EXTI rising trigger selection  register) 
        .equ EXTI_RTSR3_TR82, 1 << 18   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input x+64)  
        .equ EXTI_RTSR3_TR84, 1 << 20   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input x+64)  
        .equ EXTI_RTSR3_TR85, 1 << 21   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input x+64)  
        .equ EXTI_RTSR3_TR86, 1 << 22   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input x+64)  
 
    .equ EXTI_FTSR3, EXTI_BASE + 0x44 @ (EXTI falling trigger selection  register) 
        .equ EXTI_FTSR3_TR82, 1 << 18   @ bitWidth 1 (Falling trigger event configuration bit  of Configurable Event input x+64)  
        .equ EXTI_FTSR3_TR84, 1 << 20   @ bitWidth 1 (Falling trigger event configuration bit  of Configurable Event input x+64)  
        .equ EXTI_FTSR3_TR85, 1 << 21   @ bitWidth 1 (Falling trigger event configuration bit  of Configurable Event input x+64)  
        .equ EXTI_FTSR3_TR86, 1 << 22   @ bitWidth 1 (Falling trigger event configuration bit  of Configurable Event input x+64)  
 
    .equ EXTI_SWIER3, EXTI_BASE + 0x48 @ (EXTI software interrupt event  register) 
        .equ EXTI_SWIER3_SWIER82, 1 << 18   @ bitWidth 1 (Software interrupt on line  x+64)  
        .equ EXTI_SWIER3_SWIER84, 1 << 20   @ bitWidth 1 (Software interrupt on line  x+64)  
        .equ EXTI_SWIER3_SWIER85, 1 << 21   @ bitWidth 1 (Software interrupt on line  x+64)  
        .equ EXTI_SWIER3_SWIER86, 1 << 22   @ bitWidth 1 (Software interrupt on line  x+64)  
 
    .equ EXTI_D3PMR3, EXTI_BASE + 0x4C @ (EXTI D3 pending mask register) 
        .equ EXTI_D3PMR3_MR88, 1 << 24   @ bitWidth 1 (D3 Pending Mask on Event input  x+64)  
 
    .equ EXTI_D3PCR3H, EXTI_BASE + 0x54 @ (EXTI D3 pending clear selection register  high) 
        .equ EXTI_D3PCR3H_PCS88_Shift, 18   @ bitWidth 2 (D3 Pending request clear input signal  selection on Event input x= truncate  N+160/2)  
 
    .equ EXTI_CPUIMR1, EXTI_BASE + 0x80 @ (EXTI interrupt mask register) 
        .equ EXTI_CPUIMR1_MR0, 1 << 0   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR1, 1 << 1   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR2, 1 << 2   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR3, 1 << 3   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR4, 1 << 4   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR5, 1 << 5   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR6, 1 << 6   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR7, 1 << 7   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR8, 1 << 8   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR9, 1 << 9   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR10, 1 << 10   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR11, 1 << 11   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR12, 1 << 12   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR13, 1 << 13   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR14, 1 << 14   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR15, 1 << 15   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR16, 1 << 16   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR17, 1 << 17   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR18, 1 << 18   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR19, 1 << 19   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR20, 1 << 20   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR21, 1 << 21   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR22, 1 << 22   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR23, 1 << 23   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR24, 1 << 24   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR25, 1 << 25   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR26, 1 << 26   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR27, 1 << 27   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR28, 1 << 28   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR29, 1 << 29   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR30, 1 << 30   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
        .equ EXTI_CPUIMR1_MR31, 1 << 31   @ bitWidth 1 (Rising trigger event configuration bit  of Configurable Event input)  
 
    .equ EXTI_CPUEMR1, EXTI_BASE + 0x84 @ (EXTI event mask register) 
        .equ EXTI_CPUEMR1_MR0, 1 << 0   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR1, 1 << 1   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR2, 1 << 2   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR3, 1 << 3   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR4, 1 << 4   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR5, 1 << 5   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR6, 1 << 6   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR7, 1 << 7   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR8, 1 << 8   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR9, 1 << 9   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR10, 1 << 10   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR11, 1 << 11   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR12, 1 << 12   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR13, 1 << 13   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR14, 1 << 14   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR15, 1 << 15   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR16, 1 << 16   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR17, 1 << 17   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR18, 1 << 18   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR19, 1 << 19   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR20, 1 << 20   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR21, 1 << 21   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR22, 1 << 22   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR23, 1 << 23   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR24, 1 << 24   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR25, 1 << 25   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR26, 1 << 26   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR27, 1 << 27   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR28, 1 << 28   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR29, 1 << 29   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR30, 1 << 30   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUEMR1_MR31, 1 << 31   @ bitWidth 1 (CPU Event mask on Event input  x)  
 
    .equ EXTI_CPUPR1, EXTI_BASE + 0x88 @ (EXTI pending register) 
        .equ EXTI_CPUPR1_PR0, 1 << 0   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR1, 1 << 1   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR2, 1 << 2   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR3, 1 << 3   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR4, 1 << 4   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR5, 1 << 5   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR6, 1 << 6   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR7, 1 << 7   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR8, 1 << 8   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR9, 1 << 9   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR10, 1 << 10   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR11, 1 << 11   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR12, 1 << 12   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR13, 1 << 13   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR14, 1 << 14   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR15, 1 << 15   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR16, 1 << 16   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR17, 1 << 17   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR18, 1 << 18   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR19, 1 << 19   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR20, 1 << 20   @ bitWidth 1 (CPU Event mask on Event input  x)  
        .equ EXTI_CPUPR1_PR21, 1 << 21   @ bitWidth 1 (CPU Event mask on Event input  x)  
 
    .equ EXTI_CPUIMR2, EXTI_BASE + 0x90 @ (EXTI interrupt mask register) 
        .equ EXTI_CPUIMR2_MR0, 1 << 0   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR1, 1 << 1   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR2, 1 << 2   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR3, 1 << 3   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR4, 1 << 4   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR5, 1 << 5   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR6, 1 << 6   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR7, 1 << 7   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR8, 1 << 8   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR9, 1 << 9   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR10, 1 << 10   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR11, 1 << 11   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR12, 1 << 12   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR14, 1 << 14   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR15, 1 << 15   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR16, 1 << 16   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR17, 1 << 17   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR18, 1 << 18   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR19, 1 << 19   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR20, 1 << 20   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR21, 1 << 21   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR22, 1 << 22   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR23, 1 << 23   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR24, 1 << 24   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR25, 1 << 25   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR26, 1 << 26   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR27, 1 << 27   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR28, 1 << 28   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR29, 1 << 29   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR30, 1 << 30   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUIMR2_MR31, 1 << 31   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
 
    .equ EXTI_CPUEMR2, EXTI_BASE + 0x94 @ (EXTI event mask register) 
        .equ EXTI_CPUEMR2_MR32, 1 << 0   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR33, 1 << 1   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR34, 1 << 2   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR35, 1 << 3   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR36, 1 << 4   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR37, 1 << 5   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR38, 1 << 6   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR39, 1 << 7   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR40, 1 << 8   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR41, 1 << 9   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR42, 1 << 10   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR43, 1 << 11   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR44, 1 << 12   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR46, 1 << 14   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR47, 1 << 15   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR48, 1 << 16   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR49, 1 << 17   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR50, 1 << 18   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR51, 1 << 19   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR52, 1 << 20   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR53, 1 << 21   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR54, 1 << 22   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR55, 1 << 23   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR56, 1 << 24   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR57, 1 << 25   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR58, 1 << 26   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR59, 1 << 27   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR60, 1 << 28   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR61, 1 << 29   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR62, 1 << 30   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
        .equ EXTI_CPUEMR2_MR63, 1 << 31   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+32)  
 
    .equ EXTI_CPUPR2, EXTI_BASE + 0x98 @ (EXTI pending register) 
        .equ EXTI_CPUPR2_PR49, 1 << 17   @ bitWidth 1 (Configurable event inputs x+32 Pending  bit)  
        .equ EXTI_CPUPR2_PR51, 1 << 19   @ bitWidth 1 (Configurable event inputs x+32 Pending  bit)  
 
    .equ EXTI_CPUIMR3, EXTI_BASE + 0xA0 @ (EXTI interrupt mask register) 
        .equ EXTI_CPUIMR3_MR64, 1 << 0   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR65, 1 << 1   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR66, 1 << 2   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR67, 1 << 3   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR68, 1 << 4   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR69, 1 << 5   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR70, 1 << 6   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR71, 1 << 7   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR72, 1 << 8   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR73, 1 << 9   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR74, 1 << 10   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR75, 1 << 11   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR76, 1 << 12   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR77, 1 << 13   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR78, 1 << 14   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR79, 1 << 15   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR80, 1 << 16   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR82, 1 << 18   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR84, 1 << 20   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR85, 1 << 21   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR86, 1 << 22   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR87, 1 << 23   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
        .equ EXTI_CPUIMR3_MR88, 1 << 24   @ bitWidth 1 (CPU Interrupt Mask on Direct Event input  x+64)  
 
    .equ EXTI_CPUEMR3, EXTI_BASE + 0xA4 @ (EXTI event mask register) 
        .equ EXTI_CPUEMR3_MR64, 1 << 0   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR65, 1 << 1   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR66, 1 << 2   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR67, 1 << 3   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR68, 1 << 4   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR69, 1 << 5   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR70, 1 << 6   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR71, 1 << 7   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR72, 1 << 8   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR73, 1 << 9   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR74, 1 << 10   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR75, 1 << 11   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR76, 1 << 12   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR77, 1 << 13   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR78, 1 << 14   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR79, 1 << 15   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR80, 1 << 16   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR82, 1 << 18   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR84, 1 << 20   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR85, 1 << 21   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR86, 1 << 22   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR87, 1 << 23   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
        .equ EXTI_CPUEMR3_MR88, 1 << 24   @ bitWidth 1 (CPU Event mask on Event input  x+64)  
 
    .equ EXTI_CPUPR3, EXTI_BASE + 0xA8 @ (EXTI pending register) 
        .equ EXTI_CPUPR3_PR82, 1 << 18   @ bitWidth 1 (Configurable event inputs x+64 Pending  bit)  
        .equ EXTI_CPUPR3_PR84, 1 << 20   @ bitWidth 1 (Configurable event inputs x+64 Pending  bit)  
        .equ EXTI_CPUPR3_PR85, 1 << 21   @ bitWidth 1 (Configurable event inputs x+64 Pending  bit)  
        .equ EXTI_CPUPR3_PR86, 1 << 22   @ bitWidth 1 (Configurable event inputs x+64 Pending  bit)  
 

@=========================== DELAY_Block_SDMMC1 ===========================@
.equ DELAY_Block_SDMMC1_BASE, 0x52008000 @ (DELAY_Block_SDMMC1) 
    .equ DELAY_Block_SDMMC1_CR, DELAY_Block_SDMMC1_BASE + 0x0 @ (DLYB control register) 
        .equ DELAY_Block_SDMMC1_CR_DEN, 1 << 0   @ bitWidth 1 (Delay block enable bit)  
        .equ DELAY_Block_SDMMC1_CR_SEN, 1 << 1   @ bitWidth 1 (Sampler length enable bit)  
 
    .equ DELAY_Block_SDMMC1_CFGR, DELAY_Block_SDMMC1_BASE + 0x4 @ (DLYB configuration register) 
        .equ DELAY_Block_SDMMC1_CFGR_SEL_Shift, 0   @ bitWidth 4 (Select the phase for the Output  clock)  
        .equ DELAY_Block_SDMMC1_CFGR_UNIT_Shift, 8   @ bitWidth 7 (Delay Defines the delay of a Unit delay  cell)  
        .equ DELAY_Block_SDMMC1_CFGR_LNG_Shift, 16   @ bitWidth 12 (Delay line length value)  
        .equ DELAY_Block_SDMMC1_CFGR_LNGF, 1 << 31   @ bitWidth 1 (Length valid flag)  
 

@=========================== DELAY_Block_QUADSPI ===========================@
.equ DELAY_Block_QUADSPI_BASE, 0x52006000 @ (DELAY_Block_SDMMC1) 
    .equ DELAY_Block_QUADSPI_CR, DELAY_Block_QUADSPI_BASE + 0x0 @ (DLYB control register) 
        .equ DELAY_Block_QUADSPI_CR_DEN, 1 << 0   @ bitWidth 1 (Delay block enable bit)  
        .equ DELAY_Block_QUADSPI_CR_SEN, 1 << 1   @ bitWidth 1 (Sampler length enable bit)  
 
    .equ DELAY_Block_QUADSPI_CFGR, DELAY_Block_QUADSPI_BASE + 0x4 @ (DLYB configuration register) 
        .equ DELAY_Block_QUADSPI_CFGR_SEL_Shift, 0   @ bitWidth 4 (Select the phase for the Output  clock)  
        .equ DELAY_Block_QUADSPI_CFGR_UNIT_Shift, 8   @ bitWidth 7 (Delay Defines the delay of a Unit delay  cell)  
        .equ DELAY_Block_QUADSPI_CFGR_LNG_Shift, 16   @ bitWidth 12 (Delay line length value)  
        .equ DELAY_Block_QUADSPI_CFGR_LNGF, 1 << 31   @ bitWidth 1 (Length valid flag)  
 

@=========================== DELAY_Block_SDMMC2 ===========================@
.equ DELAY_Block_SDMMC2_BASE, 0x48022800 @ (DELAY_Block_SDMMC1) 
    .equ DELAY_Block_SDMMC2_CR, DELAY_Block_SDMMC2_BASE + 0x0 @ (DLYB control register) 
        .equ DELAY_Block_SDMMC2_CR_DEN, 1 << 0   @ bitWidth 1 (Delay block enable bit)  
        .equ DELAY_Block_SDMMC2_CR_SEN, 1 << 1   @ bitWidth 1 (Sampler length enable bit)  
 
    .equ DELAY_Block_SDMMC2_CFGR, DELAY_Block_SDMMC2_BASE + 0x4 @ (DLYB configuration register) 
        .equ DELAY_Block_SDMMC2_CFGR_SEL_Shift, 0   @ bitWidth 4 (Select the phase for the Output  clock)  
        .equ DELAY_Block_SDMMC2_CFGR_UNIT_Shift, 8   @ bitWidth 7 (Delay Defines the delay of a Unit delay  cell)  
        .equ DELAY_Block_SDMMC2_CFGR_LNG_Shift, 16   @ bitWidth 12 (Delay line length value)  
        .equ DELAY_Block_SDMMC2_CFGR_LNGF, 1 << 31   @ bitWidth 1 (Length valid flag)  
 

@=========================== Flash ===========================@
.equ Flash_BASE, 0x52002000 @ (Flash) 
    .equ Flash_ACR, Flash_BASE + 0x0 @ (Access control register) 
        .equ Flash_ACR_LATENCY_Shift, 0   @ bitWidth 3 (Read latency)  
        .equ Flash_ACR_WRHIGHFREQ_Shift, 4   @ bitWidth 2 (Flash signal delay)  
 
    .equ Flash_ACR_, Flash_BASE + 0x100 @ (Access control register) 
        .equ Flash_ACR__LATENCY_Shift, 0   @ bitWidth 3 (Read latency)  
        .equ Flash_ACR__WRHIGHFREQ_Shift, 4   @ bitWidth 2 (Flash signal delay)  
 
    .equ Flash_KEYR1, Flash_BASE + 0x4 @ (FLASH key register for bank 1) 
        .equ Flash_KEYR1_KEYR1_Shift, 0   @ bitWidth 32 (Bank 1 access configuration unlock  key)  
 
    .equ Flash_OPTKEYR, Flash_BASE + 0x8 @ (FLASH option key register) 
        .equ Flash_OPTKEYR_OPTKEYR_Shift, 0   @ bitWidth 32 (Unlock key option bytes)  
 
    .equ Flash_OPTKEYR_, Flash_BASE + 0x108 @ (FLASH option key register) 
        .equ Flash_OPTKEYR__OPTKEYR_Shift, 0   @ bitWidth 32 (Unlock key option bytes)  
 
    .equ Flash_CR1, Flash_BASE + 0xC @ (FLASH control register for bank  1) 
        .equ Flash_CR1_LOCK1, 1 << 0   @ bitWidth 1 (Bank 1 configuration lock  bit)  
        .equ Flash_CR1_PG1, 1 << 1   @ bitWidth 1 (Bank 1 program enable bit)  
        .equ Flash_CR1_SER1, 1 << 2   @ bitWidth 1 (Bank 1 sector erase  request)  
        .equ Flash_CR1_BER1, 1 << 3   @ bitWidth 1 (Bank 1 erase request)  
        .equ Flash_CR1_PSIZE1_Shift, 4   @ bitWidth 2 (Bank 1 program size)  
        .equ Flash_CR1_FW1, 1 << 6   @ bitWidth 1 (Bank 1 write forcing control  bit)  
        .equ Flash_CR1_START1, 1 << 7   @ bitWidth 1 (Bank 1 bank or sector erase start  control bit)  
        .equ Flash_CR1_SNB1_Shift, 8   @ bitWidth 3 (Bank 1 sector erase selection  number)  
        .equ Flash_CR1_CRC_EN, 1 << 15   @ bitWidth 1 (Bank 1 CRC control bit)  
        .equ Flash_CR1_EOPIE1, 1 << 16   @ bitWidth 1 (Bank 1 end-of-program interrupt control  bit)  
        .equ Flash_CR1_WRPERRIE1, 1 << 17   @ bitWidth 1 (Bank 1 write protection error interrupt  enable bit)  
        .equ Flash_CR1_PGSERRIE1, 1 << 18   @ bitWidth 1 (Bank 1 programming sequence error  interrupt enable bit)  
        .equ Flash_CR1_STRBERRIE1, 1 << 19   @ bitWidth 1 (Bank 1 strobe error interrupt enable  bit)  
        .equ Flash_CR1_INCERRIE1, 1 << 21   @ bitWidth 1 (Bank 1 inconsistency error interrupt  enable bit)  
        .equ Flash_CR1_OPERRIE1, 1 << 22   @ bitWidth 1 (Bank 1 write/erase error interrupt  enable bit)  
        .equ Flash_CR1_RDPERRIE1, 1 << 23   @ bitWidth 1 (Bank 1 read protection error interrupt  enable bit)  
        .equ Flash_CR1_RDSERRIE1, 1 << 24   @ bitWidth 1 (Bank 1 secure error interrupt enable  bit)  
        .equ Flash_CR1_SNECCERRIE1, 1 << 25   @ bitWidth 1 (Bank 1 ECC single correction error  interrupt enable bit)  
        .equ Flash_CR1_DBECCERRIE1, 1 << 26   @ bitWidth 1 (Bank 1 ECC double detection error  interrupt enable bit)  
        .equ Flash_CR1_CRCENDIE1, 1 << 27   @ bitWidth 1 (Bank 1 end of CRC calculation interrupt  enable bit)  
 
    .equ Flash_SR1, Flash_BASE + 0x10 @ (FLASH status register for bank  1) 
        .equ Flash_SR1_BSY1, 1 << 0   @ bitWidth 1 (Bank 1 ongoing program  flag)  
        .equ Flash_SR1_WBNE1, 1 << 1   @ bitWidth 1 (Bank 1 write buffer not empty  flag)  
        .equ Flash_SR1_QW1, 1 << 2   @ bitWidth 1 (Bank 1 wait queue flag)  
        .equ Flash_SR1_CRC_BUSY1, 1 << 3   @ bitWidth 1 (Bank 1 CRC busy flag)  
        .equ Flash_SR1_EOP1, 1 << 16   @ bitWidth 1 (Bank 1 end-of-program flag)  
        .equ Flash_SR1_WRPERR1, 1 << 17   @ bitWidth 1 (Bank 1 write protection error  flag)  
        .equ Flash_SR1_PGSERR1, 1 << 18   @ bitWidth 1 (Bank 1 programming sequence error  flag)  
        .equ Flash_SR1_STRBERR1, 1 << 19   @ bitWidth 1 (Bank 1 strobe error flag)  
        .equ Flash_SR1_INCERR1, 1 << 21   @ bitWidth 1 (Bank 1 inconsistency error  flag)  
        .equ Flash_SR1_OPERR1, 1 << 22   @ bitWidth 1 (Bank 1 write/erase error  flag)  
        .equ Flash_SR1_RDPERR1, 1 << 23   @ bitWidth 1 (Bank 1 read protection error  flag)  
        .equ Flash_SR1_RDSERR1, 1 << 24   @ bitWidth 1 (Bank 1 secure error flag)  
        .equ Flash_SR1_SNECCERR11, 1 << 25   @ bitWidth 1 (Bank 1 single correction error  flag)  
        .equ Flash_SR1_DBECCERR1, 1 << 26   @ bitWidth 1 (Bank 1 ECC double detection error  flag)  
        .equ Flash_SR1_CRCEND1, 1 << 27   @ bitWidth 1 (Bank 1 CRC-complete flag)  
 
    .equ Flash_CCR1, Flash_BASE + 0x14 @ (FLASH clear control register for bank  1) 
        .equ Flash_CCR1_CLR_EOP1, 1 << 16   @ bitWidth 1 (Bank 1 EOP1 flag clear bit)  
        .equ Flash_CCR1_CLR_WRPERR1, 1 << 17   @ bitWidth 1 (Bank 1 WRPERR1 flag clear  bit)  
        .equ Flash_CCR1_CLR_PGSERR1, 1 << 18   @ bitWidth 1 (Bank 1 PGSERR1 flag clear  bi)  
        .equ Flash_CCR1_CLR_STRBERR1, 1 << 19   @ bitWidth 1 (Bank 1 STRBERR1 flag clear  bit)  
        .equ Flash_CCR1_CLR_INCERR1, 1 << 21   @ bitWidth 1 (Bank 1 INCERR1 flag clear  bit)  
        .equ Flash_CCR1_CLR_OPERR1, 1 << 22   @ bitWidth 1 (Bank 1 OPERR1 flag clear  bit)  
        .equ Flash_CCR1_CLR_RDPERR1, 1 << 23   @ bitWidth 1 (Bank 1 RDPERR1 flag clear  bit)  
        .equ Flash_CCR1_CLR_RDSERR1, 1 << 24   @ bitWidth 1 (Bank 1 RDSERR1 flag clear  bit)  
        .equ Flash_CCR1_CLR_SNECCERR1, 1 << 25   @ bitWidth 1 (Bank 1 SNECCERR1 flag clear  bit)  
        .equ Flash_CCR1_CLR_DBECCERR1, 1 << 26   @ bitWidth 1 (Bank 1 DBECCERR1 flag clear  bit)  
        .equ Flash_CCR1_CLR_CRCEND1, 1 << 27   @ bitWidth 1 (Bank 1 CRCEND1 flag clear  bit)  
 
    .equ Flash_OPTCR, Flash_BASE + 0x18 @ (FLASH option control register) 
        .equ Flash_OPTCR_OPTLOCK, 1 << 0   @ bitWidth 1 (FLASH_OPTCR lock option configuration  bit)  
        .equ Flash_OPTCR_OPTSTART, 1 << 1   @ bitWidth 1 (Option byte start change option  configuration bit)  
        .equ Flash_OPTCR_MER, 1 << 4   @ bitWidth 1 (Flash mass erase enable  bit)  
        .equ Flash_OPTCR_OPTCHANGEERRIE, 1 << 30   @ bitWidth 1 (Option byte change error interrupt  enable bit)  
        .equ Flash_OPTCR_SWAP_BANK, 1 << 31   @ bitWidth 1 (Bank swapping configuration  bit)  
 
    .equ Flash_OPTCR_, Flash_BASE + 0x118 @ (FLASH option control register) 
        .equ Flash_OPTCR__OPTLOCK, 1 << 0   @ bitWidth 1 (FLASH_OPTCR lock option configuration  bit)  
        .equ Flash_OPTCR__OPTSTART, 1 << 1   @ bitWidth 1 (Option byte start change option  configuration bit)  
        .equ Flash_OPTCR__MER, 1 << 4   @ bitWidth 1 (Flash mass erase enable  bit)  
        .equ Flash_OPTCR__OPTCHANGEERRIE, 1 << 30   @ bitWidth 1 (Option byte change error interrupt  enable bit)  
        .equ Flash_OPTCR__SWAP_BANK, 1 << 31   @ bitWidth 1 (Bank swapping configuration  bit)  
 
    .equ Flash_OPTSR_CUR_, Flash_BASE + 0x11C @ (FLASH option status register) 
        .equ Flash_OPTSR_CUR__OPT_BUSY, 1 << 0   @ bitWidth 1 (Option byte change ongoing  flag)  
        .equ Flash_OPTSR_CUR__BOR_LEV_Shift, 2   @ bitWidth 2 (Brownout level option status  bit)  
        .equ Flash_OPTSR_CUR__IWDG1_HW, 1 << 4   @ bitWidth 1 (IWDG1 control option status  bit)  
        .equ Flash_OPTSR_CUR__nRST_STOP_D1, 1 << 6   @ bitWidth 1 (D1 DStop entry reset option status  bit)  
        .equ Flash_OPTSR_CUR__nRST_STBY_D1, 1 << 7   @ bitWidth 1 (D1 DStandby entry reset option status  bit)  
        .equ Flash_OPTSR_CUR__RDP_Shift, 8   @ bitWidth 8 (Readout protection level option status  byte)  
        .equ Flash_OPTSR_CUR__FZ_IWDG_STOP, 1 << 17   @ bitWidth 1 (IWDG Stop mode freeze option status  bit)  
        .equ Flash_OPTSR_CUR__FZ_IWDG_SDBY, 1 << 18   @ bitWidth 1 (IWDG Standby mode freeze option status  bit)  
        .equ Flash_OPTSR_CUR__ST_RAM_SIZE_Shift, 19   @ bitWidth 2 (DTCM RAM size option  status)  
        .equ Flash_OPTSR_CUR__SECURITY, 1 << 21   @ bitWidth 1 (Security enable option status  bit)  
        .equ Flash_OPTSR_CUR__RSS1, 1 << 26   @ bitWidth 1 (User option bit 1)  
        .equ Flash_OPTSR_CUR__PERSO_OK, 1 << 28   @ bitWidth 1 (Device personalization status  bit)  
        .equ Flash_OPTSR_CUR__IO_HSLV, 1 << 29   @ bitWidth 1 (I/O high-speed at low-voltage status bit  PRODUCT_BELOW_25V)  
        .equ Flash_OPTSR_CUR__OPTCHANGEERR, 1 << 30   @ bitWidth 1 (Option byte change error  flag)  
        .equ Flash_OPTSR_CUR__SWAP_BANK_OPT, 1 << 31   @ bitWidth 1 (Bank swapping option status  bit)  
 
    .equ Flash_OPTSR_CUR, Flash_BASE + 0x1C @ (FLASH option status register) 
        .equ Flash_OPTSR_CUR_OPT_BUSY, 1 << 0   @ bitWidth 1 (Option byte change ongoing  flag)  
        .equ Flash_OPTSR_CUR_BOR_LEV_Shift, 2   @ bitWidth 2 (Brownout level option status  bit)  
        .equ Flash_OPTSR_CUR_IWDG1_HW, 1 << 4   @ bitWidth 1 (IWDG1 control option status  bit)  
        .equ Flash_OPTSR_CUR_nRST_STOP_D1, 1 << 6   @ bitWidth 1 (D1 DStop entry reset option status  bit)  
        .equ Flash_OPTSR_CUR_nRST_STBY_D1, 1 << 7   @ bitWidth 1 (D1 DStandby entry reset option status  bit)  
        .equ Flash_OPTSR_CUR_RDP_Shift, 8   @ bitWidth 8 (Readout protection level option status  byte)  
        .equ Flash_OPTSR_CUR_FZ_IWDG_STOP, 1 << 17   @ bitWidth 1 (IWDG Stop mode freeze option status  bit)  
        .equ Flash_OPTSR_CUR_FZ_IWDG_SDBY, 1 << 18   @ bitWidth 1 (IWDG Standby mode freeze option status  bit)  
        .equ Flash_OPTSR_CUR_ST_RAM_SIZE_Shift, 19   @ bitWidth 2 (DTCM RAM size option  status)  
        .equ Flash_OPTSR_CUR_SECURITY, 1 << 21   @ bitWidth 1 (Security enable option status  bit)  
        .equ Flash_OPTSR_CUR_RSS1, 1 << 26   @ bitWidth 1 (User option bit 1)  
        .equ Flash_OPTSR_CUR_PERSO_OK, 1 << 28   @ bitWidth 1 (Device personalization status  bit)  
        .equ Flash_OPTSR_CUR_IO_HSLV, 1 << 29   @ bitWidth 1 (I/O high-speed at low-voltage status bit  PRODUCT_BELOW_25V)  
        .equ Flash_OPTSR_CUR_OPTCHANGEERR, 1 << 30   @ bitWidth 1 (Option byte change error  flag)  
        .equ Flash_OPTSR_CUR_SWAP_BANK_OPT, 1 << 31   @ bitWidth 1 (Bank swapping option status  bit)  
 
    .equ Flash_OPTSR_PRG, Flash_BASE + 0x20 @ (FLASH option status register) 
        .equ Flash_OPTSR_PRG_BOR_LEV_Shift, 2   @ bitWidth 2 (BOR reset level option configuration  bits)  
        .equ Flash_OPTSR_PRG_IWDG1_HW, 1 << 4   @ bitWidth 1 (IWDG1 option configuration  bit)  
        .equ Flash_OPTSR_PRG_nRST_STOP_D1, 1 << 6   @ bitWidth 1 (Option byte erase after D1 DStop option  configuration bit)  
        .equ Flash_OPTSR_PRG_nRST_STBY_D1, 1 << 7   @ bitWidth 1 (Option byte erase after D1 DStandby  option configuration bit)  
        .equ Flash_OPTSR_PRG_RDP_Shift, 8   @ bitWidth 8 (Readout protection level option  configuration byte)  
        .equ Flash_OPTSR_PRG_FZ_IWDG_STOP, 1 << 17   @ bitWidth 1 (IWDG Stop mode freeze option  configuration bit)  
        .equ Flash_OPTSR_PRG_FZ_IWDG_SDBY, 1 << 18   @ bitWidth 1 (IWDG Standby mode freeze option  configuration bit)  
        .equ Flash_OPTSR_PRG_ST_RAM_SIZE_Shift, 19   @ bitWidth 2 (DTCM size select option configuration  bits)  
        .equ Flash_OPTSR_PRG_SECURITY, 1 << 21   @ bitWidth 1 (Security option configuration  bit)  
        .equ Flash_OPTSR_PRG_RSS1, 1 << 26   @ bitWidth 1 (User option configuration bit  1)  
        .equ Flash_OPTSR_PRG_RSS2, 1 << 27   @ bitWidth 1 (User option configuration bit  2)  
        .equ Flash_OPTSR_PRG_IO_HSLV, 1 << 29   @ bitWidth 1 (I/O high-speed at low-voltage  PRODUCT_BELOW_25V)  
        .equ Flash_OPTSR_PRG_SWAP_BANK_OPT, 1 << 31   @ bitWidth 1 (Bank swapping option configuration  bit)  
 
    .equ Flash_OPTSR_PRG_, Flash_BASE + 0x120 @ (FLASH option status register) 
        .equ Flash_OPTSR_PRG__BOR_LEV_Shift, 2   @ bitWidth 2 (BOR reset level option configuration  bits)  
        .equ Flash_OPTSR_PRG__IWDG1_HW, 1 << 4   @ bitWidth 1 (IWDG1 option configuration  bit)  
        .equ Flash_OPTSR_PRG__nRST_STOP_D1, 1 << 6   @ bitWidth 1 (Option byte erase after D1 DStop option  configuration bit)  
        .equ Flash_OPTSR_PRG__nRST_STBY_D1, 1 << 7   @ bitWidth 1 (Option byte erase after D1 DStandby  option configuration bit)  
        .equ Flash_OPTSR_PRG__RDP_Shift, 8   @ bitWidth 8 (Readout protection level option  configuration byte)  
        .equ Flash_OPTSR_PRG__FZ_IWDG_STOP, 1 << 17   @ bitWidth 1 (IWDG Stop mode freeze option  configuration bit)  
        .equ Flash_OPTSR_PRG__FZ_IWDG_SDBY, 1 << 18   @ bitWidth 1 (IWDG Standby mode freeze option  configuration bit)  
        .equ Flash_OPTSR_PRG__ST_RAM_SIZE_Shift, 19   @ bitWidth 2 (DTCM size select option configuration  bits)  
        .equ Flash_OPTSR_PRG__SECURITY, 1 << 21   @ bitWidth 1 (Security option configuration  bit)  
        .equ Flash_OPTSR_PRG__RSS1, 1 << 26   @ bitWidth 1 (User option configuration bit  1)  
        .equ Flash_OPTSR_PRG__RSS2, 1 << 27   @ bitWidth 1 (User option configuration bit  2)  
        .equ Flash_OPTSR_PRG__IO_HSLV, 1 << 29   @ bitWidth 1 (I/O high-speed at low-voltage  PRODUCT_BELOW_25V)  
        .equ Flash_OPTSR_PRG__SWAP_BANK_OPT, 1 << 31   @ bitWidth 1 (Bank swapping option configuration  bit)  
 
    .equ Flash_OPTCCR_, Flash_BASE + 0x124 @ (FLASH option clear control  register) 
        .equ Flash_OPTCCR__CLR_OPTCHANGEERR, 1 << 30   @ bitWidth 1 (OPTCHANGEERR reset bit)  
 
    .equ Flash_OPTCCR, Flash_BASE + 0x24 @ (FLASH option clear control  register) 
        .equ Flash_OPTCCR_CLR_OPTCHANGEERR, 1 << 30   @ bitWidth 1 (OPTCHANGEERR reset bit)  
 
    .equ Flash_PRAR_CUR1, Flash_BASE + 0x28 @ (FLASH protection address for bank  1) 
        .equ Flash_PRAR_CUR1_PROT_AREA_START1_Shift, 0   @ bitWidth 12 (Bank 1 lowest PCROP protected  address)  
        .equ Flash_PRAR_CUR1_PROT_AREA_END1_Shift, 16   @ bitWidth 12 (Bank 1 highest PCROP protected  address)  
        .equ Flash_PRAR_CUR1_DMEP1, 1 << 31   @ bitWidth 1 (Bank 1 PCROP protected erase enable  option status bit)  
 
    .equ Flash_PRAR_PRG1, Flash_BASE + 0x2C @ (FLASH protection address for bank  1) 
        .equ Flash_PRAR_PRG1_PROT_AREA_START1_Shift, 0   @ bitWidth 12 (Bank 1 lowest PCROP protected address  configuration)  
        .equ Flash_PRAR_PRG1_PROT_AREA_END1_Shift, 16   @ bitWidth 12 (Bank 1 highest PCROP protected address  configuration)  
        .equ Flash_PRAR_PRG1_DMEP1, 1 << 31   @ bitWidth 1 (Bank 1 PCROP protected erase enable  option configuration bit)  
 
    .equ Flash_SCAR_CUR1, Flash_BASE + 0x30 @ (FLASH secure address for bank  1) 
        .equ Flash_SCAR_CUR1_SEC_AREA_START1_Shift, 0   @ bitWidth 12 (Bank 1 lowest secure protected  address)  
        .equ Flash_SCAR_CUR1_SEC_AREA_END1_Shift, 16   @ bitWidth 12 (Bank 1 highest secure protected  address)  
        .equ Flash_SCAR_CUR1_DMES1, 1 << 31   @ bitWidth 1 (Bank 1 secure protected erase enable  option status bit)  
 
    .equ Flash_SCAR_PRG1, Flash_BASE + 0x34 @ (FLASH secure address for bank  1) 
        .equ Flash_SCAR_PRG1_SEC_AREA_START1_Shift, 0   @ bitWidth 12 (Bank 1 lowest secure protected address  configuration)  
        .equ Flash_SCAR_PRG1_SEC_AREA_END1_Shift, 16   @ bitWidth 12 (Bank 1 highest secure protected address  configuration)  
        .equ Flash_SCAR_PRG1_DMES1, 1 << 31   @ bitWidth 1 (Bank 1 secure protected erase enable  option configuration bit)  
 
    .equ Flash_WPSN_CUR1R, Flash_BASE + 0x38 @ (FLASH write sector protection for bank  1) 
        .equ Flash_WPSN_CUR1R_WRPSn1_Shift, 0   @ bitWidth 8 (Bank 1 sector write protection option  status byte)  
 
    .equ Flash_WPSN_PRG1R, Flash_BASE + 0x3C @ (FLASH write sector protection for bank  1) 
        .equ Flash_WPSN_PRG1R_WRPSn1_Shift, 0   @ bitWidth 8 (Bank 1 sector write protection  configuration byte)  
 
    .equ Flash_BOOT_CURR, Flash_BASE + 0x40 @ (FLASH register with boot  address) 
        .equ Flash_BOOT_CURR_BOOT_ADD0_Shift, 0   @ bitWidth 16 (Boot address 0)  
        .equ Flash_BOOT_CURR_BOOT_ADD1_Shift, 16   @ bitWidth 16 (Boot address 1)  
 
    .equ Flash_BOOT_PRGR, Flash_BASE + 0x44 @ (FLASH register with boot  address) 
        .equ Flash_BOOT_PRGR_BOOT_ADD0_Shift, 0   @ bitWidth 16 (Boot address 0)  
        .equ Flash_BOOT_PRGR_BOOT_ADD1_Shift, 16   @ bitWidth 16 (Boot address 1)  
 
    .equ Flash_CRCCR1, Flash_BASE + 0x50 @ (FLASH CRC control register for bank  1) 
        .equ Flash_CRCCR1_CRC_SECT_Shift, 0   @ bitWidth 3 (Bank 1 CRC sector number)  
        .equ Flash_CRCCR1_ALL_BANK, 1 << 7   @ bitWidth 1 (Bank 1 CRC select bit)  
        .equ Flash_CRCCR1_CRC_BY_SECT, 1 << 8   @ bitWidth 1 (Bank 1 CRC sector mode select  bit)  
        .equ Flash_CRCCR1_ADD_SECT, 1 << 9   @ bitWidth 1 (Bank 1 CRC sector select  bit)  
        .equ Flash_CRCCR1_CLEAN_SECT, 1 << 10   @ bitWidth 1 (Bank 1 CRC sector list clear  bit)  
        .equ Flash_CRCCR1_START_CRC, 1 << 16   @ bitWidth 1 (Bank 1 CRC start bit)  
        .equ Flash_CRCCR1_CLEAN_CRC, 1 << 17   @ bitWidth 1 (Bank 1 CRC clear bit)  
        .equ Flash_CRCCR1_CRC_BURST_Shift, 20   @ bitWidth 2 (Bank 1 CRC burst size)  
 
    .equ Flash_CRCSADD1R, Flash_BASE + 0x54 @ (FLASH CRC start address register for bank  1) 
        .equ Flash_CRCSADD1R_CRC_START_ADDR_Shift, 0   @ bitWidth 32 (CRC start address on bank  1)  
 
    .equ Flash_CRCEADD1R, Flash_BASE + 0x58 @ (FLASH CRC end address register for bank  1) 
        .equ Flash_CRCEADD1R_CRC_END_ADDR_Shift, 0   @ bitWidth 32 (CRC end address on bank 1)  
 
    .equ Flash_CRCDATAR, Flash_BASE + 0x5C @ (FLASH CRC data register) 
        .equ Flash_CRCDATAR_CRC_DATA_Shift, 0   @ bitWidth 32 (CRC result)  
 
    .equ Flash_ECC_FA1R, Flash_BASE + 0x60 @ (FLASH ECC fail address for bank  1) 
        .equ Flash_ECC_FA1R_FAIL_ECC_ADDR1_Shift, 0   @ bitWidth 15 (Bank 1 ECC error address)  
 
    .equ Flash_KEYR2, Flash_BASE + 0x104 @ (FLASH key register for bank 2) 
        .equ Flash_KEYR2_KEYR2_Shift, 0   @ bitWidth 32 (Bank 2 access configuration unlock  key)  
 
    .equ Flash_CR2, Flash_BASE + 0x10C @ (FLASH control register for bank  2) 
        .equ Flash_CR2_LOCK2, 1 << 0   @ bitWidth 1 (Bank 2 configuration lock  bit)  
        .equ Flash_CR2_PG2, 1 << 1   @ bitWidth 1 (Bank 2 program enable bit)  
        .equ Flash_CR2_SER2, 1 << 2   @ bitWidth 1 (Bank 2 sector erase  request)  
        .equ Flash_CR2_BER2, 1 << 3   @ bitWidth 1 (Bank 2 erase request)  
        .equ Flash_CR2_PSIZE2_Shift, 4   @ bitWidth 2 (Bank 2 program size)  
        .equ Flash_CR2_FW2, 1 << 6   @ bitWidth 1 (Bank 2 write forcing control  bit)  
        .equ Flash_CR2_START2, 1 << 7   @ bitWidth 1 (Bank 2 bank or sector erase start  control bit)  
        .equ Flash_CR2_SNB2_Shift, 8   @ bitWidth 3 (Bank 2 sector erase selection  number)  
        .equ Flash_CR2_CRC_EN, 1 << 15   @ bitWidth 1 (Bank 2 CRC control bit)  
        .equ Flash_CR2_EOPIE2, 1 << 16   @ bitWidth 1 (Bank 2 end-of-program interrupt control  bit)  
        .equ Flash_CR2_WRPERRIE2, 1 << 17   @ bitWidth 1 (Bank 2 write protection error interrupt  enable bit)  
        .equ Flash_CR2_PGSERRIE2, 1 << 18   @ bitWidth 1 (Bank 2 programming sequence error  interrupt enable bit)  
        .equ Flash_CR2_STRBERRIE2, 1 << 19   @ bitWidth 1 (Bank 2 strobe error interrupt enable  bit)  
        .equ Flash_CR2_INCERRIE2, 1 << 21   @ bitWidth 1 (Bank 2 inconsistency error interrupt  enable bit)  
        .equ Flash_CR2_OPERRIE2, 1 << 22   @ bitWidth 1 (Bank 2 write/erase error interrupt  enable bit)  
        .equ Flash_CR2_RDPERRIE2, 1 << 23   @ bitWidth 1 (Bank 2 read protection error interrupt  enable bit)  
        .equ Flash_CR2_RDSERRIE2, 1 << 24   @ bitWidth 1 (Bank 2 secure error interrupt enable  bit)  
        .equ Flash_CR2_SNECCERRIE2, 1 << 25   @ bitWidth 1 (Bank 2 ECC single correction error  interrupt enable bit)  
        .equ Flash_CR2_DBECCERRIE2, 1 << 26   @ bitWidth 1 (Bank 2 ECC double detection error  interrupt enable bit)  
        .equ Flash_CR2_CRCENDIE2, 1 << 27   @ bitWidth 1 (Bank 2 end of CRC calculation interrupt  enable bit)  
 
    .equ Flash_SR2, Flash_BASE + 0x110 @ (FLASH status register for bank  2) 
        .equ Flash_SR2_BSY2, 1 << 0   @ bitWidth 1 (Bank 2 ongoing program  flag)  
        .equ Flash_SR2_WBNE2, 1 << 1   @ bitWidth 1 (Bank 2 write buffer not empty  flag)  
        .equ Flash_SR2_QW2, 1 << 2   @ bitWidth 1 (Bank 2 wait queue flag)  
        .equ Flash_SR2_CRC_BUSY2, 1 << 3   @ bitWidth 1 (Bank 2 CRC busy flag)  
        .equ Flash_SR2_EOP2, 1 << 16   @ bitWidth 1 (Bank 2 end-of-program flag)  
        .equ Flash_SR2_WRPERR2, 1 << 17   @ bitWidth 1 (Bank 2 write protection error  flag)  
        .equ Flash_SR2_PGSERR2, 1 << 18   @ bitWidth 1 (Bank 2 programming sequence error  flag)  
        .equ Flash_SR2_STRBERR2, 1 << 19   @ bitWidth 1 (Bank 2 strobe error flag)  
        .equ Flash_SR2_INCERR2, 1 << 21   @ bitWidth 1 (Bank 2 inconsistency error  flag)  
        .equ Flash_SR2_OPERR2, 1 << 22   @ bitWidth 1 (Bank 2 write/erase error  flag)  
        .equ Flash_SR2_RDPERR2, 1 << 23   @ bitWidth 1 (Bank 2 read protection error  flag)  
        .equ Flash_SR2_RDSERR2, 1 << 24   @ bitWidth 1 (Bank 2 secure error flag)  
        .equ Flash_SR2_SNECCERR2, 1 << 25   @ bitWidth 1 (Bank 2 single correction error  flag)  
        .equ Flash_SR2_DBECCERR2, 1 << 26   @ bitWidth 1 (Bank 2 ECC double detection error  flag)  
        .equ Flash_SR2_CRCEND2, 1 << 27   @ bitWidth 1 (Bank 2 CRC-complete flag)  
 
    .equ Flash_CCR2, Flash_BASE + 0x114 @ (FLASH clear control register for bank  2) 
        .equ Flash_CCR2_CLR_EOP2, 1 << 16   @ bitWidth 1 (Bank 1 EOP1 flag clear bit)  
        .equ Flash_CCR2_CLR_WRPERR2, 1 << 17   @ bitWidth 1 (Bank 2 WRPERR1 flag clear  bit)  
        .equ Flash_CCR2_CLR_PGSERR2, 1 << 18   @ bitWidth 1 (Bank 2 PGSERR1 flag clear  bi)  
        .equ Flash_CCR2_CLR_STRBERR2, 1 << 19   @ bitWidth 1 (Bank 2 STRBERR1 flag clear  bit)  
        .equ Flash_CCR2_CLR_INCERR2, 1 << 21   @ bitWidth 1 (Bank 2 INCERR1 flag clear  bit)  
        .equ Flash_CCR2_CLR_OPERR2, 1 << 22   @ bitWidth 1 (Bank 2 OPERR1 flag clear  bit)  
        .equ Flash_CCR2_CLR_RDPERR2, 1 << 23   @ bitWidth 1 (Bank 2 RDPERR1 flag clear  bit)  
        .equ Flash_CCR2_CLR_RDSERR1, 1 << 24   @ bitWidth 1 (Bank 1 RDSERR1 flag clear  bit)  
        .equ Flash_CCR2_CLR_SNECCERR2, 1 << 25   @ bitWidth 1 (Bank 2 SNECCERR1 flag clear  bit)  
        .equ Flash_CCR2_CLR_DBECCERR1, 1 << 26   @ bitWidth 1 (Bank 1 DBECCERR1 flag clear  bit)  
        .equ Flash_CCR2_CLR_CRCEND2, 1 << 27   @ bitWidth 1 (Bank 2 CRCEND1 flag clear  bit)  
 
    .equ Flash_PRAR_CUR2, Flash_BASE + 0x128 @ (FLASH protection address for bank  1) 
        .equ Flash_PRAR_CUR2_PROT_AREA_START2_Shift, 0   @ bitWidth 12 (Bank 2 lowest PCROP protected  address)  
        .equ Flash_PRAR_CUR2_PROT_AREA_END2_Shift, 16   @ bitWidth 12 (Bank 2 highest PCROP protected  address)  
        .equ Flash_PRAR_CUR2_DMEP2, 1 << 31   @ bitWidth 1 (Bank 2 PCROP protected erase enable  option status bit)  
 
    .equ Flash_PRAR_PRG2, Flash_BASE + 0x2C @ (FLASH protection address for bank  2) 
        .equ Flash_PRAR_PRG2_PROT_AREA_START2_Shift, 0   @ bitWidth 12 (Bank 2 lowest PCROP protected address  configuration)  
        .equ Flash_PRAR_PRG2_PROT_AREA_END2_Shift, 16   @ bitWidth 12 (Bank 2 highest PCROP protected address  configuration)  
        .equ Flash_PRAR_PRG2_DMEP2, 1 << 31   @ bitWidth 1 (Bank 2 PCROP protected erase enable  option configuration bit)  
 
    .equ Flash_SCAR_CUR2, Flash_BASE + 0x130 @ (FLASH secure address for bank  2) 
        .equ Flash_SCAR_CUR2_SEC_AREA_START2_Shift, 0   @ bitWidth 12 (Bank 2 lowest secure protected  address)  
        .equ Flash_SCAR_CUR2_SEC_AREA_END2_Shift, 16   @ bitWidth 12 (Bank 2 highest secure protected  address)  
        .equ Flash_SCAR_CUR2_DMES2, 1 << 31   @ bitWidth 1 (Bank 2 secure protected erase enable  option status bit)  
 
    .equ Flash_SCAR_PRG2, Flash_BASE + 0x134 @ (FLASH secure address for bank  2) 
        .equ Flash_SCAR_PRG2_SEC_AREA_START2_Shift, 0   @ bitWidth 12 (Bank 2 lowest secure protected address  configuration)  
        .equ Flash_SCAR_PRG2_SEC_AREA_END2_Shift, 16   @ bitWidth 12 (Bank 2 highest secure protected address  configuration)  
        .equ Flash_SCAR_PRG2_DMES2, 1 << 31   @ bitWidth 1 (Bank 2 secure protected erase enable  option configuration bit)  
 
    .equ Flash_WPSN_CUR2R, Flash_BASE + 0x138 @ (FLASH write sector protection for bank  2) 
        .equ Flash_WPSN_CUR2R_WRPSn2_Shift, 0   @ bitWidth 8 (Bank 2 sector write protection option  status byte)  
 
    .equ Flash_WPSN_PRG2R, Flash_BASE + 0x13C @ (FLASH write sector protection for bank  2) 
        .equ Flash_WPSN_PRG2R_WRPSn2_Shift, 0   @ bitWidth 8 (Bank 2 sector write protection  configuration byte)  
 
    .equ Flash_CRCCR2, Flash_BASE + 0x150 @ (FLASH CRC control register for bank  1) 
        .equ Flash_CRCCR2_CRC_SECT_Shift, 0   @ bitWidth 3 (Bank 2 CRC sector number)  
        .equ Flash_CRCCR2_ALL_BANK, 1 << 7   @ bitWidth 1 (Bank 2 CRC select bit)  
        .equ Flash_CRCCR2_CRC_BY_SECT, 1 << 8   @ bitWidth 1 (Bank 2 CRC sector mode select  bit)  
        .equ Flash_CRCCR2_ADD_SECT, 1 << 9   @ bitWidth 1 (Bank 2 CRC sector select  bit)  
        .equ Flash_CRCCR2_CLEAN_SECT, 1 << 10   @ bitWidth 1 (Bank 2 CRC sector list clear  bit)  
        .equ Flash_CRCCR2_START_CRC, 1 << 16   @ bitWidth 1 (Bank 2 CRC start bit)  
        .equ Flash_CRCCR2_CLEAN_CRC, 1 << 17   @ bitWidth 1 (Bank 2 CRC clear bit)  
        .equ Flash_CRCCR2_CRC_BURST_Shift, 20   @ bitWidth 2 (Bank 2 CRC burst size)  
 
    .equ Flash_CRCSADD2R, Flash_BASE + 0x154 @ (FLASH CRC start address register for bank  2) 
        .equ Flash_CRCSADD2R_CRC_START_ADDR_Shift, 0   @ bitWidth 32 (CRC start address on bank  2)  
 
    .equ Flash_CRCEADD2R, Flash_BASE + 0x158 @ (FLASH CRC end address register for bank  2) 
        .equ Flash_CRCEADD2R_CRC_END_ADDR_Shift, 0   @ bitWidth 32 (CRC end address on bank 2)  
 
    .equ Flash_ECC_FA2R, Flash_BASE + 0x160 @ (FLASH ECC fail address for bank  2) 
        .equ Flash_ECC_FA2R_FAIL_ECC_ADDR2_Shift, 0   @ bitWidth 15 (Bank 2 ECC error address)  
 

@=========================== AXI ===========================@
.equ AXI_BASE, 0x51000000 @ (AXI interconnect registers) 
    .equ AXI_AXI_PERIPH_ID_4, AXI_BASE + 0x1FD0 @ (AXI interconnect - peripheral ID4  register) 
        .equ AXI_AXI_PERIPH_ID_4_JEP106CON_Shift, 0   @ bitWidth 4 (JEP106 continuation code)  
        .equ AXI_AXI_PERIPH_ID_4_KCOUNT4_Shift, 4   @ bitWidth 4 (Register file size)  
 
    .equ AXI_AXI_PERIPH_ID_0, AXI_BASE + 0x1FE0 @ (AXI interconnect - peripheral ID0  register) 
        .equ AXI_AXI_PERIPH_ID_0_PARTNUM_Shift, 0   @ bitWidth 8 (Peripheral part number bits 0 to  7)  
 
    .equ AXI_AXI_PERIPH_ID_1, AXI_BASE + 0x1FE4 @ (AXI interconnect - peripheral ID1  register) 
        .equ AXI_AXI_PERIPH_ID_1_PARTNUM_Shift, 0   @ bitWidth 4 (Peripheral part number bits 8 to  11)  
        .equ AXI_AXI_PERIPH_ID_1_JEP106I_Shift, 4   @ bitWidth 4 (JEP106 identity bits 0 to  3)  
 
    .equ AXI_AXI_PERIPH_ID_2, AXI_BASE + 0x1FE8 @ (AXI interconnect - peripheral ID2  register) 
        .equ AXI_AXI_PERIPH_ID_2_JEP106ID_Shift, 0   @ bitWidth 3 (JEP106 Identity bits 4 to  6)  
        .equ AXI_AXI_PERIPH_ID_2_JEDEC, 1 << 3   @ bitWidth 1 (JEP106 code flag)  
        .equ AXI_AXI_PERIPH_ID_2_REVISION_Shift, 4   @ bitWidth 4 (Peripheral revision number)  
 
    .equ AXI_AXI_PERIPH_ID_3, AXI_BASE + 0x1FEC @ (AXI interconnect - peripheral ID3  register) 
        .equ AXI_AXI_PERIPH_ID_3_CUST_MOD_NUM_Shift, 0   @ bitWidth 4 (Customer modification)  
        .equ AXI_AXI_PERIPH_ID_3_REV_AND_Shift, 4   @ bitWidth 4 (Customer version)  
 
    .equ AXI_AXI_COMP_ID_0, AXI_BASE + 0x1FF0 @ (AXI interconnect - component ID0  register) 
        .equ AXI_AXI_COMP_ID_0_PREAMBLE_Shift, 0   @ bitWidth 8 (Preamble bits 0 to 7)  
 
    .equ AXI_AXI_COMP_ID_1, AXI_BASE + 0x1FF4 @ (AXI interconnect - component ID1  register) 
        .equ AXI_AXI_COMP_ID_1_PREAMBLE_Shift, 0   @ bitWidth 4 (Preamble bits 8 to 11)  
        .equ AXI_AXI_COMP_ID_1_CLASS_Shift, 4   @ bitWidth 4 (Component class)  
 
    .equ AXI_AXI_COMP_ID_2, AXI_BASE + 0x1FF8 @ (AXI interconnect - component ID2  register) 
        .equ AXI_AXI_COMP_ID_2_PREAMBLE_Shift, 0   @ bitWidth 8 (Preamble bits 12 to 19)  
 
    .equ AXI_AXI_COMP_ID_3, AXI_BASE + 0x1FFC @ (AXI interconnect - component ID3  register) 
        .equ AXI_AXI_COMP_ID_3_PREAMBLE_Shift, 0   @ bitWidth 8 (Preamble bits 20 to 27)  
 
    .equ AXI_AXI_TARG1_FN_MOD_ISS_BM, AXI_BASE + 0x2008 @ (AXI interconnect - TARG x bus matrix issuing  functionality register) 
        .equ AXI_AXI_TARG1_FN_MOD_ISS_BM_READ_ISS_OVERRIDE, 1 << 0   @ bitWidth 1 (READ_ISS_OVERRIDE)  
        .equ AXI_AXI_TARG1_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE, 1 << 1   @ bitWidth 1 (Switch matrix write issuing override for  target)  
 
    .equ AXI_AXI_TARG2_FN_MOD_ISS_BM, AXI_BASE + 0x3008 @ (AXI interconnect - TARG x bus matrix issuing  functionality register) 
        .equ AXI_AXI_TARG2_FN_MOD_ISS_BM_READ_ISS_OVERRIDE, 1 << 0   @ bitWidth 1 (READ_ISS_OVERRIDE)  
        .equ AXI_AXI_TARG2_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE, 1 << 1   @ bitWidth 1 (Switch matrix write issuing override for  target)  
 
    .equ AXI_AXI_TARG3_FN_MOD_ISS_BM, AXI_BASE + 0x4008 @ (AXI interconnect - TARG x bus matrix issuing  functionality register) 
        .equ AXI_AXI_TARG3_FN_MOD_ISS_BM_READ_ISS_OVERRIDE, 1 << 0   @ bitWidth 1 (READ_ISS_OVERRIDE)  
        .equ AXI_AXI_TARG3_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE, 1 << 1   @ bitWidth 1 (Switch matrix write issuing override for  target)  
 
    .equ AXI_AXI_TARG4_FN_MOD_ISS_BM, AXI_BASE + 0x5008 @ (AXI interconnect - TARG x bus matrix issuing  functionality register) 
        .equ AXI_AXI_TARG4_FN_MOD_ISS_BM_READ_ISS_OVERRIDE, 1 << 0   @ bitWidth 1 (READ_ISS_OVERRIDE)  
        .equ AXI_AXI_TARG4_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE, 1 << 1   @ bitWidth 1 (Switch matrix write issuing override for  target)  
 
    .equ AXI_AXI_TARG5_FN_MOD_ISS_BM, AXI_BASE + 0x6008 @ (AXI interconnect - TARG x bus matrix issuing  functionality register) 
        .equ AXI_AXI_TARG5_FN_MOD_ISS_BM_READ_ISS_OVERRIDE, 1 << 0   @ bitWidth 1 (READ_ISS_OVERRIDE)  
        .equ AXI_AXI_TARG5_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE, 1 << 1   @ bitWidth 1 (Switch matrix write issuing override for  target)  
 
    .equ AXI_AXI_TARG6_FN_MOD_ISS_BM, AXI_BASE + 0x7008 @ (AXI interconnect - TARG x bus matrix issuing  functionality register) 
        .equ AXI_AXI_TARG6_FN_MOD_ISS_BM_READ_ISS_OVERRIDE, 1 << 0   @ bitWidth 1 (READ_ISS_OVERRIDE)  
        .equ AXI_AXI_TARG6_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE, 1 << 1   @ bitWidth 1 (Switch matrix write issuing override for  target)  
 
    .equ AXI_AXI_TARG7_FN_MOD_ISS_BM, AXI_BASE + 0x800C @ (AXI interconnect - TARG x bus matrix issuing  functionality register) 
        .equ AXI_AXI_TARG7_FN_MOD_ISS_BM_READ_ISS_OVERRIDE, 1 << 0   @ bitWidth 1 (READ_ISS_OVERRIDE)  
        .equ AXI_AXI_TARG7_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE, 1 << 1   @ bitWidth 1 (Switch matrix write issuing override for  target)  
 
    .equ AXI_AXI_TARG1_FN_MOD2, AXI_BASE + 0x2024 @ (AXI interconnect - TARG x bus matrix  functionality 2 register) 
        .equ AXI_AXI_TARG1_FN_MOD2_BYPASS_MERGE, 1 << 0   @ bitWidth 1 (Disable packing of beats to match the  output data width)  
 
    .equ AXI_AXI_TARG2_FN_MOD2, AXI_BASE + 0x3024 @ (AXI interconnect - TARG x bus matrix  functionality 2 register) 
        .equ AXI_AXI_TARG2_FN_MOD2_BYPASS_MERGE, 1 << 0   @ bitWidth 1 (Disable packing of beats to match the  output data width)  
 
    .equ AXI_AXI_TARG7_FN_MOD2, AXI_BASE + 0x8024 @ (AXI interconnect - TARG x bus matrix  functionality 2 register) 
        .equ AXI_AXI_TARG7_FN_MOD2_BYPASS_MERGE, 1 << 0   @ bitWidth 1 (Disable packing of beats to match the  output data width)  
 
    .equ AXI_AXI_TARG1_FN_MOD_LB, AXI_BASE + 0x202C @ (AXI interconnect - TARG x long burst  functionality modification) 
        .equ AXI_AXI_TARG1_FN_MOD_LB_FN_MOD_LB, 1 << 0   @ bitWidth 1 (Controls burst breaking of long  bursts)  
 
    .equ AXI_AXI_TARG2_FN_MOD_LB, AXI_BASE + 0x302C @ (AXI interconnect - TARG x long burst  functionality modification) 
        .equ AXI_AXI_TARG2_FN_MOD_LB_FN_MOD_LB, 1 << 0   @ bitWidth 1 (Controls burst breaking of long  bursts)  
 
    .equ AXI_AXI_TARG1_FN_MOD, AXI_BASE + 0x2108 @ (AXI interconnect - TARG x long burst  functionality modification) 
        .equ AXI_AXI_TARG1_FN_MOD_READ_ISS_OVERRIDE, 1 << 0   @ bitWidth 1 (Override AMIB read issuing  capability)  
        .equ AXI_AXI_TARG1_FN_MOD_WRITE_ISS_OVERRIDE, 1 << 1   @ bitWidth 1 (Override AMIB write issuing  capability)  
 
    .equ AXI_AXI_TARG2_FN_MOD, AXI_BASE + 0x3108 @ (AXI interconnect - TARG x long burst  functionality modification) 
        .equ AXI_AXI_TARG2_FN_MOD_READ_ISS_OVERRIDE, 1 << 0   @ bitWidth 1 (Override AMIB read issuing  capability)  
        .equ AXI_AXI_TARG2_FN_MOD_WRITE_ISS_OVERRIDE, 1 << 1   @ bitWidth 1 (Override AMIB write issuing  capability)  
 
    .equ AXI_AXI_TARG7_FN_MOD, AXI_BASE + 0x8108 @ (AXI interconnect - TARG x long burst  functionality modification) 
        .equ AXI_AXI_TARG7_FN_MOD_READ_ISS_OVERRIDE, 1 << 0   @ bitWidth 1 (Override AMIB read issuing  capability)  
        .equ AXI_AXI_TARG7_FN_MOD_WRITE_ISS_OVERRIDE, 1 << 1   @ bitWidth 1 (Override AMIB write issuing  capability)  
 
    .equ AXI_AXI_INI1_FN_MOD2, AXI_BASE + 0x42024 @ (AXI interconnect - INI x functionality  modification 2 register) 
        .equ AXI_AXI_INI1_FN_MOD2_BYPASS_MERGE, 1 << 0   @ bitWidth 1 (Disables alteration of transactions by  the up-sizer unless required by the  protocol)  
 
    .equ AXI_AXI_INI3_FN_MOD2, AXI_BASE + 0x44024 @ (AXI interconnect - INI x functionality  modification 2 register) 
        .equ AXI_AXI_INI3_FN_MOD2_BYPASS_MERGE, 1 << 0   @ bitWidth 1 (Disables alteration of transactions by  the up-sizer unless required by the  protocol)  
 
    .equ AXI_AXI_INI1_FN_MOD_AHB, AXI_BASE + 0x42028 @ (AXI interconnect - INI x AHB functionality  modification register) 
        .equ AXI_AXI_INI1_FN_MOD_AHB_RD_INC_OVERRIDE, 1 << 0   @ bitWidth 1 (Converts all AHB-Lite write transactions  to a series of single beat AXI)  
        .equ AXI_AXI_INI1_FN_MOD_AHB_WR_INC_OVERRIDE, 1 << 1   @ bitWidth 1 (Converts all AHB-Lite read transactions  to a series of single beat AXI)  
 
    .equ AXI_AXI_INI3_FN_MOD_AHB, AXI_BASE + 0x44028 @ (AXI interconnect - INI x AHB functionality  modification register) 
        .equ AXI_AXI_INI3_FN_MOD_AHB_RD_INC_OVERRIDE, 1 << 0   @ bitWidth 1 (Converts all AHB-Lite write transactions  to a series of single beat AXI)  
        .equ AXI_AXI_INI3_FN_MOD_AHB_WR_INC_OVERRIDE, 1 << 1   @ bitWidth 1 (Converts all AHB-Lite read transactions  to a series of single beat AXI)  
 
    .equ AXI_AXI_INI1_READ_QOS, AXI_BASE + 0x42100 @ (AXI interconnect - INI x read QoS  register) 
        .equ AXI_AXI_INI1_READ_QOS_AR_QOS_Shift, 0   @ bitWidth 4 (Read channel QoS setting)  
 
    .equ AXI_AXI_INI2_READ_QOS, AXI_BASE + 0x43100 @ (AXI interconnect - INI x read QoS  register) 
        .equ AXI_AXI_INI2_READ_QOS_AR_QOS_Shift, 0   @ bitWidth 4 (Read channel QoS setting)  
 
    .equ AXI_AXI_INI3_READ_QOS, AXI_BASE + 0x44100 @ (AXI interconnect - INI x read QoS  register) 
        .equ AXI_AXI_INI3_READ_QOS_AR_QOS_Shift, 0   @ bitWidth 4 (Read channel QoS setting)  
 
    .equ AXI_AXI_INI4_READ_QOS, AXI_BASE + 0x45100 @ (AXI interconnect - INI x read QoS  register) 
        .equ AXI_AXI_INI4_READ_QOS_AR_QOS_Shift, 0   @ bitWidth 4 (Read channel QoS setting)  
 
    .equ AXI_AXI_INI5_READ_QOS, AXI_BASE + 0x46100 @ (AXI interconnect - INI x read QoS  register) 
        .equ AXI_AXI_INI5_READ_QOS_AR_QOS_Shift, 0   @ bitWidth 4 (Read channel QoS setting)  
 
    .equ AXI_AXI_INI6_READ_QOS, AXI_BASE + 0x47100 @ (AXI interconnect - INI x read QoS  register) 
        .equ AXI_AXI_INI6_READ_QOS_AR_QOS_Shift, 0   @ bitWidth 4 (Read channel QoS setting)  
 
    .equ AXI_AXI_INI1_WRITE_QOS, AXI_BASE + 0x42104 @ (AXI interconnect - INI x write QoS  register) 
        .equ AXI_AXI_INI1_WRITE_QOS_AW_QOS_Shift, 0   @ bitWidth 4 (Write channel QoS setting)  
 
    .equ AXI_AXI_INI2_WRITE_QOS, AXI_BASE + 0x43104 @ (AXI interconnect - INI x write QoS  register) 
        .equ AXI_AXI_INI2_WRITE_QOS_AW_QOS_Shift, 0   @ bitWidth 4 (Write channel QoS setting)  
 
    .equ AXI_AXI_INI3_WRITE_QOS, AXI_BASE + 0x44104 @ (AXI interconnect - INI x write QoS  register) 
        .equ AXI_AXI_INI3_WRITE_QOS_AW_QOS_Shift, 0   @ bitWidth 4 (Write channel QoS setting)  
 
    .equ AXI_AXI_INI4_WRITE_QOS, AXI_BASE + 0x45104 @ (AXI interconnect - INI x write QoS  register) 
        .equ AXI_AXI_INI4_WRITE_QOS_AW_QOS_Shift, 0   @ bitWidth 4 (Write channel QoS setting)  
 
    .equ AXI_AXI_INI5_WRITE_QOS, AXI_BASE + 0x46104 @ (AXI interconnect - INI x write QoS  register) 
        .equ AXI_AXI_INI5_WRITE_QOS_AW_QOS_Shift, 0   @ bitWidth 4 (Write channel QoS setting)  
 
    .equ AXI_AXI_INI6_WRITE_QOS, AXI_BASE + 0x47104 @ (AXI interconnect - INI x write QoS  register) 
        .equ AXI_AXI_INI6_WRITE_QOS_AW_QOS_Shift, 0   @ bitWidth 4 (Write channel QoS setting)  
 
    .equ AXI_AXI_INI1_FN_MOD, AXI_BASE + 0x42108 @ (AXI interconnect - INI x issuing  functionality modification register) 
        .equ AXI_AXI_INI1_FN_MOD_READ_ISS_OVERRIDE, 1 << 0   @ bitWidth 1 (Override ASIB read issuing  capability)  
        .equ AXI_AXI_INI1_FN_MOD_WRITE_ISS_OVERRIDE, 1 << 1   @ bitWidth 1 (Override ASIB write issuing  capability)  
 
    .equ AXI_AXI_INI2_FN_MOD, AXI_BASE + 0x43108 @ (AXI interconnect - INI x issuing  functionality modification register) 
        .equ AXI_AXI_INI2_FN_MOD_READ_ISS_OVERRIDE, 1 << 0   @ bitWidth 1 (Override ASIB read issuing  capability)  
        .equ AXI_AXI_INI2_FN_MOD_WRITE_ISS_OVERRIDE, 1 << 1   @ bitWidth 1 (Override ASIB write issuing  capability)  
 
    .equ AXI_AXI_INI3_FN_MOD, AXI_BASE + 0x44108 @ (AXI interconnect - INI x issuing  functionality modification register) 
        .equ AXI_AXI_INI3_FN_MOD_READ_ISS_OVERRIDE, 1 << 0   @ bitWidth 1 (Override ASIB read issuing  capability)  
        .equ AXI_AXI_INI3_FN_MOD_WRITE_ISS_OVERRIDE, 1 << 1   @ bitWidth 1 (Override ASIB write issuing  capability)  
 
    .equ AXI_AXI_INI4_FN_MOD, AXI_BASE + 0x45108 @ (AXI interconnect - INI x issuing  functionality modification register) 
        .equ AXI_AXI_INI4_FN_MOD_READ_ISS_OVERRIDE, 1 << 0   @ bitWidth 1 (Override ASIB read issuing  capability)  
        .equ AXI_AXI_INI4_FN_MOD_WRITE_ISS_OVERRIDE, 1 << 1   @ bitWidth 1 (Override ASIB write issuing  capability)  
 
    .equ AXI_AXI_INI5_FN_MOD, AXI_BASE + 0x46108 @ (AXI interconnect - INI x issuing  functionality modification register) 
        .equ AXI_AXI_INI5_FN_MOD_READ_ISS_OVERRIDE, 1 << 0   @ bitWidth 1 (Override ASIB read issuing  capability)  
        .equ AXI_AXI_INI5_FN_MOD_WRITE_ISS_OVERRIDE, 1 << 1   @ bitWidth 1 (Override ASIB write issuing  capability)  
 
    .equ AXI_AXI_INI6_FN_MOD, AXI_BASE + 0x47108 @ (AXI interconnect - INI x issuing  functionality modification register) 
        .equ AXI_AXI_INI6_FN_MOD_READ_ISS_OVERRIDE, 1 << 0   @ bitWidth 1 (Override ASIB read issuing  capability)  
        .equ AXI_AXI_INI6_FN_MOD_WRITE_ISS_OVERRIDE, 1 << 1   @ bitWidth 1 (Override ASIB write issuing  capability)  
 

@=========================== HASH ===========================@
.equ HASH_BASE, 0x48021400 @ (Hash processor) 
    .equ HASH_CR, HASH_BASE + 0x0 @ (control register) 
        .equ HASH_CR_INIT, 1 << 2   @ bitWidth 1 (Initialize message digest  calculation)  
        .equ HASH_CR_DMAE, 1 << 3   @ bitWidth 1 (DMA enable)  
        .equ HASH_CR_DATATYPE_Shift, 4   @ bitWidth 2 (Data type selection)  
        .equ HASH_CR_MODE, 1 << 6   @ bitWidth 1 (Mode selection)  
        .equ HASH_CR_ALGO0, 1 << 7   @ bitWidth 1 (Algorithm selection)  
        .equ HASH_CR_NBW_Shift, 8   @ bitWidth 4 (Number of words already  pushed)  
        .equ HASH_CR_DINNE, 1 << 12   @ bitWidth 1 (DIN not empty)  
        .equ HASH_CR_MDMAT, 1 << 13   @ bitWidth 1 (Multiple DMA Transfers)  
        .equ HASH_CR_LKEY, 1 << 16   @ bitWidth 1 (Long key selection)  
        .equ HASH_CR_ALGO1, 1 << 18   @ bitWidth 1 (ALGO)  
 
    .equ HASH_DIN, HASH_BASE + 0x4 @ (data input register) 
        .equ HASH_DIN_DATAIN_Shift, 0   @ bitWidth 32 (Data input)  
 
    .equ HASH_STR, HASH_BASE + 0x8 @ (start register) 
        .equ HASH_STR_DCAL, 1 << 8   @ bitWidth 1 (Digest calculation)  
        .equ HASH_STR_NBLW_Shift, 0   @ bitWidth 5 (Number of valid bits in the last word of  the message)  
 
    .equ HASH_HR0, HASH_BASE + 0xC @ (digest registers) 
        .equ HASH_HR0_H0_Shift, 0   @ bitWidth 32 (H0)  
 
    .equ HASH_HR1, HASH_BASE + 0x10 @ (digest registers) 
        .equ HASH_HR1_H1_Shift, 0   @ bitWidth 32 (H1)  
 
    .equ HASH_HR2, HASH_BASE + 0x14 @ (digest registers) 
        .equ HASH_HR2_H2_Shift, 0   @ bitWidth 32 (H2)  
 
    .equ HASH_HR3, HASH_BASE + 0x18 @ (digest registers) 
        .equ HASH_HR3_H3_Shift, 0   @ bitWidth 32 (H3)  
 
    .equ HASH_HR4, HASH_BASE + 0x1C @ (digest registers) 
        .equ HASH_HR4_H4_Shift, 0   @ bitWidth 32 (H4)  
 
    .equ HASH_IMR, HASH_BASE + 0x20 @ (interrupt enable register) 
        .equ HASH_IMR_DCIE, 1 << 1   @ bitWidth 1 (Digest calculation completion interrupt  enable)  
        .equ HASH_IMR_DINIE, 1 << 0   @ bitWidth 1 (Data input interrupt  enable)  
 
    .equ HASH_SR, HASH_BASE + 0x24 @ (status register) 
        .equ HASH_SR_BUSY, 1 << 3   @ bitWidth 1 (Busy bit)  
        .equ HASH_SR_DMAS, 1 << 2   @ bitWidth 1 (DMA Status)  
        .equ HASH_SR_DCIS, 1 << 1   @ bitWidth 1 (Digest calculation completion interrupt  status)  
        .equ HASH_SR_DINIS, 1 << 0   @ bitWidth 1 (Data input interrupt  status)  
 
    .equ HASH_CSR0, HASH_BASE + 0xF8 @ (context swap registers) 
        .equ HASH_CSR0_CSR0_Shift, 0   @ bitWidth 32 (CSR0)  
 
    .equ HASH_CSR1, HASH_BASE + 0xFC @ (context swap registers) 
        .equ HASH_CSR1_CSR1_Shift, 0   @ bitWidth 32 (CSR1)  
 
    .equ HASH_CSR2, HASH_BASE + 0x100 @ (context swap registers) 
        .equ HASH_CSR2_CSR2_Shift, 0   @ bitWidth 32 (CSR2)  
 
    .equ HASH_CSR3, HASH_BASE + 0x104 @ (context swap registers) 
        .equ HASH_CSR3_CSR3_Shift, 0   @ bitWidth 32 (CSR3)  
 
    .equ HASH_CSR4, HASH_BASE + 0x108 @ (context swap registers) 
        .equ HASH_CSR4_CSR4_Shift, 0   @ bitWidth 32 (CSR4)  
 
    .equ HASH_CSR5, HASH_BASE + 0x10C @ (context swap registers) 
        .equ HASH_CSR5_CSR5_Shift, 0   @ bitWidth 32 (CSR5)  
 
    .equ HASH_CSR6, HASH_BASE + 0x110 @ (context swap registers) 
        .equ HASH_CSR6_CSR6_Shift, 0   @ bitWidth 32 (CSR6)  
 
    .equ HASH_CSR7, HASH_BASE + 0x114 @ (context swap registers) 
        .equ HASH_CSR7_CSR7_Shift, 0   @ bitWidth 32 (CSR7)  
 
    .equ HASH_CSR8, HASH_BASE + 0x118 @ (context swap registers) 
        .equ HASH_CSR8_CSR8_Shift, 0   @ bitWidth 32 (CSR8)  
 
    .equ HASH_CSR9, HASH_BASE + 0x11C @ (context swap registers) 
        .equ HASH_CSR9_CSR9_Shift, 0   @ bitWidth 32 (CSR9)  
 
    .equ HASH_CSR10, HASH_BASE + 0x120 @ (context swap registers) 
        .equ HASH_CSR10_CSR10_Shift, 0   @ bitWidth 32 (CSR10)  
 
    .equ HASH_CSR11, HASH_BASE + 0x124 @ (context swap registers) 
        .equ HASH_CSR11_CSR11_Shift, 0   @ bitWidth 32 (CSR11)  
 
    .equ HASH_CSR12, HASH_BASE + 0x128 @ (context swap registers) 
        .equ HASH_CSR12_CSR12_Shift, 0   @ bitWidth 32 (CSR12)  
 
    .equ HASH_CSR13, HASH_BASE + 0x12C @ (context swap registers) 
        .equ HASH_CSR13_CSR13_Shift, 0   @ bitWidth 32 (CSR13)  
 
    .equ HASH_CSR14, HASH_BASE + 0x130 @ (context swap registers) 
        .equ HASH_CSR14_CSR14_Shift, 0   @ bitWidth 32 (CSR14)  
 
    .equ HASH_CSR15, HASH_BASE + 0x134 @ (context swap registers) 
        .equ HASH_CSR15_CSR15_Shift, 0   @ bitWidth 32 (CSR15)  
 
    .equ HASH_CSR16, HASH_BASE + 0x138 @ (context swap registers) 
        .equ HASH_CSR16_CSR16_Shift, 0   @ bitWidth 32 (CSR16)  
 
    .equ HASH_CSR17, HASH_BASE + 0x13C @ (context swap registers) 
        .equ HASH_CSR17_CSR17_Shift, 0   @ bitWidth 32 (CSR17)  
 
    .equ HASH_CSR18, HASH_BASE + 0x140 @ (context swap registers) 
        .equ HASH_CSR18_CSR18_Shift, 0   @ bitWidth 32 (CSR18)  
 
    .equ HASH_CSR19, HASH_BASE + 0x144 @ (context swap registers) 
        .equ HASH_CSR19_CSR19_Shift, 0   @ bitWidth 32 (CSR19)  
 
    .equ HASH_CSR20, HASH_BASE + 0x148 @ (context swap registers) 
        .equ HASH_CSR20_CSR20_Shift, 0   @ bitWidth 32 (CSR20)  
 
    .equ HASH_CSR21, HASH_BASE + 0x14C @ (context swap registers) 
        .equ HASH_CSR21_CSR21_Shift, 0   @ bitWidth 32 (CSR21)  
 
    .equ HASH_CSR22, HASH_BASE + 0x150 @ (context swap registers) 
        .equ HASH_CSR22_CSR22_Shift, 0   @ bitWidth 32 (CSR22)  
 
    .equ HASH_CSR23, HASH_BASE + 0x154 @ (context swap registers) 
        .equ HASH_CSR23_CSR23_Shift, 0   @ bitWidth 32 (CSR23)  
 
    .equ HASH_CSR24, HASH_BASE + 0x158 @ (context swap registers) 
        .equ HASH_CSR24_CSR24_Shift, 0   @ bitWidth 32 (CSR24)  
 
    .equ HASH_CSR25, HASH_BASE + 0x15C @ (context swap registers) 
        .equ HASH_CSR25_CSR25_Shift, 0   @ bitWidth 32 (CSR25)  
 
    .equ HASH_CSR26, HASH_BASE + 0x160 @ (context swap registers) 
        .equ HASH_CSR26_CSR26_Shift, 0   @ bitWidth 32 (CSR26)  
 
    .equ HASH_CSR27, HASH_BASE + 0x164 @ (context swap registers) 
        .equ HASH_CSR27_CSR27_Shift, 0   @ bitWidth 32 (CSR27)  
 
    .equ HASH_CSR28, HASH_BASE + 0x168 @ (context swap registers) 
        .equ HASH_CSR28_CSR28_Shift, 0   @ bitWidth 32 (CSR28)  
 
    .equ HASH_CSR29, HASH_BASE + 0x16C @ (context swap registers) 
        .equ HASH_CSR29_CSR29_Shift, 0   @ bitWidth 32 (CSR29)  
 
    .equ HASH_CSR30, HASH_BASE + 0x170 @ (context swap registers) 
        .equ HASH_CSR30_CSR30_Shift, 0   @ bitWidth 32 (CSR30)  
 
    .equ HASH_CSR31, HASH_BASE + 0x174 @ (context swap registers) 
        .equ HASH_CSR31_CSR31_Shift, 0   @ bitWidth 32 (CSR31)  
 
    .equ HASH_CSR32, HASH_BASE + 0x178 @ (context swap registers) 
        .equ HASH_CSR32_CSR32_Shift, 0   @ bitWidth 32 (CSR32)  
 
    .equ HASH_CSR33, HASH_BASE + 0x17C @ (context swap registers) 
        .equ HASH_CSR33_CSR33_Shift, 0   @ bitWidth 32 (CSR33)  
 
    .equ HASH_CSR34, HASH_BASE + 0x180 @ (context swap registers) 
        .equ HASH_CSR34_CSR34_Shift, 0   @ bitWidth 32 (CSR34)  
 
    .equ HASH_CSR35, HASH_BASE + 0x184 @ (context swap registers) 
        .equ HASH_CSR35_CSR35_Shift, 0   @ bitWidth 32 (CSR35)  
 
    .equ HASH_CSR36, HASH_BASE + 0x188 @ (context swap registers) 
        .equ HASH_CSR36_CSR36_Shift, 0   @ bitWidth 32 (CSR36)  
 
    .equ HASH_CSR37, HASH_BASE + 0x18C @ (context swap registers) 
        .equ HASH_CSR37_CSR37_Shift, 0   @ bitWidth 32 (CSR37)  
 
    .equ HASH_CSR38, HASH_BASE + 0x190 @ (context swap registers) 
        .equ HASH_CSR38_CSR38_Shift, 0   @ bitWidth 32 (CSR38)  
 
    .equ HASH_CSR39, HASH_BASE + 0x194 @ (context swap registers) 
        .equ HASH_CSR39_CSR39_Shift, 0   @ bitWidth 32 (CSR39)  
 
    .equ HASH_CSR40, HASH_BASE + 0x198 @ (context swap registers) 
        .equ HASH_CSR40_CSR40_Shift, 0   @ bitWidth 32 (CSR40)  
 
    .equ HASH_CSR41, HASH_BASE + 0x19C @ (context swap registers) 
        .equ HASH_CSR41_CSR41_Shift, 0   @ bitWidth 32 (CSR41)  
 
    .equ HASH_CSR42, HASH_BASE + 0x1A0 @ (context swap registers) 
        .equ HASH_CSR42_CSR42_Shift, 0   @ bitWidth 32 (CSR42)  
 
    .equ HASH_CSR43, HASH_BASE + 0x1A4 @ (context swap registers) 
        .equ HASH_CSR43_CSR43_Shift, 0   @ bitWidth 32 (CSR43)  
 
    .equ HASH_CSR44, HASH_BASE + 0x1A8 @ (context swap registers) 
        .equ HASH_CSR44_CSR44_Shift, 0   @ bitWidth 32 (CSR44)  
 
    .equ HASH_CSR45, HASH_BASE + 0x1AC @ (context swap registers) 
        .equ HASH_CSR45_CSR45_Shift, 0   @ bitWidth 32 (CSR45)  
 
    .equ HASH_CSR46, HASH_BASE + 0x1B0 @ (context swap registers) 
        .equ HASH_CSR46_CSR46_Shift, 0   @ bitWidth 32 (CSR46)  
 
    .equ HASH_CSR47, HASH_BASE + 0x1B4 @ (context swap registers) 
        .equ HASH_CSR47_CSR47_Shift, 0   @ bitWidth 32 (CSR47)  
 
    .equ HASH_CSR48, HASH_BASE + 0x1B8 @ (context swap registers) 
        .equ HASH_CSR48_CSR48_Shift, 0   @ bitWidth 32 (CSR48)  
 
    .equ HASH_CSR49, HASH_BASE + 0x1BC @ (context swap registers) 
        .equ HASH_CSR49_CSR49_Shift, 0   @ bitWidth 32 (CSR49)  
 
    .equ HASH_CSR50, HASH_BASE + 0x1C0 @ (context swap registers) 
        .equ HASH_CSR50_CSR50_Shift, 0   @ bitWidth 32 (CSR50)  
 
    .equ HASH_CSR51, HASH_BASE + 0x1C4 @ (context swap registers) 
        .equ HASH_CSR51_CSR51_Shift, 0   @ bitWidth 32 (CSR51)  
 
    .equ HASH_CSR52, HASH_BASE + 0x1C8 @ (context swap registers) 
        .equ HASH_CSR52_CSR52_Shift, 0   @ bitWidth 32 (CSR52)  
 
    .equ HASH_CSR53, HASH_BASE + 0x1CC @ (context swap registers) 
        .equ HASH_CSR53_CSR53_Shift, 0   @ bitWidth 32 (CSR53)  
 
    .equ HASH_HASH_HR0, HASH_BASE + 0x310 @ (HASH digest register) 
        .equ HASH_HASH_HR0_H0_Shift, 0   @ bitWidth 32 (H0)  
 
    .equ HASH_HASH_HR1, HASH_BASE + 0x314 @ (read-only) 
        .equ HASH_HASH_HR1_H1_Shift, 0   @ bitWidth 32 (H1)  
 
    .equ HASH_HASH_HR2, HASH_BASE + 0x318 @ (read-only) 
        .equ HASH_HASH_HR2_H2_Shift, 0   @ bitWidth 32 (H2)  
 
    .equ HASH_HASH_HR3, HASH_BASE + 0x31C @ (read-only) 
        .equ HASH_HASH_HR3_H3_Shift, 0   @ bitWidth 32 (H3)  
 
    .equ HASH_HASH_HR4, HASH_BASE + 0x320 @ (read-only) 
        .equ HASH_HASH_HR4_H4_Shift, 0   @ bitWidth 32 (H4)  
 
    .equ HASH_HASH_HR5, HASH_BASE + 0x324 @ (read-only) 
        .equ HASH_HASH_HR5_H5_Shift, 0   @ bitWidth 32 (H5)  
 
    .equ HASH_HASH_HR6, HASH_BASE + 0x328 @ (read-only) 
        .equ HASH_HASH_HR6_H6_Shift, 0   @ bitWidth 32 (H6)  
 
    .equ HASH_HASH_HR7, HASH_BASE + 0x32C @ (read-only) 
        .equ HASH_HASH_HR7_H7_Shift, 0   @ bitWidth 32 (H7)  
 

@=========================== CRYP ===========================@
.equ CRYP_BASE, 0x48021000 @ (Cryptographic processor) 
    .equ CRYP_CR, CRYP_BASE + 0x0 @ (control register) 
        .equ CRYP_CR_ALGODIR, 1 << 2   @ bitWidth 1 (Algorithm direction)  
        .equ CRYP_CR_ALGOMODE0_Shift, 3   @ bitWidth 3 (Algorithm mode)  
        .equ CRYP_CR_DATATYPE_Shift, 6   @ bitWidth 2 (Data type selection)  
        .equ CRYP_CR_KEYSIZE_Shift, 8   @ bitWidth 2 (Key size selection AES mode  only)  
        .equ CRYP_CR_FFLUSH, 1 << 14   @ bitWidth 1 (FIFO flush)  
        .equ CRYP_CR_CRYPEN, 1 << 15   @ bitWidth 1 (Cryptographic processor  enable)  
        .equ CRYP_CR_GCM_CCMPH_Shift, 16   @ bitWidth 2 (GCM_CCMPH)  
        .equ CRYP_CR_ALGOMODE3, 1 << 19   @ bitWidth 1 (ALGOMODE)  
 
    .equ CRYP_SR, CRYP_BASE + 0x4 @ (status register) 
        .equ CRYP_SR_BUSY, 1 << 4   @ bitWidth 1 (Busy bit)  
        .equ CRYP_SR_OFFU, 1 << 3   @ bitWidth 1 (Output FIFO full)  
        .equ CRYP_SR_OFNE, 1 << 2   @ bitWidth 1 (Output FIFO not empty)  
        .equ CRYP_SR_IFNF, 1 << 1   @ bitWidth 1 (Input FIFO not full)  
        .equ CRYP_SR_IFEM, 1 << 0   @ bitWidth 1 (Input FIFO empty)  
 
    .equ CRYP_DIN, CRYP_BASE + 0x8 @ (data input register) 
        .equ CRYP_DIN_DATAIN_Shift, 0   @ bitWidth 32 (Data input)  
 
    .equ CRYP_DOUT, CRYP_BASE + 0xC @ (data output register) 
        .equ CRYP_DOUT_DATAOUT_Shift, 0   @ bitWidth 32 (Data output)  
 
    .equ CRYP_DMACR, CRYP_BASE + 0x10 @ (DMA control register) 
        .equ CRYP_DMACR_DOEN, 1 << 1   @ bitWidth 1 (DMA output enable)  
        .equ CRYP_DMACR_DIEN, 1 << 0   @ bitWidth 1 (DMA input enable)  
 
    .equ CRYP_IMSCR, CRYP_BASE + 0x14 @ (interrupt mask set/clear  register) 
        .equ CRYP_IMSCR_OUTIM, 1 << 1   @ bitWidth 1 (Output FIFO service interrupt  mask)  
        .equ CRYP_IMSCR_INIM, 1 << 0   @ bitWidth 1 (Input FIFO service interrupt  mask)  
 
    .equ CRYP_RISR, CRYP_BASE + 0x18 @ (raw interrupt status register) 
        .equ CRYP_RISR_OUTRIS, 1 << 1   @ bitWidth 1 (Output FIFO service raw interrupt  status)  
        .equ CRYP_RISR_INRIS, 1 << 0   @ bitWidth 1 (Input FIFO service raw interrupt  status)  
 
    .equ CRYP_MISR, CRYP_BASE + 0x1C @ (masked interrupt status  register) 
        .equ CRYP_MISR_OUTMIS, 1 << 1   @ bitWidth 1 (Output FIFO service masked interrupt  status)  
        .equ CRYP_MISR_INMIS, 1 << 0   @ bitWidth 1 (Input FIFO service masked interrupt  status)  
 
    .equ CRYP_K0LR, CRYP_BASE + 0x20 @ (key registers) 
        .equ CRYP_K0LR_K224, 1 << 0   @ bitWidth 1 (K224)  
        .equ CRYP_K0LR_K225, 1 << 1   @ bitWidth 1 (K225)  
        .equ CRYP_K0LR_K226, 1 << 2   @ bitWidth 1 (K226)  
        .equ CRYP_K0LR_K227, 1 << 3   @ bitWidth 1 (K227)  
        .equ CRYP_K0LR_K228, 1 << 4   @ bitWidth 1 (K228)  
        .equ CRYP_K0LR_K229, 1 << 5   @ bitWidth 1 (K229)  
        .equ CRYP_K0LR_K230, 1 << 6   @ bitWidth 1 (K230)  
        .equ CRYP_K0LR_K231, 1 << 7   @ bitWidth 1 (K231)  
        .equ CRYP_K0LR_K232, 1 << 8   @ bitWidth 1 (K232)  
        .equ CRYP_K0LR_K233, 1 << 9   @ bitWidth 1 (K233)  
        .equ CRYP_K0LR_K234, 1 << 10   @ bitWidth 1 (K234)  
        .equ CRYP_K0LR_K235, 1 << 11   @ bitWidth 1 (K235)  
        .equ CRYP_K0LR_K236, 1 << 12   @ bitWidth 1 (K236)  
        .equ CRYP_K0LR_K237, 1 << 13   @ bitWidth 1 (K237)  
        .equ CRYP_K0LR_K238, 1 << 14   @ bitWidth 1 (K238)  
        .equ CRYP_K0LR_K239, 1 << 15   @ bitWidth 1 (K239)  
        .equ CRYP_K0LR_K240, 1 << 16   @ bitWidth 1 (K240)  
        .equ CRYP_K0LR_K241, 1 << 17   @ bitWidth 1 (K241)  
        .equ CRYP_K0LR_K242, 1 << 18   @ bitWidth 1 (K242)  
        .equ CRYP_K0LR_K243, 1 << 19   @ bitWidth 1 (K243)  
        .equ CRYP_K0LR_K244, 1 << 20   @ bitWidth 1 (K244)  
        .equ CRYP_K0LR_K245, 1 << 21   @ bitWidth 1 (K245)  
        .equ CRYP_K0LR_K246, 1 << 22   @ bitWidth 1 (K246)  
        .equ CRYP_K0LR_K247, 1 << 23   @ bitWidth 1 (K247)  
        .equ CRYP_K0LR_K248, 1 << 24   @ bitWidth 1 (K248)  
        .equ CRYP_K0LR_K249, 1 << 25   @ bitWidth 1 (K249)  
        .equ CRYP_K0LR_K250, 1 << 26   @ bitWidth 1 (K250)  
        .equ CRYP_K0LR_K251, 1 << 27   @ bitWidth 1 (K251)  
        .equ CRYP_K0LR_K252, 1 << 28   @ bitWidth 1 (K252)  
        .equ CRYP_K0LR_K253, 1 << 29   @ bitWidth 1 (K253)  
        .equ CRYP_K0LR_K254, 1 << 30   @ bitWidth 1 (K254)  
        .equ CRYP_K0LR_K255, 1 << 31   @ bitWidth 1 (K255)  
 
    .equ CRYP_K0RR, CRYP_BASE + 0x24 @ (key registers) 
        .equ CRYP_K0RR_K192, 1 << 0   @ bitWidth 1 (K192)  
        .equ CRYP_K0RR_K193, 1 << 1   @ bitWidth 1 (K193)  
        .equ CRYP_K0RR_K194, 1 << 2   @ bitWidth 1 (K194)  
        .equ CRYP_K0RR_K195, 1 << 3   @ bitWidth 1 (K195)  
        .equ CRYP_K0RR_K196, 1 << 4   @ bitWidth 1 (K196)  
        .equ CRYP_K0RR_K197, 1 << 5   @ bitWidth 1 (K197)  
        .equ CRYP_K0RR_K198, 1 << 6   @ bitWidth 1 (K198)  
        .equ CRYP_K0RR_K199, 1 << 7   @ bitWidth 1 (K199)  
        .equ CRYP_K0RR_K200, 1 << 8   @ bitWidth 1 (K200)  
        .equ CRYP_K0RR_K201, 1 << 9   @ bitWidth 1 (K201)  
        .equ CRYP_K0RR_K202, 1 << 10   @ bitWidth 1 (K202)  
        .equ CRYP_K0RR_K203, 1 << 11   @ bitWidth 1 (K203)  
        .equ CRYP_K0RR_K204, 1 << 12   @ bitWidth 1 (K204)  
        .equ CRYP_K0RR_K205, 1 << 13   @ bitWidth 1 (K205)  
        .equ CRYP_K0RR_K206, 1 << 14   @ bitWidth 1 (K206)  
        .equ CRYP_K0RR_K207, 1 << 15   @ bitWidth 1 (K207)  
        .equ CRYP_K0RR_K208, 1 << 16   @ bitWidth 1 (K208)  
        .equ CRYP_K0RR_K209, 1 << 17   @ bitWidth 1 (K209)  
        .equ CRYP_K0RR_K210, 1 << 18   @ bitWidth 1 (K210)  
        .equ CRYP_K0RR_K211, 1 << 19   @ bitWidth 1 (K211)  
        .equ CRYP_K0RR_K212, 1 << 20   @ bitWidth 1 (K212)  
        .equ CRYP_K0RR_K213, 1 << 21   @ bitWidth 1 (K213)  
        .equ CRYP_K0RR_K214, 1 << 22   @ bitWidth 1 (K214)  
        .equ CRYP_K0RR_K215, 1 << 23   @ bitWidth 1 (K215)  
        .equ CRYP_K0RR_K216, 1 << 24   @ bitWidth 1 (K216)  
        .equ CRYP_K0RR_K217, 1 << 25   @ bitWidth 1 (K217)  
        .equ CRYP_K0RR_K218, 1 << 26   @ bitWidth 1 (K218)  
        .equ CRYP_K0RR_K219, 1 << 27   @ bitWidth 1 (K219)  
        .equ CRYP_K0RR_K220, 1 << 28   @ bitWidth 1 (K220)  
        .equ CRYP_K0RR_K221, 1 << 29   @ bitWidth 1 (K221)  
        .equ CRYP_K0RR_K222, 1 << 30   @ bitWidth 1 (K222)  
        .equ CRYP_K0RR_K223, 1 << 31   @ bitWidth 1 (K223)  
 
    .equ CRYP_K1LR, CRYP_BASE + 0x28 @ (key registers) 
        .equ CRYP_K1LR_K160, 1 << 0   @ bitWidth 1 (K160)  
        .equ CRYP_K1LR_K161, 1 << 1   @ bitWidth 1 (K161)  
        .equ CRYP_K1LR_K162, 1 << 2   @ bitWidth 1 (K162)  
        .equ CRYP_K1LR_K163, 1 << 3   @ bitWidth 1 (K163)  
        .equ CRYP_K1LR_K164, 1 << 4   @ bitWidth 1 (K164)  
        .equ CRYP_K1LR_K165, 1 << 5   @ bitWidth 1 (K165)  
        .equ CRYP_K1LR_K166, 1 << 6   @ bitWidth 1 (K166)  
        .equ CRYP_K1LR_K167, 1 << 7   @ bitWidth 1 (K167)  
        .equ CRYP_K1LR_K168, 1 << 8   @ bitWidth 1 (K168)  
        .equ CRYP_K1LR_K169, 1 << 9   @ bitWidth 1 (K169)  
        .equ CRYP_K1LR_K170, 1 << 10   @ bitWidth 1 (K170)  
        .equ CRYP_K1LR_K171, 1 << 11   @ bitWidth 1 (K171)  
        .equ CRYP_K1LR_K172, 1 << 12   @ bitWidth 1 (K172)  
        .equ CRYP_K1LR_K173, 1 << 13   @ bitWidth 1 (K173)  
        .equ CRYP_K1LR_K174, 1 << 14   @ bitWidth 1 (K174)  
        .equ CRYP_K1LR_K175, 1 << 15   @ bitWidth 1 (K175)  
        .equ CRYP_K1LR_K176, 1 << 16   @ bitWidth 1 (K176)  
        .equ CRYP_K1LR_K177, 1 << 17   @ bitWidth 1 (K177)  
        .equ CRYP_K1LR_K178, 1 << 18   @ bitWidth 1 (K178)  
        .equ CRYP_K1LR_K179, 1 << 19   @ bitWidth 1 (K179)  
        .equ CRYP_K1LR_K180, 1 << 20   @ bitWidth 1 (K180)  
        .equ CRYP_K1LR_K181, 1 << 21   @ bitWidth 1 (K181)  
        .equ CRYP_K1LR_K182, 1 << 22   @ bitWidth 1 (K182)  
        .equ CRYP_K1LR_K183, 1 << 23   @ bitWidth 1 (K183)  
        .equ CRYP_K1LR_K184, 1 << 24   @ bitWidth 1 (K184)  
        .equ CRYP_K1LR_K185, 1 << 25   @ bitWidth 1 (K185)  
        .equ CRYP_K1LR_K186, 1 << 26   @ bitWidth 1 (K186)  
        .equ CRYP_K1LR_K187, 1 << 27   @ bitWidth 1 (K187)  
        .equ CRYP_K1LR_K188, 1 << 28   @ bitWidth 1 (K188)  
        .equ CRYP_K1LR_K189, 1 << 29   @ bitWidth 1 (K189)  
        .equ CRYP_K1LR_K190, 1 << 30   @ bitWidth 1 (K190)  
        .equ CRYP_K1LR_K191, 1 << 31   @ bitWidth 1 (K191)  
 
    .equ CRYP_K1RR, CRYP_BASE + 0x2C @ (key registers) 
        .equ CRYP_K1RR_K128, 1 << 0   @ bitWidth 1 (K128)  
        .equ CRYP_K1RR_K129, 1 << 1   @ bitWidth 1 (K129)  
        .equ CRYP_K1RR_K130, 1 << 2   @ bitWidth 1 (K130)  
        .equ CRYP_K1RR_K131, 1 << 3   @ bitWidth 1 (K131)  
        .equ CRYP_K1RR_K132, 1 << 4   @ bitWidth 1 (K132)  
        .equ CRYP_K1RR_K133, 1 << 5   @ bitWidth 1 (K133)  
        .equ CRYP_K1RR_K134, 1 << 6   @ bitWidth 1 (K134)  
        .equ CRYP_K1RR_K135, 1 << 7   @ bitWidth 1 (K135)  
        .equ CRYP_K1RR_K136, 1 << 8   @ bitWidth 1 (K136)  
        .equ CRYP_K1RR_K137, 1 << 9   @ bitWidth 1 (K137)  
        .equ CRYP_K1RR_K138, 1 << 10   @ bitWidth 1 (K138)  
        .equ CRYP_K1RR_K139, 1 << 11   @ bitWidth 1 (K139)  
        .equ CRYP_K1RR_K140, 1 << 12   @ bitWidth 1 (K140)  
        .equ CRYP_K1RR_K141, 1 << 13   @ bitWidth 1 (K141)  
        .equ CRYP_K1RR_K142, 1 << 14   @ bitWidth 1 (K142)  
        .equ CRYP_K1RR_K143, 1 << 15   @ bitWidth 1 (K143)  
        .equ CRYP_K1RR_K144, 1 << 16   @ bitWidth 1 (K144)  
        .equ CRYP_K1RR_K145, 1 << 17   @ bitWidth 1 (K145)  
        .equ CRYP_K1RR_K146, 1 << 18   @ bitWidth 1 (K146)  
        .equ CRYP_K1RR_K147, 1 << 19   @ bitWidth 1 (K147)  
        .equ CRYP_K1RR_K148, 1 << 20   @ bitWidth 1 (K148)  
        .equ CRYP_K1RR_K149, 1 << 21   @ bitWidth 1 (K149)  
        .equ CRYP_K1RR_K150, 1 << 22   @ bitWidth 1 (K150)  
        .equ CRYP_K1RR_K151, 1 << 23   @ bitWidth 1 (K151)  
        .equ CRYP_K1RR_K152, 1 << 24   @ bitWidth 1 (K152)  
        .equ CRYP_K1RR_K153, 1 << 25   @ bitWidth 1 (K153)  
        .equ CRYP_K1RR_K154, 1 << 26   @ bitWidth 1 (K154)  
        .equ CRYP_K1RR_K155, 1 << 27   @ bitWidth 1 (K155)  
        .equ CRYP_K1RR_K156, 1 << 28   @ bitWidth 1 (K156)  
        .equ CRYP_K1RR_K157, 1 << 29   @ bitWidth 1 (K157)  
        .equ CRYP_K1RR_K158, 1 << 30   @ bitWidth 1 (K158)  
        .equ CRYP_K1RR_K159, 1 << 31   @ bitWidth 1 (K159)  
 
    .equ CRYP_K2LR, CRYP_BASE + 0x30 @ (key registers) 
        .equ CRYP_K2LR_K96, 1 << 0   @ bitWidth 1 (K96)  
        .equ CRYP_K2LR_K97, 1 << 1   @ bitWidth 1 (K97)  
        .equ CRYP_K2LR_K98, 1 << 2   @ bitWidth 1 (K98)  
        .equ CRYP_K2LR_K99, 1 << 3   @ bitWidth 1 (K99)  
        .equ CRYP_K2LR_K100, 1 << 4   @ bitWidth 1 (K100)  
        .equ CRYP_K2LR_K101, 1 << 5   @ bitWidth 1 (K101)  
        .equ CRYP_K2LR_K102, 1 << 6   @ bitWidth 1 (K102)  
        .equ CRYP_K2LR_K103, 1 << 7   @ bitWidth 1 (K103)  
        .equ CRYP_K2LR_K104, 1 << 8   @ bitWidth 1 (K104)  
        .equ CRYP_K2LR_K105, 1 << 9   @ bitWidth 1 (K105)  
        .equ CRYP_K2LR_K106, 1 << 10   @ bitWidth 1 (K106)  
        .equ CRYP_K2LR_K107, 1 << 11   @ bitWidth 1 (K107)  
        .equ CRYP_K2LR_K108, 1 << 12   @ bitWidth 1 (K108)  
        .equ CRYP_K2LR_K109, 1 << 13   @ bitWidth 1 (K109)  
        .equ CRYP_K2LR_K110, 1 << 14   @ bitWidth 1 (K110)  
        .equ CRYP_K2LR_K111, 1 << 15   @ bitWidth 1 (K111)  
        .equ CRYP_K2LR_K112, 1 << 16   @ bitWidth 1 (K112)  
        .equ CRYP_K2LR_K113, 1 << 17   @ bitWidth 1 (K113)  
        .equ CRYP_K2LR_K114, 1 << 18   @ bitWidth 1 (K114)  
        .equ CRYP_K2LR_K115, 1 << 19   @ bitWidth 1 (K115)  
        .equ CRYP_K2LR_K116, 1 << 20   @ bitWidth 1 (K116)  
        .equ CRYP_K2LR_K117, 1 << 21   @ bitWidth 1 (K117)  
        .equ CRYP_K2LR_K118, 1 << 22   @ bitWidth 1 (K118)  
        .equ CRYP_K2LR_K119, 1 << 23   @ bitWidth 1 (K119)  
        .equ CRYP_K2LR_K120, 1 << 24   @ bitWidth 1 (K120)  
        .equ CRYP_K2LR_K121, 1 << 25   @ bitWidth 1 (K121)  
        .equ CRYP_K2LR_K122, 1 << 26   @ bitWidth 1 (K122)  
        .equ CRYP_K2LR_K123, 1 << 27   @ bitWidth 1 (K123)  
        .equ CRYP_K2LR_K124, 1 << 28   @ bitWidth 1 (K124)  
        .equ CRYP_K2LR_K125, 1 << 29   @ bitWidth 1 (K125)  
        .equ CRYP_K2LR_K126, 1 << 30   @ bitWidth 1 (K126)  
        .equ CRYP_K2LR_K127, 1 << 31   @ bitWidth 1 (K127)  
 
    .equ CRYP_K2RR, CRYP_BASE + 0x34 @ (key registers) 
        .equ CRYP_K2RR_K64, 1 << 0   @ bitWidth 1 (K64)  
        .equ CRYP_K2RR_K65, 1 << 1   @ bitWidth 1 (K65)  
        .equ CRYP_K2RR_K66, 1 << 2   @ bitWidth 1 (K66)  
        .equ CRYP_K2RR_K67, 1 << 3   @ bitWidth 1 (K67)  
        .equ CRYP_K2RR_K68, 1 << 4   @ bitWidth 1 (K68)  
        .equ CRYP_K2RR_K69, 1 << 5   @ bitWidth 1 (K69)  
        .equ CRYP_K2RR_K70, 1 << 6   @ bitWidth 1 (K70)  
        .equ CRYP_K2RR_K71, 1 << 7   @ bitWidth 1 (K71)  
        .equ CRYP_K2RR_K72, 1 << 8   @ bitWidth 1 (K72)  
        .equ CRYP_K2RR_K73, 1 << 9   @ bitWidth 1 (K73)  
        .equ CRYP_K2RR_K74, 1 << 10   @ bitWidth 1 (K74)  
        .equ CRYP_K2RR_K75, 1 << 11   @ bitWidth 1 (K75)  
        .equ CRYP_K2RR_K76, 1 << 12   @ bitWidth 1 (K76)  
        .equ CRYP_K2RR_K77, 1 << 13   @ bitWidth 1 (K77)  
        .equ CRYP_K2RR_K78, 1 << 14   @ bitWidth 1 (K78)  
        .equ CRYP_K2RR_K79, 1 << 15   @ bitWidth 1 (K79)  
        .equ CRYP_K2RR_K80, 1 << 16   @ bitWidth 1 (K80)  
        .equ CRYP_K2RR_K81, 1 << 17   @ bitWidth 1 (K81)  
        .equ CRYP_K2RR_K82, 1 << 18   @ bitWidth 1 (K82)  
        .equ CRYP_K2RR_K83, 1 << 19   @ bitWidth 1 (K83)  
        .equ CRYP_K2RR_K84, 1 << 20   @ bitWidth 1 (K84)  
        .equ CRYP_K2RR_K85, 1 << 21   @ bitWidth 1 (K85)  
        .equ CRYP_K2RR_K86, 1 << 22   @ bitWidth 1 (K86)  
        .equ CRYP_K2RR_K87, 1 << 23   @ bitWidth 1 (K87)  
        .equ CRYP_K2RR_K88, 1 << 24   @ bitWidth 1 (K88)  
        .equ CRYP_K2RR_K89, 1 << 25   @ bitWidth 1 (K89)  
        .equ CRYP_K2RR_K90, 1 << 26   @ bitWidth 1 (K90)  
        .equ CRYP_K2RR_K91, 1 << 27   @ bitWidth 1 (K91)  
        .equ CRYP_K2RR_K92, 1 << 28   @ bitWidth 1 (K92)  
        .equ CRYP_K2RR_K93, 1 << 29   @ bitWidth 1 (K93)  
        .equ CRYP_K2RR_K94, 1 << 30   @ bitWidth 1 (K94)  
        .equ CRYP_K2RR_K95, 1 << 31   @ bitWidth 1 (K95)  
 
    .equ CRYP_K3LR, CRYP_BASE + 0x38 @ (key registers) 
        .equ CRYP_K3LR_K32, 1 << 0   @ bitWidth 1 (K32)  
        .equ CRYP_K3LR_K33, 1 << 1   @ bitWidth 1 (K33)  
        .equ CRYP_K3LR_K34, 1 << 2   @ bitWidth 1 (K34)  
        .equ CRYP_K3LR_K35, 1 << 3   @ bitWidth 1 (K35)  
        .equ CRYP_K3LR_K36, 1 << 4   @ bitWidth 1 (K36)  
        .equ CRYP_K3LR_K37, 1 << 5   @ bitWidth 1 (K37)  
        .equ CRYP_K3LR_K38, 1 << 6   @ bitWidth 1 (K38)  
        .equ CRYP_K3LR_K39, 1 << 7   @ bitWidth 1 (K39)  
        .equ CRYP_K3LR_K40, 1 << 8   @ bitWidth 1 (K40)  
        .equ CRYP_K3LR_K41, 1 << 9   @ bitWidth 1 (K41)  
        .equ CRYP_K3LR_K42, 1 << 10   @ bitWidth 1 (K42)  
        .equ CRYP_K3LR_K43, 1 << 11   @ bitWidth 1 (K43)  
        .equ CRYP_K3LR_K44, 1 << 12   @ bitWidth 1 (K44)  
        .equ CRYP_K3LR_K45, 1 << 13   @ bitWidth 1 (K45)  
        .equ CRYP_K3LR_K46, 1 << 14   @ bitWidth 1 (K46)  
        .equ CRYP_K3LR_K47, 1 << 15   @ bitWidth 1 (K47)  
        .equ CRYP_K3LR_K48, 1 << 16   @ bitWidth 1 (K48)  
        .equ CRYP_K3LR_K49, 1 << 17   @ bitWidth 1 (K49)  
        .equ CRYP_K3LR_K50, 1 << 18   @ bitWidth 1 (K50)  
        .equ CRYP_K3LR_K51, 1 << 19   @ bitWidth 1 (K51)  
        .equ CRYP_K3LR_K52, 1 << 20   @ bitWidth 1 (K52)  
        .equ CRYP_K3LR_K53, 1 << 21   @ bitWidth 1 (K53)  
        .equ CRYP_K3LR_K54, 1 << 22   @ bitWidth 1 (K54)  
        .equ CRYP_K3LR_K55, 1 << 23   @ bitWidth 1 (K55)  
        .equ CRYP_K3LR_K56, 1 << 24   @ bitWidth 1 (K56)  
        .equ CRYP_K3LR_K57, 1 << 25   @ bitWidth 1 (K57)  
        .equ CRYP_K3LR_K58, 1 << 26   @ bitWidth 1 (K58)  
        .equ CRYP_K3LR_K59, 1 << 27   @ bitWidth 1 (K59)  
        .equ CRYP_K3LR_K60, 1 << 28   @ bitWidth 1 (K60)  
        .equ CRYP_K3LR_K61, 1 << 29   @ bitWidth 1 (K61)  
        .equ CRYP_K3LR_K62, 1 << 30   @ bitWidth 1 (K62)  
        .equ CRYP_K3LR_K63, 1 << 31   @ bitWidth 1 (K63)  
 
    .equ CRYP_K3RR, CRYP_BASE + 0x3C @ (key registers) 
        .equ CRYP_K3RR_K0, 1 << 0   @ bitWidth 1 (K0)  
        .equ CRYP_K3RR_K1, 1 << 1   @ bitWidth 1 (K1)  
        .equ CRYP_K3RR_K2, 1 << 2   @ bitWidth 1 (K2)  
        .equ CRYP_K3RR_K3, 1 << 3   @ bitWidth 1 (K3)  
        .equ CRYP_K3RR_K4, 1 << 4   @ bitWidth 1 (K4)  
        .equ CRYP_K3RR_K5, 1 << 5   @ bitWidth 1 (K5)  
        .equ CRYP_K3RR_K6, 1 << 6   @ bitWidth 1 (K6)  
        .equ CRYP_K3RR_K7, 1 << 7   @ bitWidth 1 (K7)  
        .equ CRYP_K3RR_K8, 1 << 8   @ bitWidth 1 (K8)  
        .equ CRYP_K3RR_K9, 1 << 9   @ bitWidth 1 (K9)  
        .equ CRYP_K3RR_K10, 1 << 10   @ bitWidth 1 (K10)  
        .equ CRYP_K3RR_K11, 1 << 11   @ bitWidth 1 (K11)  
        .equ CRYP_K3RR_K12, 1 << 12   @ bitWidth 1 (K12)  
        .equ CRYP_K3RR_K13, 1 << 13   @ bitWidth 1 (K13)  
        .equ CRYP_K3RR_K14, 1 << 14   @ bitWidth 1 (K14)  
        .equ CRYP_K3RR_K15, 1 << 15   @ bitWidth 1 (K15)  
        .equ CRYP_K3RR_K16, 1 << 16   @ bitWidth 1 (K16)  
        .equ CRYP_K3RR_K17, 1 << 17   @ bitWidth 1 (K17)  
        .equ CRYP_K3RR_K18, 1 << 18   @ bitWidth 1 (K18)  
        .equ CRYP_K3RR_K19, 1 << 19   @ bitWidth 1 (K19)  
        .equ CRYP_K3RR_K20, 1 << 20   @ bitWidth 1 (K20)  
        .equ CRYP_K3RR_K21, 1 << 21   @ bitWidth 1 (K21)  
        .equ CRYP_K3RR_K22, 1 << 22   @ bitWidth 1 (K22)  
        .equ CRYP_K3RR_K23, 1 << 23   @ bitWidth 1 (K23)  
        .equ CRYP_K3RR_K24, 1 << 24   @ bitWidth 1 (K24)  
        .equ CRYP_K3RR_K25, 1 << 25   @ bitWidth 1 (K25)  
        .equ CRYP_K3RR_K26, 1 << 26   @ bitWidth 1 (K26)  
        .equ CRYP_K3RR_K27, 1 << 27   @ bitWidth 1 (K27)  
        .equ CRYP_K3RR_K28, 1 << 28   @ bitWidth 1 (K28)  
        .equ CRYP_K3RR_K29, 1 << 29   @ bitWidth 1 (K29)  
        .equ CRYP_K3RR_K30, 1 << 30   @ bitWidth 1 (K30)  
        .equ CRYP_K3RR_K31, 1 << 31   @ bitWidth 1 (K31)  
 
    .equ CRYP_IV0LR, CRYP_BASE + 0x40 @ (initialization vector  registers) 
        .equ CRYP_IV0LR_IV31, 1 << 0   @ bitWidth 1 (IV31)  
        .equ CRYP_IV0LR_IV30, 1 << 1   @ bitWidth 1 (IV30)  
        .equ CRYP_IV0LR_IV29, 1 << 2   @ bitWidth 1 (IV29)  
        .equ CRYP_IV0LR_IV28, 1 << 3   @ bitWidth 1 (IV28)  
        .equ CRYP_IV0LR_IV27, 1 << 4   @ bitWidth 1 (IV27)  
        .equ CRYP_IV0LR_IV26, 1 << 5   @ bitWidth 1 (IV26)  
        .equ CRYP_IV0LR_IV25, 1 << 6   @ bitWidth 1 (IV25)  
        .equ CRYP_IV0LR_IV24, 1 << 7   @ bitWidth 1 (IV24)  
        .equ CRYP_IV0LR_IV23, 1 << 8   @ bitWidth 1 (IV23)  
        .equ CRYP_IV0LR_IV22, 1 << 9   @ bitWidth 1 (IV22)  
        .equ CRYP_IV0LR_IV21, 1 << 10   @ bitWidth 1 (IV21)  
        .equ CRYP_IV0LR_IV20, 1 << 11   @ bitWidth 1 (IV20)  
        .equ CRYP_IV0LR_IV19, 1 << 12   @ bitWidth 1 (IV19)  
        .equ CRYP_IV0LR_IV18, 1 << 13   @ bitWidth 1 (IV18)  
        .equ CRYP_IV0LR_IV17, 1 << 14   @ bitWidth 1 (IV17)  
        .equ CRYP_IV0LR_IV16, 1 << 15   @ bitWidth 1 (IV16)  
        .equ CRYP_IV0LR_IV15, 1 << 16   @ bitWidth 1 (IV15)  
        .equ CRYP_IV0LR_IV14, 1 << 17   @ bitWidth 1 (IV14)  
        .equ CRYP_IV0LR_IV13, 1 << 18   @ bitWidth 1 (IV13)  
        .equ CRYP_IV0LR_IV12, 1 << 19   @ bitWidth 1 (IV12)  
        .equ CRYP_IV0LR_IV11, 1 << 20   @ bitWidth 1 (IV11)  
        .equ CRYP_IV0LR_IV10, 1 << 21   @ bitWidth 1 (IV10)  
        .equ CRYP_IV0LR_IV9, 1 << 22   @ bitWidth 1 (IV9)  
        .equ CRYP_IV0LR_IV8, 1 << 23   @ bitWidth 1 (IV8)  
        .equ CRYP_IV0LR_IV7, 1 << 24   @ bitWidth 1 (IV7)  
        .equ CRYP_IV0LR_IV6, 1 << 25   @ bitWidth 1 (IV6)  
        .equ CRYP_IV0LR_IV5, 1 << 26   @ bitWidth 1 (IV5)  
        .equ CRYP_IV0LR_IV4, 1 << 27   @ bitWidth 1 (IV4)  
        .equ CRYP_IV0LR_IV3, 1 << 28   @ bitWidth 1 (IV3)  
        .equ CRYP_IV0LR_IV2, 1 << 29   @ bitWidth 1 (IV2)  
        .equ CRYP_IV0LR_IV1, 1 << 30   @ bitWidth 1 (IV1)  
        .equ CRYP_IV0LR_IV0, 1 << 31   @ bitWidth 1 (IV0)  
 
    .equ CRYP_IV0RR, CRYP_BASE + 0x44 @ (initialization vector  registers) 
        .equ CRYP_IV0RR_IV63, 1 << 0   @ bitWidth 1 (IV63)  
        .equ CRYP_IV0RR_IV62, 1 << 1   @ bitWidth 1 (IV62)  
        .equ CRYP_IV0RR_IV61, 1 << 2   @ bitWidth 1 (IV61)  
        .equ CRYP_IV0RR_IV60, 1 << 3   @ bitWidth 1 (IV60)  
        .equ CRYP_IV0RR_IV59, 1 << 4   @ bitWidth 1 (IV59)  
        .equ CRYP_IV0RR_IV58, 1 << 5   @ bitWidth 1 (IV58)  
        .equ CRYP_IV0RR_IV57, 1 << 6   @ bitWidth 1 (IV57)  
        .equ CRYP_IV0RR_IV56, 1 << 7   @ bitWidth 1 (IV56)  
        .equ CRYP_IV0RR_IV55, 1 << 8   @ bitWidth 1 (IV55)  
        .equ CRYP_IV0RR_IV54, 1 << 9   @ bitWidth 1 (IV54)  
        .equ CRYP_IV0RR_IV53, 1 << 10   @ bitWidth 1 (IV53)  
        .equ CRYP_IV0RR_IV52, 1 << 11   @ bitWidth 1 (IV52)  
        .equ CRYP_IV0RR_IV51, 1 << 12   @ bitWidth 1 (IV51)  
        .equ CRYP_IV0RR_IV50, 1 << 13   @ bitWidth 1 (IV50)  
        .equ CRYP_IV0RR_IV49, 1 << 14   @ bitWidth 1 (IV49)  
        .equ CRYP_IV0RR_IV48, 1 << 15   @ bitWidth 1 (IV48)  
        .equ CRYP_IV0RR_IV47, 1 << 16   @ bitWidth 1 (IV47)  
        .equ CRYP_IV0RR_IV46, 1 << 17   @ bitWidth 1 (IV46)  
        .equ CRYP_IV0RR_IV45, 1 << 18   @ bitWidth 1 (IV45)  
        .equ CRYP_IV0RR_IV44, 1 << 19   @ bitWidth 1 (IV44)  
        .equ CRYP_IV0RR_IV43, 1 << 20   @ bitWidth 1 (IV43)  
        .equ CRYP_IV0RR_IV42, 1 << 21   @ bitWidth 1 (IV42)  
        .equ CRYP_IV0RR_IV41, 1 << 22   @ bitWidth 1 (IV41)  
        .equ CRYP_IV0RR_IV40, 1 << 23   @ bitWidth 1 (IV40)  
        .equ CRYP_IV0RR_IV39, 1 << 24   @ bitWidth 1 (IV39)  
        .equ CRYP_IV0RR_IV38, 1 << 25   @ bitWidth 1 (IV38)  
        .equ CRYP_IV0RR_IV37, 1 << 26   @ bitWidth 1 (IV37)  
        .equ CRYP_IV0RR_IV36, 1 << 27   @ bitWidth 1 (IV36)  
        .equ CRYP_IV0RR_IV35, 1 << 28   @ bitWidth 1 (IV35)  
        .equ CRYP_IV0RR_IV34, 1 << 29   @ bitWidth 1 (IV34)  
        .equ CRYP_IV0RR_IV33, 1 << 30   @ bitWidth 1 (IV33)  
        .equ CRYP_IV0RR_IV32, 1 << 31   @ bitWidth 1 (IV32)  
 
    .equ CRYP_IV1LR, CRYP_BASE + 0x48 @ (initialization vector  registers) 
        .equ CRYP_IV1LR_IV95, 1 << 0   @ bitWidth 1 (IV95)  
        .equ CRYP_IV1LR_IV94, 1 << 1   @ bitWidth 1 (IV94)  
        .equ CRYP_IV1LR_IV93, 1 << 2   @ bitWidth 1 (IV93)  
        .equ CRYP_IV1LR_IV92, 1 << 3   @ bitWidth 1 (IV92)  
        .equ CRYP_IV1LR_IV91, 1 << 4   @ bitWidth 1 (IV91)  
        .equ CRYP_IV1LR_IV90, 1 << 5   @ bitWidth 1 (IV90)  
        .equ CRYP_IV1LR_IV89, 1 << 6   @ bitWidth 1 (IV89)  
        .equ CRYP_IV1LR_IV88, 1 << 7   @ bitWidth 1 (IV88)  
        .equ CRYP_IV1LR_IV87, 1 << 8   @ bitWidth 1 (IV87)  
        .equ CRYP_IV1LR_IV86, 1 << 9   @ bitWidth 1 (IV86)  
        .equ CRYP_IV1LR_IV85, 1 << 10   @ bitWidth 1 (IV85)  
        .equ CRYP_IV1LR_IV84, 1 << 11   @ bitWidth 1 (IV84)  
        .equ CRYP_IV1LR_IV83, 1 << 12   @ bitWidth 1 (IV83)  
        .equ CRYP_IV1LR_IV82, 1 << 13   @ bitWidth 1 (IV82)  
        .equ CRYP_IV1LR_IV81, 1 << 14   @ bitWidth 1 (IV81)  
        .equ CRYP_IV1LR_IV80, 1 << 15   @ bitWidth 1 (IV80)  
        .equ CRYP_IV1LR_IV79, 1 << 16   @ bitWidth 1 (IV79)  
        .equ CRYP_IV1LR_IV78, 1 << 17   @ bitWidth 1 (IV78)  
        .equ CRYP_IV1LR_IV77, 1 << 18   @ bitWidth 1 (IV77)  
        .equ CRYP_IV1LR_IV76, 1 << 19   @ bitWidth 1 (IV76)  
        .equ CRYP_IV1LR_IV75, 1 << 20   @ bitWidth 1 (IV75)  
        .equ CRYP_IV1LR_IV74, 1 << 21   @ bitWidth 1 (IV74)  
        .equ CRYP_IV1LR_IV73, 1 << 22   @ bitWidth 1 (IV73)  
        .equ CRYP_IV1LR_IV72, 1 << 23   @ bitWidth 1 (IV72)  
        .equ CRYP_IV1LR_IV71, 1 << 24   @ bitWidth 1 (IV71)  
        .equ CRYP_IV1LR_IV70, 1 << 25   @ bitWidth 1 (IV70)  
        .equ CRYP_IV1LR_IV69, 1 << 26   @ bitWidth 1 (IV69)  
        .equ CRYP_IV1LR_IV68, 1 << 27   @ bitWidth 1 (IV68)  
        .equ CRYP_IV1LR_IV67, 1 << 28   @ bitWidth 1 (IV67)  
        .equ CRYP_IV1LR_IV66, 1 << 29   @ bitWidth 1 (IV66)  
        .equ CRYP_IV1LR_IV65, 1 << 30   @ bitWidth 1 (IV65)  
        .equ CRYP_IV1LR_IV64, 1 << 31   @ bitWidth 1 (IV64)  
 
    .equ CRYP_IV1RR, CRYP_BASE + 0x4C @ (initialization vector  registers) 
        .equ CRYP_IV1RR_IV127, 1 << 0   @ bitWidth 1 (IV127)  
        .equ CRYP_IV1RR_IV126, 1 << 1   @ bitWidth 1 (IV126)  
        .equ CRYP_IV1RR_IV125, 1 << 2   @ bitWidth 1 (IV125)  
        .equ CRYP_IV1RR_IV124, 1 << 3   @ bitWidth 1 (IV124)  
        .equ CRYP_IV1RR_IV123, 1 << 4   @ bitWidth 1 (IV123)  
        .equ CRYP_IV1RR_IV122, 1 << 5   @ bitWidth 1 (IV122)  
        .equ CRYP_IV1RR_IV121, 1 << 6   @ bitWidth 1 (IV121)  
        .equ CRYP_IV1RR_IV120, 1 << 7   @ bitWidth 1 (IV120)  
        .equ CRYP_IV1RR_IV119, 1 << 8   @ bitWidth 1 (IV119)  
        .equ CRYP_IV1RR_IV118, 1 << 9   @ bitWidth 1 (IV118)  
        .equ CRYP_IV1RR_IV117, 1 << 10   @ bitWidth 1 (IV117)  
        .equ CRYP_IV1RR_IV116, 1 << 11   @ bitWidth 1 (IV116)  
        .equ CRYP_IV1RR_IV115, 1 << 12   @ bitWidth 1 (IV115)  
        .equ CRYP_IV1RR_IV114, 1 << 13   @ bitWidth 1 (IV114)  
        .equ CRYP_IV1RR_IV113, 1 << 14   @ bitWidth 1 (IV113)  
        .equ CRYP_IV1RR_IV112, 1 << 15   @ bitWidth 1 (IV112)  
        .equ CRYP_IV1RR_IV111, 1 << 16   @ bitWidth 1 (IV111)  
        .equ CRYP_IV1RR_IV110, 1 << 17   @ bitWidth 1 (IV110)  
        .equ CRYP_IV1RR_IV109, 1 << 18   @ bitWidth 1 (IV109)  
        .equ CRYP_IV1RR_IV108, 1 << 19   @ bitWidth 1 (IV108)  
        .equ CRYP_IV1RR_IV107, 1 << 20   @ bitWidth 1 (IV107)  
        .equ CRYP_IV1RR_IV106, 1 << 21   @ bitWidth 1 (IV106)  
        .equ CRYP_IV1RR_IV105, 1 << 22   @ bitWidth 1 (IV105)  
        .equ CRYP_IV1RR_IV104, 1 << 23   @ bitWidth 1 (IV104)  
        .equ CRYP_IV1RR_IV103, 1 << 24   @ bitWidth 1 (IV103)  
        .equ CRYP_IV1RR_IV102, 1 << 25   @ bitWidth 1 (IV102)  
        .equ CRYP_IV1RR_IV101, 1 << 26   @ bitWidth 1 (IV101)  
        .equ CRYP_IV1RR_IV100, 1 << 27   @ bitWidth 1 (IV100)  
        .equ CRYP_IV1RR_IV99, 1 << 28   @ bitWidth 1 (IV99)  
        .equ CRYP_IV1RR_IV98, 1 << 29   @ bitWidth 1 (IV98)  
        .equ CRYP_IV1RR_IV97, 1 << 30   @ bitWidth 1 (IV97)  
        .equ CRYP_IV1RR_IV96, 1 << 31   @ bitWidth 1 (IV96)  
 
    .equ CRYP_CSGCMCCM0R, CRYP_BASE + 0x50 @ (context swap register) 
        .equ CRYP_CSGCMCCM0R_CSGCMCCM0_Shift, 0   @ bitWidth 32 (CSGCMCCM0)  
 
    .equ CRYP_CSGCMCCM1R, CRYP_BASE + 0x54 @ (context swap register) 
        .equ CRYP_CSGCMCCM1R_CSGCMCCM1_Shift, 0   @ bitWidth 32 (CSGCMCCM1)  
 
    .equ CRYP_CSGCMCCM2R, CRYP_BASE + 0x58 @ (context swap register) 
        .equ CRYP_CSGCMCCM2R_CSGCMCCM2_Shift, 0   @ bitWidth 32 (CSGCMCCM2)  
 
    .equ CRYP_CSGCMCCM3R, CRYP_BASE + 0x5C @ (context swap register) 
        .equ CRYP_CSGCMCCM3R_CSGCMCCM3_Shift, 0   @ bitWidth 32 (CSGCMCCM3)  
 
    .equ CRYP_CSGCMCCM4R, CRYP_BASE + 0x60 @ (context swap register) 
        .equ CRYP_CSGCMCCM4R_CSGCMCCM4_Shift, 0   @ bitWidth 32 (CSGCMCCM4)  
 
    .equ CRYP_CSGCMCCM5R, CRYP_BASE + 0x64 @ (context swap register) 
        .equ CRYP_CSGCMCCM5R_CSGCMCCM5_Shift, 0   @ bitWidth 32 (CSGCMCCM5)  
 
    .equ CRYP_CSGCMCCM6R, CRYP_BASE + 0x68 @ (context swap register) 
        .equ CRYP_CSGCMCCM6R_CSGCMCCM6_Shift, 0   @ bitWidth 32 (CSGCMCCM6)  
 
    .equ CRYP_CSGCMCCM7R, CRYP_BASE + 0x6C @ (context swap register) 
        .equ CRYP_CSGCMCCM7R_CSGCMCCM7_Shift, 0   @ bitWidth 32 (CSGCMCCM7)  
 
    .equ CRYP_CSGCM0R, CRYP_BASE + 0x70 @ (context swap register) 
        .equ CRYP_CSGCM0R_CSGCM0_Shift, 0   @ bitWidth 32 (CSGCM0)  
 
    .equ CRYP_CSGCM1R, CRYP_BASE + 0x74 @ (context swap register) 
        .equ CRYP_CSGCM1R_CSGCM1_Shift, 0   @ bitWidth 32 (CSGCM1)  
 
    .equ CRYP_CSGCM2R, CRYP_BASE + 0x78 @ (context swap register) 
        .equ CRYP_CSGCM2R_CSGCM2_Shift, 0   @ bitWidth 32 (CSGCM2)  
 
    .equ CRYP_CSGCM3R, CRYP_BASE + 0x7C @ (context swap register) 
        .equ CRYP_CSGCM3R_CSGCM3_Shift, 0   @ bitWidth 32 (CSGCM3)  
 
    .equ CRYP_CSGCM4R, CRYP_BASE + 0x80 @ (context swap register) 
        .equ CRYP_CSGCM4R_CSGCM4_Shift, 0   @ bitWidth 32 (CSGCM4)  
 
    .equ CRYP_CSGCM5R, CRYP_BASE + 0x84 @ (context swap register) 
        .equ CRYP_CSGCM5R_CSGCM5_Shift, 0   @ bitWidth 32 (CSGCM5)  
 
    .equ CRYP_CSGCM6R, CRYP_BASE + 0x88 @ (context swap register) 
        .equ CRYP_CSGCM6R_CSGCM6_Shift, 0   @ bitWidth 32 (CSGCM6)  
 
    .equ CRYP_CSGCM7R, CRYP_BASE + 0x8C @ (context swap register) 
        .equ CRYP_CSGCM7R_CSGCM7_Shift, 0   @ bitWidth 32 (CSGCM7)  
 

@=========================== DCMI ===========================@
.equ DCMI_BASE, 0x48020000 @ (Digital camera interface) 
    .equ DCMI_CR, DCMI_BASE + 0x0 @ (control register 1) 
        .equ DCMI_CR_OELS, 1 << 20   @ bitWidth 1 (Odd/Even Line Select Line Select  Start)  
        .equ DCMI_CR_LSM, 1 << 19   @ bitWidth 1 (Line Select mode)  
        .equ DCMI_CR_OEBS, 1 << 18   @ bitWidth 1 (Odd/Even Byte Select Byte Select  Start)  
        .equ DCMI_CR_BSM_Shift, 16   @ bitWidth 2 (Byte Select mode)  
        .equ DCMI_CR_ENABLE, 1 << 14   @ bitWidth 1 (DCMI enable)  
        .equ DCMI_CR_EDM_Shift, 10   @ bitWidth 2 (Extended data mode)  
        .equ DCMI_CR_FCRC_Shift, 8   @ bitWidth 2 (Frame capture rate control)  
        .equ DCMI_CR_VSPOL, 1 << 7   @ bitWidth 1 (Vertical synchronization  polarity)  
        .equ DCMI_CR_HSPOL, 1 << 6   @ bitWidth 1 (Horizontal synchronization  polarity)  
        .equ DCMI_CR_PCKPOL, 1 << 5   @ bitWidth 1 (Pixel clock polarity)  
        .equ DCMI_CR_ESS, 1 << 4   @ bitWidth 1 (Embedded synchronization  select)  
        .equ DCMI_CR_JPEG, 1 << 3   @ bitWidth 1 (JPEG format)  
        .equ DCMI_CR_CROP, 1 << 2   @ bitWidth 1 (Crop feature)  
        .equ DCMI_CR_CM, 1 << 1   @ bitWidth 1 (Capture mode)  
        .equ DCMI_CR_CAPTURE, 1 << 0   @ bitWidth 1 (Capture enable)  
 
    .equ DCMI_SR, DCMI_BASE + 0x4 @ (status register) 
        .equ DCMI_SR_FNE, 1 << 2   @ bitWidth 1 (FIFO not empty)  
        .equ DCMI_SR_VSYNC, 1 << 1   @ bitWidth 1 (VSYNC)  
        .equ DCMI_SR_HSYNC, 1 << 0   @ bitWidth 1 (HSYNC)  
 
    .equ DCMI_RIS, DCMI_BASE + 0x8 @ (raw interrupt status register) 
        .equ DCMI_RIS_LINE_RIS, 1 << 4   @ bitWidth 1 (Line raw interrupt status)  
        .equ DCMI_RIS_VSYNC_RIS, 1 << 3   @ bitWidth 1 (VSYNC raw interrupt status)  
        .equ DCMI_RIS_ERR_RIS, 1 << 2   @ bitWidth 1 (Synchronization error raw interrupt  status)  
        .equ DCMI_RIS_OVR_RIS, 1 << 1   @ bitWidth 1 (Overrun raw interrupt  status)  
        .equ DCMI_RIS_FRAME_RIS, 1 << 0   @ bitWidth 1 (Capture complete raw interrupt  status)  
 
    .equ DCMI_IER, DCMI_BASE + 0xC @ (interrupt enable register) 
        .equ DCMI_IER_LINE_IE, 1 << 4   @ bitWidth 1 (Line interrupt enable)  
        .equ DCMI_IER_VSYNC_IE, 1 << 3   @ bitWidth 1 (VSYNC interrupt enable)  
        .equ DCMI_IER_ERR_IE, 1 << 2   @ bitWidth 1 (Synchronization error interrupt  enable)  
        .equ DCMI_IER_OVR_IE, 1 << 1   @ bitWidth 1 (Overrun interrupt enable)  
        .equ DCMI_IER_FRAME_IE, 1 << 0   @ bitWidth 1 (Capture complete interrupt  enable)  
 
    .equ DCMI_MIS, DCMI_BASE + 0x10 @ (masked interrupt status  register) 
        .equ DCMI_MIS_LINE_MIS, 1 << 4   @ bitWidth 1 (Line masked interrupt  status)  
        .equ DCMI_MIS_VSYNC_MIS, 1 << 3   @ bitWidth 1 (VSYNC masked interrupt  status)  
        .equ DCMI_MIS_ERR_MIS, 1 << 2   @ bitWidth 1 (Synchronization error masked interrupt  status)  
        .equ DCMI_MIS_OVR_MIS, 1 << 1   @ bitWidth 1 (Overrun masked interrupt  status)  
        .equ DCMI_MIS_FRAME_MIS, 1 << 0   @ bitWidth 1 (Capture complete masked interrupt  status)  
 
    .equ DCMI_ICR, DCMI_BASE + 0x14 @ (interrupt clear register) 
        .equ DCMI_ICR_LINE_ISC, 1 << 4   @ bitWidth 1 (line interrupt status  clear)  
        .equ DCMI_ICR_VSYNC_ISC, 1 << 3   @ bitWidth 1 (Vertical synch interrupt status  clear)  
        .equ DCMI_ICR_ERR_ISC, 1 << 2   @ bitWidth 1 (Synchronization error interrupt status  clear)  
        .equ DCMI_ICR_OVR_ISC, 1 << 1   @ bitWidth 1 (Overrun interrupt status  clear)  
        .equ DCMI_ICR_FRAME_ISC, 1 << 0   @ bitWidth 1 (Capture complete interrupt status  clear)  
 
    .equ DCMI_ESCR, DCMI_BASE + 0x18 @ (embedded synchronization code  register) 
        .equ DCMI_ESCR_FEC_Shift, 24   @ bitWidth 8 (Frame end delimiter code)  
        .equ DCMI_ESCR_LEC_Shift, 16   @ bitWidth 8 (Line end delimiter code)  
        .equ DCMI_ESCR_LSC_Shift, 8   @ bitWidth 8 (Line start delimiter code)  
        .equ DCMI_ESCR_FSC_Shift, 0   @ bitWidth 8 (Frame start delimiter code)  
 
    .equ DCMI_ESUR, DCMI_BASE + 0x1C @ (embedded synchronization unmask  register) 
        .equ DCMI_ESUR_FEU_Shift, 24   @ bitWidth 8 (Frame end delimiter unmask)  
        .equ DCMI_ESUR_LEU_Shift, 16   @ bitWidth 8 (Line end delimiter unmask)  
        .equ DCMI_ESUR_LSU_Shift, 8   @ bitWidth 8 (Line start delimiter  unmask)  
        .equ DCMI_ESUR_FSU_Shift, 0   @ bitWidth 8 (Frame start delimiter  unmask)  
 
    .equ DCMI_CWSTRT, DCMI_BASE + 0x20 @ (crop window start) 
        .equ DCMI_CWSTRT_VST_Shift, 16   @ bitWidth 13 (Vertical start line count)  
        .equ DCMI_CWSTRT_HOFFCNT_Shift, 0   @ bitWidth 14 (Horizontal offset count)  
 
    .equ DCMI_CWSIZE, DCMI_BASE + 0x24 @ (crop window size) 
        .equ DCMI_CWSIZE_VLINE_Shift, 16   @ bitWidth 14 (Vertical line count)  
        .equ DCMI_CWSIZE_CAPCNT_Shift, 0   @ bitWidth 14 (Capture count)  
 
    .equ DCMI_DR, DCMI_BASE + 0x28 @ (data register) 
        .equ DCMI_DR_Byte3_Shift, 24   @ bitWidth 8 (Data byte 3)  
        .equ DCMI_DR_Byte2_Shift, 16   @ bitWidth 8 (Data byte 2)  
        .equ DCMI_DR_Byte1_Shift, 8   @ bitWidth 8 (Data byte 1)  
        .equ DCMI_DR_Byte0_Shift, 0   @ bitWidth 8 (Data byte 0)  
 

@=========================== OTG1_HS_GLOBAL ===========================@
.equ OTG1_HS_GLOBAL_BASE, 0x40040000 @ (USB 1 on the go high speed) 
    .equ OTG1_HS_GLOBAL_OTG_HS_GOTGCTL, OTG1_HS_GLOBAL_BASE + 0x0 @ (OTG_HS control and status  register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_SRQSCS, 1 << 0   @ bitWidth 1 (Session request success)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_SRQ, 1 << 1   @ bitWidth 1 (Session request)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_HNGSCS, 1 << 8   @ bitWidth 1 (Host negotiation success)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_HNPRQ, 1 << 9   @ bitWidth 1 (HNP request)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_HSHNPEN, 1 << 10   @ bitWidth 1 (Host set HNP enable)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_DHNPEN, 1 << 11   @ bitWidth 1 (Device HNP enabled)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_CIDSTS, 1 << 16   @ bitWidth 1 (Connector ID status)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_DBCT, 1 << 17   @ bitWidth 1 (Long/short debounce time)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_ASVLD, 1 << 18   @ bitWidth 1 (A-session valid)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_BSVLD, 1 << 19   @ bitWidth 1 (B-session valid)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_EHEN, 1 << 12   @ bitWidth 1 (Embedded host enable)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_GOTGINT, OTG1_HS_GLOBAL_BASE + 0x4 @ (OTG_HS interrupt register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGINT_SEDET, 1 << 2   @ bitWidth 1 (Session end detected)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGINT_SRSSCHG, 1 << 8   @ bitWidth 1 (Session request success status  change)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGINT_HNSSCHG, 1 << 9   @ bitWidth 1 (Host negotiation success status  change)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGINT_HNGDET, 1 << 17   @ bitWidth 1 (Host negotiation detected)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGINT_ADTOCHG, 1 << 18   @ bitWidth 1 (A-device timeout change)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGINT_DBCDNE, 1 << 19   @ bitWidth 1 (Debounce done)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GOTGINT_IDCHNG, 1 << 20   @ bitWidth 1 (ID input pin changed)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_GAHBCFG, OTG1_HS_GLOBAL_BASE + 0x8 @ (OTG_HS AHB configuration  register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_GINT, 1 << 0   @ bitWidth 1 (Global interrupt mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN_Shift, 1   @ bitWidth 4 (Burst length/type)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_DMAEN, 1 << 5   @ bitWidth 1 (DMA enable)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_TXFELVL, 1 << 7   @ bitWidth 1 (TxFIFO empty level)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_PTXFELVL, 1 << 8   @ bitWidth 1 (Periodic TxFIFO empty  level)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG, OTG1_HS_GLOBAL_BASE + 0xC @ (OTG_HS USB configuration  register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL_Shift, 0   @ bitWidth 3 (FS timeout calibration)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PHYSEL, 1 << 6   @ bitWidth 1 (USB 2.0 high-speed ULPI PHY or USB 1.1  full-speed serial transceiver select)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_SRPCAP, 1 << 8   @ bitWidth 1 (SRP-capable)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_HNPCAP, 1 << 9   @ bitWidth 1 (HNP-capable)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT_Shift, 10   @ bitWidth 4 (USB turnaround time)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PHYLPCS, 1 << 15   @ bitWidth 1 (PHY Low-power clock select)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIFSLS, 1 << 17   @ bitWidth 1 (ULPI FS/LS select)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIAR, 1 << 18   @ bitWidth 1 (ULPI Auto-resume)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPICSM, 1 << 19   @ bitWidth 1 (ULPI Clock SuspendM)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSD, 1 << 20   @ bitWidth 1 (ULPI External VBUS Drive)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSI, 1 << 21   @ bitWidth 1 (ULPI external VBUS  indicator)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TSDPS, 1 << 22   @ bitWidth 1 (TermSel DLine pulsing  selection)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PCCI, 1 << 23   @ bitWidth 1 (Indicator complement)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PTCI, 1 << 24   @ bitWidth 1 (Indicator pass through)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIIPD, 1 << 25   @ bitWidth 1 (ULPI interface protect  disable)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_FHMOD, 1 << 29   @ bitWidth 1 (Forced host mode)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_FDMOD, 1 << 30   @ bitWidth 1 (Forced peripheral mode)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_GRSTCTL, OTG1_HS_GLOBAL_BASE + 0x10 @ (OTG_HS reset register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_CSRST, 1 << 0   @ bitWidth 1 (Core soft reset)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_HSRST, 1 << 1   @ bitWidth 1 (HCLK soft reset)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_FCRST, 1 << 2   @ bitWidth 1 (Host frame counter reset)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_RXFFLSH, 1 << 4   @ bitWidth 1 (RxFIFO flush)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_TXFFLSH, 1 << 5   @ bitWidth 1 (TxFIFO flush)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM_Shift, 6   @ bitWidth 5 (TxFIFO number)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_AHBIDL, 1 << 31   @ bitWidth 1 (AHB master idle)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_DMAREQ, 1 << 30   @ bitWidth 1 (DMA request signal enabled for USB OTG  HS)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS, OTG1_HS_GLOBAL_BASE + 0x14 @ (OTG_HS core interrupt register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_CMOD, 1 << 0   @ bitWidth 1 (Current mode of operation)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_MMIS, 1 << 1   @ bitWidth 1 (Mode mismatch interrupt)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_OTGINT, 1 << 2   @ bitWidth 1 (OTG interrupt)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_SOF, 1 << 3   @ bitWidth 1 (Start of frame)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_RXFLVL, 1 << 4   @ bitWidth 1 (RxFIFO nonempty)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_NPTXFE, 1 << 5   @ bitWidth 1 (Nonperiodic TxFIFO empty)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_GINAKEFF, 1 << 6   @ bitWidth 1 (Global IN nonperiodic NAK  effective)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_BOUTNAKEFF, 1 << 7   @ bitWidth 1 (Global OUT NAK effective)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_ESUSP, 1 << 10   @ bitWidth 1 (Early suspend)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_USBSUSP, 1 << 11   @ bitWidth 1 (USB suspend)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_USBRST, 1 << 12   @ bitWidth 1 (USB reset)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_ENUMDNE, 1 << 13   @ bitWidth 1 (Enumeration done)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_ISOODRP, 1 << 14   @ bitWidth 1 (Isochronous OUT packet dropped  interrupt)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_EOPF, 1 << 15   @ bitWidth 1 (End of periodic frame  interrupt)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_IEPINT, 1 << 18   @ bitWidth 1 (IN endpoint interrupt)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_OEPINT, 1 << 19   @ bitWidth 1 (OUT endpoint interrupt)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_IISOIXFR, 1 << 20   @ bitWidth 1 (Incomplete isochronous IN  transfer)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_PXFR_INCOMPISOOUT, 1 << 21   @ bitWidth 1 (Incomplete periodic  transfer)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_DATAFSUSP, 1 << 22   @ bitWidth 1 (Data fetch suspended)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_HPRTINT, 1 << 24   @ bitWidth 1 (Host port interrupt)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_HCINT, 1 << 25   @ bitWidth 1 (Host channels interrupt)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_PTXFE, 1 << 26   @ bitWidth 1 (Periodic TxFIFO empty)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_CIDSCHG, 1 << 28   @ bitWidth 1 (Connector ID status change)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_DISCINT, 1 << 29   @ bitWidth 1 (Disconnect detected  interrupt)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_SRQINT, 1 << 30   @ bitWidth 1 (Session request/new session detected  interrupt)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTSTS_WKUINT, 1 << 31   @ bitWidth 1 (Resume/remote wakeup detected  interrupt)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK, OTG1_HS_GLOBAL_BASE + 0x18 @ (OTG_HS interrupt mask register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_MMISM, 1 << 1   @ bitWidth 1 (Mode mismatch interrupt  mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_OTGINT, 1 << 2   @ bitWidth 1 (OTG interrupt mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_SOFM, 1 << 3   @ bitWidth 1 (Start of frame mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_RXFLVLM, 1 << 4   @ bitWidth 1 (Receive FIFO nonempty mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_NPTXFEM, 1 << 5   @ bitWidth 1 (Nonperiodic TxFIFO empty  mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_GINAKEFFM, 1 << 6   @ bitWidth 1 (Global nonperiodic IN NAK effective  mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_GONAKEFFM, 1 << 7   @ bitWidth 1 (Global OUT NAK effective  mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_ESUSPM, 1 << 10   @ bitWidth 1 (Early suspend mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_USBSUSPM, 1 << 11   @ bitWidth 1 (USB suspend mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_USBRST, 1 << 12   @ bitWidth 1 (USB reset mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_ENUMDNEM, 1 << 13   @ bitWidth 1 (Enumeration done mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_ISOODRPM, 1 << 14   @ bitWidth 1 (Isochronous OUT packet dropped interrupt  mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_EOPFM, 1 << 15   @ bitWidth 1 (End of periodic frame interrupt  mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_IEPINT, 1 << 18   @ bitWidth 1 (IN endpoints interrupt  mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_OEPINT, 1 << 19   @ bitWidth 1 (OUT endpoints interrupt  mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_IISOIXFRM, 1 << 20   @ bitWidth 1 (Incomplete isochronous IN transfer  mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_PXFRM_IISOOXFRM, 1 << 21   @ bitWidth 1 (Incomplete periodic transfer  mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_FSUSPM, 1 << 22   @ bitWidth 1 (Data fetch suspended mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_PRTIM, 1 << 24   @ bitWidth 1 (Host port interrupt mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_HCIM, 1 << 25   @ bitWidth 1 (Host channels interrupt  mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_PTXFEM, 1 << 26   @ bitWidth 1 (Periodic TxFIFO empty mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_CIDSCHGM, 1 << 28   @ bitWidth 1 (Connector ID status change  mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_DISCINT, 1 << 29   @ bitWidth 1 (Disconnect detected interrupt  mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_SRQIM, 1 << 30   @ bitWidth 1 (Session request/new session detected  interrupt mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_WUIM, 1 << 31   @ bitWidth 1 (Resume/remote wakeup detected interrupt  mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_RSTDE, 1 << 23   @ bitWidth 1 (Reset detected interrupt  mask)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GINTMSK_LPMINTM, 1 << 27   @ bitWidth 1 (LPM interrupt mask)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Host, OTG1_HS_GLOBAL_BASE + 0x1C @ (OTG_HS Receive status debug read register  host mode) 
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Host_CHNUM_Shift, 0   @ bitWidth 4 (Channel number)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Host_BCNT_Shift, 4   @ bitWidth 11 (Byte count)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Host_DPID_Shift, 15   @ bitWidth 2 (Data PID)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Host_PKTSTS_Shift, 17   @ bitWidth 4 (Packet status)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Host, OTG1_HS_GLOBAL_BASE + 0x20 @ (OTG_HS status read and pop register host  mode) 
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Host_CHNUM_Shift, 0   @ bitWidth 4 (Channel number)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Host_BCNT_Shift, 4   @ bitWidth 11 (Byte count)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Host_DPID_Shift, 15   @ bitWidth 2 (Data PID)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Host_PKTSTS_Shift, 17   @ bitWidth 4 (Packet status)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_GRXFSIZ, OTG1_HS_GLOBAL_BASE + 0x24 @ (OTG_HS Receive FIFO size  register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXFSIZ_RXFD_Shift, 0   @ bitWidth 16 (RxFIFO depth)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_Host, OTG1_HS_GLOBAL_BASE + 0x28 @ (OTG_HS nonperiodic transmit FIFO size  register host mode) 
        .equ OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_Host_NPTXFSA_Shift, 0   @ bitWidth 16 (Nonperiodic transmit RAM start  address)  
        .equ OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_Host_NPTXFD_Shift, 16   @ bitWidth 16 (Nonperiodic TxFIFO depth)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF0_Device, OTG1_HS_GLOBAL_BASE + 0x28 @ (Endpoint 0 transmit FIFO size peripheral  mode) 
        .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF0_Device_TX0FSA_Shift, 0   @ bitWidth 16 (Endpoint 0 transmit RAM start  address)  
        .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF0_Device_TX0FD_Shift, 16   @ bitWidth 16 (Endpoint 0 TxFIFO depth)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS, OTG1_HS_GLOBAL_BASE + 0x2C @ (OTG_HS nonperiodic transmit FIFO/queue  status register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXFSAV_Shift, 0   @ bitWidth 16 (Nonperiodic TxFIFO space  available)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTQXSAV_Shift, 16   @ bitWidth 8 (Nonperiodic transmit request queue space  available)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXQTOP_Shift, 24   @ bitWidth 7 (Top of the nonperiodic transmit request  queue)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_GCCFG, OTG1_HS_GLOBAL_BASE + 0x38 @ (OTG_HS general core configuration  register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_GCCFG_PWRDWN, 1 << 16   @ bitWidth 1 (Power down)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GCCFG_BCDEN, 1 << 17   @ bitWidth 1 (Battery charging detector BCD  enable)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GCCFG_DCDEN, 1 << 18   @ bitWidth 1 (Data contact detection DCD mode  enable)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GCCFG_PDEN, 1 << 19   @ bitWidth 1 (Primary detection PD mode  enable)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GCCFG_SDEN, 1 << 20   @ bitWidth 1 (Secondary detection SD mode  enable)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GCCFG_VBDEN, 1 << 21   @ bitWidth 1 (USB VBUS detection enable)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GCCFG_DCDET, 1 << 0   @ bitWidth 1 (Data contact detection DCD  status)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GCCFG_PDET, 1 << 1   @ bitWidth 1 (Primary detection PD  status)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GCCFG_SDET, 1 << 2   @ bitWidth 1 (Secondary detection SD  status)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GCCFG_PS2DET, 1 << 3   @ bitWidth 1 (DM pull-up detection  status)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_CID, OTG1_HS_GLOBAL_BASE + 0x3C @ (OTG_HS core ID register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_CID_PRODUCT_ID_Shift, 0   @ bitWidth 32 (Product ID field)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ, OTG1_HS_GLOBAL_BASE + 0x100 @ (OTG_HS Host periodic transmit FIFO size  register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA_Shift, 0   @ bitWidth 16 (Host periodic TxFIFO start  address)  
        .equ OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD_Shift, 16   @ bitWidth 16 (Host periodic TxFIFO depth)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF1, OTG1_HS_GLOBAL_BASE + 0x104 @ (OTG_HS device IN endpoint transmit FIFO size  register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXSA_Shift, 0   @ bitWidth 16 (IN endpoint FIFOx transmit RAM start  address)  
        .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXFD_Shift, 16   @ bitWidth 16 (IN endpoint TxFIFO depth)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF2, OTG1_HS_GLOBAL_BASE + 0x108 @ (OTG_HS device IN endpoint transmit FIFO size  register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXSA_Shift, 0   @ bitWidth 16 (IN endpoint FIFOx transmit RAM start  address)  
        .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXFD_Shift, 16   @ bitWidth 16 (IN endpoint TxFIFO depth)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF3, OTG1_HS_GLOBAL_BASE + 0x11C @ (OTG_HS device IN endpoint transmit FIFO size  register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXSA_Shift, 0   @ bitWidth 16 (IN endpoint FIFOx transmit RAM start  address)  
        .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXFD_Shift, 16   @ bitWidth 16 (IN endpoint TxFIFO depth)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF4, OTG1_HS_GLOBAL_BASE + 0x120 @ (OTG_HS device IN endpoint transmit FIFO size  register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXSA_Shift, 0   @ bitWidth 16 (IN endpoint FIFOx transmit RAM start  address)  
        .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXFD_Shift, 16   @ bitWidth 16 (IN endpoint TxFIFO depth)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF5, OTG1_HS_GLOBAL_BASE + 0x124 @ (OTG_HS device IN endpoint transmit FIFO size  register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXSA_Shift, 0   @ bitWidth 16 (IN endpoint FIFOx transmit RAM start  address)  
        .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXFD_Shift, 16   @ bitWidth 16 (IN endpoint TxFIFO depth)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF6, OTG1_HS_GLOBAL_BASE + 0x128 @ (OTG_HS device IN endpoint transmit FIFO size  register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXSA_Shift, 0   @ bitWidth 16 (IN endpoint FIFOx transmit RAM start  address)  
        .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXFD_Shift, 16   @ bitWidth 16 (IN endpoint TxFIFO depth)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF7, OTG1_HS_GLOBAL_BASE + 0x12C @ (OTG_HS device IN endpoint transmit FIFO size  register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXSA_Shift, 0   @ bitWidth 16 (IN endpoint FIFOx transmit RAM start  address)  
        .equ OTG1_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXFD_Shift, 16   @ bitWidth 16 (IN endpoint TxFIFO depth)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Device, OTG1_HS_GLOBAL_BASE + 0x1C @ (OTG_HS Receive status debug read register  peripheral mode mode) 
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Device_EPNUM_Shift, 0   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Device_BCNT_Shift, 4   @ bitWidth 11 (Byte count)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Device_DPID_Shift, 15   @ bitWidth 2 (Data PID)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Device_PKTSTS_Shift, 17   @ bitWidth 4 (Packet status)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Device_FRMNUM_Shift, 21   @ bitWidth 4 (Frame number)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Device, OTG1_HS_GLOBAL_BASE + 0x20 @ (OTG_HS status read and pop register  peripheral mode) 
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Device_EPNUM_Shift, 0   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Device_BCNT_Shift, 4   @ bitWidth 11 (Byte count)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Device_DPID_Shift, 15   @ bitWidth 2 (Data PID)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Device_PKTSTS_Shift, 17   @ bitWidth 4 (Packet status)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Device_FRMNUM_Shift, 21   @ bitWidth 4 (Frame number)  
 
    .equ OTG1_HS_GLOBAL_OTG_HS_GLPMCFG, OTG1_HS_GLOBAL_BASE + 0x54 @ (OTG core LPM configuration  register) 
        .equ OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMEN, 1 << 0   @ bitWidth 1 (LPM support enable)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMACK, 1 << 1   @ bitWidth 1 (LPM token acknowledge  enable)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_BESL_Shift, 2   @ bitWidth 4 (Best effort service  latency)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_REMWAKE, 1 << 6   @ bitWidth 1 (bRemoteWake value)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_L1SSEN, 1 << 7   @ bitWidth 1 (L1 Shallow Sleep enable)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS_Shift, 8   @ bitWidth 4 (BESL threshold)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_L1DSEN, 1 << 12   @ bitWidth 1 (L1 deep sleep enable)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST_Shift, 13   @ bitWidth 2 (LPM response)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_SLPSTS, 1 << 15   @ bitWidth 1 (Port sleep status)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_L1RSMOK, 1 << 16   @ bitWidth 1 (Sleep State Resume OK)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX_Shift, 17   @ bitWidth 4 (LPM Channel Index)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT_Shift, 21   @ bitWidth 3 (LPM retry count)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_SNDLPM, 1 << 24   @ bitWidth 1 (Send LPM transaction)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS_Shift, 25   @ bitWidth 3 (LPM retry count status)  
        .equ OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_ENBESL, 1 << 28   @ bitWidth 1 (Enable best effort service  latency)  
 

@=========================== OTG2_HS_GLOBAL ===========================@
.equ OTG2_HS_GLOBAL_BASE, 0x40080000 @ (USB 1 on the go high speed) 
    .equ OTG2_HS_GLOBAL_OTG_HS_GOTGCTL, OTG2_HS_GLOBAL_BASE + 0x0 @ (OTG_HS control and status  register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_SRQSCS, 1 << 0   @ bitWidth 1 (Session request success)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_SRQ, 1 << 1   @ bitWidth 1 (Session request)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_HNGSCS, 1 << 8   @ bitWidth 1 (Host negotiation success)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_HNPRQ, 1 << 9   @ bitWidth 1 (HNP request)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_HSHNPEN, 1 << 10   @ bitWidth 1 (Host set HNP enable)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_DHNPEN, 1 << 11   @ bitWidth 1 (Device HNP enabled)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_CIDSTS, 1 << 16   @ bitWidth 1 (Connector ID status)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_DBCT, 1 << 17   @ bitWidth 1 (Long/short debounce time)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_ASVLD, 1 << 18   @ bitWidth 1 (A-session valid)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_BSVLD, 1 << 19   @ bitWidth 1 (B-session valid)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_EHEN, 1 << 12   @ bitWidth 1 (Embedded host enable)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_GOTGINT, OTG2_HS_GLOBAL_BASE + 0x4 @ (OTG_HS interrupt register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGINT_SEDET, 1 << 2   @ bitWidth 1 (Session end detected)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGINT_SRSSCHG, 1 << 8   @ bitWidth 1 (Session request success status  change)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGINT_HNSSCHG, 1 << 9   @ bitWidth 1 (Host negotiation success status  change)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGINT_HNGDET, 1 << 17   @ bitWidth 1 (Host negotiation detected)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGINT_ADTOCHG, 1 << 18   @ bitWidth 1 (A-device timeout change)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGINT_DBCDNE, 1 << 19   @ bitWidth 1 (Debounce done)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GOTGINT_IDCHNG, 1 << 20   @ bitWidth 1 (ID input pin changed)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_GAHBCFG, OTG2_HS_GLOBAL_BASE + 0x8 @ (OTG_HS AHB configuration  register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_GINT, 1 << 0   @ bitWidth 1 (Global interrupt mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN_Shift, 1   @ bitWidth 4 (Burst length/type)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_DMAEN, 1 << 5   @ bitWidth 1 (DMA enable)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_TXFELVL, 1 << 7   @ bitWidth 1 (TxFIFO empty level)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_PTXFELVL, 1 << 8   @ bitWidth 1 (Periodic TxFIFO empty  level)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG, OTG2_HS_GLOBAL_BASE + 0xC @ (OTG_HS USB configuration  register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL_Shift, 0   @ bitWidth 3 (FS timeout calibration)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PHYSEL, 1 << 6   @ bitWidth 1 (USB 2.0 high-speed ULPI PHY or USB 1.1  full-speed serial transceiver select)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_SRPCAP, 1 << 8   @ bitWidth 1 (SRP-capable)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_HNPCAP, 1 << 9   @ bitWidth 1 (HNP-capable)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT_Shift, 10   @ bitWidth 4 (USB turnaround time)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PHYLPCS, 1 << 15   @ bitWidth 1 (PHY Low-power clock select)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIFSLS, 1 << 17   @ bitWidth 1 (ULPI FS/LS select)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIAR, 1 << 18   @ bitWidth 1 (ULPI Auto-resume)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPICSM, 1 << 19   @ bitWidth 1 (ULPI Clock SuspendM)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSD, 1 << 20   @ bitWidth 1 (ULPI External VBUS Drive)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSI, 1 << 21   @ bitWidth 1 (ULPI external VBUS  indicator)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_TSDPS, 1 << 22   @ bitWidth 1 (TermSel DLine pulsing  selection)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PCCI, 1 << 23   @ bitWidth 1 (Indicator complement)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PTCI, 1 << 24   @ bitWidth 1 (Indicator pass through)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIIPD, 1 << 25   @ bitWidth 1 (ULPI interface protect  disable)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_FHMOD, 1 << 29   @ bitWidth 1 (Forced host mode)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_FDMOD, 1 << 30   @ bitWidth 1 (Forced peripheral mode)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_GRSTCTL, OTG2_HS_GLOBAL_BASE + 0x10 @ (OTG_HS reset register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_CSRST, 1 << 0   @ bitWidth 1 (Core soft reset)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_HSRST, 1 << 1   @ bitWidth 1 (HCLK soft reset)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_FCRST, 1 << 2   @ bitWidth 1 (Host frame counter reset)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_RXFFLSH, 1 << 4   @ bitWidth 1 (RxFIFO flush)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_TXFFLSH, 1 << 5   @ bitWidth 1 (TxFIFO flush)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM_Shift, 6   @ bitWidth 5 (TxFIFO number)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_AHBIDL, 1 << 31   @ bitWidth 1 (AHB master idle)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_DMAREQ, 1 << 30   @ bitWidth 1 (DMA request signal enabled for USB OTG  HS)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS, OTG2_HS_GLOBAL_BASE + 0x14 @ (OTG_HS core interrupt register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_CMOD, 1 << 0   @ bitWidth 1 (Current mode of operation)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_MMIS, 1 << 1   @ bitWidth 1 (Mode mismatch interrupt)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_OTGINT, 1 << 2   @ bitWidth 1 (OTG interrupt)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_SOF, 1 << 3   @ bitWidth 1 (Start of frame)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_RXFLVL, 1 << 4   @ bitWidth 1 (RxFIFO nonempty)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_NPTXFE, 1 << 5   @ bitWidth 1 (Nonperiodic TxFIFO empty)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_GINAKEFF, 1 << 6   @ bitWidth 1 (Global IN nonperiodic NAK  effective)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_BOUTNAKEFF, 1 << 7   @ bitWidth 1 (Global OUT NAK effective)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_ESUSP, 1 << 10   @ bitWidth 1 (Early suspend)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_USBSUSP, 1 << 11   @ bitWidth 1 (USB suspend)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_USBRST, 1 << 12   @ bitWidth 1 (USB reset)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_ENUMDNE, 1 << 13   @ bitWidth 1 (Enumeration done)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_ISOODRP, 1 << 14   @ bitWidth 1 (Isochronous OUT packet dropped  interrupt)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_EOPF, 1 << 15   @ bitWidth 1 (End of periodic frame  interrupt)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_IEPINT, 1 << 18   @ bitWidth 1 (IN endpoint interrupt)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_OEPINT, 1 << 19   @ bitWidth 1 (OUT endpoint interrupt)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_IISOIXFR, 1 << 20   @ bitWidth 1 (Incomplete isochronous IN  transfer)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_PXFR_INCOMPISOOUT, 1 << 21   @ bitWidth 1 (Incomplete periodic  transfer)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_DATAFSUSP, 1 << 22   @ bitWidth 1 (Data fetch suspended)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_HPRTINT, 1 << 24   @ bitWidth 1 (Host port interrupt)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_HCINT, 1 << 25   @ bitWidth 1 (Host channels interrupt)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_PTXFE, 1 << 26   @ bitWidth 1 (Periodic TxFIFO empty)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_CIDSCHG, 1 << 28   @ bitWidth 1 (Connector ID status change)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_DISCINT, 1 << 29   @ bitWidth 1 (Disconnect detected  interrupt)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_SRQINT, 1 << 30   @ bitWidth 1 (Session request/new session detected  interrupt)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTSTS_WKUINT, 1 << 31   @ bitWidth 1 (Resume/remote wakeup detected  interrupt)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK, OTG2_HS_GLOBAL_BASE + 0x18 @ (OTG_HS interrupt mask register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_MMISM, 1 << 1   @ bitWidth 1 (Mode mismatch interrupt  mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_OTGINT, 1 << 2   @ bitWidth 1 (OTG interrupt mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_SOFM, 1 << 3   @ bitWidth 1 (Start of frame mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_RXFLVLM, 1 << 4   @ bitWidth 1 (Receive FIFO nonempty mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_NPTXFEM, 1 << 5   @ bitWidth 1 (Nonperiodic TxFIFO empty  mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_GINAKEFFM, 1 << 6   @ bitWidth 1 (Global nonperiodic IN NAK effective  mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_GONAKEFFM, 1 << 7   @ bitWidth 1 (Global OUT NAK effective  mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_ESUSPM, 1 << 10   @ bitWidth 1 (Early suspend mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_USBSUSPM, 1 << 11   @ bitWidth 1 (USB suspend mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_USBRST, 1 << 12   @ bitWidth 1 (USB reset mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_ENUMDNEM, 1 << 13   @ bitWidth 1 (Enumeration done mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_ISOODRPM, 1 << 14   @ bitWidth 1 (Isochronous OUT packet dropped interrupt  mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_EOPFM, 1 << 15   @ bitWidth 1 (End of periodic frame interrupt  mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_IEPINT, 1 << 18   @ bitWidth 1 (IN endpoints interrupt  mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_OEPINT, 1 << 19   @ bitWidth 1 (OUT endpoints interrupt  mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_IISOIXFRM, 1 << 20   @ bitWidth 1 (Incomplete isochronous IN transfer  mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_PXFRM_IISOOXFRM, 1 << 21   @ bitWidth 1 (Incomplete periodic transfer  mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_FSUSPM, 1 << 22   @ bitWidth 1 (Data fetch suspended mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_PRTIM, 1 << 24   @ bitWidth 1 (Host port interrupt mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_HCIM, 1 << 25   @ bitWidth 1 (Host channels interrupt  mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_PTXFEM, 1 << 26   @ bitWidth 1 (Periodic TxFIFO empty mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_CIDSCHGM, 1 << 28   @ bitWidth 1 (Connector ID status change  mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_DISCINT, 1 << 29   @ bitWidth 1 (Disconnect detected interrupt  mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_SRQIM, 1 << 30   @ bitWidth 1 (Session request/new session detected  interrupt mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_WUIM, 1 << 31   @ bitWidth 1 (Resume/remote wakeup detected interrupt  mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_RSTDE, 1 << 23   @ bitWidth 1 (Reset detected interrupt  mask)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GINTMSK_LPMINTM, 1 << 27   @ bitWidth 1 (LPM interrupt mask)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Host, OTG2_HS_GLOBAL_BASE + 0x1C @ (OTG_HS Receive status debug read register  host mode) 
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Host_CHNUM_Shift, 0   @ bitWidth 4 (Channel number)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Host_BCNT_Shift, 4   @ bitWidth 11 (Byte count)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Host_DPID_Shift, 15   @ bitWidth 2 (Data PID)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Host_PKTSTS_Shift, 17   @ bitWidth 4 (Packet status)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Host, OTG2_HS_GLOBAL_BASE + 0x20 @ (OTG_HS status read and pop register host  mode) 
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Host_CHNUM_Shift, 0   @ bitWidth 4 (Channel number)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Host_BCNT_Shift, 4   @ bitWidth 11 (Byte count)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Host_DPID_Shift, 15   @ bitWidth 2 (Data PID)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Host_PKTSTS_Shift, 17   @ bitWidth 4 (Packet status)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_GRXFSIZ, OTG2_HS_GLOBAL_BASE + 0x24 @ (OTG_HS Receive FIFO size  register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXFSIZ_RXFD_Shift, 0   @ bitWidth 16 (RxFIFO depth)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_HNPTXFSIZ_Host, OTG2_HS_GLOBAL_BASE + 0x28 @ (OTG_HS nonperiodic transmit FIFO size  register host mode) 
        .equ OTG2_HS_GLOBAL_OTG_HS_HNPTXFSIZ_Host_NPTXFSA_Shift, 0   @ bitWidth 16 (Nonperiodic transmit RAM start  address)  
        .equ OTG2_HS_GLOBAL_OTG_HS_HNPTXFSIZ_Host_NPTXFD_Shift, 16   @ bitWidth 16 (Nonperiodic TxFIFO depth)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF0_Device, OTG2_HS_GLOBAL_BASE + 0x28 @ (Endpoint 0 transmit FIFO size peripheral  mode) 
        .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF0_Device_TX0FSA_Shift, 0   @ bitWidth 16 (Endpoint 0 transmit RAM start  address)  
        .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF0_Device_TX0FD_Shift, 16   @ bitWidth 16 (Endpoint 0 TxFIFO depth)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS, OTG2_HS_GLOBAL_BASE + 0x2C @ (OTG_HS nonperiodic transmit FIFO/queue  status register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXFSAV_Shift, 0   @ bitWidth 16 (Nonperiodic TxFIFO space  available)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTQXSAV_Shift, 16   @ bitWidth 8 (Nonperiodic transmit request queue space  available)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXQTOP_Shift, 24   @ bitWidth 7 (Top of the nonperiodic transmit request  queue)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_GCCFG, OTG2_HS_GLOBAL_BASE + 0x38 @ (OTG_HS general core configuration  register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_GCCFG_PWRDWN, 1 << 16   @ bitWidth 1 (Power down)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GCCFG_BCDEN, 1 << 17   @ bitWidth 1 (Battery charging detector BCD  enable)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GCCFG_DCDEN, 1 << 18   @ bitWidth 1 (Data contact detection DCD mode  enable)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GCCFG_PDEN, 1 << 19   @ bitWidth 1 (Primary detection PD mode  enable)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GCCFG_SDEN, 1 << 20   @ bitWidth 1 (Secondary detection SD mode  enable)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GCCFG_VBDEN, 1 << 21   @ bitWidth 1 (USB VBUS detection enable)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GCCFG_DCDET, 1 << 0   @ bitWidth 1 (Data contact detection DCD  status)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GCCFG_PDET, 1 << 1   @ bitWidth 1 (Primary detection PD  status)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GCCFG_SDET, 1 << 2   @ bitWidth 1 (Secondary detection SD  status)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GCCFG_PS2DET, 1 << 3   @ bitWidth 1 (DM pull-up detection  status)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_CID, OTG2_HS_GLOBAL_BASE + 0x3C @ (OTG_HS core ID register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_CID_PRODUCT_ID_Shift, 0   @ bitWidth 32 (Product ID field)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_HPTXFSIZ, OTG2_HS_GLOBAL_BASE + 0x100 @ (OTG_HS Host periodic transmit FIFO size  register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA_Shift, 0   @ bitWidth 16 (Host periodic TxFIFO start  address)  
        .equ OTG2_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD_Shift, 16   @ bitWidth 16 (Host periodic TxFIFO depth)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF1, OTG2_HS_GLOBAL_BASE + 0x104 @ (OTG_HS device IN endpoint transmit FIFO size  register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXSA_Shift, 0   @ bitWidth 16 (IN endpoint FIFOx transmit RAM start  address)  
        .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXFD_Shift, 16   @ bitWidth 16 (IN endpoint TxFIFO depth)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF2, OTG2_HS_GLOBAL_BASE + 0x108 @ (OTG_HS device IN endpoint transmit FIFO size  register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXSA_Shift, 0   @ bitWidth 16 (IN endpoint FIFOx transmit RAM start  address)  
        .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXFD_Shift, 16   @ bitWidth 16 (IN endpoint TxFIFO depth)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF3, OTG2_HS_GLOBAL_BASE + 0x11C @ (OTG_HS device IN endpoint transmit FIFO size  register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXSA_Shift, 0   @ bitWidth 16 (IN endpoint FIFOx transmit RAM start  address)  
        .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXFD_Shift, 16   @ bitWidth 16 (IN endpoint TxFIFO depth)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF4, OTG2_HS_GLOBAL_BASE + 0x120 @ (OTG_HS device IN endpoint transmit FIFO size  register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXSA_Shift, 0   @ bitWidth 16 (IN endpoint FIFOx transmit RAM start  address)  
        .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXFD_Shift, 16   @ bitWidth 16 (IN endpoint TxFIFO depth)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF5, OTG2_HS_GLOBAL_BASE + 0x124 @ (OTG_HS device IN endpoint transmit FIFO size  register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXSA_Shift, 0   @ bitWidth 16 (IN endpoint FIFOx transmit RAM start  address)  
        .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXFD_Shift, 16   @ bitWidth 16 (IN endpoint TxFIFO depth)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF6, OTG2_HS_GLOBAL_BASE + 0x128 @ (OTG_HS device IN endpoint transmit FIFO size  register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXSA_Shift, 0   @ bitWidth 16 (IN endpoint FIFOx transmit RAM start  address)  
        .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXFD_Shift, 16   @ bitWidth 16 (IN endpoint TxFIFO depth)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF7, OTG2_HS_GLOBAL_BASE + 0x12C @ (OTG_HS device IN endpoint transmit FIFO size  register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXSA_Shift, 0   @ bitWidth 16 (IN endpoint FIFOx transmit RAM start  address)  
        .equ OTG2_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXFD_Shift, 16   @ bitWidth 16 (IN endpoint TxFIFO depth)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Device, OTG2_HS_GLOBAL_BASE + 0x1C @ (OTG_HS Receive status debug read register  peripheral mode mode) 
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Device_EPNUM_Shift, 0   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Device_BCNT_Shift, 4   @ bitWidth 11 (Byte count)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Device_DPID_Shift, 15   @ bitWidth 2 (Data PID)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Device_PKTSTS_Shift, 17   @ bitWidth 4 (Packet status)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Device_FRMNUM_Shift, 21   @ bitWidth 4 (Frame number)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Device, OTG2_HS_GLOBAL_BASE + 0x20 @ (OTG_HS status read and pop register  peripheral mode) 
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Device_EPNUM_Shift, 0   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Device_BCNT_Shift, 4   @ bitWidth 11 (Byte count)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Device_DPID_Shift, 15   @ bitWidth 2 (Data PID)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Device_PKTSTS_Shift, 17   @ bitWidth 4 (Packet status)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Device_FRMNUM_Shift, 21   @ bitWidth 4 (Frame number)  
 
    .equ OTG2_HS_GLOBAL_OTG_HS_GLPMCFG, OTG2_HS_GLOBAL_BASE + 0x54 @ (OTG core LPM configuration  register) 
        .equ OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMEN, 1 << 0   @ bitWidth 1 (LPM support enable)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMACK, 1 << 1   @ bitWidth 1 (LPM token acknowledge  enable)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_BESL_Shift, 2   @ bitWidth 4 (Best effort service  latency)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_REMWAKE, 1 << 6   @ bitWidth 1 (bRemoteWake value)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_L1SSEN, 1 << 7   @ bitWidth 1 (L1 Shallow Sleep enable)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS_Shift, 8   @ bitWidth 4 (BESL threshold)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_L1DSEN, 1 << 12   @ bitWidth 1 (L1 deep sleep enable)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST_Shift, 13   @ bitWidth 2 (LPM response)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_SLPSTS, 1 << 15   @ bitWidth 1 (Port sleep status)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_L1RSMOK, 1 << 16   @ bitWidth 1 (Sleep State Resume OK)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX_Shift, 17   @ bitWidth 4 (LPM Channel Index)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT_Shift, 21   @ bitWidth 3 (LPM retry count)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_SNDLPM, 1 << 24   @ bitWidth 1 (Send LPM transaction)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS_Shift, 25   @ bitWidth 3 (LPM retry count status)  
        .equ OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_ENBESL, 1 << 28   @ bitWidth 1 (Enable best effort service  latency)  
 

@=========================== OTG1_HS_HOST ===========================@
.equ OTG1_HS_HOST_BASE, 0x40040400 @ (USB 1 on the go high speed) 
    .equ OTG1_HS_HOST_OTG_HS_HCFG, OTG1_HS_HOST_BASE + 0x0 @ (OTG_HS host configuration  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCFG_FSLSPCS_Shift, 0   @ bitWidth 2 (FS/LS PHY clock select)  
        .equ OTG1_HS_HOST_OTG_HS_HCFG_FSLSS, 1 << 2   @ bitWidth 1 (FS- and LS-only support)  
 
    .equ OTG1_HS_HOST_OTG_HS_HFIR, OTG1_HS_HOST_BASE + 0x4 @ (OTG_HS Host frame interval  register) 
        .equ OTG1_HS_HOST_OTG_HS_HFIR_FRIVL_Shift, 0   @ bitWidth 16 (Frame interval)  
 
    .equ OTG1_HS_HOST_OTG_HS_HFNUM, OTG1_HS_HOST_BASE + 0x8 @ (OTG_HS host frame number/frame time  remaining register) 
        .equ OTG1_HS_HOST_OTG_HS_HFNUM_FRNUM_Shift, 0   @ bitWidth 16 (Frame number)  
        .equ OTG1_HS_HOST_OTG_HS_HFNUM_FTREM_Shift, 16   @ bitWidth 16 (Frame time remaining)  
 
    .equ OTG1_HS_HOST_OTG_HS_HPTXSTS, OTG1_HS_HOST_BASE + 0x10 @ (OTG_HS_Host periodic transmit FIFO/queue  status register) 
        .equ OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXFSAVL_Shift, 0   @ bitWidth 16 (Periodic transmit data FIFO space  available)  
        .equ OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXQSAV_Shift, 16   @ bitWidth 8 (Periodic transmit request queue space  available)  
        .equ OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP_Shift, 24   @ bitWidth 8 (Top of the periodic transmit request  queue)  
 
    .equ OTG1_HS_HOST_OTG_HS_HAINT, OTG1_HS_HOST_BASE + 0x14 @ (OTG_HS Host all channels interrupt  register) 
        .equ OTG1_HS_HOST_OTG_HS_HAINT_HAINT_Shift, 0   @ bitWidth 16 (Channel interrupts)  
 
    .equ OTG1_HS_HOST_OTG_HS_HAINTMSK, OTG1_HS_HOST_BASE + 0x18 @ (OTG_HS host all channels interrupt mask  register) 
        .equ OTG1_HS_HOST_OTG_HS_HAINTMSK_HAINTM_Shift, 0   @ bitWidth 16 (Channel interrupt mask)  
 
    .equ OTG1_HS_HOST_OTG_HS_HPRT, OTG1_HS_HOST_BASE + 0x40 @ (OTG_HS host port control and status  register) 
        .equ OTG1_HS_HOST_OTG_HS_HPRT_PCSTS, 1 << 0   @ bitWidth 1 (Port connect status)  
        .equ OTG1_HS_HOST_OTG_HS_HPRT_PCDET, 1 << 1   @ bitWidth 1 (Port connect detected)  
        .equ OTG1_HS_HOST_OTG_HS_HPRT_PENA, 1 << 2   @ bitWidth 1 (Port enable)  
        .equ OTG1_HS_HOST_OTG_HS_HPRT_PENCHNG, 1 << 3   @ bitWidth 1 (Port enable/disable change)  
        .equ OTG1_HS_HOST_OTG_HS_HPRT_POCA, 1 << 4   @ bitWidth 1 (Port overcurrent active)  
        .equ OTG1_HS_HOST_OTG_HS_HPRT_POCCHNG, 1 << 5   @ bitWidth 1 (Port overcurrent change)  
        .equ OTG1_HS_HOST_OTG_HS_HPRT_PRES, 1 << 6   @ bitWidth 1 (Port resume)  
        .equ OTG1_HS_HOST_OTG_HS_HPRT_PSUSP, 1 << 7   @ bitWidth 1 (Port suspend)  
        .equ OTG1_HS_HOST_OTG_HS_HPRT_PRST, 1 << 8   @ bitWidth 1 (Port reset)  
        .equ OTG1_HS_HOST_OTG_HS_HPRT_PLSTS_Shift, 10   @ bitWidth 2 (Port line status)  
        .equ OTG1_HS_HOST_OTG_HS_HPRT_PPWR, 1 << 12   @ bitWidth 1 (Port power)  
        .equ OTG1_HS_HOST_OTG_HS_HPRT_PTCTL_Shift, 13   @ bitWidth 4 (Port test control)  
        .equ OTG1_HS_HOST_OTG_HS_HPRT_PSPD_Shift, 17   @ bitWidth 2 (Port speed)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCCHAR0, OTG1_HS_HOST_BASE + 0x100 @ (OTG_HS host channel-0 characteristics  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR0_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR0_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR0_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR0_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR0_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR0_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR0_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR0_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR0_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR0_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCCHAR1, OTG1_HS_HOST_BASE + 0x120 @ (OTG_HS host channel-1 characteristics  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR1_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR1_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR1_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR1_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR1_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR1_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR1_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR1_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR1_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR1_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCCHAR2, OTG1_HS_HOST_BASE + 0x140 @ (OTG_HS host channel-2 characteristics  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR2_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR2_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR2_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR2_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR2_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR2_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR2_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR2_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR2_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR2_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCCHAR3, OTG1_HS_HOST_BASE + 0x160 @ (OTG_HS host channel-3 characteristics  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR3_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR3_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR3_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR3_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR3_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR3_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR3_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR3_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR3_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR3_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCCHAR4, OTG1_HS_HOST_BASE + 0x180 @ (OTG_HS host channel-4 characteristics  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR4_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR4_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR4_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR4_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR4_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR4_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR4_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR4_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR4_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR4_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCCHAR5, OTG1_HS_HOST_BASE + 0x1A0 @ (OTG_HS host channel-5 characteristics  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR5_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR5_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR5_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR5_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR5_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR5_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR5_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR5_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR5_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR5_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCCHAR6, OTG1_HS_HOST_BASE + 0x1C0 @ (OTG_HS host channel-6 characteristics  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR6_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR6_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR6_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR6_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR6_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR6_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR6_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR6_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR6_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR6_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCCHAR7, OTG1_HS_HOST_BASE + 0x1E0 @ (OTG_HS host channel-7 characteristics  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR7_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR7_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR7_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR7_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR7_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR7_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR7_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR7_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR7_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR7_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCCHAR8, OTG1_HS_HOST_BASE + 0x200 @ (OTG_HS host channel-8 characteristics  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR8_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR8_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR8_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR8_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR8_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR8_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR8_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR8_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR8_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR8_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCCHAR9, OTG1_HS_HOST_BASE + 0x220 @ (OTG_HS host channel-9 characteristics  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR9_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR9_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR9_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR9_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR9_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR9_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR9_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR9_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR9_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR9_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCCHAR10, OTG1_HS_HOST_BASE + 0x240 @ (OTG_HS host channel-10 characteristics  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR10_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR10_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR10_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR10_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR10_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR10_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR10_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR10_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR10_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR10_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCCHAR11, OTG1_HS_HOST_BASE + 0x260 @ (OTG_HS host channel-11 characteristics  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR11_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR11_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR11_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR11_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR11_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR11_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR11_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR11_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR11_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR11_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCSPLT0, OTG1_HS_HOST_BASE + 0x104 @ (OTG_HS host channel-0 split control  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT0_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT0_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT0_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT0_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT0_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCSPLT1, OTG1_HS_HOST_BASE + 0x124 @ (OTG_HS host channel-1 split control  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT1_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT1_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT1_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT1_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT1_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCSPLT2, OTG1_HS_HOST_BASE + 0x144 @ (OTG_HS host channel-2 split control  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT2_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT2_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT2_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT2_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT2_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCSPLT3, OTG1_HS_HOST_BASE + 0x164 @ (OTG_HS host channel-3 split control  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT3_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT3_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT3_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT3_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT3_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCSPLT4, OTG1_HS_HOST_BASE + 0x184 @ (OTG_HS host channel-4 split control  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT4_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT4_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT4_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT4_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT4_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCSPLT5, OTG1_HS_HOST_BASE + 0x1A4 @ (OTG_HS host channel-5 split control  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT5_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT5_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT5_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT5_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT5_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCSPLT6, OTG1_HS_HOST_BASE + 0x1C4 @ (OTG_HS host channel-6 split control  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT6_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT6_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT6_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT6_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT6_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCSPLT7, OTG1_HS_HOST_BASE + 0x1E4 @ (OTG_HS host channel-7 split control  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT7_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT7_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT7_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT7_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT7_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCSPLT8, OTG1_HS_HOST_BASE + 0x204 @ (OTG_HS host channel-8 split control  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT8_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT8_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT8_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT8_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT8_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCSPLT9, OTG1_HS_HOST_BASE + 0x224 @ (OTG_HS host channel-9 split control  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT9_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT9_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT9_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT9_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT9_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCSPLT10, OTG1_HS_HOST_BASE + 0x244 @ (OTG_HS host channel-10 split control  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT10_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT10_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT10_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT10_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT10_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCSPLT11, OTG1_HS_HOST_BASE + 0x264 @ (OTG_HS host channel-11 split control  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT11_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT11_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT11_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT11_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT11_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINT0, OTG1_HS_HOST_BASE + 0x108 @ (OTG_HS host channel-11 interrupt  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINT0_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT0_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT0_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT0_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT0_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT0_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT0_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT0_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT0_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT0_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT0_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINT1, OTG1_HS_HOST_BASE + 0x128 @ (OTG_HS host channel-1 interrupt  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINT1_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT1_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT1_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT1_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT1_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT1_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT1_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT1_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT1_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT1_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT1_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINT2, OTG1_HS_HOST_BASE + 0x148 @ (OTG_HS host channel-2 interrupt  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINT2_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT2_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT2_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT2_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT2_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT2_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT2_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT2_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT2_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT2_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT2_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINT3, OTG1_HS_HOST_BASE + 0x168 @ (OTG_HS host channel-3 interrupt  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINT3_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT3_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT3_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT3_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT3_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT3_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT3_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT3_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT3_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT3_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT3_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINT4, OTG1_HS_HOST_BASE + 0x188 @ (OTG_HS host channel-4 interrupt  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINT4_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT4_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT4_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT4_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT4_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT4_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT4_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT4_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT4_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT4_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT4_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINT5, OTG1_HS_HOST_BASE + 0x1A8 @ (OTG_HS host channel-5 interrupt  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINT5_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT5_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT5_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT5_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT5_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT5_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT5_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT5_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT5_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT5_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT5_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINT6, OTG1_HS_HOST_BASE + 0x1C8 @ (OTG_HS host channel-6 interrupt  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINT6_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT6_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT6_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT6_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT6_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT6_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT6_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT6_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT6_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT6_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT6_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINT7, OTG1_HS_HOST_BASE + 0x1E8 @ (OTG_HS host channel-7 interrupt  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINT7_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT7_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT7_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT7_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT7_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT7_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT7_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT7_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT7_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT7_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT7_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINT8, OTG1_HS_HOST_BASE + 0x208 @ (OTG_HS host channel-8 interrupt  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINT8_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT8_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT8_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT8_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT8_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT8_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT8_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT8_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT8_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT8_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT8_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINT9, OTG1_HS_HOST_BASE + 0x228 @ (OTG_HS host channel-9 interrupt  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINT9_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT9_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT9_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT9_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT9_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT9_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT9_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT9_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT9_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT9_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT9_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINT10, OTG1_HS_HOST_BASE + 0x248 @ (OTG_HS host channel-10 interrupt  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINT10_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT10_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT10_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT10_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT10_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT10_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT10_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT10_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT10_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT10_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT10_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINT11, OTG1_HS_HOST_BASE + 0x268 @ (OTG_HS host channel-11 interrupt  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINT11_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT11_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT11_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT11_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT11_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT11_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT11_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT11_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT11_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT11_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT11_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINTMSK0, OTG1_HS_HOST_BASE + 0x10C @ (OTG_HS host channel-11 interrupt mask  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK0_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK0_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK0_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK0_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK0_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK0_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK0_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK0_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK0_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK0_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK0_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINTMSK1, OTG1_HS_HOST_BASE + 0x12C @ (OTG_HS host channel-1 interrupt mask  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK1_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK1_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK1_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK1_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK1_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK1_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK1_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK1_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK1_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK1_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK1_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINTMSK2, OTG1_HS_HOST_BASE + 0x14C @ (OTG_HS host channel-2 interrupt mask  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK2_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK2_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK2_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK2_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK2_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK2_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK2_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK2_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK2_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK2_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK2_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINTMSK3, OTG1_HS_HOST_BASE + 0x16C @ (OTG_HS host channel-3 interrupt mask  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK3_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK3_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK3_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK3_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK3_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK3_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK3_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK3_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK3_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK3_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK3_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINTMSK4, OTG1_HS_HOST_BASE + 0x18C @ (OTG_HS host channel-4 interrupt mask  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK4_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK4_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK4_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK4_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK4_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK4_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK4_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK4_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK4_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK4_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK4_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINTMSK5, OTG1_HS_HOST_BASE + 0x1AC @ (OTG_HS host channel-5 interrupt mask  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK5_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK5_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK5_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK5_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK5_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK5_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK5_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK5_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK5_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK5_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK5_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINTMSK6, OTG1_HS_HOST_BASE + 0x1CC @ (OTG_HS host channel-6 interrupt mask  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK6_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK6_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK6_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK6_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK6_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK6_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK6_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK6_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK6_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK6_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK6_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINTMSK7, OTG1_HS_HOST_BASE + 0x1EC @ (OTG_HS host channel-7 interrupt mask  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK7_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK7_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK7_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK7_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK7_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK7_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK7_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK7_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK7_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK7_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK7_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINTMSK8, OTG1_HS_HOST_BASE + 0x20C @ (OTG_HS host channel-8 interrupt mask  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK8_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK8_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK8_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK8_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK8_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK8_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK8_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK8_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK8_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK8_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK8_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINTMSK9, OTG1_HS_HOST_BASE + 0x22C @ (OTG_HS host channel-9 interrupt mask  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK9_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK9_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK9_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK9_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK9_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK9_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK9_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK9_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK9_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK9_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK9_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINTMSK10, OTG1_HS_HOST_BASE + 0x24C @ (OTG_HS host channel-10 interrupt mask  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK10_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK10_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK10_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK10_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK10_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK10_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK10_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK10_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK10_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK10_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK10_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINTMSK11, OTG1_HS_HOST_BASE + 0x26C @ (OTG_HS host channel-11 interrupt mask  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK11_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK11_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK11_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK11_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK11_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK11_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK11_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK11_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK11_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK11_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK11_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCTSIZ0, OTG1_HS_HOST_BASE + 0x110 @ (OTG_HS host channel-11 transfer size  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ0_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ0_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ0_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCTSIZ1, OTG1_HS_HOST_BASE + 0x130 @ (OTG_HS host channel-1 transfer size  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ1_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ1_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ1_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCTSIZ2, OTG1_HS_HOST_BASE + 0x150 @ (OTG_HS host channel-2 transfer size  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ2_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ2_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ2_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCTSIZ3, OTG1_HS_HOST_BASE + 0x170 @ (OTG_HS host channel-3 transfer size  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ3_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ3_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ3_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCTSIZ4, OTG1_HS_HOST_BASE + 0x190 @ (OTG_HS host channel-4 transfer size  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ4_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ4_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ4_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCTSIZ5, OTG1_HS_HOST_BASE + 0x1B0 @ (OTG_HS host channel-5 transfer size  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ5_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ5_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ5_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCTSIZ6, OTG1_HS_HOST_BASE + 0x1D0 @ (OTG_HS host channel-6 transfer size  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ6_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ6_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ6_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCTSIZ7, OTG1_HS_HOST_BASE + 0x1F0 @ (OTG_HS host channel-7 transfer size  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ7_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ7_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ7_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCTSIZ8, OTG1_HS_HOST_BASE + 0x210 @ (OTG_HS host channel-8 transfer size  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ8_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ8_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ8_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCTSIZ9, OTG1_HS_HOST_BASE + 0x230 @ (OTG_HS host channel-9 transfer size  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ9_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ9_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ9_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCTSIZ10, OTG1_HS_HOST_BASE + 0x250 @ (OTG_HS host channel-10 transfer size  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ10_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ10_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ10_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCTSIZ11, OTG1_HS_HOST_BASE + 0x270 @ (OTG_HS host channel-11 transfer size  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ11_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ11_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ11_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCDMA0, OTG1_HS_HOST_BASE + 0x114 @ (OTG_HS host channel-0 DMA address  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCDMA0_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCDMA1, OTG1_HS_HOST_BASE + 0x134 @ (OTG_HS host channel-1 DMA address  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCDMA1_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCDMA2, OTG1_HS_HOST_BASE + 0x154 @ (OTG_HS host channel-2 DMA address  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCDMA2_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCDMA3, OTG1_HS_HOST_BASE + 0x174 @ (OTG_HS host channel-3 DMA address  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCDMA3_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCDMA4, OTG1_HS_HOST_BASE + 0x194 @ (OTG_HS host channel-4 DMA address  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCDMA4_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCDMA5, OTG1_HS_HOST_BASE + 0x1B4 @ (OTG_HS host channel-5 DMA address  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCDMA5_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCDMA6, OTG1_HS_HOST_BASE + 0x1D4 @ (OTG_HS host channel-6 DMA address  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCDMA6_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCDMA7, OTG1_HS_HOST_BASE + 0x1F4 @ (OTG_HS host channel-7 DMA address  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCDMA7_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCDMA8, OTG1_HS_HOST_BASE + 0x214 @ (OTG_HS host channel-8 DMA address  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCDMA8_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCDMA9, OTG1_HS_HOST_BASE + 0x234 @ (OTG_HS host channel-9 DMA address  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCDMA9_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCDMA10, OTG1_HS_HOST_BASE + 0x254 @ (OTG_HS host channel-10 DMA address  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCDMA10_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCDMA11, OTG1_HS_HOST_BASE + 0x274 @ (OTG_HS host channel-11 DMA address  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCDMA11_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCCHAR12, OTG1_HS_HOST_BASE + 0x278 @ (OTG_HS host channel-12 characteristics  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR12_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR12_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR12_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR12_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR12_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR12_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR12_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR12_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR12_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR12_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCSPLT12, OTG1_HS_HOST_BASE + 0x27C @ (OTG_HS host channel-12 split control  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT12_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT12_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT12_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT12_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT12_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINT12, OTG1_HS_HOST_BASE + 0x280 @ (OTG_HS host channel-12 interrupt  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINT12_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT12_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT12_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT12_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT12_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT12_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT12_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT12_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT12_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT12_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT12_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINTMSK12, OTG1_HS_HOST_BASE + 0x284 @ (OTG_HS host channel-12 interrupt mask  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK12_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK12_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK12_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK12_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK12_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK12_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK12_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK12_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK12_BBERRM, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK12_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK12_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCTSIZ12, OTG1_HS_HOST_BASE + 0x288 @ (OTG_HS host channel-12 transfer size  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ12_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ12_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ12_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCDMA12, OTG1_HS_HOST_BASE + 0x28C @ (OTG_HS host channel-12 DMA address  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCDMA12_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCCHAR13, OTG1_HS_HOST_BASE + 0x290 @ (OTG_HS host channel-13 characteristics  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR13_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR13_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR13_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR13_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR13_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR13_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR13_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR13_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR13_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR13_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCSPLT13, OTG1_HS_HOST_BASE + 0x294 @ (OTG_HS host channel-13 split control  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT13_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT13_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT13_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT13_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT13_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINT13, OTG1_HS_HOST_BASE + 0x298 @ (OTG_HS host channel-13 interrupt  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINT13_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT13_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT13_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT13_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT13_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT13_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT13_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT13_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT13_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT13_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT13_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINTMSK13, OTG1_HS_HOST_BASE + 0x29C @ (OTG_HS host channel-13 interrupt mask  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK13_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK13_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK13_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK13_STALLM, 1 << 3   @ bitWidth 1 (STALLM response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK13_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK13_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK13_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK13_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK13_BBERRM, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK13_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK13_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCTSIZ13, OTG1_HS_HOST_BASE + 0x2A0 @ (OTG_HS host channel-13 transfer size  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ13_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ13_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ13_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCDMA13, OTG1_HS_HOST_BASE + 0x2A4 @ (OTG_HS host channel-13 DMA address  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCDMA13_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCCHAR14, OTG1_HS_HOST_BASE + 0x2A8 @ (OTG_HS host channel-14 characteristics  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR14_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR14_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR14_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR14_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR14_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR14_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR14_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR14_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR14_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR14_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCSPLT14, OTG1_HS_HOST_BASE + 0x2AC @ (OTG_HS host channel-14 split control  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT14_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT14_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT14_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT14_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT14_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINT14, OTG1_HS_HOST_BASE + 0x2B0 @ (OTG_HS host channel-14 interrupt  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINT14_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT14_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT14_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT14_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT14_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT14_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT14_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT14_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT14_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT14_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT14_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINTMSK14, OTG1_HS_HOST_BASE + 0x2B4 @ (OTG_HS host channel-14 interrupt mask  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK14_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK14_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK14_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK14_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK14_NAKM, 1 << 4   @ bitWidth 1 (NAKM response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK14_ACKM, 1 << 5   @ bitWidth 1 (ACKM response received/transmitted  interrupt mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK14_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK14_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK14_BBERRM, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK14_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK14_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCTSIZ14, OTG1_HS_HOST_BASE + 0x2B8 @ (OTG_HS host channel-14 transfer size  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ14_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ14_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ14_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCDMA14, OTG1_HS_HOST_BASE + 0x2BC @ (OTG_HS host channel-14 DMA address  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCDMA14_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCCHAR15, OTG1_HS_HOST_BASE + 0x2C0 @ (OTG_HS host channel-15 characteristics  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR15_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR15_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR15_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR15_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR15_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR15_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR15_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR15_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR15_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG1_HS_HOST_OTG_HS_HCCHAR15_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCSPLT15, OTG1_HS_HOST_BASE + 0x2C4 @ (OTG_HS host channel-15 split control  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT15_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT15_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT15_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT15_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG1_HS_HOST_OTG_HS_HCSPLT15_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINT15, OTG1_HS_HOST_BASE + 0x2C8 @ (OTG_HS host channel-15 interrupt  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINT15_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT15_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT15_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT15_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT15_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT15_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT15_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT15_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT15_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT15_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG1_HS_HOST_OTG_HS_HCINT15_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCINTMSK15, OTG1_HS_HOST_BASE + 0x2CC @ (OTG_HS host channel-15 interrupt mask  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK15_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK15_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK15_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK15_STALL, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK15_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK15_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK15_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK15_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK15_BBERRM, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK15_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG1_HS_HOST_OTG_HS_HCINTMSK15_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCTSIZ15, OTG1_HS_HOST_BASE + 0x2D0 @ (OTG_HS host channel-15 transfer size  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ15_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ15_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_HOST_OTG_HS_HCTSIZ15_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG1_HS_HOST_OTG_HS_HCDMA15, OTG1_HS_HOST_BASE + 0x2D4 @ (OTG_HS host channel-15 DMA address  register) 
        .equ OTG1_HS_HOST_OTG_HS_HCDMA15_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 

@=========================== OTG2_HS_HOST ===========================@
.equ OTG2_HS_HOST_BASE, 0x40080400 @ (USB 1 on the go high speed) 
    .equ OTG2_HS_HOST_OTG_HS_HCFG, OTG2_HS_HOST_BASE + 0x0 @ (OTG_HS host configuration  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCFG_FSLSPCS_Shift, 0   @ bitWidth 2 (FS/LS PHY clock select)  
        .equ OTG2_HS_HOST_OTG_HS_HCFG_FSLSS, 1 << 2   @ bitWidth 1 (FS- and LS-only support)  
 
    .equ OTG2_HS_HOST_OTG_HS_HFIR, OTG2_HS_HOST_BASE + 0x4 @ (OTG_HS Host frame interval  register) 
        .equ OTG2_HS_HOST_OTG_HS_HFIR_FRIVL_Shift, 0   @ bitWidth 16 (Frame interval)  
 
    .equ OTG2_HS_HOST_OTG_HS_HFNUM, OTG2_HS_HOST_BASE + 0x8 @ (OTG_HS host frame number/frame time  remaining register) 
        .equ OTG2_HS_HOST_OTG_HS_HFNUM_FRNUM_Shift, 0   @ bitWidth 16 (Frame number)  
        .equ OTG2_HS_HOST_OTG_HS_HFNUM_FTREM_Shift, 16   @ bitWidth 16 (Frame time remaining)  
 
    .equ OTG2_HS_HOST_OTG_HS_HPTXSTS, OTG2_HS_HOST_BASE + 0x10 @ (OTG_HS_Host periodic transmit FIFO/queue  status register) 
        .equ OTG2_HS_HOST_OTG_HS_HPTXSTS_PTXFSAVL_Shift, 0   @ bitWidth 16 (Periodic transmit data FIFO space  available)  
        .equ OTG2_HS_HOST_OTG_HS_HPTXSTS_PTXQSAV_Shift, 16   @ bitWidth 8 (Periodic transmit request queue space  available)  
        .equ OTG2_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP_Shift, 24   @ bitWidth 8 (Top of the periodic transmit request  queue)  
 
    .equ OTG2_HS_HOST_OTG_HS_HAINT, OTG2_HS_HOST_BASE + 0x14 @ (OTG_HS Host all channels interrupt  register) 
        .equ OTG2_HS_HOST_OTG_HS_HAINT_HAINT_Shift, 0   @ bitWidth 16 (Channel interrupts)  
 
    .equ OTG2_HS_HOST_OTG_HS_HAINTMSK, OTG2_HS_HOST_BASE + 0x18 @ (OTG_HS host all channels interrupt mask  register) 
        .equ OTG2_HS_HOST_OTG_HS_HAINTMSK_HAINTM_Shift, 0   @ bitWidth 16 (Channel interrupt mask)  
 
    .equ OTG2_HS_HOST_OTG_HS_HPRT, OTG2_HS_HOST_BASE + 0x40 @ (OTG_HS host port control and status  register) 
        .equ OTG2_HS_HOST_OTG_HS_HPRT_PCSTS, 1 << 0   @ bitWidth 1 (Port connect status)  
        .equ OTG2_HS_HOST_OTG_HS_HPRT_PCDET, 1 << 1   @ bitWidth 1 (Port connect detected)  
        .equ OTG2_HS_HOST_OTG_HS_HPRT_PENA, 1 << 2   @ bitWidth 1 (Port enable)  
        .equ OTG2_HS_HOST_OTG_HS_HPRT_PENCHNG, 1 << 3   @ bitWidth 1 (Port enable/disable change)  
        .equ OTG2_HS_HOST_OTG_HS_HPRT_POCA, 1 << 4   @ bitWidth 1 (Port overcurrent active)  
        .equ OTG2_HS_HOST_OTG_HS_HPRT_POCCHNG, 1 << 5   @ bitWidth 1 (Port overcurrent change)  
        .equ OTG2_HS_HOST_OTG_HS_HPRT_PRES, 1 << 6   @ bitWidth 1 (Port resume)  
        .equ OTG2_HS_HOST_OTG_HS_HPRT_PSUSP, 1 << 7   @ bitWidth 1 (Port suspend)  
        .equ OTG2_HS_HOST_OTG_HS_HPRT_PRST, 1 << 8   @ bitWidth 1 (Port reset)  
        .equ OTG2_HS_HOST_OTG_HS_HPRT_PLSTS_Shift, 10   @ bitWidth 2 (Port line status)  
        .equ OTG2_HS_HOST_OTG_HS_HPRT_PPWR, 1 << 12   @ bitWidth 1 (Port power)  
        .equ OTG2_HS_HOST_OTG_HS_HPRT_PTCTL_Shift, 13   @ bitWidth 4 (Port test control)  
        .equ OTG2_HS_HOST_OTG_HS_HPRT_PSPD_Shift, 17   @ bitWidth 2 (Port speed)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCCHAR0, OTG2_HS_HOST_BASE + 0x100 @ (OTG_HS host channel-0 characteristics  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR0_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR0_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR0_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR0_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR0_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR0_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR0_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR0_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR0_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR0_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCCHAR1, OTG2_HS_HOST_BASE + 0x120 @ (OTG_HS host channel-1 characteristics  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR1_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR1_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR1_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR1_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR1_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR1_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR1_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR1_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR1_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR1_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCCHAR2, OTG2_HS_HOST_BASE + 0x140 @ (OTG_HS host channel-2 characteristics  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR2_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR2_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR2_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR2_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR2_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR2_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR2_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR2_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR2_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR2_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCCHAR3, OTG2_HS_HOST_BASE + 0x160 @ (OTG_HS host channel-3 characteristics  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR3_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR3_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR3_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR3_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR3_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR3_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR3_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR3_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR3_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR3_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCCHAR4, OTG2_HS_HOST_BASE + 0x180 @ (OTG_HS host channel-4 characteristics  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR4_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR4_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR4_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR4_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR4_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR4_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR4_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR4_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR4_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR4_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCCHAR5, OTG2_HS_HOST_BASE + 0x1A0 @ (OTG_HS host channel-5 characteristics  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR5_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR5_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR5_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR5_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR5_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR5_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR5_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR5_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR5_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR5_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCCHAR6, OTG2_HS_HOST_BASE + 0x1C0 @ (OTG_HS host channel-6 characteristics  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR6_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR6_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR6_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR6_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR6_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR6_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR6_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR6_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR6_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR6_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCCHAR7, OTG2_HS_HOST_BASE + 0x1E0 @ (OTG_HS host channel-7 characteristics  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR7_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR7_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR7_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR7_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR7_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR7_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR7_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR7_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR7_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR7_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCCHAR8, OTG2_HS_HOST_BASE + 0x200 @ (OTG_HS host channel-8 characteristics  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR8_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR8_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR8_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR8_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR8_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR8_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR8_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR8_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR8_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR8_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCCHAR9, OTG2_HS_HOST_BASE + 0x220 @ (OTG_HS host channel-9 characteristics  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR9_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR9_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR9_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR9_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR9_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR9_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR9_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR9_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR9_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR9_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCCHAR10, OTG2_HS_HOST_BASE + 0x240 @ (OTG_HS host channel-10 characteristics  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR10_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR10_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR10_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR10_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR10_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR10_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR10_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR10_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR10_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR10_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCCHAR11, OTG2_HS_HOST_BASE + 0x260 @ (OTG_HS host channel-11 characteristics  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR11_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR11_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR11_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR11_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR11_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR11_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR11_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR11_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR11_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR11_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCSPLT0, OTG2_HS_HOST_BASE + 0x104 @ (OTG_HS host channel-0 split control  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT0_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT0_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT0_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT0_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT0_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCSPLT1, OTG2_HS_HOST_BASE + 0x124 @ (OTG_HS host channel-1 split control  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT1_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT1_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT1_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT1_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT1_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCSPLT2, OTG2_HS_HOST_BASE + 0x144 @ (OTG_HS host channel-2 split control  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT2_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT2_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT2_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT2_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT2_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCSPLT3, OTG2_HS_HOST_BASE + 0x164 @ (OTG_HS host channel-3 split control  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT3_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT3_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT3_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT3_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT3_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCSPLT4, OTG2_HS_HOST_BASE + 0x184 @ (OTG_HS host channel-4 split control  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT4_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT4_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT4_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT4_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT4_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCSPLT5, OTG2_HS_HOST_BASE + 0x1A4 @ (OTG_HS host channel-5 split control  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT5_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT5_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT5_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT5_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT5_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCSPLT6, OTG2_HS_HOST_BASE + 0x1C4 @ (OTG_HS host channel-6 split control  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT6_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT6_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT6_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT6_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT6_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCSPLT7, OTG2_HS_HOST_BASE + 0x1E4 @ (OTG_HS host channel-7 split control  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT7_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT7_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT7_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT7_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT7_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCSPLT8, OTG2_HS_HOST_BASE + 0x204 @ (OTG_HS host channel-8 split control  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT8_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT8_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT8_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT8_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT8_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCSPLT9, OTG2_HS_HOST_BASE + 0x224 @ (OTG_HS host channel-9 split control  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT9_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT9_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT9_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT9_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT9_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCSPLT10, OTG2_HS_HOST_BASE + 0x244 @ (OTG_HS host channel-10 split control  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT10_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT10_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT10_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT10_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT10_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCSPLT11, OTG2_HS_HOST_BASE + 0x264 @ (OTG_HS host channel-11 split control  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT11_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT11_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT11_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT11_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT11_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINT0, OTG2_HS_HOST_BASE + 0x108 @ (OTG_HS host channel-11 interrupt  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINT0_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT0_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT0_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT0_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT0_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT0_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT0_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT0_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT0_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT0_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT0_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINT1, OTG2_HS_HOST_BASE + 0x128 @ (OTG_HS host channel-1 interrupt  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINT1_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT1_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT1_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT1_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT1_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT1_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT1_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT1_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT1_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT1_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT1_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINT2, OTG2_HS_HOST_BASE + 0x148 @ (OTG_HS host channel-2 interrupt  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINT2_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT2_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT2_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT2_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT2_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT2_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT2_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT2_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT2_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT2_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT2_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINT3, OTG2_HS_HOST_BASE + 0x168 @ (OTG_HS host channel-3 interrupt  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINT3_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT3_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT3_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT3_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT3_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT3_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT3_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT3_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT3_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT3_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT3_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINT4, OTG2_HS_HOST_BASE + 0x188 @ (OTG_HS host channel-4 interrupt  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINT4_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT4_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT4_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT4_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT4_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT4_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT4_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT4_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT4_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT4_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT4_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINT5, OTG2_HS_HOST_BASE + 0x1A8 @ (OTG_HS host channel-5 interrupt  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINT5_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT5_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT5_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT5_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT5_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT5_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT5_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT5_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT5_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT5_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT5_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINT6, OTG2_HS_HOST_BASE + 0x1C8 @ (OTG_HS host channel-6 interrupt  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINT6_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT6_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT6_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT6_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT6_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT6_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT6_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT6_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT6_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT6_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT6_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINT7, OTG2_HS_HOST_BASE + 0x1E8 @ (OTG_HS host channel-7 interrupt  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINT7_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT7_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT7_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT7_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT7_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT7_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT7_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT7_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT7_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT7_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT7_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINT8, OTG2_HS_HOST_BASE + 0x208 @ (OTG_HS host channel-8 interrupt  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINT8_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT8_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT8_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT8_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT8_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT8_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT8_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT8_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT8_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT8_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT8_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINT9, OTG2_HS_HOST_BASE + 0x228 @ (OTG_HS host channel-9 interrupt  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINT9_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT9_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT9_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT9_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT9_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT9_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT9_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT9_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT9_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT9_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT9_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINT10, OTG2_HS_HOST_BASE + 0x248 @ (OTG_HS host channel-10 interrupt  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINT10_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT10_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT10_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT10_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT10_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT10_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT10_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT10_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT10_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT10_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT10_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINT11, OTG2_HS_HOST_BASE + 0x268 @ (OTG_HS host channel-11 interrupt  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINT11_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT11_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT11_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT11_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT11_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT11_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT11_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT11_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT11_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT11_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT11_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINTMSK0, OTG2_HS_HOST_BASE + 0x10C @ (OTG_HS host channel-11 interrupt mask  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK0_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK0_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK0_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK0_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK0_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK0_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK0_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK0_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK0_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK0_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK0_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINTMSK1, OTG2_HS_HOST_BASE + 0x12C @ (OTG_HS host channel-1 interrupt mask  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK1_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK1_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK1_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK1_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK1_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK1_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK1_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK1_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK1_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK1_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK1_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINTMSK2, OTG2_HS_HOST_BASE + 0x14C @ (OTG_HS host channel-2 interrupt mask  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK2_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK2_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK2_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK2_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK2_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK2_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK2_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK2_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK2_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK2_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK2_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINTMSK3, OTG2_HS_HOST_BASE + 0x16C @ (OTG_HS host channel-3 interrupt mask  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK3_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK3_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK3_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK3_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK3_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK3_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK3_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK3_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK3_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK3_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK3_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINTMSK4, OTG2_HS_HOST_BASE + 0x18C @ (OTG_HS host channel-4 interrupt mask  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK4_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK4_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK4_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK4_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK4_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK4_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK4_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK4_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK4_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK4_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK4_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINTMSK5, OTG2_HS_HOST_BASE + 0x1AC @ (OTG_HS host channel-5 interrupt mask  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK5_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK5_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK5_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK5_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK5_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK5_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK5_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK5_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK5_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK5_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK5_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINTMSK6, OTG2_HS_HOST_BASE + 0x1CC @ (OTG_HS host channel-6 interrupt mask  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK6_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK6_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK6_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK6_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK6_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK6_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK6_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK6_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK6_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK6_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK6_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINTMSK7, OTG2_HS_HOST_BASE + 0x1EC @ (OTG_HS host channel-7 interrupt mask  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK7_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK7_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK7_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK7_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK7_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK7_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK7_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK7_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK7_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK7_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK7_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINTMSK8, OTG2_HS_HOST_BASE + 0x20C @ (OTG_HS host channel-8 interrupt mask  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK8_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK8_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK8_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK8_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK8_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK8_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK8_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK8_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK8_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK8_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK8_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINTMSK9, OTG2_HS_HOST_BASE + 0x22C @ (OTG_HS host channel-9 interrupt mask  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK9_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK9_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK9_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK9_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK9_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK9_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK9_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK9_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK9_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK9_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK9_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINTMSK10, OTG2_HS_HOST_BASE + 0x24C @ (OTG_HS host channel-10 interrupt mask  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK10_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK10_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK10_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK10_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK10_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK10_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK10_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK10_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK10_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK10_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK10_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINTMSK11, OTG2_HS_HOST_BASE + 0x26C @ (OTG_HS host channel-11 interrupt mask  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK11_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK11_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK11_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK11_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK11_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK11_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK11_NYET, 1 << 6   @ bitWidth 1 (response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK11_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK11_BBERRM, 1 << 8   @ bitWidth 1 (Babble error mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK11_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK11_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCTSIZ0, OTG2_HS_HOST_BASE + 0x110 @ (OTG_HS host channel-11 transfer size  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ0_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ0_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ0_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCTSIZ1, OTG2_HS_HOST_BASE + 0x130 @ (OTG_HS host channel-1 transfer size  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ1_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ1_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ1_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCTSIZ2, OTG2_HS_HOST_BASE + 0x150 @ (OTG_HS host channel-2 transfer size  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ2_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ2_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ2_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCTSIZ3, OTG2_HS_HOST_BASE + 0x170 @ (OTG_HS host channel-3 transfer size  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ3_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ3_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ3_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCTSIZ4, OTG2_HS_HOST_BASE + 0x190 @ (OTG_HS host channel-4 transfer size  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ4_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ4_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ4_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCTSIZ5, OTG2_HS_HOST_BASE + 0x1B0 @ (OTG_HS host channel-5 transfer size  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ5_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ5_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ5_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCTSIZ6, OTG2_HS_HOST_BASE + 0x1D0 @ (OTG_HS host channel-6 transfer size  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ6_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ6_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ6_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCTSIZ7, OTG2_HS_HOST_BASE + 0x1F0 @ (OTG_HS host channel-7 transfer size  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ7_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ7_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ7_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCTSIZ8, OTG2_HS_HOST_BASE + 0x210 @ (OTG_HS host channel-8 transfer size  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ8_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ8_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ8_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCTSIZ9, OTG2_HS_HOST_BASE + 0x230 @ (OTG_HS host channel-9 transfer size  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ9_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ9_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ9_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCTSIZ10, OTG2_HS_HOST_BASE + 0x250 @ (OTG_HS host channel-10 transfer size  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ10_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ10_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ10_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCTSIZ11, OTG2_HS_HOST_BASE + 0x270 @ (OTG_HS host channel-11 transfer size  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ11_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ11_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ11_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCDMA0, OTG2_HS_HOST_BASE + 0x114 @ (OTG_HS host channel-0 DMA address  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCDMA0_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCDMA1, OTG2_HS_HOST_BASE + 0x134 @ (OTG_HS host channel-1 DMA address  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCDMA1_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCDMA2, OTG2_HS_HOST_BASE + 0x154 @ (OTG_HS host channel-2 DMA address  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCDMA2_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCDMA3, OTG2_HS_HOST_BASE + 0x174 @ (OTG_HS host channel-3 DMA address  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCDMA3_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCDMA4, OTG2_HS_HOST_BASE + 0x194 @ (OTG_HS host channel-4 DMA address  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCDMA4_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCDMA5, OTG2_HS_HOST_BASE + 0x1B4 @ (OTG_HS host channel-5 DMA address  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCDMA5_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCDMA6, OTG2_HS_HOST_BASE + 0x1D4 @ (OTG_HS host channel-6 DMA address  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCDMA6_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCDMA7, OTG2_HS_HOST_BASE + 0x1F4 @ (OTG_HS host channel-7 DMA address  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCDMA7_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCDMA8, OTG2_HS_HOST_BASE + 0x214 @ (OTG_HS host channel-8 DMA address  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCDMA8_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCDMA9, OTG2_HS_HOST_BASE + 0x234 @ (OTG_HS host channel-9 DMA address  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCDMA9_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCDMA10, OTG2_HS_HOST_BASE + 0x254 @ (OTG_HS host channel-10 DMA address  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCDMA10_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCDMA11, OTG2_HS_HOST_BASE + 0x274 @ (OTG_HS host channel-11 DMA address  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCDMA11_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCCHAR12, OTG2_HS_HOST_BASE + 0x278 @ (OTG_HS host channel-12 characteristics  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR12_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR12_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR12_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR12_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR12_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR12_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR12_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR12_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR12_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR12_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCSPLT12, OTG2_HS_HOST_BASE + 0x27C @ (OTG_HS host channel-12 split control  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT12_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT12_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT12_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT12_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT12_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINT12, OTG2_HS_HOST_BASE + 0x280 @ (OTG_HS host channel-12 interrupt  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINT12_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT12_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT12_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT12_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT12_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT12_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT12_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT12_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT12_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT12_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT12_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINTMSK12, OTG2_HS_HOST_BASE + 0x284 @ (OTG_HS host channel-12 interrupt mask  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK12_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK12_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK12_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK12_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK12_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK12_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK12_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK12_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK12_BBERRM, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK12_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK12_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCTSIZ12, OTG2_HS_HOST_BASE + 0x288 @ (OTG_HS host channel-12 transfer size  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ12_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ12_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ12_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCDMA12, OTG2_HS_HOST_BASE + 0x28C @ (OTG_HS host channel-12 DMA address  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCDMA12_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCCHAR13, OTG2_HS_HOST_BASE + 0x290 @ (OTG_HS host channel-13 characteristics  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR13_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR13_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR13_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR13_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR13_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR13_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR13_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR13_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR13_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR13_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCSPLT13, OTG2_HS_HOST_BASE + 0x294 @ (OTG_HS host channel-13 split control  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT13_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT13_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT13_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT13_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT13_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINT13, OTG2_HS_HOST_BASE + 0x298 @ (OTG_HS host channel-13 interrupt  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINT13_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT13_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT13_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT13_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT13_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT13_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT13_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT13_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT13_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT13_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT13_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINTMSK13, OTG2_HS_HOST_BASE + 0x29C @ (OTG_HS host channel-13 interrupt mask  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK13_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK13_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK13_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK13_STALLM, 1 << 3   @ bitWidth 1 (STALLM response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK13_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK13_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK13_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK13_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK13_BBERRM, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK13_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK13_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCTSIZ13, OTG2_HS_HOST_BASE + 0x2A0 @ (OTG_HS host channel-13 transfer size  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ13_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ13_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ13_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCDMA13, OTG2_HS_HOST_BASE + 0x2A4 @ (OTG_HS host channel-13 DMA address  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCDMA13_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCCHAR14, OTG2_HS_HOST_BASE + 0x2A8 @ (OTG_HS host channel-14 characteristics  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR14_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR14_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR14_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR14_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR14_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR14_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR14_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR14_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR14_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR14_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCSPLT14, OTG2_HS_HOST_BASE + 0x2AC @ (OTG_HS host channel-14 split control  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT14_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT14_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT14_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT14_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT14_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINT14, OTG2_HS_HOST_BASE + 0x2B0 @ (OTG_HS host channel-14 interrupt  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINT14_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT14_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT14_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT14_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT14_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT14_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT14_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT14_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT14_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT14_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT14_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINTMSK14, OTG2_HS_HOST_BASE + 0x2B4 @ (OTG_HS host channel-14 interrupt mask  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK14_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK14_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK14_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK14_STALLM, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK14_NAKM, 1 << 4   @ bitWidth 1 (NAKM response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK14_ACKM, 1 << 5   @ bitWidth 1 (ACKM response received/transmitted  interrupt mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK14_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK14_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK14_BBERRM, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK14_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK14_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCTSIZ14, OTG2_HS_HOST_BASE + 0x2B8 @ (OTG_HS host channel-14 transfer size  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ14_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ14_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ14_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCDMA14, OTG2_HS_HOST_BASE + 0x2BC @ (OTG_HS host channel-14 DMA address  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCDMA14_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCCHAR15, OTG2_HS_HOST_BASE + 0x2C0 @ (OTG_HS host channel-15 characteristics  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR15_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR15_EPNUM_Shift, 11   @ bitWidth 4 (Endpoint number)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR15_EPDIR, 1 << 15   @ bitWidth 1 (Endpoint direction)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR15_LSDEV, 1 << 17   @ bitWidth 1 (Low-speed device)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR15_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR15_MC_Shift, 20   @ bitWidth 2 (Multi Count MC / Error Count  EC)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR15_DAD_Shift, 22   @ bitWidth 7 (Device address)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR15_ODDFRM, 1 << 29   @ bitWidth 1 (Odd frame)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR15_CHDIS, 1 << 30   @ bitWidth 1 (Channel disable)  
        .equ OTG2_HS_HOST_OTG_HS_HCCHAR15_CHENA, 1 << 31   @ bitWidth 1 (Channel enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCSPLT15, OTG2_HS_HOST_BASE + 0x2C4 @ (OTG_HS host channel-15 split control  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT15_PRTADDR_Shift, 0   @ bitWidth 7 (Port address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT15_HUBADDR_Shift, 7   @ bitWidth 7 (Hub address)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT15_XACTPOS_Shift, 14   @ bitWidth 2 (XACTPOS)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT15_COMPLSPLT, 1 << 16   @ bitWidth 1 (Do complete split)  
        .equ OTG2_HS_HOST_OTG_HS_HCSPLT15_SPLITEN, 1 << 31   @ bitWidth 1 (Split enable)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINT15, OTG2_HS_HOST_BASE + 0x2C8 @ (OTG_HS host channel-15 interrupt  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINT15_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT15_CHH, 1 << 1   @ bitWidth 1 (Channel halted)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT15_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT15_STALL, 1 << 3   @ bitWidth 1 (STALL response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT15_NAK, 1 << 4   @ bitWidth 1 (NAK response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT15_ACK, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT15_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT15_TXERR, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT15_BBERR, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT15_FRMOR, 1 << 9   @ bitWidth 1 (Frame overrun)  
        .equ OTG2_HS_HOST_OTG_HS_HCINT15_DTERR, 1 << 10   @ bitWidth 1 (Data toggle error)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCINTMSK15, OTG2_HS_HOST_BASE + 0x2CC @ (OTG_HS host channel-15 interrupt mask  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK15_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK15_CHHM, 1 << 1   @ bitWidth 1 (Channel halted mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK15_AHBERR, 1 << 2   @ bitWidth 1 (AHB error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK15_STALL, 1 << 3   @ bitWidth 1 (STALL response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK15_NAKM, 1 << 4   @ bitWidth 1 (NAK response received interrupt  mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK15_ACKM, 1 << 5   @ bitWidth 1 (ACK response received/transmitted  interrupt mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK15_NYET, 1 << 6   @ bitWidth 1 (Response received  interrupt)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK15_TXERRM, 1 << 7   @ bitWidth 1 (Transaction error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK15_BBERRM, 1 << 8   @ bitWidth 1 (Babble error)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK15_FRMORM, 1 << 9   @ bitWidth 1 (Frame overrun mask)  
        .equ OTG2_HS_HOST_OTG_HS_HCINTMSK15_DTERRM, 1 << 10   @ bitWidth 1 (Data toggle error mask)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCTSIZ15, OTG2_HS_HOST_BASE + 0x2D0 @ (OTG_HS host channel-15 transfer size  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ15_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ15_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_HOST_OTG_HS_HCTSIZ15_DPID_Shift, 29   @ bitWidth 2 (Data PID)  
 
    .equ OTG2_HS_HOST_OTG_HS_HCDMA15, OTG2_HS_HOST_BASE + 0x2D4 @ (OTG_HS host channel-15 DMA address  register) 
        .equ OTG2_HS_HOST_OTG_HS_HCDMA15_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 

@=========================== OTG1_HS_DEVICE ===========================@
.equ OTG1_HS_DEVICE_BASE, 0x40040800 @ (USB 1 on the go high speed) 
    .equ OTG1_HS_DEVICE_OTG_HS_DCFG, OTG1_HS_DEVICE_BASE + 0x0 @ (OTG_HS device configuration  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DCFG_DSPD_Shift, 0   @ bitWidth 2 (Device speed)  
        .equ OTG1_HS_DEVICE_OTG_HS_DCFG_NZLSOHSK, 1 << 2   @ bitWidth 1 (Nonzero-length status OUT  handshake)  
        .equ OTG1_HS_DEVICE_OTG_HS_DCFG_DAD_Shift, 4   @ bitWidth 7 (Device address)  
        .equ OTG1_HS_DEVICE_OTG_HS_DCFG_PFIVL_Shift, 11   @ bitWidth 2 (Periodic microframe  interval)  
        .equ OTG1_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL_Shift, 24   @ bitWidth 2 (Periodic scheduling  interval)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DCTL, OTG1_HS_DEVICE_BASE + 0x4 @ (OTG_HS device control register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DCTL_RWUSIG, 1 << 0   @ bitWidth 1 (Remote wakeup signaling)  
        .equ OTG1_HS_DEVICE_OTG_HS_DCTL_SDIS, 1 << 1   @ bitWidth 1 (Soft disconnect)  
        .equ OTG1_HS_DEVICE_OTG_HS_DCTL_GINSTS, 1 << 2   @ bitWidth 1 (Global IN NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DCTL_GONSTS, 1 << 3   @ bitWidth 1 (Global OUT NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DCTL_TCTL_Shift, 4   @ bitWidth 3 (Test control)  
        .equ OTG1_HS_DEVICE_OTG_HS_DCTL_SGINAK, 1 << 7   @ bitWidth 1 (Set global IN NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DCTL_CGINAK, 1 << 8   @ bitWidth 1 (Clear global IN NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DCTL_SGONAK, 1 << 9   @ bitWidth 1 (Set global OUT NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DCTL_CGONAK, 1 << 10   @ bitWidth 1 (Clear global OUT NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DCTL_POPRGDNE, 1 << 11   @ bitWidth 1 (Power-on programming done)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DSTS, OTG1_HS_DEVICE_BASE + 0x8 @ (OTG_HS device status register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DSTS_SUSPSTS, 1 << 0   @ bitWidth 1 (Suspend status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DSTS_ENUMSPD_Shift, 1   @ bitWidth 2 (Enumerated speed)  
        .equ OTG1_HS_DEVICE_OTG_HS_DSTS_EERR, 1 << 3   @ bitWidth 1 (Erratic error)  
        .equ OTG1_HS_DEVICE_OTG_HS_DSTS_FNSOF_Shift, 8   @ bitWidth 14 (Frame number of the received  SOF)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPMSK, OTG1_HS_DEVICE_BASE + 0x10 @ (OTG_HS device IN endpoint common interrupt  mask register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPMSK_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed interrupt  mask)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPMSK_EPDM, 1 << 1   @ bitWidth 1 (Endpoint disabled interrupt  mask)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPMSK_TOM, 1 << 3   @ bitWidth 1 (Timeout condition mask nonisochronous  endpoints)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPMSK_ITTXFEMSK, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO empty  mask)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPMSK_INEPNMM, 1 << 5   @ bitWidth 1 (IN token received with EP mismatch  mask)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPMSK_INEPNEM, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective  mask)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPMSK_TXFURM, 1 << 8   @ bitWidth 1 (FIFO underrun mask)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPMSK_BIM, 1 << 9   @ bitWidth 1 (BNA interrupt mask)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPMSK, OTG1_HS_DEVICE_BASE + 0x14 @ (OTG_HS device OUT endpoint common interrupt  mask register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPMSK_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed interrupt  mask)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPMSK_EPDM, 1 << 1   @ bitWidth 1 (Endpoint disabled interrupt  mask)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPMSK_STUPM, 1 << 3   @ bitWidth 1 (SETUP phase done mask)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPMSK_OTEPDM, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled mask)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPMSK_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets received  mask)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPMSK_OPEM, 1 << 8   @ bitWidth 1 (OUT packet error mask)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPMSK_BOIM, 1 << 9   @ bitWidth 1 (BNA interrupt mask)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DAINT, OTG1_HS_DEVICE_BASE + 0x18 @ (OTG_HS device all endpoints interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DAINT_IEPINT_Shift, 0   @ bitWidth 16 (IN endpoint interrupt bits)  
        .equ OTG1_HS_DEVICE_OTG_HS_DAINT_OEPINT_Shift, 16   @ bitWidth 16 (OUT endpoint interrupt  bits)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DAINTMSK, OTG1_HS_DEVICE_BASE + 0x1C @ (OTG_HS all endpoints interrupt mask  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DAINTMSK_IEPM_Shift, 0   @ bitWidth 16 (IN EP interrupt mask bits)  
        .equ OTG1_HS_DEVICE_OTG_HS_DAINTMSK_OEPM_Shift, 16   @ bitWidth 16 (OUT EP interrupt mask bits)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DVBUSDIS, OTG1_HS_DEVICE_BASE + 0x28 @ (OTG_HS device VBUS discharge time  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DVBUSDIS_VBUSDT_Shift, 0   @ bitWidth 16 (Device VBUS discharge time)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DVBUSPULSE, OTG1_HS_DEVICE_BASE + 0x2C @ (OTG_HS device VBUS pulsing time  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP_Shift, 0   @ bitWidth 12 (Device VBUS pulsing time)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DTHRCTL, OTG1_HS_DEVICE_BASE + 0x30 @ (OTG_HS Device threshold control  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DTHRCTL_NONISOTHREN, 1 << 0   @ bitWidth 1 (Nonisochronous IN endpoints threshold  enable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DTHRCTL_ISOTHREN, 1 << 1   @ bitWidth 1 (ISO IN endpoint threshold  enable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN_Shift, 2   @ bitWidth 9 (Transmit threshold length)  
        .equ OTG1_HS_DEVICE_OTG_HS_DTHRCTL_RXTHREN, 1 << 16   @ bitWidth 1 (Receive threshold enable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN_Shift, 17   @ bitWidth 9 (Receive threshold length)  
        .equ OTG1_HS_DEVICE_OTG_HS_DTHRCTL_ARPEN, 1 << 27   @ bitWidth 1 (Arbiter parking enable)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPEMPMSK, OTG1_HS_DEVICE_BASE + 0x34 @ (OTG_HS device IN endpoint FIFO empty  interrupt mask register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPEMPMSK_INEPTXFEM_Shift, 0   @ bitWidth 16 (IN EP Tx FIFO empty interrupt mask  bits)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DEACHINT, OTG1_HS_DEVICE_BASE + 0x38 @ (OTG_HS device each endpoint interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DEACHINT_IEP1INT, 1 << 1   @ bitWidth 1 (IN endpoint 1interrupt bit)  
        .equ OTG1_HS_DEVICE_OTG_HS_DEACHINT_OEP1INT, 1 << 17   @ bitWidth 1 (OUT endpoint 1 interrupt  bit)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DEACHINTMSK, OTG1_HS_DEVICE_BASE + 0x3C @ (OTG_HS device each endpoint interrupt  register mask) 
        .equ OTG1_HS_DEVICE_OTG_HS_DEACHINTMSK_IEP1INTM, 1 << 1   @ bitWidth 1 (IN Endpoint 1 interrupt mask  bit)  
        .equ OTG1_HS_DEVICE_OTG_HS_DEACHINTMSK_OEP1INTM, 1 << 17   @ bitWidth 1 (OUT Endpoint 1 interrupt mask  bit)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL0, OTG1_HS_DEVICE_BASE + 0x100 @ (OTG device endpoint-0 control  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even/odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_TXFNUM_Shift, 22   @ bitWidth 4 (TxFIFO number)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL1, OTG1_HS_DEVICE_BASE + 0x120 @ (OTG device endpoint-1 control  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even/odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_TXFNUM_Shift, 22   @ bitWidth 4 (TxFIFO number)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL2, OTG1_HS_DEVICE_BASE + 0x140 @ (OTG device endpoint-2 control  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even/odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_TXFNUM_Shift, 22   @ bitWidth 4 (TxFIFO number)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL3, OTG1_HS_DEVICE_BASE + 0x160 @ (OTG device endpoint-3 control  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even/odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_TXFNUM_Shift, 22   @ bitWidth 4 (TxFIFO number)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL4, OTG1_HS_DEVICE_BASE + 0x180 @ (OTG device endpoint-4 control  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even/odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_TXFNUM_Shift, 22   @ bitWidth 4 (TxFIFO number)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL5, OTG1_HS_DEVICE_BASE + 0x1A0 @ (OTG device endpoint-5 control  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even/odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_TXFNUM_Shift, 22   @ bitWidth 4 (TxFIFO number)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL6, OTG1_HS_DEVICE_BASE + 0x1C0 @ (OTG device endpoint-6 control  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even/odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_TXFNUM_Shift, 22   @ bitWidth 4 (TxFIFO number)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL7, OTG1_HS_DEVICE_BASE + 0x1E0 @ (OTG device endpoint-7 control  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even/odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_TXFNUM_Shift, 22   @ bitWidth 4 (TxFIFO number)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT0, OTG1_HS_DEVICE_BASE + 0x108 @ (OTG device endpoint-0 interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT0_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT0_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT0_TOC, 1 << 3   @ bitWidth 1 (Timeout condition)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT0_ITTXFE, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO is  empty)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT0_INEPNE, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT0_TXFE, 1 << 7   @ bitWidth 1 (Transmit FIFO empty)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT0_TXFIFOUDRN, 1 << 8   @ bitWidth 1 (Transmit Fifo Underrun)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT0_BNA, 1 << 9   @ bitWidth 1 (Buffer not available  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT0_PKTDRPSTS, 1 << 11   @ bitWidth 1 (Packet dropped status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT0_BERR, 1 << 12   @ bitWidth 1 (Babble error interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT0_NAK, 1 << 13   @ bitWidth 1 (NAK interrupt)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT1, OTG1_HS_DEVICE_BASE + 0x128 @ (OTG device endpoint-1 interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT1_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT1_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT1_TOC, 1 << 3   @ bitWidth 1 (Timeout condition)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT1_ITTXFE, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO is  empty)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT1_INEPNE, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT1_TXFE, 1 << 7   @ bitWidth 1 (Transmit FIFO empty)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT1_TXFIFOUDRN, 1 << 8   @ bitWidth 1 (Transmit Fifo Underrun)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT1_BNA, 1 << 9   @ bitWidth 1 (Buffer not available  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT1_PKTDRPSTS, 1 << 11   @ bitWidth 1 (Packet dropped status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT1_BERR, 1 << 12   @ bitWidth 1 (Babble error interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT1_NAK, 1 << 13   @ bitWidth 1 (NAK interrupt)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT2, OTG1_HS_DEVICE_BASE + 0x148 @ (OTG device endpoint-2 interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT2_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT2_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT2_TOC, 1 << 3   @ bitWidth 1 (Timeout condition)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT2_ITTXFE, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO is  empty)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT2_INEPNE, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT2_TXFE, 1 << 7   @ bitWidth 1 (Transmit FIFO empty)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT2_TXFIFOUDRN, 1 << 8   @ bitWidth 1 (Transmit Fifo Underrun)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT2_BNA, 1 << 9   @ bitWidth 1 (Buffer not available  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT2_PKTDRPSTS, 1 << 11   @ bitWidth 1 (Packet dropped status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT2_BERR, 1 << 12   @ bitWidth 1 (Babble error interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT2_NAK, 1 << 13   @ bitWidth 1 (NAK interrupt)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT3, OTG1_HS_DEVICE_BASE + 0x168 @ (OTG device endpoint-3 interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT3_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT3_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT3_TOC, 1 << 3   @ bitWidth 1 (Timeout condition)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT3_ITTXFE, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO is  empty)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT3_INEPNE, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT3_TXFE, 1 << 7   @ bitWidth 1 (Transmit FIFO empty)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT3_TXFIFOUDRN, 1 << 8   @ bitWidth 1 (Transmit Fifo Underrun)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT3_BNA, 1 << 9   @ bitWidth 1 (Buffer not available  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT3_PKTDRPSTS, 1 << 11   @ bitWidth 1 (Packet dropped status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT3_BERR, 1 << 12   @ bitWidth 1 (Babble error interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT3_NAK, 1 << 13   @ bitWidth 1 (NAK interrupt)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT4, OTG1_HS_DEVICE_BASE + 0x188 @ (OTG device endpoint-4 interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT4_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT4_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT4_TOC, 1 << 3   @ bitWidth 1 (Timeout condition)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT4_ITTXFE, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO is  empty)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT4_INEPNE, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT4_TXFE, 1 << 7   @ bitWidth 1 (Transmit FIFO empty)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT4_TXFIFOUDRN, 1 << 8   @ bitWidth 1 (Transmit Fifo Underrun)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT4_BNA, 1 << 9   @ bitWidth 1 (Buffer not available  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT4_PKTDRPSTS, 1 << 11   @ bitWidth 1 (Packet dropped status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT4_BERR, 1 << 12   @ bitWidth 1 (Babble error interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT4_NAK, 1 << 13   @ bitWidth 1 (NAK interrupt)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT5, OTG1_HS_DEVICE_BASE + 0x1A8 @ (OTG device endpoint-5 interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT5_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT5_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT5_TOC, 1 << 3   @ bitWidth 1 (Timeout condition)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT5_ITTXFE, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO is  empty)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT5_INEPNE, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT5_TXFE, 1 << 7   @ bitWidth 1 (Transmit FIFO empty)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT5_TXFIFOUDRN, 1 << 8   @ bitWidth 1 (Transmit Fifo Underrun)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT5_BNA, 1 << 9   @ bitWidth 1 (Buffer not available  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT5_PKTDRPSTS, 1 << 11   @ bitWidth 1 (Packet dropped status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT5_BERR, 1 << 12   @ bitWidth 1 (Babble error interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT5_NAK, 1 << 13   @ bitWidth 1 (NAK interrupt)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT6, OTG1_HS_DEVICE_BASE + 0x1C8 @ (OTG device endpoint-6 interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT6_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT6_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT6_TOC, 1 << 3   @ bitWidth 1 (Timeout condition)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT6_ITTXFE, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO is  empty)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT6_INEPNE, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT6_TXFE, 1 << 7   @ bitWidth 1 (Transmit FIFO empty)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT6_TXFIFOUDRN, 1 << 8   @ bitWidth 1 (Transmit Fifo Underrun)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT6_BNA, 1 << 9   @ bitWidth 1 (Buffer not available  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT6_PKTDRPSTS, 1 << 11   @ bitWidth 1 (Packet dropped status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT6_BERR, 1 << 12   @ bitWidth 1 (Babble error interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT6_NAK, 1 << 13   @ bitWidth 1 (NAK interrupt)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT7, OTG1_HS_DEVICE_BASE + 0x1E8 @ (OTG device endpoint-7 interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT7_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT7_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT7_TOC, 1 << 3   @ bitWidth 1 (Timeout condition)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT7_ITTXFE, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO is  empty)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT7_INEPNE, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT7_TXFE, 1 << 7   @ bitWidth 1 (Transmit FIFO empty)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT7_TXFIFOUDRN, 1 << 8   @ bitWidth 1 (Transmit Fifo Underrun)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT7_BNA, 1 << 9   @ bitWidth 1 (Buffer not available  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT7_PKTDRPSTS, 1 << 11   @ bitWidth 1 (Packet dropped status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT7_BERR, 1 << 12   @ bitWidth 1 (Babble error interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPINT7_NAK, 1 << 13   @ bitWidth 1 (NAK interrupt)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0, OTG1_HS_DEVICE_BASE + 0x110 @ (OTG_HS device IN endpoint 0 transfer size  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_XFRSIZ_Shift, 0   @ bitWidth 7 (Transfer size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_PKTCNT_Shift, 19   @ bitWidth 2 (Packet count)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPDMA1, OTG1_HS_DEVICE_BASE + 0x114 @ (OTG_HS device endpoint-1 DMA address  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPDMA1_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPDMA2, OTG1_HS_DEVICE_BASE + 0x134 @ (OTG_HS device endpoint-2 DMA address  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPDMA2_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPDMA3, OTG1_HS_DEVICE_BASE + 0x154 @ (OTG_HS device endpoint-3 DMA address  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPDMA3_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPDMA4, OTG1_HS_DEVICE_BASE + 0x174 @ (OTG_HS device endpoint-4 DMA address  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPDMA4_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPDMA5, OTG1_HS_DEVICE_BASE + 0x194 @ (OTG_HS device endpoint-5 DMA address  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPDMA5_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DTXFSTS0, OTG1_HS_DEVICE_BASE + 0x118 @ (OTG_HS device IN endpoint transmit FIFO  status register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DTXFSTS0_INEPTFSAV_Shift, 0   @ bitWidth 16 (IN endpoint TxFIFO space  avail)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DTXFSTS1, OTG1_HS_DEVICE_BASE + 0x138 @ (OTG_HS device IN endpoint transmit FIFO  status register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DTXFSTS1_INEPTFSAV_Shift, 0   @ bitWidth 16 (IN endpoint TxFIFO space  avail)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DTXFSTS2, OTG1_HS_DEVICE_BASE + 0x158 @ (OTG_HS device IN endpoint transmit FIFO  status register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DTXFSTS2_INEPTFSAV_Shift, 0   @ bitWidth 16 (IN endpoint TxFIFO space  avail)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DTXFSTS3, OTG1_HS_DEVICE_BASE + 0x178 @ (OTG_HS device IN endpoint transmit FIFO  status register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DTXFSTS3_INEPTFSAV_Shift, 0   @ bitWidth 16 (IN endpoint TxFIFO space  avail)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DTXFSTS4, OTG1_HS_DEVICE_BASE + 0x198 @ (OTG_HS device IN endpoint transmit FIFO  status register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DTXFSTS4_INEPTFSAV_Shift, 0   @ bitWidth 16 (IN endpoint TxFIFO space  avail)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DTXFSTS5, OTG1_HS_DEVICE_BASE + 0x1B8 @ (OTG_HS device IN endpoint transmit FIFO  status register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DTXFSTS5_INEPTFSAV_Shift, 0   @ bitWidth 16 (IN endpoint TxFIFO space  avail)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1, OTG1_HS_DEVICE_BASE + 0x130 @ (OTG_HS device endpoint transfer size  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_MCNT_Shift, 29   @ bitWidth 2 (Multi count)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2, OTG1_HS_DEVICE_BASE + 0x150 @ (OTG_HS device endpoint transfer size  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_MCNT_Shift, 29   @ bitWidth 2 (Multi count)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3, OTG1_HS_DEVICE_BASE + 0x170 @ (OTG_HS device endpoint transfer size  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_MCNT_Shift, 29   @ bitWidth 2 (Multi count)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4, OTG1_HS_DEVICE_BASE + 0x190 @ (OTG_HS device endpoint transfer size  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_MCNT_Shift, 29   @ bitWidth 2 (Multi count)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5, OTG1_HS_DEVICE_BASE + 0x1B0 @ (OTG_HS device endpoint transfer size  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_MCNT_Shift, 29   @ bitWidth 2 (Multi count)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL0, OTG1_HS_DEVICE_BASE + 0x300 @ (OTG_HS device control OUT endpoint 0 control  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_MPSIZ_Shift, 0   @ bitWidth 2 (Maximum packet size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_SNPM, 1 << 20   @ bitWidth 1 (Snoop mode)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL1, OTG1_HS_DEVICE_BASE + 0x320 @ (OTG device endpoint-1 control  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even odd frame/Endpoint data  PID)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SNPM, 1 << 20   @ bitWidth 1 (Snoop mode)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID/Set even  frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL2, OTG1_HS_DEVICE_BASE + 0x340 @ (OTG device endpoint-2 control  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even odd frame/Endpoint data  PID)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SNPM, 1 << 20   @ bitWidth 1 (Snoop mode)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID/Set even  frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL3, OTG1_HS_DEVICE_BASE + 0x360 @ (OTG device endpoint-3 control  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even odd frame/Endpoint data  PID)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SNPM, 1 << 20   @ bitWidth 1 (Snoop mode)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID/Set even  frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT0, OTG1_HS_DEVICE_BASE + 0x308 @ (OTG_HS device endpoint-0 interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT0_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT0_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT0_STUP, 1 << 3   @ bitWidth 1 (SETUP phase done)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT0_OTEPDIS, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT0_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets  received)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT0_NYET, 1 << 14   @ bitWidth 1 (NYET interrupt)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT1, OTG1_HS_DEVICE_BASE + 0x328 @ (OTG_HS device endpoint-1 interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT1_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT1_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT1_STUP, 1 << 3   @ bitWidth 1 (SETUP phase done)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT1_OTEPDIS, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT1_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets  received)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT1_NYET, 1 << 14   @ bitWidth 1 (NYET interrupt)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT2, OTG1_HS_DEVICE_BASE + 0x348 @ (OTG_HS device endpoint-2 interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT2_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT2_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT2_STUP, 1 << 3   @ bitWidth 1 (SETUP phase done)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT2_OTEPDIS, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT2_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets  received)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT2_NYET, 1 << 14   @ bitWidth 1 (NYET interrupt)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT3, OTG1_HS_DEVICE_BASE + 0x368 @ (OTG_HS device endpoint-3 interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT3_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT3_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT3_STUP, 1 << 3   @ bitWidth 1 (SETUP phase done)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT3_OTEPDIS, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT3_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets  received)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT3_NYET, 1 << 14   @ bitWidth 1 (NYET interrupt)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT4, OTG1_HS_DEVICE_BASE + 0x388 @ (OTG_HS device endpoint-4 interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT4_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT4_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT4_STUP, 1 << 3   @ bitWidth 1 (SETUP phase done)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT4_OTEPDIS, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT4_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets  received)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT4_NYET, 1 << 14   @ bitWidth 1 (NYET interrupt)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT5, OTG1_HS_DEVICE_BASE + 0x3A8 @ (OTG_HS device endpoint-5 interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT5_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT5_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT5_STUP, 1 << 3   @ bitWidth 1 (SETUP phase done)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT5_OTEPDIS, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT5_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets  received)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT5_NYET, 1 << 14   @ bitWidth 1 (NYET interrupt)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT6, OTG1_HS_DEVICE_BASE + 0x3C8 @ (OTG_HS device endpoint-6 interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT6_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT6_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT6_STUP, 1 << 3   @ bitWidth 1 (SETUP phase done)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT6_OTEPDIS, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT6_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets  received)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT6_NYET, 1 << 14   @ bitWidth 1 (NYET interrupt)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT7, OTG1_HS_DEVICE_BASE + 0x3E8 @ (OTG_HS device endpoint-7 interrupt  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT7_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT7_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT7_STUP, 1 << 3   @ bitWidth 1 (SETUP phase done)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT7_OTEPDIS, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT7_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets  received)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPINT7_NYET, 1 << 14   @ bitWidth 1 (NYET interrupt)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0, OTG1_HS_DEVICE_BASE + 0x310 @ (OTG_HS device endpoint-0 transfer size  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_XFRSIZ_Shift, 0   @ bitWidth 7 (Transfer size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_PKTCNT, 1 << 19   @ bitWidth 1 (Packet count)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_STUPCNT_Shift, 29   @ bitWidth 2 (SETUP packet count)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1, OTG1_HS_DEVICE_BASE + 0x330 @ (OTG_HS device endpoint-1 transfer size  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT_Shift, 29   @ bitWidth 2 (Received data PID/SETUP packet  count)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2, OTG1_HS_DEVICE_BASE + 0x350 @ (OTG_HS device endpoint-2 transfer size  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT_Shift, 29   @ bitWidth 2 (Received data PID/SETUP packet  count)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3, OTG1_HS_DEVICE_BASE + 0x370 @ (OTG_HS device endpoint-3 transfer size  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT_Shift, 29   @ bitWidth 2 (Received data PID/SETUP packet  count)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4, OTG1_HS_DEVICE_BASE + 0x390 @ (OTG_HS device endpoint-4 transfer size  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT_Shift, 29   @ bitWidth 2 (Received data PID/SETUP packet  count)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6, OTG1_HS_DEVICE_BASE + 0x1A0 @ (OTG_HS device endpoint transfer size  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6_MCNT_Shift, 29   @ bitWidth 2 (Multi count)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DTXFSTS6, OTG1_HS_DEVICE_BASE + 0x1A4 @ (OTG_HS device IN endpoint transmit FIFO  status register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DTXFSTS6_INEPTFSAV_Shift, 0   @ bitWidth 16 (IN endpoint TxFIFO space  avail)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7, OTG1_HS_DEVICE_BASE + 0x1A8 @ (OTG_HS device endpoint transfer size  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_MCNT_Shift, 29   @ bitWidth 2 (Multi count)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DTXFSTS7, OTG1_HS_DEVICE_BASE + 0x1AC @ (OTG_HS device IN endpoint transmit FIFO  status register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DTXFSTS7_INEPTFSAV_Shift, 0   @ bitWidth 16 (IN endpoint TxFIFO space  avail)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL4, OTG1_HS_DEVICE_BASE + 0x380 @ (OTG device endpoint-4 control  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even odd frame/Endpoint data  PID)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SNPM, 1 << 20   @ bitWidth 1 (Snoop mode)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID/Set even  frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL5, OTG1_HS_DEVICE_BASE + 0x3A0 @ (OTG device endpoint-5 control  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even odd frame/Endpoint data  PID)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SNPM, 1 << 20   @ bitWidth 1 (Snoop mode)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID/Set even  frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL6, OTG1_HS_DEVICE_BASE + 0x3C0 @ (OTG device endpoint-6 control  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even odd frame/Endpoint data  PID)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SNPM, 1 << 20   @ bitWidth 1 (Snoop mode)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID/Set even  frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL7, OTG1_HS_DEVICE_BASE + 0x3E0 @ (OTG device endpoint-7 control  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even odd frame/Endpoint data  PID)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SNPM, 1 << 20   @ bitWidth 1 (Snoop mode)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID/Set even  frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5, OTG1_HS_DEVICE_BASE + 0x3B0 @ (OTG_HS device endpoint-5 transfer size  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT_Shift, 29   @ bitWidth 2 (Received data PID/SETUP packet  count)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6, OTG1_HS_DEVICE_BASE + 0x3D0 @ (OTG_HS device endpoint-6 transfer size  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT_Shift, 29   @ bitWidth 2 (Received data PID/SETUP packet  count)  
 
    .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7, OTG1_HS_DEVICE_BASE + 0x3F0 @ (OTG_HS device endpoint-7 transfer size  register) 
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT_Shift, 29   @ bitWidth 2 (Received data PID/SETUP packet  count)  
 

@=========================== OTG2_HS_DEVICE ===========================@
.equ OTG2_HS_DEVICE_BASE, 0x40080800 @ (USB 1 on the go high speed) 
    .equ OTG2_HS_DEVICE_OTG_HS_DCFG, OTG2_HS_DEVICE_BASE + 0x0 @ (OTG_HS device configuration  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DCFG_DSPD_Shift, 0   @ bitWidth 2 (Device speed)  
        .equ OTG2_HS_DEVICE_OTG_HS_DCFG_NZLSOHSK, 1 << 2   @ bitWidth 1 (Nonzero-length status OUT  handshake)  
        .equ OTG2_HS_DEVICE_OTG_HS_DCFG_DAD_Shift, 4   @ bitWidth 7 (Device address)  
        .equ OTG2_HS_DEVICE_OTG_HS_DCFG_PFIVL_Shift, 11   @ bitWidth 2 (Periodic microframe  interval)  
        .equ OTG2_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL_Shift, 24   @ bitWidth 2 (Periodic scheduling  interval)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DCTL, OTG2_HS_DEVICE_BASE + 0x4 @ (OTG_HS device control register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DCTL_RWUSIG, 1 << 0   @ bitWidth 1 (Remote wakeup signaling)  
        .equ OTG2_HS_DEVICE_OTG_HS_DCTL_SDIS, 1 << 1   @ bitWidth 1 (Soft disconnect)  
        .equ OTG2_HS_DEVICE_OTG_HS_DCTL_GINSTS, 1 << 2   @ bitWidth 1 (Global IN NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DCTL_GONSTS, 1 << 3   @ bitWidth 1 (Global OUT NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DCTL_TCTL_Shift, 4   @ bitWidth 3 (Test control)  
        .equ OTG2_HS_DEVICE_OTG_HS_DCTL_SGINAK, 1 << 7   @ bitWidth 1 (Set global IN NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DCTL_CGINAK, 1 << 8   @ bitWidth 1 (Clear global IN NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DCTL_SGONAK, 1 << 9   @ bitWidth 1 (Set global OUT NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DCTL_CGONAK, 1 << 10   @ bitWidth 1 (Clear global OUT NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DCTL_POPRGDNE, 1 << 11   @ bitWidth 1 (Power-on programming done)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DSTS, OTG2_HS_DEVICE_BASE + 0x8 @ (OTG_HS device status register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DSTS_SUSPSTS, 1 << 0   @ bitWidth 1 (Suspend status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DSTS_ENUMSPD_Shift, 1   @ bitWidth 2 (Enumerated speed)  
        .equ OTG2_HS_DEVICE_OTG_HS_DSTS_EERR, 1 << 3   @ bitWidth 1 (Erratic error)  
        .equ OTG2_HS_DEVICE_OTG_HS_DSTS_FNSOF_Shift, 8   @ bitWidth 14 (Frame number of the received  SOF)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPMSK, OTG2_HS_DEVICE_BASE + 0x10 @ (OTG_HS device IN endpoint common interrupt  mask register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPMSK_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed interrupt  mask)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPMSK_EPDM, 1 << 1   @ bitWidth 1 (Endpoint disabled interrupt  mask)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPMSK_TOM, 1 << 3   @ bitWidth 1 (Timeout condition mask nonisochronous  endpoints)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPMSK_ITTXFEMSK, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO empty  mask)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPMSK_INEPNMM, 1 << 5   @ bitWidth 1 (IN token received with EP mismatch  mask)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPMSK_INEPNEM, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective  mask)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPMSK_TXFURM, 1 << 8   @ bitWidth 1 (FIFO underrun mask)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPMSK_BIM, 1 << 9   @ bitWidth 1 (BNA interrupt mask)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPMSK, OTG2_HS_DEVICE_BASE + 0x14 @ (OTG_HS device OUT endpoint common interrupt  mask register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPMSK_XFRCM, 1 << 0   @ bitWidth 1 (Transfer completed interrupt  mask)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPMSK_EPDM, 1 << 1   @ bitWidth 1 (Endpoint disabled interrupt  mask)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPMSK_STUPM, 1 << 3   @ bitWidth 1 (SETUP phase done mask)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPMSK_OTEPDM, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled mask)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPMSK_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets received  mask)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPMSK_OPEM, 1 << 8   @ bitWidth 1 (OUT packet error mask)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPMSK_BOIM, 1 << 9   @ bitWidth 1 (BNA interrupt mask)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DAINT, OTG2_HS_DEVICE_BASE + 0x18 @ (OTG_HS device all endpoints interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DAINT_IEPINT_Shift, 0   @ bitWidth 16 (IN endpoint interrupt bits)  
        .equ OTG2_HS_DEVICE_OTG_HS_DAINT_OEPINT_Shift, 16   @ bitWidth 16 (OUT endpoint interrupt  bits)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DAINTMSK, OTG2_HS_DEVICE_BASE + 0x1C @ (OTG_HS all endpoints interrupt mask  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DAINTMSK_IEPM_Shift, 0   @ bitWidth 16 (IN EP interrupt mask bits)  
        .equ OTG2_HS_DEVICE_OTG_HS_DAINTMSK_OEPM_Shift, 16   @ bitWidth 16 (OUT EP interrupt mask bits)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DVBUSDIS, OTG2_HS_DEVICE_BASE + 0x28 @ (OTG_HS device VBUS discharge time  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DVBUSDIS_VBUSDT_Shift, 0   @ bitWidth 16 (Device VBUS discharge time)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DVBUSPULSE, OTG2_HS_DEVICE_BASE + 0x2C @ (OTG_HS device VBUS pulsing time  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP_Shift, 0   @ bitWidth 12 (Device VBUS pulsing time)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DTHRCTL, OTG2_HS_DEVICE_BASE + 0x30 @ (OTG_HS Device threshold control  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DTHRCTL_NONISOTHREN, 1 << 0   @ bitWidth 1 (Nonisochronous IN endpoints threshold  enable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DTHRCTL_ISOTHREN, 1 << 1   @ bitWidth 1 (ISO IN endpoint threshold  enable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN_Shift, 2   @ bitWidth 9 (Transmit threshold length)  
        .equ OTG2_HS_DEVICE_OTG_HS_DTHRCTL_RXTHREN, 1 << 16   @ bitWidth 1 (Receive threshold enable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN_Shift, 17   @ bitWidth 9 (Receive threshold length)  
        .equ OTG2_HS_DEVICE_OTG_HS_DTHRCTL_ARPEN, 1 << 27   @ bitWidth 1 (Arbiter parking enable)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPEMPMSK, OTG2_HS_DEVICE_BASE + 0x34 @ (OTG_HS device IN endpoint FIFO empty  interrupt mask register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPEMPMSK_INEPTXFEM_Shift, 0   @ bitWidth 16 (IN EP Tx FIFO empty interrupt mask  bits)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DEACHINT, OTG2_HS_DEVICE_BASE + 0x38 @ (OTG_HS device each endpoint interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DEACHINT_IEP1INT, 1 << 1   @ bitWidth 1 (IN endpoint 1interrupt bit)  
        .equ OTG2_HS_DEVICE_OTG_HS_DEACHINT_OEP1INT, 1 << 17   @ bitWidth 1 (OUT endpoint 1 interrupt  bit)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DEACHINTMSK, OTG2_HS_DEVICE_BASE + 0x3C @ (OTG_HS device each endpoint interrupt  register mask) 
        .equ OTG2_HS_DEVICE_OTG_HS_DEACHINTMSK_IEP1INTM, 1 << 1   @ bitWidth 1 (IN Endpoint 1 interrupt mask  bit)  
        .equ OTG2_HS_DEVICE_OTG_HS_DEACHINTMSK_OEP1INTM, 1 << 17   @ bitWidth 1 (OUT Endpoint 1 interrupt mask  bit)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL0, OTG2_HS_DEVICE_BASE + 0x100 @ (OTG device endpoint-0 control  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even/odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_TXFNUM_Shift, 22   @ bitWidth 4 (TxFIFO number)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL1, OTG2_HS_DEVICE_BASE + 0x120 @ (OTG device endpoint-1 control  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even/odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_TXFNUM_Shift, 22   @ bitWidth 4 (TxFIFO number)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL2, OTG2_HS_DEVICE_BASE + 0x140 @ (OTG device endpoint-2 control  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even/odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_TXFNUM_Shift, 22   @ bitWidth 4 (TxFIFO number)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL3, OTG2_HS_DEVICE_BASE + 0x160 @ (OTG device endpoint-3 control  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even/odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_TXFNUM_Shift, 22   @ bitWidth 4 (TxFIFO number)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL4, OTG2_HS_DEVICE_BASE + 0x180 @ (OTG device endpoint-4 control  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even/odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_TXFNUM_Shift, 22   @ bitWidth 4 (TxFIFO number)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL5, OTG2_HS_DEVICE_BASE + 0x1A0 @ (OTG device endpoint-5 control  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even/odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_TXFNUM_Shift, 22   @ bitWidth 4 (TxFIFO number)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL6, OTG2_HS_DEVICE_BASE + 0x1C0 @ (OTG device endpoint-6 control  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even/odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_TXFNUM_Shift, 22   @ bitWidth 4 (TxFIFO number)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL7, OTG2_HS_DEVICE_BASE + 0x1E0 @ (OTG device endpoint-7 control  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even/odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_TXFNUM_Shift, 22   @ bitWidth 4 (TxFIFO number)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT0, OTG2_HS_DEVICE_BASE + 0x108 @ (OTG device endpoint-0 interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT0_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT0_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT0_TOC, 1 << 3   @ bitWidth 1 (Timeout condition)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT0_ITTXFE, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO is  empty)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT0_INEPNE, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT0_TXFE, 1 << 7   @ bitWidth 1 (Transmit FIFO empty)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT0_TXFIFOUDRN, 1 << 8   @ bitWidth 1 (Transmit Fifo Underrun)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT0_BNA, 1 << 9   @ bitWidth 1 (Buffer not available  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT0_PKTDRPSTS, 1 << 11   @ bitWidth 1 (Packet dropped status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT0_BERR, 1 << 12   @ bitWidth 1 (Babble error interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT0_NAK, 1 << 13   @ bitWidth 1 (NAK interrupt)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT1, OTG2_HS_DEVICE_BASE + 0x128 @ (OTG device endpoint-1 interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT1_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT1_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT1_TOC, 1 << 3   @ bitWidth 1 (Timeout condition)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT1_ITTXFE, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO is  empty)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT1_INEPNE, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT1_TXFE, 1 << 7   @ bitWidth 1 (Transmit FIFO empty)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT1_TXFIFOUDRN, 1 << 8   @ bitWidth 1 (Transmit Fifo Underrun)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT1_BNA, 1 << 9   @ bitWidth 1 (Buffer not available  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT1_PKTDRPSTS, 1 << 11   @ bitWidth 1 (Packet dropped status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT1_BERR, 1 << 12   @ bitWidth 1 (Babble error interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT1_NAK, 1 << 13   @ bitWidth 1 (NAK interrupt)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT2, OTG2_HS_DEVICE_BASE + 0x148 @ (OTG device endpoint-2 interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT2_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT2_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT2_TOC, 1 << 3   @ bitWidth 1 (Timeout condition)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT2_ITTXFE, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO is  empty)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT2_INEPNE, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT2_TXFE, 1 << 7   @ bitWidth 1 (Transmit FIFO empty)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT2_TXFIFOUDRN, 1 << 8   @ bitWidth 1 (Transmit Fifo Underrun)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT2_BNA, 1 << 9   @ bitWidth 1 (Buffer not available  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT2_PKTDRPSTS, 1 << 11   @ bitWidth 1 (Packet dropped status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT2_BERR, 1 << 12   @ bitWidth 1 (Babble error interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT2_NAK, 1 << 13   @ bitWidth 1 (NAK interrupt)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT3, OTG2_HS_DEVICE_BASE + 0x168 @ (OTG device endpoint-3 interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT3_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT3_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT3_TOC, 1 << 3   @ bitWidth 1 (Timeout condition)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT3_ITTXFE, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO is  empty)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT3_INEPNE, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT3_TXFE, 1 << 7   @ bitWidth 1 (Transmit FIFO empty)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT3_TXFIFOUDRN, 1 << 8   @ bitWidth 1 (Transmit Fifo Underrun)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT3_BNA, 1 << 9   @ bitWidth 1 (Buffer not available  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT3_PKTDRPSTS, 1 << 11   @ bitWidth 1 (Packet dropped status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT3_BERR, 1 << 12   @ bitWidth 1 (Babble error interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT3_NAK, 1 << 13   @ bitWidth 1 (NAK interrupt)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT4, OTG2_HS_DEVICE_BASE + 0x188 @ (OTG device endpoint-4 interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT4_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT4_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT4_TOC, 1 << 3   @ bitWidth 1 (Timeout condition)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT4_ITTXFE, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO is  empty)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT4_INEPNE, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT4_TXFE, 1 << 7   @ bitWidth 1 (Transmit FIFO empty)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT4_TXFIFOUDRN, 1 << 8   @ bitWidth 1 (Transmit Fifo Underrun)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT4_BNA, 1 << 9   @ bitWidth 1 (Buffer not available  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT4_PKTDRPSTS, 1 << 11   @ bitWidth 1 (Packet dropped status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT4_BERR, 1 << 12   @ bitWidth 1 (Babble error interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT4_NAK, 1 << 13   @ bitWidth 1 (NAK interrupt)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT5, OTG2_HS_DEVICE_BASE + 0x1A8 @ (OTG device endpoint-5 interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT5_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT5_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT5_TOC, 1 << 3   @ bitWidth 1 (Timeout condition)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT5_ITTXFE, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO is  empty)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT5_INEPNE, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT5_TXFE, 1 << 7   @ bitWidth 1 (Transmit FIFO empty)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT5_TXFIFOUDRN, 1 << 8   @ bitWidth 1 (Transmit Fifo Underrun)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT5_BNA, 1 << 9   @ bitWidth 1 (Buffer not available  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT5_PKTDRPSTS, 1 << 11   @ bitWidth 1 (Packet dropped status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT5_BERR, 1 << 12   @ bitWidth 1 (Babble error interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT5_NAK, 1 << 13   @ bitWidth 1 (NAK interrupt)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT6, OTG2_HS_DEVICE_BASE + 0x1C8 @ (OTG device endpoint-6 interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT6_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT6_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT6_TOC, 1 << 3   @ bitWidth 1 (Timeout condition)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT6_ITTXFE, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO is  empty)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT6_INEPNE, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT6_TXFE, 1 << 7   @ bitWidth 1 (Transmit FIFO empty)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT6_TXFIFOUDRN, 1 << 8   @ bitWidth 1 (Transmit Fifo Underrun)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT6_BNA, 1 << 9   @ bitWidth 1 (Buffer not available  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT6_PKTDRPSTS, 1 << 11   @ bitWidth 1 (Packet dropped status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT6_BERR, 1 << 12   @ bitWidth 1 (Babble error interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT6_NAK, 1 << 13   @ bitWidth 1 (NAK interrupt)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT7, OTG2_HS_DEVICE_BASE + 0x1E8 @ (OTG device endpoint-7 interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT7_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT7_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT7_TOC, 1 << 3   @ bitWidth 1 (Timeout condition)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT7_ITTXFE, 1 << 4   @ bitWidth 1 (IN token received when TxFIFO is  empty)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT7_INEPNE, 1 << 6   @ bitWidth 1 (IN endpoint NAK effective)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT7_TXFE, 1 << 7   @ bitWidth 1 (Transmit FIFO empty)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT7_TXFIFOUDRN, 1 << 8   @ bitWidth 1 (Transmit Fifo Underrun)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT7_BNA, 1 << 9   @ bitWidth 1 (Buffer not available  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT7_PKTDRPSTS, 1 << 11   @ bitWidth 1 (Packet dropped status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT7_BERR, 1 << 12   @ bitWidth 1 (Babble error interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPINT7_NAK, 1 << 13   @ bitWidth 1 (NAK interrupt)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ0, OTG2_HS_DEVICE_BASE + 0x110 @ (OTG_HS device IN endpoint 0 transfer size  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ0_XFRSIZ_Shift, 0   @ bitWidth 7 (Transfer size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ0_PKTCNT_Shift, 19   @ bitWidth 2 (Packet count)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPDMA1, OTG2_HS_DEVICE_BASE + 0x114 @ (OTG_HS device endpoint-1 DMA address  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPDMA1_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPDMA2, OTG2_HS_DEVICE_BASE + 0x134 @ (OTG_HS device endpoint-2 DMA address  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPDMA2_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPDMA3, OTG2_HS_DEVICE_BASE + 0x154 @ (OTG_HS device endpoint-3 DMA address  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPDMA3_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPDMA4, OTG2_HS_DEVICE_BASE + 0x174 @ (OTG_HS device endpoint-4 DMA address  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPDMA4_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPDMA5, OTG2_HS_DEVICE_BASE + 0x194 @ (OTG_HS device endpoint-5 DMA address  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPDMA5_DMAADDR_Shift, 0   @ bitWidth 32 (DMA address)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DTXFSTS0, OTG2_HS_DEVICE_BASE + 0x118 @ (OTG_HS device IN endpoint transmit FIFO  status register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DTXFSTS0_INEPTFSAV_Shift, 0   @ bitWidth 16 (IN endpoint TxFIFO space  avail)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DTXFSTS1, OTG2_HS_DEVICE_BASE + 0x138 @ (OTG_HS device IN endpoint transmit FIFO  status register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DTXFSTS1_INEPTFSAV_Shift, 0   @ bitWidth 16 (IN endpoint TxFIFO space  avail)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DTXFSTS2, OTG2_HS_DEVICE_BASE + 0x158 @ (OTG_HS device IN endpoint transmit FIFO  status register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DTXFSTS2_INEPTFSAV_Shift, 0   @ bitWidth 16 (IN endpoint TxFIFO space  avail)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DTXFSTS3, OTG2_HS_DEVICE_BASE + 0x178 @ (OTG_HS device IN endpoint transmit FIFO  status register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DTXFSTS3_INEPTFSAV_Shift, 0   @ bitWidth 16 (IN endpoint TxFIFO space  avail)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DTXFSTS4, OTG2_HS_DEVICE_BASE + 0x198 @ (OTG_HS device IN endpoint transmit FIFO  status register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DTXFSTS4_INEPTFSAV_Shift, 0   @ bitWidth 16 (IN endpoint TxFIFO space  avail)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DTXFSTS5, OTG2_HS_DEVICE_BASE + 0x1B8 @ (OTG_HS device IN endpoint transmit FIFO  status register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DTXFSTS5_INEPTFSAV_Shift, 0   @ bitWidth 16 (IN endpoint TxFIFO space  avail)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1, OTG2_HS_DEVICE_BASE + 0x130 @ (OTG_HS device endpoint transfer size  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1_MCNT_Shift, 29   @ bitWidth 2 (Multi count)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2, OTG2_HS_DEVICE_BASE + 0x150 @ (OTG_HS device endpoint transfer size  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2_MCNT_Shift, 29   @ bitWidth 2 (Multi count)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3, OTG2_HS_DEVICE_BASE + 0x170 @ (OTG_HS device endpoint transfer size  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3_MCNT_Shift, 29   @ bitWidth 2 (Multi count)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4, OTG2_HS_DEVICE_BASE + 0x190 @ (OTG_HS device endpoint transfer size  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4_MCNT_Shift, 29   @ bitWidth 2 (Multi count)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5, OTG2_HS_DEVICE_BASE + 0x1B0 @ (OTG_HS device endpoint transfer size  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5_MCNT_Shift, 29   @ bitWidth 2 (Multi count)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL0, OTG2_HS_DEVICE_BASE + 0x300 @ (OTG_HS device control OUT endpoint 0 control  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_MPSIZ_Shift, 0   @ bitWidth 2 (Maximum packet size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_SNPM, 1 << 20   @ bitWidth 1 (Snoop mode)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL1, OTG2_HS_DEVICE_BASE + 0x320 @ (OTG device endpoint-1 control  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even odd frame/Endpoint data  PID)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_SNPM, 1 << 20   @ bitWidth 1 (Snoop mode)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID/Set even  frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL2, OTG2_HS_DEVICE_BASE + 0x340 @ (OTG device endpoint-2 control  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even odd frame/Endpoint data  PID)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_SNPM, 1 << 20   @ bitWidth 1 (Snoop mode)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID/Set even  frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL3, OTG2_HS_DEVICE_BASE + 0x360 @ (OTG device endpoint-3 control  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even odd frame/Endpoint data  PID)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_SNPM, 1 << 20   @ bitWidth 1 (Snoop mode)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID/Set even  frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT0, OTG2_HS_DEVICE_BASE + 0x308 @ (OTG_HS device endpoint-0 interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT0_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT0_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT0_STUP, 1 << 3   @ bitWidth 1 (SETUP phase done)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT0_OTEPDIS, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT0_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets  received)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT0_NYET, 1 << 14   @ bitWidth 1 (NYET interrupt)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT1, OTG2_HS_DEVICE_BASE + 0x328 @ (OTG_HS device endpoint-1 interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT1_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT1_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT1_STUP, 1 << 3   @ bitWidth 1 (SETUP phase done)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT1_OTEPDIS, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT1_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets  received)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT1_NYET, 1 << 14   @ bitWidth 1 (NYET interrupt)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT2, OTG2_HS_DEVICE_BASE + 0x348 @ (OTG_HS device endpoint-2 interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT2_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT2_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT2_STUP, 1 << 3   @ bitWidth 1 (SETUP phase done)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT2_OTEPDIS, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT2_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets  received)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT2_NYET, 1 << 14   @ bitWidth 1 (NYET interrupt)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT3, OTG2_HS_DEVICE_BASE + 0x368 @ (OTG_HS device endpoint-3 interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT3_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT3_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT3_STUP, 1 << 3   @ bitWidth 1 (SETUP phase done)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT3_OTEPDIS, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT3_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets  received)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT3_NYET, 1 << 14   @ bitWidth 1 (NYET interrupt)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT4, OTG2_HS_DEVICE_BASE + 0x388 @ (OTG_HS device endpoint-4 interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT4_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT4_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT4_STUP, 1 << 3   @ bitWidth 1 (SETUP phase done)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT4_OTEPDIS, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT4_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets  received)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT4_NYET, 1 << 14   @ bitWidth 1 (NYET interrupt)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT5, OTG2_HS_DEVICE_BASE + 0x3A8 @ (OTG_HS device endpoint-5 interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT5_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT5_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT5_STUP, 1 << 3   @ bitWidth 1 (SETUP phase done)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT5_OTEPDIS, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT5_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets  received)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT5_NYET, 1 << 14   @ bitWidth 1 (NYET interrupt)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT6, OTG2_HS_DEVICE_BASE + 0x3C8 @ (OTG_HS device endpoint-6 interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT6_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT6_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT6_STUP, 1 << 3   @ bitWidth 1 (SETUP phase done)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT6_OTEPDIS, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT6_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets  received)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT6_NYET, 1 << 14   @ bitWidth 1 (NYET interrupt)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT7, OTG2_HS_DEVICE_BASE + 0x3E8 @ (OTG_HS device endpoint-7 interrupt  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT7_XFRC, 1 << 0   @ bitWidth 1 (Transfer completed  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT7_EPDISD, 1 << 1   @ bitWidth 1 (Endpoint disabled  interrupt)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT7_STUP, 1 << 3   @ bitWidth 1 (SETUP phase done)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT7_OTEPDIS, 1 << 4   @ bitWidth 1 (OUT token received when endpoint  disabled)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT7_B2BSTUP, 1 << 6   @ bitWidth 1 (Back-to-back SETUP packets  received)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPINT7_NYET, 1 << 14   @ bitWidth 1 (NYET interrupt)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0, OTG2_HS_DEVICE_BASE + 0x310 @ (OTG_HS device endpoint-0 transfer size  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0_XFRSIZ_Shift, 0   @ bitWidth 7 (Transfer size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0_PKTCNT, 1 << 19   @ bitWidth 1 (Packet count)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0_STUPCNT_Shift, 29   @ bitWidth 2 (SETUP packet count)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1, OTG2_HS_DEVICE_BASE + 0x330 @ (OTG_HS device endpoint-1 transfer size  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT_Shift, 29   @ bitWidth 2 (Received data PID/SETUP packet  count)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2, OTG2_HS_DEVICE_BASE + 0x350 @ (OTG_HS device endpoint-2 transfer size  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT_Shift, 29   @ bitWidth 2 (Received data PID/SETUP packet  count)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3, OTG2_HS_DEVICE_BASE + 0x370 @ (OTG_HS device endpoint-3 transfer size  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT_Shift, 29   @ bitWidth 2 (Received data PID/SETUP packet  count)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4, OTG2_HS_DEVICE_BASE + 0x390 @ (OTG_HS device endpoint-4 transfer size  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT_Shift, 29   @ bitWidth 2 (Received data PID/SETUP packet  count)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6, OTG2_HS_DEVICE_BASE + 0x1A0 @ (OTG_HS device endpoint transfer size  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6_MCNT_Shift, 29   @ bitWidth 2 (Multi count)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DTXFSTS6, OTG2_HS_DEVICE_BASE + 0x1A4 @ (OTG_HS device IN endpoint transmit FIFO  status register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DTXFSTS6_INEPTFSAV_Shift, 0   @ bitWidth 16 (IN endpoint TxFIFO space  avail)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7, OTG2_HS_DEVICE_BASE + 0x1A8 @ (OTG_HS device endpoint transfer size  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7_MCNT_Shift, 29   @ bitWidth 2 (Multi count)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DTXFSTS7, OTG2_HS_DEVICE_BASE + 0x1AC @ (OTG_HS device IN endpoint transmit FIFO  status register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DTXFSTS7_INEPTFSAV_Shift, 0   @ bitWidth 16 (IN endpoint TxFIFO space  avail)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL4, OTG2_HS_DEVICE_BASE + 0x380 @ (OTG device endpoint-4 control  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even odd frame/Endpoint data  PID)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_SNPM, 1 << 20   @ bitWidth 1 (Snoop mode)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID/Set even  frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL5, OTG2_HS_DEVICE_BASE + 0x3A0 @ (OTG device endpoint-5 control  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even odd frame/Endpoint data  PID)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_SNPM, 1 << 20   @ bitWidth 1 (Snoop mode)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID/Set even  frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL6, OTG2_HS_DEVICE_BASE + 0x3C0 @ (OTG device endpoint-6 control  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even odd frame/Endpoint data  PID)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_SNPM, 1 << 20   @ bitWidth 1 (Snoop mode)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID/Set even  frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL7, OTG2_HS_DEVICE_BASE + 0x3E0 @ (OTG device endpoint-7 control  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_MPSIZ_Shift, 0   @ bitWidth 11 (Maximum packet size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_USBAEP, 1 << 15   @ bitWidth 1 (USB active endpoint)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_EONUM_DPID, 1 << 16   @ bitWidth 1 (Even odd frame/Endpoint data  PID)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_NAKSTS, 1 << 17   @ bitWidth 1 (NAK status)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_EPTYP_Shift, 18   @ bitWidth 2 (Endpoint type)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_SNPM, 1 << 20   @ bitWidth 1 (Snoop mode)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_Stall, 1 << 21   @ bitWidth 1 (STALL handshake)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_CNAK, 1 << 26   @ bitWidth 1 (Clear NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_SNAK, 1 << 27   @ bitWidth 1 (Set NAK)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_SD0PID_SEVNFRM, 1 << 28   @ bitWidth 1 (Set DATA0 PID/Set even  frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_SODDFRM, 1 << 29   @ bitWidth 1 (Set odd frame)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_EPDIS, 1 << 30   @ bitWidth 1 (Endpoint disable)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_EPENA, 1 << 31   @ bitWidth 1 (Endpoint enable)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5, OTG2_HS_DEVICE_BASE + 0x3B0 @ (OTG_HS device endpoint-5 transfer size  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT_Shift, 29   @ bitWidth 2 (Received data PID/SETUP packet  count)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6, OTG2_HS_DEVICE_BASE + 0x3D0 @ (OTG_HS device endpoint-6 transfer size  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT_Shift, 29   @ bitWidth 2 (Received data PID/SETUP packet  count)  
 
    .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7, OTG2_HS_DEVICE_BASE + 0x3F0 @ (OTG_HS device endpoint-7 transfer size  register) 
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7_XFRSIZ_Shift, 0   @ bitWidth 19 (Transfer size)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7_PKTCNT_Shift, 19   @ bitWidth 10 (Packet count)  
        .equ OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT_Shift, 29   @ bitWidth 2 (Received data PID/SETUP packet  count)  
 

@=========================== OTG1_HS_PWRCLK ===========================@
.equ OTG1_HS_PWRCLK_BASE, 0x40040E00 @ (USB 1 on the go high speed) 
    .equ OTG1_HS_PWRCLK_OTG_HS_PCGCR, OTG1_HS_PWRCLK_BASE + 0x0 @ (Power and clock gating control  register) 
        .equ OTG1_HS_PWRCLK_OTG_HS_PCGCR_STPPCLK, 1 << 0   @ bitWidth 1 (Stop PHY clock)  
        .equ OTG1_HS_PWRCLK_OTG_HS_PCGCR_GATEHCLK, 1 << 1   @ bitWidth 1 (Gate HCLK)  
        .equ OTG1_HS_PWRCLK_OTG_HS_PCGCR_PHYSUSP, 1 << 4   @ bitWidth 1 (PHY suspended)  
 

@=========================== OTG2_HS_PWRCLK ===========================@
.equ OTG2_HS_PWRCLK_BASE, 0x40080E00 @ (USB 1 on the go high speed) 
    .equ OTG2_HS_PWRCLK_OTG_HS_PCGCR, OTG2_HS_PWRCLK_BASE + 0x0 @ (Power and clock gating control  register) 
        .equ OTG2_HS_PWRCLK_OTG_HS_PCGCR_STPPCLK, 1 << 0   @ bitWidth 1 (Stop PHY clock)  
        .equ OTG2_HS_PWRCLK_OTG_HS_PCGCR_GATEHCLK, 1 << 1   @ bitWidth 1 (Gate HCLK)  
        .equ OTG2_HS_PWRCLK_OTG_HS_PCGCR_PHYSUSP, 1 << 4   @ bitWidth 1 (PHY suspended)  
 

@=========================== Ethernet_DMA ===========================@
.equ Ethernet_DMA_BASE, 0x40029000 @ (Ethernet: DMA mode register DMA) 
    .equ Ethernet_DMA_DMAMR, Ethernet_DMA_BASE + 0x0 @ (DMA mode register) 
        .equ Ethernet_DMA_DMAMR_SWR, 1 << 0   @ bitWidth 1 (Software Reset)  
        .equ Ethernet_DMA_DMAMR_DA, 1 << 1   @ bitWidth 1 (DMA Tx or Rx Arbitration  Scheme)  
        .equ Ethernet_DMA_DMAMR_TXPR, 1 << 11   @ bitWidth 1 (Transmit priority)  
        .equ Ethernet_DMA_DMAMR_PR_Shift, 12   @ bitWidth 3 (Priority ratio)  
        .equ Ethernet_DMA_DMAMR_INTM, 1 << 16   @ bitWidth 1 (Interrupt Mode)  
 
    .equ Ethernet_DMA_DMASBMR, Ethernet_DMA_BASE + 0x04 @ (System bus mode register) 
        .equ Ethernet_DMA_DMASBMR_FB, 1 << 0   @ bitWidth 1 (Fixed Burst Length)  
        .equ Ethernet_DMA_DMASBMR_AAL, 1 << 12   @ bitWidth 1 (Address-Aligned Beats)  
        .equ Ethernet_DMA_DMASBMR_MB, 1 << 14   @ bitWidth 1 (Mixed Burst)  
        .equ Ethernet_DMA_DMASBMR_RB, 1 << 15   @ bitWidth 1 (Rebuild INCRx Burst)  
 
    .equ Ethernet_DMA_DMAISR, Ethernet_DMA_BASE + 0x08 @ (Interrupt status register) 
        .equ Ethernet_DMA_DMAISR_DC0IS, 1 << 0   @ bitWidth 1 (DMA Channel Interrupt  Status)  
        .equ Ethernet_DMA_DMAISR_MTLIS, 1 << 16   @ bitWidth 1 (MTL Interrupt Status)  
        .equ Ethernet_DMA_DMAISR_MACIS, 1 << 17   @ bitWidth 1 (MAC Interrupt Status)  
 
    .equ Ethernet_DMA_DMADSR, Ethernet_DMA_BASE + 0x0C @ (Debug status register) 
        .equ Ethernet_DMA_DMADSR_AXWHSTS, 1 << 0   @ bitWidth 1 (AHB Master Write Channel)  
        .equ Ethernet_DMA_DMADSR_RPS0_Shift, 8   @ bitWidth 4 (DMA Channel Receive Process  State)  
        .equ Ethernet_DMA_DMADSR_TPS0_Shift, 12   @ bitWidth 4 (DMA Channel Transmit Process  State)  
 
    .equ Ethernet_DMA_DMACCR, Ethernet_DMA_BASE + 0x100 @ (Channel control register) 
        .equ Ethernet_DMA_DMACCR_MSS_Shift, 0   @ bitWidth 14 (Maximum Segment Size)  
        .equ Ethernet_DMA_DMACCR_PBLX8, 1 << 16   @ bitWidth 1 (8xPBL mode)  
        .equ Ethernet_DMA_DMACCR_DSL_Shift, 18   @ bitWidth 3 (Descriptor Skip Length)  
 
    .equ Ethernet_DMA_DMACTxCR, Ethernet_DMA_BASE + 0x104 @ (Channel transmit control  register) 
        .equ Ethernet_DMA_DMACTxCR_ST, 1 << 0   @ bitWidth 1 (Start or Stop Transmission  Command)  
        .equ Ethernet_DMA_DMACTxCR_OSF, 1 << 4   @ bitWidth 1 (Operate on Second Packet)  
        .equ Ethernet_DMA_DMACTxCR_TSE, 1 << 12   @ bitWidth 1 (TCP Segmentation Enabled)  
        .equ Ethernet_DMA_DMACTxCR_TXPBL_Shift, 16   @ bitWidth 6 (Transmit Programmable Burst  Length)  
 
    .equ Ethernet_DMA_DMACRxCR, Ethernet_DMA_BASE + 0x108 @ (Channel receive control  register) 
        .equ Ethernet_DMA_DMACRxCR_SR, 1 << 0   @ bitWidth 1 (Start or Stop Receive  Command)  
        .equ Ethernet_DMA_DMACRxCR_RBSZ_Shift, 1   @ bitWidth 14 (Receive Buffer size)  
        .equ Ethernet_DMA_DMACRxCR_RXPBL_Shift, 16   @ bitWidth 6 (RXPBL)  
        .equ Ethernet_DMA_DMACRxCR_RPF, 1 << 31   @ bitWidth 1 (DMA Rx Channel Packet  Flush)  
 
    .equ Ethernet_DMA_DMACTxDLAR, Ethernet_DMA_BASE + 0x114 @ (Channel Tx descriptor list address  register) 
        .equ Ethernet_DMA_DMACTxDLAR_TDESLA_Shift, 2   @ bitWidth 30 (Start of Transmit List)  
 
    .equ Ethernet_DMA_DMACRxDLAR, Ethernet_DMA_BASE + 0x11C @ (Channel Rx descriptor list address  register) 
        .equ Ethernet_DMA_DMACRxDLAR_RDESLA_Shift, 2   @ bitWidth 30 (Start of Receive List)  
 
    .equ Ethernet_DMA_DMACTxDTPR, Ethernet_DMA_BASE + 0x120 @ (Channel Tx descriptor tail pointer  register) 
        .equ Ethernet_DMA_DMACTxDTPR_TDT_Shift, 2   @ bitWidth 30 (Transmit Descriptor Tail  Pointer)  
 
    .equ Ethernet_DMA_DMACRxDTPR, Ethernet_DMA_BASE + 0x128 @ (Channel Rx descriptor tail pointer  register) 
        .equ Ethernet_DMA_DMACRxDTPR_RDT_Shift, 2   @ bitWidth 30 (Receive Descriptor Tail  Pointer)  
 
    .equ Ethernet_DMA_DMACTxRLR, Ethernet_DMA_BASE + 0x12C @ (Channel Tx descriptor ring length  register) 
        .equ Ethernet_DMA_DMACTxRLR_TDRL_Shift, 0   @ bitWidth 10 (Transmit Descriptor Ring  Length)  
 
    .equ Ethernet_DMA_DMACRxRLR, Ethernet_DMA_BASE + 0x130 @ (Channel Rx descriptor ring length  register) 
        .equ Ethernet_DMA_DMACRxRLR_RDRL_Shift, 0   @ bitWidth 10 (Receive Descriptor Ring  Length)  
 
    .equ Ethernet_DMA_DMACIER, Ethernet_DMA_BASE + 0x134 @ (Channel interrupt enable  register) 
        .equ Ethernet_DMA_DMACIER_TIE, 1 << 0   @ bitWidth 1 (Transmit Interrupt Enable)  
        .equ Ethernet_DMA_DMACIER_TXSE, 1 << 1   @ bitWidth 1 (Transmit Stopped Enable)  
        .equ Ethernet_DMA_DMACIER_TBUE, 1 << 2   @ bitWidth 1 (Transmit Buffer Unavailable  Enable)  
        .equ Ethernet_DMA_DMACIER_RIE, 1 << 6   @ bitWidth 1 (Receive Interrupt Enable)  
        .equ Ethernet_DMA_DMACIER_RBUE, 1 << 7   @ bitWidth 1 (Receive Buffer Unavailable  Enable)  
        .equ Ethernet_DMA_DMACIER_RSE, 1 << 8   @ bitWidth 1 (Receive Stopped Enable)  
        .equ Ethernet_DMA_DMACIER_RWTE, 1 << 9   @ bitWidth 1 (Receive Watchdog Timeout  Enable)  
        .equ Ethernet_DMA_DMACIER_ETIE, 1 << 10   @ bitWidth 1 (Early Transmit Interrupt  Enable)  
        .equ Ethernet_DMA_DMACIER_ERIE, 1 << 11   @ bitWidth 1 (Early Receive Interrupt  Enable)  
        .equ Ethernet_DMA_DMACIER_FBEE, 1 << 12   @ bitWidth 1 (Fatal Bus Error Enable)  
        .equ Ethernet_DMA_DMACIER_CDEE, 1 << 13   @ bitWidth 1 (Context Descriptor Error  Enable)  
        .equ Ethernet_DMA_DMACIER_AIE, 1 << 14   @ bitWidth 1 (Abnormal Interrupt Summary  Enable)  
        .equ Ethernet_DMA_DMACIER_NIE, 1 << 15   @ bitWidth 1 (Normal Interrupt Summary  Enable)  
 
    .equ Ethernet_DMA_DMACRxIWTR, Ethernet_DMA_BASE + 0x138 @ (Channel Rx interrupt watchdog timer  register) 
        .equ Ethernet_DMA_DMACRxIWTR_RWT_Shift, 0   @ bitWidth 8 (Receive Interrupt Watchdog Timer  Count)  
 
    .equ Ethernet_DMA_DMACCATxDR, Ethernet_DMA_BASE + 0x144 @ (Channel current application transmit  descriptor register) 
        .equ Ethernet_DMA_DMACCATxDR_CURTDESAPTR_Shift, 0   @ bitWidth 32 (Application Transmit Descriptor Address  Pointer)  
 
    .equ Ethernet_DMA_DMACCARxDR, Ethernet_DMA_BASE + 0x14C @ (Channel current application receive  descriptor register) 
        .equ Ethernet_DMA_DMACCARxDR_CURRDESAPTR_Shift, 0   @ bitWidth 32 (Application Receive Descriptor Address  Pointer)  
 
    .equ Ethernet_DMA_DMACCATxBR, Ethernet_DMA_BASE + 0x154 @ (Channel current application transmit buffer  register) 
        .equ Ethernet_DMA_DMACCATxBR_CURTBUFAPTR_Shift, 0   @ bitWidth 32 (Application Transmit Buffer Address  Pointer)  
 
    .equ Ethernet_DMA_DMACCARxBR, Ethernet_DMA_BASE + 0x15C @ (Channel current application receive buffer  register) 
        .equ Ethernet_DMA_DMACCARxBR_CURRBUFAPTR_Shift, 0   @ bitWidth 32 (Application Receive Buffer Address  Pointer)  
 
    .equ Ethernet_DMA_DMACSR, Ethernet_DMA_BASE + 0x160 @ (Channel status register) 
        .equ Ethernet_DMA_DMACSR_TI, 1 << 0   @ bitWidth 1 (Transmit Interrupt)  
        .equ Ethernet_DMA_DMACSR_TPS, 1 << 1   @ bitWidth 1 (Transmit Process Stopped)  
        .equ Ethernet_DMA_DMACSR_TBU, 1 << 2   @ bitWidth 1 (Transmit Buffer  Unavailable)  
        .equ Ethernet_DMA_DMACSR_RI, 1 << 6   @ bitWidth 1 (Receive Interrupt)  
        .equ Ethernet_DMA_DMACSR_RBU, 1 << 7   @ bitWidth 1 (Receive Buffer Unavailable)  
        .equ Ethernet_DMA_DMACSR_RPS, 1 << 8   @ bitWidth 1 (Receive Process Stopped)  
        .equ Ethernet_DMA_DMACSR_RWT, 1 << 9   @ bitWidth 1 (Receive Watchdog Timeout)  
        .equ Ethernet_DMA_DMACSR_ET, 1 << 10   @ bitWidth 1 (Early Transmit Interrupt)  
        .equ Ethernet_DMA_DMACSR_ER, 1 << 11   @ bitWidth 1 (Early Receive Interrupt)  
        .equ Ethernet_DMA_DMACSR_FBE, 1 << 12   @ bitWidth 1 (Fatal Bus Error)  
        .equ Ethernet_DMA_DMACSR_CDE, 1 << 13   @ bitWidth 1 (Context Descriptor Error)  
        .equ Ethernet_DMA_DMACSR_AIS, 1 << 14   @ bitWidth 1 (Abnormal Interrupt Summary)  
        .equ Ethernet_DMA_DMACSR_NIS, 1 << 15   @ bitWidth 1 (Normal Interrupt Summary)  
        .equ Ethernet_DMA_DMACSR_TEB_Shift, 16   @ bitWidth 3 (Tx DMA Error Bits)  
        .equ Ethernet_DMA_DMACSR_REB_Shift, 19   @ bitWidth 3 (Rx DMA Error Bits)  
 
    .equ Ethernet_DMA_DMACMFCR, Ethernet_DMA_BASE + 0x16C @ (Channel missed frame count  register) 
        .equ Ethernet_DMA_DMACMFCR_MFC_Shift, 0   @ bitWidth 11 (Dropped Packet Counters)  
        .equ Ethernet_DMA_DMACMFCR_MFCO, 1 << 15   @ bitWidth 1 (Overflow status of the MFC  Counter)  
 

@=========================== Ethernet_MTL ===========================@
.equ Ethernet_MTL_BASE, 0x40028C00 @ (Ethernet: MTL mode register MTL) 
    .equ Ethernet_MTL_MTLOMR, Ethernet_MTL_BASE + 0x0 @ (Operating mode Register) 
        .equ Ethernet_MTL_MTLOMR_DTXSTS, 1 << 1   @ bitWidth 1 (DTXSTS)  
        .equ Ethernet_MTL_MTLOMR_CNTPRST, 1 << 8   @ bitWidth 1 (CNTPRST)  
        .equ Ethernet_MTL_MTLOMR_CNTCLR, 1 << 9   @ bitWidth 1 (CNTCLR)  
 
    .equ Ethernet_MTL_MTLISR, Ethernet_MTL_BASE + 0x20 @ (Interrupt status Register) 
        .equ Ethernet_MTL_MTLISR_Q0IS, 1 << 0   @ bitWidth 1 (Queue interrupt status)  
 
    .equ Ethernet_MTL_MTLTxQOMR, Ethernet_MTL_BASE + 0x100 @ (Tx queue operating mode  Register) 
        .equ Ethernet_MTL_MTLTxQOMR_FTQ, 1 << 0   @ bitWidth 1 (Flush Transmit Queue)  
        .equ Ethernet_MTL_MTLTxQOMR_TSF, 1 << 1   @ bitWidth 1 (Transmit Store and Forward)  
        .equ Ethernet_MTL_MTLTxQOMR_TXQEN_Shift, 2   @ bitWidth 2 (Transmit Queue Enable)  
        .equ Ethernet_MTL_MTLTxQOMR_TTC_Shift, 4   @ bitWidth 3 (Transmit Threshold Control)  
        .equ Ethernet_MTL_MTLTxQOMR_TQS_Shift, 16   @ bitWidth 3 (Transmit Queue Size)  
 
    .equ Ethernet_MTL_MTLTxQUR, Ethernet_MTL_BASE + 0x104 @ (Tx queue underflow register) 
        .equ Ethernet_MTL_MTLTxQUR_UFFRMCNT_Shift, 0   @ bitWidth 11 (Underflow Packet Counter)  
        .equ Ethernet_MTL_MTLTxQUR_UFCNTOVF, 1 << 11   @ bitWidth 1 (UFCNTOVF)  
 
    .equ Ethernet_MTL_MTLTxQDR, Ethernet_MTL_BASE + 0x108 @ (Tx queue debug Register) 
        .equ Ethernet_MTL_MTLTxQDR_TXQPAUSED, 1 << 0   @ bitWidth 1 (TXQPAUSED)  
        .equ Ethernet_MTL_MTLTxQDR_TRCSTS_Shift, 1   @ bitWidth 2 (TRCSTS)  
        .equ Ethernet_MTL_MTLTxQDR_TWCSTS, 1 << 3   @ bitWidth 1 (TWCSTS)  
        .equ Ethernet_MTL_MTLTxQDR_TXQSTS, 1 << 4   @ bitWidth 1 (TXQSTS)  
        .equ Ethernet_MTL_MTLTxQDR_TXSTSFSTS, 1 << 5   @ bitWidth 1 (TXSTSFSTS)  
        .equ Ethernet_MTL_MTLTxQDR_PTXQ_Shift, 16   @ bitWidth 3 (PTXQ)  
        .equ Ethernet_MTL_MTLTxQDR_STXSTSF_Shift, 20   @ bitWidth 3 (STXSTSF)  
 
    .equ Ethernet_MTL_MTLQICSR, Ethernet_MTL_BASE + 0x12C @ (Queue interrupt control status  Register) 
        .equ Ethernet_MTL_MTLQICSR_TXUNFIS, 1 << 0   @ bitWidth 1 (TXUNFIS)  
        .equ Ethernet_MTL_MTLQICSR_TXUIE, 1 << 8   @ bitWidth 1 (TXUIE)  
        .equ Ethernet_MTL_MTLQICSR_RXOVFIS, 1 << 16   @ bitWidth 1 (RXOVFIS)  
        .equ Ethernet_MTL_MTLQICSR_RXOIE, 1 << 24   @ bitWidth 1 (RXOIE)  
 
    .equ Ethernet_MTL_MTLRxQOMR, Ethernet_MTL_BASE + 0x130 @ (Rx queue operating mode  register) 
        .equ Ethernet_MTL_MTLRxQOMR_RTC_Shift, 0   @ bitWidth 2 (RTC)  
        .equ Ethernet_MTL_MTLRxQOMR_FUP, 1 << 3   @ bitWidth 1 (FUP)  
        .equ Ethernet_MTL_MTLRxQOMR_FEP, 1 << 4   @ bitWidth 1 (FEP)  
        .equ Ethernet_MTL_MTLRxQOMR_RSF, 1 << 5   @ bitWidth 1 (RSF)  
        .equ Ethernet_MTL_MTLRxQOMR_DIS_TCP_EF, 1 << 6   @ bitWidth 1 (DIS_TCP_EF)  
        .equ Ethernet_MTL_MTLRxQOMR_EHFC, 1 << 7   @ bitWidth 1 (EHFC)  
        .equ Ethernet_MTL_MTLRxQOMR_RFA_Shift, 8   @ bitWidth 3 (RFA)  
        .equ Ethernet_MTL_MTLRxQOMR_RFD_Shift, 14   @ bitWidth 3 (RFD)  
        .equ Ethernet_MTL_MTLRxQOMR_RQS_Shift, 20   @ bitWidth 3 (RQS)  
 
    .equ Ethernet_MTL_MTLRxQMPOCR, Ethernet_MTL_BASE + 0x134 @ (Rx queue missed packet and overflow counter  register) 
        .equ Ethernet_MTL_MTLRxQMPOCR_OVFPKTCNT_Shift, 0   @ bitWidth 11 (OVFPKTCNT)  
        .equ Ethernet_MTL_MTLRxQMPOCR_OVFCNTOVF, 1 << 11   @ bitWidth 1 (OVFCNTOVF)  
        .equ Ethernet_MTL_MTLRxQMPOCR_MISPKTCNT_Shift, 16   @ bitWidth 11 (MISPKTCNT)  
        .equ Ethernet_MTL_MTLRxQMPOCR_MISCNTOVF, 1 << 27   @ bitWidth 1 (MISCNTOVF)  
 
    .equ Ethernet_MTL_MTLRxQDR, Ethernet_MTL_BASE + 0x138 @ (Rx queue debug register) 
        .equ Ethernet_MTL_MTLRxQDR_RWCSTS, 1 << 0   @ bitWidth 1 (RWCSTS)  
        .equ Ethernet_MTL_MTLRxQDR_RRCSTS_Shift, 1   @ bitWidth 2 (RRCSTS)  
        .equ Ethernet_MTL_MTLRxQDR_RXQSTS_Shift, 4   @ bitWidth 2 (RXQSTS)  
        .equ Ethernet_MTL_MTLRxQDR_PRXQ_Shift, 16   @ bitWidth 14 (PRXQ)  
 

@=========================== Ethernet_MAC ===========================@
.equ Ethernet_MAC_BASE, 0x40028000 @ (Ethernet: media access control MAC) 
    .equ Ethernet_MAC_MACCR, Ethernet_MAC_BASE + 0x0 @ (Operating mode configuration  register) 
        .equ Ethernet_MAC_MACCR_RE, 1 << 0   @ bitWidth 1 (Receiver Enable)  
        .equ Ethernet_MAC_MACCR_TE, 1 << 1   @ bitWidth 1 (TE)  
        .equ Ethernet_MAC_MACCR_PRELEN_Shift, 2   @ bitWidth 2 (PRELEN)  
        .equ Ethernet_MAC_MACCR_DC, 1 << 4   @ bitWidth 1 (DC)  
        .equ Ethernet_MAC_MACCR_BL_Shift, 5   @ bitWidth 2 (BL)  
        .equ Ethernet_MAC_MACCR_DR, 1 << 8   @ bitWidth 1 (DR)  
        .equ Ethernet_MAC_MACCR_DCRS, 1 << 9   @ bitWidth 1 (DCRS)  
        .equ Ethernet_MAC_MACCR_DO, 1 << 10   @ bitWidth 1 (DO)  
        .equ Ethernet_MAC_MACCR_ECRSFD, 1 << 11   @ bitWidth 1 (ECRSFD)  
        .equ Ethernet_MAC_MACCR_LM, 1 << 12   @ bitWidth 1 (LM)  
        .equ Ethernet_MAC_MACCR_DM, 1 << 13   @ bitWidth 1 (DM)  
        .equ Ethernet_MAC_MACCR_FES, 1 << 14   @ bitWidth 1 (FES)  
        .equ Ethernet_MAC_MACCR_JE, 1 << 16   @ bitWidth 1 (JE)  
        .equ Ethernet_MAC_MACCR_JD, 1 << 17   @ bitWidth 1 (JD)  
        .equ Ethernet_MAC_MACCR_WD, 1 << 19   @ bitWidth 1 (WD)  
        .equ Ethernet_MAC_MACCR_ACS, 1 << 20   @ bitWidth 1 (ACS)  
        .equ Ethernet_MAC_MACCR_CST, 1 << 21   @ bitWidth 1 (CST)  
        .equ Ethernet_MAC_MACCR_S2KP, 1 << 22   @ bitWidth 1 (S2KP)  
        .equ Ethernet_MAC_MACCR_GPSLCE, 1 << 23   @ bitWidth 1 (GPSLCE)  
        .equ Ethernet_MAC_MACCR_IPG_Shift, 24   @ bitWidth 3 (IPG)  
        .equ Ethernet_MAC_MACCR_IPC, 1 << 27   @ bitWidth 1 (IPC)  
        .equ Ethernet_MAC_MACCR_SARC_Shift, 28   @ bitWidth 3 (SARC)  
        .equ Ethernet_MAC_MACCR_ARPEN, 1 << 31   @ bitWidth 1 (ARPEN)  
 
    .equ Ethernet_MAC_MACECR, Ethernet_MAC_BASE + 0x4 @ (Extended operating mode configuration  register) 
        .equ Ethernet_MAC_MACECR_GPSL_Shift, 0   @ bitWidth 14 (GPSL)  
        .equ Ethernet_MAC_MACECR_DCRCC, 1 << 16   @ bitWidth 1 (DCRCC)  
        .equ Ethernet_MAC_MACECR_SPEN, 1 << 17   @ bitWidth 1 (SPEN)  
        .equ Ethernet_MAC_MACECR_USP, 1 << 18   @ bitWidth 1 (USP)  
        .equ Ethernet_MAC_MACECR_EIPGEN, 1 << 24   @ bitWidth 1 (EIPGEN)  
        .equ Ethernet_MAC_MACECR_EIPG_Shift, 25   @ bitWidth 5 (EIPG)  
 
    .equ Ethernet_MAC_MACPFR, Ethernet_MAC_BASE + 0x8 @ (Packet filtering control  register) 
        .equ Ethernet_MAC_MACPFR_PR, 1 << 0   @ bitWidth 1 (PR)  
        .equ Ethernet_MAC_MACPFR_HUC, 1 << 1   @ bitWidth 1 (HUC)  
        .equ Ethernet_MAC_MACPFR_HMC, 1 << 2   @ bitWidth 1 (HMC)  
        .equ Ethernet_MAC_MACPFR_DAIF, 1 << 3   @ bitWidth 1 (DAIF)  
        .equ Ethernet_MAC_MACPFR_PM, 1 << 4   @ bitWidth 1 (PM)  
        .equ Ethernet_MAC_MACPFR_DBF, 1 << 5   @ bitWidth 1 (DBF)  
        .equ Ethernet_MAC_MACPFR_PCF_Shift, 6   @ bitWidth 2 (PCF)  
        .equ Ethernet_MAC_MACPFR_SAIF, 1 << 8   @ bitWidth 1 (SAIF)  
        .equ Ethernet_MAC_MACPFR_SAF, 1 << 9   @ bitWidth 1 (SAF)  
        .equ Ethernet_MAC_MACPFR_HPF, 1 << 10   @ bitWidth 1 (HPF)  
        .equ Ethernet_MAC_MACPFR_VTFE, 1 << 16   @ bitWidth 1 (VTFE)  
        .equ Ethernet_MAC_MACPFR_IPFE, 1 << 20   @ bitWidth 1 (IPFE)  
        .equ Ethernet_MAC_MACPFR_DNTU, 1 << 21   @ bitWidth 1 (DNTU)  
        .equ Ethernet_MAC_MACPFR_RA, 1 << 31   @ bitWidth 1 (RA)  
 
    .equ Ethernet_MAC_MACWTR, Ethernet_MAC_BASE + 0xC @ (Watchdog timeout register) 
        .equ Ethernet_MAC_MACWTR_WTO_Shift, 0   @ bitWidth 4 (WTO)  
        .equ Ethernet_MAC_MACWTR_PWE, 1 << 8   @ bitWidth 1 (PWE)  
 
    .equ Ethernet_MAC_MACHT0R, Ethernet_MAC_BASE + 0x10 @ (Hash Table 0 register) 
        .equ Ethernet_MAC_MACHT0R_HT31T0_Shift, 0   @ bitWidth 32 (HT31T0)  
 
    .equ Ethernet_MAC_MACHT1R, Ethernet_MAC_BASE + 0x14 @ (Hash Table 1 register) 
        .equ Ethernet_MAC_MACHT1R_HT63T32_Shift, 0   @ bitWidth 32 (HT63T32)  
 
    .equ Ethernet_MAC_MACVTR, Ethernet_MAC_BASE + 0x50 @ (VLAN tag register) 
        .equ Ethernet_MAC_MACVTR_VL_Shift, 0   @ bitWidth 16 (VL)  
        .equ Ethernet_MAC_MACVTR_ETV, 1 << 16   @ bitWidth 1 (ETV)  
        .equ Ethernet_MAC_MACVTR_VTIM, 1 << 17   @ bitWidth 1 (VTIM)  
        .equ Ethernet_MAC_MACVTR_ESVL, 1 << 18   @ bitWidth 1 (ESVL)  
        .equ Ethernet_MAC_MACVTR_ERSVLM, 1 << 19   @ bitWidth 1 (ERSVLM)  
        .equ Ethernet_MAC_MACVTR_DOVLTC, 1 << 20   @ bitWidth 1 (DOVLTC)  
        .equ Ethernet_MAC_MACVTR_EVLS_Shift, 21   @ bitWidth 2 (EVLS)  
        .equ Ethernet_MAC_MACVTR_EVLRXS, 1 << 24   @ bitWidth 1 (EVLRXS)  
        .equ Ethernet_MAC_MACVTR_VTHM, 1 << 25   @ bitWidth 1 (VTHM)  
        .equ Ethernet_MAC_MACVTR_EDVLP, 1 << 26   @ bitWidth 1 (EDVLP)  
        .equ Ethernet_MAC_MACVTR_ERIVLT, 1 << 27   @ bitWidth 1 (ERIVLT)  
        .equ Ethernet_MAC_MACVTR_EIVLS_Shift, 28   @ bitWidth 2 (EIVLS)  
        .equ Ethernet_MAC_MACVTR_EIVLRXS, 1 << 31   @ bitWidth 1 (EIVLRXS)  
 
    .equ Ethernet_MAC_MACVHTR, Ethernet_MAC_BASE + 0x58 @ (VLAN Hash table register) 
        .equ Ethernet_MAC_MACVHTR_VLHT_Shift, 0   @ bitWidth 16 (VLHT)  
 
    .equ Ethernet_MAC_MACVIR, Ethernet_MAC_BASE + 0x60 @ (VLAN inclusion register) 
        .equ Ethernet_MAC_MACVIR_VLT_Shift, 0   @ bitWidth 16 (VLT)  
        .equ Ethernet_MAC_MACVIR_VLC_Shift, 16   @ bitWidth 2 (VLC)  
        .equ Ethernet_MAC_MACVIR_VLP, 1 << 18   @ bitWidth 1 (VLP)  
        .equ Ethernet_MAC_MACVIR_CSVL, 1 << 19   @ bitWidth 1 (CSVL)  
        .equ Ethernet_MAC_MACVIR_VLTI, 1 << 20   @ bitWidth 1 (VLTI)  
 
    .equ Ethernet_MAC_MACIVIR, Ethernet_MAC_BASE + 0x64 @ (Inner VLAN inclusion register) 
        .equ Ethernet_MAC_MACIVIR_VLT_Shift, 0   @ bitWidth 16 (VLT)  
        .equ Ethernet_MAC_MACIVIR_VLC_Shift, 16   @ bitWidth 2 (VLC)  
        .equ Ethernet_MAC_MACIVIR_VLP, 1 << 18   @ bitWidth 1 (VLP)  
        .equ Ethernet_MAC_MACIVIR_CSVL, 1 << 19   @ bitWidth 1 (CSVL)  
        .equ Ethernet_MAC_MACIVIR_VLTI, 1 << 20   @ bitWidth 1 (VLTI)  
 
    .equ Ethernet_MAC_MACQTxFCR, Ethernet_MAC_BASE + 0x70 @ (Tx Queue flow control register) 
        .equ Ethernet_MAC_MACQTxFCR_FCB_BPA, 1 << 0   @ bitWidth 1 (FCB_BPA)  
        .equ Ethernet_MAC_MACQTxFCR_TFE, 1 << 1   @ bitWidth 1 (TFE)  
        .equ Ethernet_MAC_MACQTxFCR_PLT_Shift, 4   @ bitWidth 3 (PLT)  
        .equ Ethernet_MAC_MACQTxFCR_DZPQ, 1 << 7   @ bitWidth 1 (DZPQ)  
        .equ Ethernet_MAC_MACQTxFCR_PT_Shift, 16   @ bitWidth 16 (PT)  
 
    .equ Ethernet_MAC_MACRxFCR, Ethernet_MAC_BASE + 0x90 @ (Rx flow control register) 
        .equ Ethernet_MAC_MACRxFCR_RFE, 1 << 0   @ bitWidth 1 (RFE)  
        .equ Ethernet_MAC_MACRxFCR_UP, 1 << 1   @ bitWidth 1 (UP)  
 
    .equ Ethernet_MAC_MACISR, Ethernet_MAC_BASE + 0xB0 @ (Interrupt status register) 
        .equ Ethernet_MAC_MACISR_PHYIS, 1 << 3   @ bitWidth 1 (PHYIS)  
        .equ Ethernet_MAC_MACISR_PMTIS, 1 << 4   @ bitWidth 1 (PMTIS)  
        .equ Ethernet_MAC_MACISR_LPIIS, 1 << 5   @ bitWidth 1 (LPIIS)  
        .equ Ethernet_MAC_MACISR_MMCIS, 1 << 8   @ bitWidth 1 (MMCIS)  
        .equ Ethernet_MAC_MACISR_MMCRXIS, 1 << 9   @ bitWidth 1 (MMCRXIS)  
        .equ Ethernet_MAC_MACISR_MMCTXIS, 1 << 10   @ bitWidth 1 (MMCTXIS)  
        .equ Ethernet_MAC_MACISR_TSIS, 1 << 12   @ bitWidth 1 (TSIS)  
        .equ Ethernet_MAC_MACISR_TXSTSIS, 1 << 13   @ bitWidth 1 (TXSTSIS)  
        .equ Ethernet_MAC_MACISR_RXSTSIS, 1 << 14   @ bitWidth 1 (RXSTSIS)  
 
    .equ Ethernet_MAC_MACIER, Ethernet_MAC_BASE + 0xB4 @ (Interrupt enable register) 
        .equ Ethernet_MAC_MACIER_PHYIE, 1 << 3   @ bitWidth 1 (PHYIE)  
        .equ Ethernet_MAC_MACIER_PMTIE, 1 << 4   @ bitWidth 1 (PMTIE)  
        .equ Ethernet_MAC_MACIER_LPIIE, 1 << 5   @ bitWidth 1 (LPIIE)  
        .equ Ethernet_MAC_MACIER_TSIE, 1 << 12   @ bitWidth 1 (TSIE)  
        .equ Ethernet_MAC_MACIER_TXSTSIE, 1 << 13   @ bitWidth 1 (TXSTSIE)  
        .equ Ethernet_MAC_MACIER_RXSTSIE, 1 << 14   @ bitWidth 1 (RXSTSIE)  
 
    .equ Ethernet_MAC_MACRxTxSR, Ethernet_MAC_BASE + 0xB8 @ (Rx Tx status register) 
        .equ Ethernet_MAC_MACRxTxSR_TJT, 1 << 0   @ bitWidth 1 (TJT)  
        .equ Ethernet_MAC_MACRxTxSR_NCARR, 1 << 1   @ bitWidth 1 (NCARR)  
        .equ Ethernet_MAC_MACRxTxSR_LCARR, 1 << 2   @ bitWidth 1 (LCARR)  
        .equ Ethernet_MAC_MACRxTxSR_EXDEF, 1 << 3   @ bitWidth 1 (EXDEF)  
        .equ Ethernet_MAC_MACRxTxSR_LCOL, 1 << 4   @ bitWidth 1 (LCOL)  
        .equ Ethernet_MAC_MACRxTxSR_EXCOL, 1 << 5   @ bitWidth 1 (LCOL)  
        .equ Ethernet_MAC_MACRxTxSR_RWT, 1 << 8   @ bitWidth 1 (RWT)  
 
    .equ Ethernet_MAC_MACPCSR, Ethernet_MAC_BASE + 0xC0 @ (PMT control status register) 
        .equ Ethernet_MAC_MACPCSR_PWRDWN, 1 << 0   @ bitWidth 1 (PWRDWN)  
        .equ Ethernet_MAC_MACPCSR_MGKPKTEN, 1 << 1   @ bitWidth 1 (MGKPKTEN)  
        .equ Ethernet_MAC_MACPCSR_RWKPKTEN, 1 << 2   @ bitWidth 1 (RWKPKTEN)  
        .equ Ethernet_MAC_MACPCSR_MGKPRCVD, 1 << 5   @ bitWidth 1 (MGKPRCVD)  
        .equ Ethernet_MAC_MACPCSR_RWKPRCVD, 1 << 6   @ bitWidth 1 (RWKPRCVD)  
        .equ Ethernet_MAC_MACPCSR_GLBLUCAST, 1 << 9   @ bitWidth 1 (GLBLUCAST)  
        .equ Ethernet_MAC_MACPCSR_RWKPFE, 1 << 10   @ bitWidth 1 (RWKPFE)  
        .equ Ethernet_MAC_MACPCSR_RWKPTR_Shift, 24   @ bitWidth 5 (RWKPTR)  
        .equ Ethernet_MAC_MACPCSR_RWKFILTRST, 1 << 31   @ bitWidth 1 (RWKFILTRST)  
 
    .equ Ethernet_MAC_MACRWKPFR, Ethernet_MAC_BASE + 0xC4 @ (Remove wakeup packet filter  register) 
        .equ Ethernet_MAC_MACRWKPFR_MACRWKPFR_Shift, 0   @ bitWidth 32 (MACRWKPFR)  
 
    .equ Ethernet_MAC_MACLCSR, Ethernet_MAC_BASE + 0xD0 @ (LPI control status register) 
        .equ Ethernet_MAC_MACLCSR_TLPIEN, 1 << 0   @ bitWidth 1 (TLPIEN)  
        .equ Ethernet_MAC_MACLCSR_TLPIEX, 1 << 1   @ bitWidth 1 (TLPIEX)  
        .equ Ethernet_MAC_MACLCSR_RLPIEN, 1 << 2   @ bitWidth 1 (RLPIEN)  
        .equ Ethernet_MAC_MACLCSR_RLPIEX, 1 << 3   @ bitWidth 1 (RLPIEX)  
        .equ Ethernet_MAC_MACLCSR_TLPIST, 1 << 8   @ bitWidth 1 (TLPIST)  
        .equ Ethernet_MAC_MACLCSR_RLPIST, 1 << 9   @ bitWidth 1 (RLPIST)  
        .equ Ethernet_MAC_MACLCSR_LPIEN, 1 << 16   @ bitWidth 1 (LPIEN)  
        .equ Ethernet_MAC_MACLCSR_PLS, 1 << 17   @ bitWidth 1 (PLS)  
        .equ Ethernet_MAC_MACLCSR_PLSEN, 1 << 18   @ bitWidth 1 (PLSEN)  
        .equ Ethernet_MAC_MACLCSR_LPITXA, 1 << 19   @ bitWidth 1 (LPITXA)  
        .equ Ethernet_MAC_MACLCSR_LPITE, 1 << 20   @ bitWidth 1 (LPITE)  
 
    .equ Ethernet_MAC_MACLTCR, Ethernet_MAC_BASE + 0xD4 @ (LPI timers control register) 
        .equ Ethernet_MAC_MACLTCR_TWT_Shift, 0   @ bitWidth 16 (TWT)  
        .equ Ethernet_MAC_MACLTCR_LST_Shift, 16   @ bitWidth 10 (LST)  
 
    .equ Ethernet_MAC_MACLETR, Ethernet_MAC_BASE + 0xD8 @ (LPI entry timer register) 
        .equ Ethernet_MAC_MACLETR_LPIET_Shift, 0   @ bitWidth 17 (LPIET)  
 
    .equ Ethernet_MAC_MAC1USTCR, Ethernet_MAC_BASE + 0xDC @ (1-microsecond-tick counter  register) 
        .equ Ethernet_MAC_MAC1USTCR_TIC_1US_CNTR_Shift, 0   @ bitWidth 12 (TIC_1US_CNTR)  
 
    .equ Ethernet_MAC_MACVR, Ethernet_MAC_BASE + 0x110 @ (Version register) 
        .equ Ethernet_MAC_MACVR_SNPSVER_Shift, 0   @ bitWidth 8 (SNPSVER)  
        .equ Ethernet_MAC_MACVR_USERVER_Shift, 8   @ bitWidth 8 (USERVER)  
 
    .equ Ethernet_MAC_MACDR, Ethernet_MAC_BASE + 0x114 @ (Debug register) 
        .equ Ethernet_MAC_MACDR_RPESTS, 1 << 0   @ bitWidth 1 (RPESTS)  
        .equ Ethernet_MAC_MACDR_RFCFCSTS_Shift, 1   @ bitWidth 2 (RFCFCSTS)  
        .equ Ethernet_MAC_MACDR_TPESTS, 1 << 16   @ bitWidth 1 (TPESTS)  
        .equ Ethernet_MAC_MACDR_TFCSTS_Shift, 17   @ bitWidth 2 (TFCSTS)  
 
    .equ Ethernet_MAC_MACHWF1R, Ethernet_MAC_BASE + 0x120 @ (HW feature 1 register) 
        .equ Ethernet_MAC_MACHWF1R_RXFIFOSIZE_Shift, 0   @ bitWidth 5 (RXFIFOSIZE)  
        .equ Ethernet_MAC_MACHWF1R_TXFIFOSIZE_Shift, 6   @ bitWidth 5 (TXFIFOSIZE)  
        .equ Ethernet_MAC_MACHWF1R_OSTEN, 1 << 11   @ bitWidth 1 (OSTEN)  
        .equ Ethernet_MAC_MACHWF1R_PTOEN, 1 << 12   @ bitWidth 1 (PTOEN)  
        .equ Ethernet_MAC_MACHWF1R_ADVTHWORD, 1 << 13   @ bitWidth 1 (ADVTHWORD)  
        .equ Ethernet_MAC_MACHWF1R_ADDR64_Shift, 14   @ bitWidth 2 (ADDR64)  
        .equ Ethernet_MAC_MACHWF1R_DCBEN, 1 << 16   @ bitWidth 1 (DCBEN)  
        .equ Ethernet_MAC_MACHWF1R_SPHEN, 1 << 17   @ bitWidth 1 (SPHEN)  
        .equ Ethernet_MAC_MACHWF1R_TSOEN, 1 << 18   @ bitWidth 1 (TSOEN)  
        .equ Ethernet_MAC_MACHWF1R_DBGMEMA, 1 << 19   @ bitWidth 1 (DBGMEMA)  
        .equ Ethernet_MAC_MACHWF1R_AVSEL, 1 << 20   @ bitWidth 1 (AVSEL)  
        .equ Ethernet_MAC_MACHWF1R_HASHTBLSZ_Shift, 24   @ bitWidth 2 (HASHTBLSZ)  
        .equ Ethernet_MAC_MACHWF1R_L3L4FNUM_Shift, 27   @ bitWidth 4 (L3L4FNUM)  
 
    .equ Ethernet_MAC_MACHWF2R, Ethernet_MAC_BASE + 0x124 @ (HW feature 2 register) 
        .equ Ethernet_MAC_MACHWF2R_RXQCNT_Shift, 0   @ bitWidth 4 (RXQCNT)  
        .equ Ethernet_MAC_MACHWF2R_TXQCNT_Shift, 6   @ bitWidth 4 (TXQCNT)  
        .equ Ethernet_MAC_MACHWF2R_RXCHCNT_Shift, 12   @ bitWidth 4 (RXCHCNT)  
        .equ Ethernet_MAC_MACHWF2R_TXCHCNT_Shift, 18   @ bitWidth 4 (TXCHCNT)  
        .equ Ethernet_MAC_MACHWF2R_PPSOUTNUM_Shift, 24   @ bitWidth 3 (PPSOUTNUM)  
        .equ Ethernet_MAC_MACHWF2R_AUXSNAPNUM_Shift, 28   @ bitWidth 3 (AUXSNAPNUM)  
 
    .equ Ethernet_MAC_MACMDIOAR, Ethernet_MAC_BASE + 0x200 @ (MDIO address register) 
        .equ Ethernet_MAC_MACMDIOAR_MB, 1 << 0   @ bitWidth 1 (MB)  
        .equ Ethernet_MAC_MACMDIOAR_C45E, 1 << 1   @ bitWidth 1 (C45E)  
        .equ Ethernet_MAC_MACMDIOAR_GOC_Shift, 2   @ bitWidth 2 (GOC)  
        .equ Ethernet_MAC_MACMDIOAR_SKAP, 1 << 4   @ bitWidth 1 (SKAP)  
        .equ Ethernet_MAC_MACMDIOAR_CR_Shift, 8   @ bitWidth 4 (CR)  
        .equ Ethernet_MAC_MACMDIOAR_NTC_Shift, 12   @ bitWidth 3 (NTC)  
        .equ Ethernet_MAC_MACMDIOAR_RDA_Shift, 16   @ bitWidth 5 (RDA)  
        .equ Ethernet_MAC_MACMDIOAR_PA_Shift, 21   @ bitWidth 5 (PA)  
        .equ Ethernet_MAC_MACMDIOAR_BTB, 1 << 26   @ bitWidth 1 (BTB)  
        .equ Ethernet_MAC_MACMDIOAR_PSE, 1 << 27   @ bitWidth 1 (PSE)  
 
    .equ Ethernet_MAC_MACMDIODR, Ethernet_MAC_BASE + 0x204 @ (MDIO data register) 
        .equ Ethernet_MAC_MACMDIODR_MD_Shift, 0   @ bitWidth 16 (MD)  
        .equ Ethernet_MAC_MACMDIODR_RA_Shift, 16   @ bitWidth 16 (RA)  
 
    .equ Ethernet_MAC_MACARPAR, Ethernet_MAC_BASE + 0xAE0 @ (ARP address register) 
        .equ Ethernet_MAC_MACARPAR_ARPPA_Shift, 0   @ bitWidth 32 (ARPPA)  
 
    .equ Ethernet_MAC_MACA0HR, Ethernet_MAC_BASE + 0x300 @ (Address 0 high register) 
        .equ Ethernet_MAC_MACA0HR_ADDRHI_Shift, 0   @ bitWidth 16 (ADDRHI)  
        .equ Ethernet_MAC_MACA0HR_AE, 1 << 31   @ bitWidth 1 (AE)  
 
    .equ Ethernet_MAC_MACA0LR, Ethernet_MAC_BASE + 0x304 @ (Address 0 low register) 
        .equ Ethernet_MAC_MACA0LR_ADDRLO_Shift, 0   @ bitWidth 32 (ADDRLO)  
 
    .equ Ethernet_MAC_MACA1LR, Ethernet_MAC_BASE + 0x30C @ (Address 1 low register) 
        .equ Ethernet_MAC_MACA1LR_ADDRLO_Shift, 0   @ bitWidth 32 (ADDRLO)  
 
    .equ Ethernet_MAC_MACA2LR, Ethernet_MAC_BASE + 0x314 @ (Address 2 low register) 
        .equ Ethernet_MAC_MACA2LR_ADDRLO_Shift, 0   @ bitWidth 32 (ADDRLO)  
 
    .equ Ethernet_MAC_MACA1HR, Ethernet_MAC_BASE + 0x308 @ (Address 1 high register) 
        .equ Ethernet_MAC_MACA1HR_ADDRHI_Shift, 0   @ bitWidth 16 (ADDRHI)  
        .equ Ethernet_MAC_MACA1HR_MBC_Shift, 24   @ bitWidth 6 (MBC)  
        .equ Ethernet_MAC_MACA1HR_SA, 1 << 30   @ bitWidth 1 (SA)  
        .equ Ethernet_MAC_MACA1HR_AE, 1 << 31   @ bitWidth 1 (AE)  
 
    .equ Ethernet_MAC_MACA2HR, Ethernet_MAC_BASE + 0x310 @ (Address 2 high register) 
        .equ Ethernet_MAC_MACA2HR_ADDRHI_Shift, 0   @ bitWidth 16 (ADDRHI)  
        .equ Ethernet_MAC_MACA2HR_MBC_Shift, 24   @ bitWidth 6 (MBC)  
        .equ Ethernet_MAC_MACA2HR_SA, 1 << 30   @ bitWidth 1 (SA)  
        .equ Ethernet_MAC_MACA2HR_AE, 1 << 31   @ bitWidth 1 (AE)  
 
    .equ Ethernet_MAC_MACA3HR, Ethernet_MAC_BASE + 0x318 @ (Address 3 high register) 
        .equ Ethernet_MAC_MACA3HR_ADDRHI_Shift, 0   @ bitWidth 16 (ADDRHI)  
        .equ Ethernet_MAC_MACA3HR_MBC_Shift, 24   @ bitWidth 6 (MBC)  
        .equ Ethernet_MAC_MACA3HR_SA, 1 << 30   @ bitWidth 1 (SA)  
        .equ Ethernet_MAC_MACA3HR_AE, 1 << 31   @ bitWidth 1 (AE)  
 
    .equ Ethernet_MAC_MACA3LR, Ethernet_MAC_BASE + 0x31C @ (Address 3 low register) 
        .equ Ethernet_MAC_MACA3LR_ADDRLO_Shift, 0   @ bitWidth 32 (ADDRLO)  
 
    .equ Ethernet_MAC_MMC_CONTROL, Ethernet_MAC_BASE + 0x700 @ (MMC control register) 
        .equ Ethernet_MAC_MMC_CONTROL_CNTRST, 1 << 0   @ bitWidth 1 (CNTRST)  
        .equ Ethernet_MAC_MMC_CONTROL_CNTSTOPRO, 1 << 1   @ bitWidth 1 (CNTSTOPRO)  
        .equ Ethernet_MAC_MMC_CONTROL_RSTONRD, 1 << 2   @ bitWidth 1 (RSTONRD)  
        .equ Ethernet_MAC_MMC_CONTROL_CNTFREEZ, 1 << 3   @ bitWidth 1 (CNTFREEZ)  
        .equ Ethernet_MAC_MMC_CONTROL_CNTPRST, 1 << 4   @ bitWidth 1 (CNTPRST)  
        .equ Ethernet_MAC_MMC_CONTROL_CNTPRSTLVL, 1 << 5   @ bitWidth 1 (CNTPRSTLVL)  
        .equ Ethernet_MAC_MMC_CONTROL_UCDBC, 1 << 8   @ bitWidth 1 (UCDBC)  
 
    .equ Ethernet_MAC_MMC_RX_INTERRUPT, Ethernet_MAC_BASE + 0x704 @ (MMC Rx interrupt register) 
        .equ Ethernet_MAC_MMC_RX_INTERRUPT_RXCRCERPIS, 1 << 5   @ bitWidth 1 (RXCRCERPIS)  
        .equ Ethernet_MAC_MMC_RX_INTERRUPT_RXALGNERPIS, 1 << 6   @ bitWidth 1 (RXALGNERPIS)  
        .equ Ethernet_MAC_MMC_RX_INTERRUPT_RXUCGPIS, 1 << 17   @ bitWidth 1 (RXUCGPIS)  
        .equ Ethernet_MAC_MMC_RX_INTERRUPT_RXLPIUSCIS, 1 << 26   @ bitWidth 1 (RXLPIUSCIS)  
        .equ Ethernet_MAC_MMC_RX_INTERRUPT_RXLPITRCIS, 1 << 27   @ bitWidth 1 (RXLPITRCIS)  
 
    .equ Ethernet_MAC_MMC_TX_INTERRUPT, Ethernet_MAC_BASE + 0x708 @ (MMC Tx interrupt register) 
        .equ Ethernet_MAC_MMC_TX_INTERRUPT_TXSCOLGPIS, 1 << 14   @ bitWidth 1 (TXSCOLGPIS)  
        .equ Ethernet_MAC_MMC_TX_INTERRUPT_TXMCOLGPIS, 1 << 15   @ bitWidth 1 (TXMCOLGPIS)  
        .equ Ethernet_MAC_MMC_TX_INTERRUPT_TXGPKTIS, 1 << 21   @ bitWidth 1 (TXGPKTIS)  
        .equ Ethernet_MAC_MMC_TX_INTERRUPT_TXLPIUSCIS, 1 << 26   @ bitWidth 1 (TXLPIUSCIS)  
        .equ Ethernet_MAC_MMC_TX_INTERRUPT_TXLPITRCIS, 1 << 27   @ bitWidth 1 (TXLPITRCIS)  
 
    .equ Ethernet_MAC_MMC_RX_INTERRUPT_MASK, Ethernet_MAC_BASE + 0x70C @ (MMC Rx interrupt mask register) 
        .equ Ethernet_MAC_MMC_RX_INTERRUPT_MASK_RXCRCERPIM, 1 << 5   @ bitWidth 1 (RXCRCERPIM)  
        .equ Ethernet_MAC_MMC_RX_INTERRUPT_MASK_RXALGNERPIM, 1 << 6   @ bitWidth 1 (RXALGNERPIM)  
        .equ Ethernet_MAC_MMC_RX_INTERRUPT_MASK_RXUCGPIM, 1 << 17   @ bitWidth 1 (RXUCGPIM)  
        .equ Ethernet_MAC_MMC_RX_INTERRUPT_MASK_RXLPIUSCIM, 1 << 26   @ bitWidth 1 (RXLPIUSCIM)  
        .equ Ethernet_MAC_MMC_RX_INTERRUPT_MASK_RXLPITRCIM, 1 << 27   @ bitWidth 1 (RXLPITRCIM)  
 
    .equ Ethernet_MAC_MMC_TX_INTERRUPT_MASK, Ethernet_MAC_BASE + 0x710 @ (MMC Tx interrupt mask register) 
        .equ Ethernet_MAC_MMC_TX_INTERRUPT_MASK_TXSCOLGPIM, 1 << 14   @ bitWidth 1 (TXSCOLGPIM)  
        .equ Ethernet_MAC_MMC_TX_INTERRUPT_MASK_TXMCOLGPIM, 1 << 15   @ bitWidth 1 (TXMCOLGPIM)  
        .equ Ethernet_MAC_MMC_TX_INTERRUPT_MASK_TXGPKTIM, 1 << 21   @ bitWidth 1 (TXGPKTIM)  
        .equ Ethernet_MAC_MMC_TX_INTERRUPT_MASK_TXLPIUSCIM, 1 << 26   @ bitWidth 1 (TXLPIUSCIM)  
        .equ Ethernet_MAC_MMC_TX_INTERRUPT_MASK_TXLPITRCIM, 1 << 27   @ bitWidth 1 (TXLPITRCIM)  
 
    .equ Ethernet_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS, Ethernet_MAC_BASE + 0x74C @ (Tx single collision good packets  register) 
        .equ Ethernet_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG_Shift, 0   @ bitWidth 32 (TXSNGLCOLG)  
 
    .equ Ethernet_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS, Ethernet_MAC_BASE + 0x750 @ (Tx multiple collision good packets  register) 
        .equ Ethernet_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG_Shift, 0   @ bitWidth 32 (TXMULTCOLG)  
 
    .equ Ethernet_MAC_TX_PACKET_COUNT_GOOD, Ethernet_MAC_BASE + 0x768 @ (Tx packet count good register) 
        .equ Ethernet_MAC_TX_PACKET_COUNT_GOOD_TXPKTG_Shift, 0   @ bitWidth 32 (TXPKTG)  
 
    .equ Ethernet_MAC_RX_CRC_ERROR_PACKETS, Ethernet_MAC_BASE + 0x794 @ (Rx CRC error packets register) 
        .equ Ethernet_MAC_RX_CRC_ERROR_PACKETS_RXCRCERR_Shift, 0   @ bitWidth 32 (RXCRCERR)  
 
    .equ Ethernet_MAC_RX_ALIGNMENT_ERROR_PACKETS, Ethernet_MAC_BASE + 0x798 @ (Rx alignment error packets  register) 
        .equ Ethernet_MAC_RX_ALIGNMENT_ERROR_PACKETS_RXALGNERR_Shift, 0   @ bitWidth 32 (RXALGNERR)  
 
    .equ Ethernet_MAC_RX_UNICAST_PACKETS_GOOD, Ethernet_MAC_BASE + 0x7C4 @ (Rx unicast packets good  register) 
        .equ Ethernet_MAC_RX_UNICAST_PACKETS_GOOD_RXUCASTG_Shift, 0   @ bitWidth 32 (RXUCASTG)  
 
    .equ Ethernet_MAC_TX_LPI_USEC_CNTR, Ethernet_MAC_BASE + 0x7EC @ (Tx LPI microsecond timer  register) 
        .equ Ethernet_MAC_TX_LPI_USEC_CNTR_TXLPIUSC_Shift, 0   @ bitWidth 32 (TXLPIUSC)  
 
    .equ Ethernet_MAC_TX_LPI_TRAN_CNTR, Ethernet_MAC_BASE + 0x7F0 @ (Tx LPI transition counter  register) 
        .equ Ethernet_MAC_TX_LPI_TRAN_CNTR_TXLPITRC_Shift, 0   @ bitWidth 32 (TXLPITRC)  
 
    .equ Ethernet_MAC_RX_LPI_USEC_CNTR, Ethernet_MAC_BASE + 0x7F4 @ (Rx LPI microsecond counter  register) 
        .equ Ethernet_MAC_RX_LPI_USEC_CNTR_RXLPIUSC_Shift, 0   @ bitWidth 32 (RXLPIUSC)  
 
    .equ Ethernet_MAC_RX_LPI_TRAN_CNTR, Ethernet_MAC_BASE + 0x7F8 @ (Rx LPI transition counter  register) 
        .equ Ethernet_MAC_RX_LPI_TRAN_CNTR_RXLPITRC_Shift, 0   @ bitWidth 32 (RXLPITRC)  
 
    .equ Ethernet_MAC_MACL3L4C0R, Ethernet_MAC_BASE + 0x900 @ (L3 and L4 control 0 register) 
        .equ Ethernet_MAC_MACL3L4C0R_L3PEN0, 1 << 0   @ bitWidth 1 (L3PEN0)  
        .equ Ethernet_MAC_MACL3L4C0R_L3SAM0, 1 << 2   @ bitWidth 1 (L3SAM0)  
        .equ Ethernet_MAC_MACL3L4C0R_L3SAIM0, 1 << 3   @ bitWidth 1 (L3SAIM0)  
        .equ Ethernet_MAC_MACL3L4C0R_L3DAM0, 1 << 4   @ bitWidth 1 (L3DAM0)  
        .equ Ethernet_MAC_MACL3L4C0R_L3DAIM0, 1 << 5   @ bitWidth 1 (L3DAIM0)  
        .equ Ethernet_MAC_MACL3L4C0R_L3HSBM0_Shift, 6   @ bitWidth 5 (L3HSBM0)  
        .equ Ethernet_MAC_MACL3L4C0R_L3HDBM0_Shift, 11   @ bitWidth 5 (L3HDBM0)  
        .equ Ethernet_MAC_MACL3L4C0R_L4PEN0, 1 << 16   @ bitWidth 1 (L4PEN0)  
        .equ Ethernet_MAC_MACL3L4C0R_L4SPM0, 1 << 18   @ bitWidth 1 (L4SPM0)  
        .equ Ethernet_MAC_MACL3L4C0R_L4SPIM0, 1 << 19   @ bitWidth 1 (L4SPIM0)  
        .equ Ethernet_MAC_MACL3L4C0R_L4DPM0, 1 << 20   @ bitWidth 1 (L4DPM0)  
        .equ Ethernet_MAC_MACL3L4C0R_L4DPIM0, 1 << 21   @ bitWidth 1 (L4DPIM0)  
 
    .equ Ethernet_MAC_MACL4A0R, Ethernet_MAC_BASE + 0x904 @ (Layer4 address filter 0  register) 
        .equ Ethernet_MAC_MACL4A0R_L4SP0_Shift, 0   @ bitWidth 16 (L4SP0)  
        .equ Ethernet_MAC_MACL4A0R_L4DP0_Shift, 16   @ bitWidth 16 (L4DP0)  
 
    .equ Ethernet_MAC_MACL3A00R, Ethernet_MAC_BASE + 0x910 @ (MACL3A00R) 
        .equ Ethernet_MAC_MACL3A00R_L3A00_Shift, 0   @ bitWidth 32 (L3A00)  
 
    .equ Ethernet_MAC_MACL3A10R, Ethernet_MAC_BASE + 0x914 @ (Layer3 address 1 filter 0  register) 
        .equ Ethernet_MAC_MACL3A10R_L3A10_Shift, 0   @ bitWidth 32 (L3A10)  
 
    .equ Ethernet_MAC_MACL3A20, Ethernet_MAC_BASE + 0x918 @ (Layer3 Address 2 filter 0  register) 
        .equ Ethernet_MAC_MACL3A20_L3A20_Shift, 0   @ bitWidth 32 (L3A20)  
 
    .equ Ethernet_MAC_MACL3A30, Ethernet_MAC_BASE + 0x91C @ (Layer3 Address 3 filter 0  register) 
        .equ Ethernet_MAC_MACL3A30_L3A30_Shift, 0   @ bitWidth 32 (L3A30)  
 
    .equ Ethernet_MAC_MACL3L4C1R, Ethernet_MAC_BASE + 0x930 @ (L3 and L4 control 1 register) 
        .equ Ethernet_MAC_MACL3L4C1R_L3PEN1, 1 << 0   @ bitWidth 1 (L3PEN1)  
        .equ Ethernet_MAC_MACL3L4C1R_L3SAM1, 1 << 2   @ bitWidth 1 (L3SAM1)  
        .equ Ethernet_MAC_MACL3L4C1R_L3SAIM1, 1 << 3   @ bitWidth 1 (L3SAIM1)  
        .equ Ethernet_MAC_MACL3L4C1R_L3DAM1, 1 << 4   @ bitWidth 1 (L3DAM1)  
        .equ Ethernet_MAC_MACL3L4C1R_L3DAIM1, 1 << 5   @ bitWidth 1 (L3DAIM1)  
        .equ Ethernet_MAC_MACL3L4C1R_L3HSBM1_Shift, 6   @ bitWidth 5 (L3HSBM1)  
        .equ Ethernet_MAC_MACL3L4C1R_L3HDBM1_Shift, 11   @ bitWidth 5 (L3HDBM1)  
        .equ Ethernet_MAC_MACL3L4C1R_L4PEN1, 1 << 16   @ bitWidth 1 (L4PEN1)  
        .equ Ethernet_MAC_MACL3L4C1R_L4SPM1, 1 << 18   @ bitWidth 1 (L4SPM1)  
        .equ Ethernet_MAC_MACL3L4C1R_L4SPIM1, 1 << 19   @ bitWidth 1 (L4SPIM1)  
        .equ Ethernet_MAC_MACL3L4C1R_L4DPM1, 1 << 20   @ bitWidth 1 (L4DPM1)  
        .equ Ethernet_MAC_MACL3L4C1R_L4DPIM1, 1 << 21   @ bitWidth 1 (L4DPIM1)  
 
    .equ Ethernet_MAC_MACL4A1R, Ethernet_MAC_BASE + 0x934 @ (Layer 4 address filter 1  register) 
        .equ Ethernet_MAC_MACL4A1R_L4SP1_Shift, 0   @ bitWidth 16 (L4SP1)  
        .equ Ethernet_MAC_MACL4A1R_L4DP1_Shift, 16   @ bitWidth 16 (L4DP1)  
 
    .equ Ethernet_MAC_MACL3A01R, Ethernet_MAC_BASE + 0x940 @ (Layer3 address 0 filter 1  Register) 
        .equ Ethernet_MAC_MACL3A01R_L3A01_Shift, 0   @ bitWidth 32 (L3A01)  
 
    .equ Ethernet_MAC_MACL3A11R, Ethernet_MAC_BASE + 0x944 @ (Layer3 address 1 filter 1  register) 
        .equ Ethernet_MAC_MACL3A11R_L3A11_Shift, 0   @ bitWidth 32 (L3A11)  
 
    .equ Ethernet_MAC_MACL3A21R, Ethernet_MAC_BASE + 0x948 @ (Layer3 address 2 filter 1  Register) 
        .equ Ethernet_MAC_MACL3A21R_L3A21_Shift, 0   @ bitWidth 32 (L3A21)  
 
    .equ Ethernet_MAC_MACL3A31R, Ethernet_MAC_BASE + 0x94C @ (Layer3 address 3 filter 1  register) 
        .equ Ethernet_MAC_MACL3A31R_L3A31_Shift, 0   @ bitWidth 32 (L3A31)  
 
    .equ Ethernet_MAC_MACTSCR, Ethernet_MAC_BASE + 0xB00 @ (Timestamp control Register) 
        .equ Ethernet_MAC_MACTSCR_TSENA, 1 << 0   @ bitWidth 1 (TSENA)  
        .equ Ethernet_MAC_MACTSCR_TSCFUPDT, 1 << 1   @ bitWidth 1 (TSCFUPDT)  
        .equ Ethernet_MAC_MACTSCR_TSINIT, 1 << 2   @ bitWidth 1 (TSINIT)  
        .equ Ethernet_MAC_MACTSCR_TSUPDT, 1 << 3   @ bitWidth 1 (TSUPDT)  
        .equ Ethernet_MAC_MACTSCR_TSADDREG, 1 << 5   @ bitWidth 1 (TSADDREG)  
        .equ Ethernet_MAC_MACTSCR_TSENALL, 1 << 8   @ bitWidth 1 (TSENALL)  
        .equ Ethernet_MAC_MACTSCR_TSCTRLSSR, 1 << 9   @ bitWidth 1 (TSCTRLSSR)  
        .equ Ethernet_MAC_MACTSCR_TSVER2ENA, 1 << 10   @ bitWidth 1 (TSVER2ENA)  
        .equ Ethernet_MAC_MACTSCR_TSIPENA, 1 << 11   @ bitWidth 1 (TSIPENA)  
        .equ Ethernet_MAC_MACTSCR_TSIPV6ENA, 1 << 12   @ bitWidth 1 (TSIPV6ENA)  
        .equ Ethernet_MAC_MACTSCR_TSIPV4ENA, 1 << 13   @ bitWidth 1 (TSIPV4ENA)  
        .equ Ethernet_MAC_MACTSCR_TSEVNTENA, 1 << 14   @ bitWidth 1 (TSEVNTENA)  
        .equ Ethernet_MAC_MACTSCR_TSMSTRENA, 1 << 15   @ bitWidth 1 (TSMSTRENA)  
        .equ Ethernet_MAC_MACTSCR_SNAPTYPSEL_Shift, 16   @ bitWidth 2 (SNAPTYPSEL)  
        .equ Ethernet_MAC_MACTSCR_TSENMACADDR, 1 << 18   @ bitWidth 1 (TSENMACADDR)  
        .equ Ethernet_MAC_MACTSCR_CSC, 1 << 19   @ bitWidth 1 (CSC)  
        .equ Ethernet_MAC_MACTSCR_TXTSSTSM, 1 << 24   @ bitWidth 1 (TXTSSTSM)  
 
    .equ Ethernet_MAC_MACSSIR, Ethernet_MAC_BASE + 0xB04 @ (Sub-second increment register) 
        .equ Ethernet_MAC_MACSSIR_SNSINC_Shift, 8   @ bitWidth 8 (SNSINC)  
        .equ Ethernet_MAC_MACSSIR_SSINC_Shift, 16   @ bitWidth 8 (SSINC)  
 
    .equ Ethernet_MAC_MACSTSR, Ethernet_MAC_BASE + 0xB08 @ (System time seconds register) 
        .equ Ethernet_MAC_MACSTSR_TSS_Shift, 0   @ bitWidth 32 (TSS)  
 
    .equ Ethernet_MAC_MACSTNR, Ethernet_MAC_BASE + 0xB0C @ (System time nanoseconds  register) 
        .equ Ethernet_MAC_MACSTNR_TSSS_Shift, 0   @ bitWidth 31 (TSSS)  
 
    .equ Ethernet_MAC_MACSTSUR, Ethernet_MAC_BASE + 0xB10 @ (System time seconds update  register) 
        .equ Ethernet_MAC_MACSTSUR_TSS_Shift, 0   @ bitWidth 32 (TSS)  
 
    .equ Ethernet_MAC_MACSTNUR, Ethernet_MAC_BASE + 0xB14 @ (System time nanoseconds update  register) 
        .equ Ethernet_MAC_MACSTNUR_TSSS_Shift, 0   @ bitWidth 31 (TSSS)  
        .equ Ethernet_MAC_MACSTNUR_ADDSUB, 1 << 31   @ bitWidth 1 (ADDSUB)  
 
    .equ Ethernet_MAC_MACTSAR, Ethernet_MAC_BASE + 0xB18 @ (Timestamp addend register) 
        .equ Ethernet_MAC_MACTSAR_TSAR_Shift, 0   @ bitWidth 32 (TSAR)  
 
    .equ Ethernet_MAC_MACTSSR, Ethernet_MAC_BASE + 0xB20 @ (Timestamp status register) 
        .equ Ethernet_MAC_MACTSSR_TSSOVF, 1 << 0   @ bitWidth 1 (TSSOVF)  
        .equ Ethernet_MAC_MACTSSR_TSTARGT0, 1 << 1   @ bitWidth 1 (TSTARGT0)  
        .equ Ethernet_MAC_MACTSSR_AUXTSTRIG, 1 << 2   @ bitWidth 1 (AUXTSTRIG)  
        .equ Ethernet_MAC_MACTSSR_TSTRGTERR0, 1 << 3   @ bitWidth 1 (TSTRGTERR0)  
        .equ Ethernet_MAC_MACTSSR_TXTSSIS, 1 << 15   @ bitWidth 1 (TXTSSIS)  
        .equ Ethernet_MAC_MACTSSR_ATSSTN_Shift, 16   @ bitWidth 4 (ATSSTN)  
        .equ Ethernet_MAC_MACTSSR_ATSSTM, 1 << 24   @ bitWidth 1 (ATSSTM)  
        .equ Ethernet_MAC_MACTSSR_ATSNS_Shift, 25   @ bitWidth 5 (ATSNS)  
 
    .equ Ethernet_MAC_MACTxTSSNR, Ethernet_MAC_BASE + 0xB30 @ (Tx timestamp status nanoseconds  register) 
        .equ Ethernet_MAC_MACTxTSSNR_TXTSSLO_Shift, 0   @ bitWidth 31 (TXTSSLO)  
        .equ Ethernet_MAC_MACTxTSSNR_TXTSSMIS, 1 << 31   @ bitWidth 1 (TXTSSMIS)  
 
    .equ Ethernet_MAC_MACTxTSSSR, Ethernet_MAC_BASE + 0xB34 @ (Tx timestamp status seconds  register) 
        .equ Ethernet_MAC_MACTxTSSSR_TXTSSHI_Shift, 0   @ bitWidth 32 (TXTSSHI)  
 
    .equ Ethernet_MAC_MACACR, Ethernet_MAC_BASE + 0xB40 @ (Auxiliary control register) 
        .equ Ethernet_MAC_MACACR_ATSFC, 1 << 0   @ bitWidth 1 (ATSFC)  
        .equ Ethernet_MAC_MACACR_ATSEN0, 1 << 4   @ bitWidth 1 (ATSEN0)  
        .equ Ethernet_MAC_MACACR_ATSEN1, 1 << 5   @ bitWidth 1 (ATSEN1)  
        .equ Ethernet_MAC_MACACR_ATSEN2, 1 << 6   @ bitWidth 1 (ATSEN2)  
        .equ Ethernet_MAC_MACACR_ATSEN3, 1 << 7   @ bitWidth 1 (ATSEN3)  
 
    .equ Ethernet_MAC_MACATSNR, Ethernet_MAC_BASE + 0xB48 @ (Auxiliary timestamp nanoseconds  register) 
        .equ Ethernet_MAC_MACATSNR_AUXTSLO_Shift, 0   @ bitWidth 31 (AUXTSLO)  
 
    .equ Ethernet_MAC_MACATSSR, Ethernet_MAC_BASE + 0xB4C @ (Auxiliary timestamp seconds  register) 
        .equ Ethernet_MAC_MACATSSR_AUXTSHI_Shift, 0   @ bitWidth 32 (AUXTSHI)  
 
    .equ Ethernet_MAC_MACTSIACR, Ethernet_MAC_BASE + 0xB50 @ (Timestamp Ingress asymmetric correction  register) 
        .equ Ethernet_MAC_MACTSIACR_OSTIAC_Shift, 0   @ bitWidth 32 (OSTIAC)  
 
    .equ Ethernet_MAC_MACTSEACR, Ethernet_MAC_BASE + 0xB54 @ (Timestamp Egress asymmetric correction  register) 
        .equ Ethernet_MAC_MACTSEACR_OSTEAC_Shift, 0   @ bitWidth 32 (OSTEAC)  
 
    .equ Ethernet_MAC_MACTSICNR, Ethernet_MAC_BASE + 0xB58 @ (Timestamp Ingress correction nanosecond  register) 
        .equ Ethernet_MAC_MACTSICNR_TSIC_Shift, 0   @ bitWidth 32 (TSIC)  
 
    .equ Ethernet_MAC_MACTSECNR, Ethernet_MAC_BASE + 0xB5C @ (Timestamp Egress correction nanosecond  register) 
        .equ Ethernet_MAC_MACTSECNR_TSEC_Shift, 0   @ bitWidth 32 (TSEC)  
 
    .equ Ethernet_MAC_MACPPSCR, Ethernet_MAC_BASE + 0xB70 @ (PPS control register) 
        .equ Ethernet_MAC_MACPPSCR_PPSCTRL_Shift, 0   @ bitWidth 4 (PPSCTRL)  
        .equ Ethernet_MAC_MACPPSCR_PPSEN0, 1 << 4   @ bitWidth 1 (PPSEN0)  
        .equ Ethernet_MAC_MACPPSCR_TRGTMODSEL0_Shift, 5   @ bitWidth 2 (TRGTMODSEL0)  
 
    .equ Ethernet_MAC_MACPPSTTSR, Ethernet_MAC_BASE + 0xB80 @ (PPS target time seconds  register) 
        .equ Ethernet_MAC_MACPPSTTSR_TSTRH0_Shift, 0   @ bitWidth 31 (TSTRH0)  
 
    .equ Ethernet_MAC_MACPPSTTNR, Ethernet_MAC_BASE + 0xB84 @ (PPS target time nanoseconds  register) 
        .equ Ethernet_MAC_MACPPSTTNR_TTSL0_Shift, 0   @ bitWidth 31 (TTSL0)  
        .equ Ethernet_MAC_MACPPSTTNR_TRGTBUSY0, 1 << 31   @ bitWidth 1 (TRGTBUSY0)  
 
    .equ Ethernet_MAC_MACPPSIR, Ethernet_MAC_BASE + 0xB88 @ (PPS interval register) 
        .equ Ethernet_MAC_MACPPSIR_PPSINT0_Shift, 0   @ bitWidth 32 (PPSINT0)  
 
    .equ Ethernet_MAC_MACPPSWR, Ethernet_MAC_BASE + 0xB8C @ (PPS width register) 
        .equ Ethernet_MAC_MACPPSWR_PPSWIDTH0_Shift, 0   @ bitWidth 32 (PPSWIDTH0)  
 
    .equ Ethernet_MAC_MACPOCR, Ethernet_MAC_BASE + 0xBC0 @ (PTP Offload control register) 
        .equ Ethernet_MAC_MACPOCR_PTOEN, 1 << 0   @ bitWidth 1 (PTOEN)  
        .equ Ethernet_MAC_MACPOCR_ASYNCEN, 1 << 1   @ bitWidth 1 (ASYNCEN)  
        .equ Ethernet_MAC_MACPOCR_APDREQEN, 1 << 2   @ bitWidth 1 (APDREQEN)  
        .equ Ethernet_MAC_MACPOCR_ASYNCTRIG, 1 << 4   @ bitWidth 1 (ASYNCTRIG)  
        .equ Ethernet_MAC_MACPOCR_APDREQTRIG, 1 << 5   @ bitWidth 1 (APDREQTRIG)  
        .equ Ethernet_MAC_MACPOCR_DRRDIS, 1 << 6   @ bitWidth 1 (DRRDIS)  
        .equ Ethernet_MAC_MACPOCR_DN_Shift, 8   @ bitWidth 8 (DN)  
 
    .equ Ethernet_MAC_MACSPI0R, Ethernet_MAC_BASE + 0xBC4 @ (PTP Source Port Identity 0  Register) 
        .equ Ethernet_MAC_MACSPI0R_SPI0_Shift, 0   @ bitWidth 32 (SPI0)  
 
    .equ Ethernet_MAC_MACSPI1R, Ethernet_MAC_BASE + 0xBC8 @ (PTP Source port identity 1  register) 
        .equ Ethernet_MAC_MACSPI1R_SPI1_Shift, 0   @ bitWidth 32 (SPI1)  
 
    .equ Ethernet_MAC_MACSPI2R, Ethernet_MAC_BASE + 0xBCC @ (PTP Source port identity 2  register) 
        .equ Ethernet_MAC_MACSPI2R_SPI2_Shift, 0   @ bitWidth 16 (SPI2)  
 
    .equ Ethernet_MAC_MACLMIR, Ethernet_MAC_BASE + 0xBD0 @ (Log message interval register) 
        .equ Ethernet_MAC_MACLMIR_LSI_Shift, 0   @ bitWidth 8 (LSI)  
        .equ Ethernet_MAC_MACLMIR_DRSYNCR_Shift, 8   @ bitWidth 3 (DRSYNCR)  
        .equ Ethernet_MAC_MACLMIR_LMPDRI_Shift, 24   @ bitWidth 8 (LMPDRI)  
 

@=========================== DMA1 ===========================@
.equ DMA1_BASE, 0x40020000 @ (DMA controller) 
    .equ DMA1_LISR, DMA1_BASE + 0x0 @ (low interrupt status register) 
        .equ DMA1_LISR_TCIF3, 1 << 27   @ bitWidth 1 (Stream x transfer complete interrupt  flag x = 3..0)  
        .equ DMA1_LISR_HTIF3, 1 << 26   @ bitWidth 1 (Stream x half transfer interrupt flag  x=3..0)  
        .equ DMA1_LISR_TEIF3, 1 << 25   @ bitWidth 1 (Stream x transfer error interrupt flag  x=3..0)  
        .equ DMA1_LISR_DMEIF3, 1 << 24   @ bitWidth 1 (Stream x direct mode error interrupt  flag x=3..0)  
        .equ DMA1_LISR_FEIF3, 1 << 22   @ bitWidth 1 (Stream x FIFO error interrupt flag  x=3..0)  
        .equ DMA1_LISR_TCIF2, 1 << 21   @ bitWidth 1 (Stream x transfer complete interrupt  flag x = 3..0)  
        .equ DMA1_LISR_HTIF2, 1 << 20   @ bitWidth 1 (Stream x half transfer interrupt flag  x=3..0)  
        .equ DMA1_LISR_TEIF2, 1 << 19   @ bitWidth 1 (Stream x transfer error interrupt flag  x=3..0)  
        .equ DMA1_LISR_DMEIF2, 1 << 18   @ bitWidth 1 (Stream x direct mode error interrupt  flag x=3..0)  
        .equ DMA1_LISR_FEIF2, 1 << 16   @ bitWidth 1 (Stream x FIFO error interrupt flag  x=3..0)  
        .equ DMA1_LISR_TCIF1, 1 << 11   @ bitWidth 1 (Stream x transfer complete interrupt  flag x = 3..0)  
        .equ DMA1_LISR_HTIF1, 1 << 10   @ bitWidth 1 (Stream x half transfer interrupt flag  x=3..0)  
        .equ DMA1_LISR_TEIF1, 1 << 9   @ bitWidth 1 (Stream x transfer error interrupt flag  x=3..0)  
        .equ DMA1_LISR_DMEIF1, 1 << 8   @ bitWidth 1 (Stream x direct mode error interrupt  flag x=3..0)  
        .equ DMA1_LISR_FEIF1, 1 << 6   @ bitWidth 1 (Stream x FIFO error interrupt flag  x=3..0)  
        .equ DMA1_LISR_TCIF0, 1 << 5   @ bitWidth 1 (Stream x transfer complete interrupt  flag x = 3..0)  
        .equ DMA1_LISR_HTIF0, 1 << 4   @ bitWidth 1 (Stream x half transfer interrupt flag  x=3..0)  
        .equ DMA1_LISR_TEIF0, 1 << 3   @ bitWidth 1 (Stream x transfer error interrupt flag  x=3..0)  
        .equ DMA1_LISR_DMEIF0, 1 << 2   @ bitWidth 1 (Stream x direct mode error interrupt  flag x=3..0)  
        .equ DMA1_LISR_FEIF0, 1 << 0   @ bitWidth 1 (Stream x FIFO error interrupt flag  x=3..0)  
 
    .equ DMA1_HISR, DMA1_BASE + 0x4 @ (high interrupt status register) 
        .equ DMA1_HISR_TCIF7, 1 << 27   @ bitWidth 1 (Stream x transfer complete interrupt  flag x=7..4)  
        .equ DMA1_HISR_HTIF7, 1 << 26   @ bitWidth 1 (Stream x half transfer interrupt flag  x=7..4)  
        .equ DMA1_HISR_TEIF7, 1 << 25   @ bitWidth 1 (Stream x transfer error interrupt flag  x=7..4)  
        .equ DMA1_HISR_DMEIF7, 1 << 24   @ bitWidth 1 (Stream x direct mode error interrupt  flag x=7..4)  
        .equ DMA1_HISR_FEIF7, 1 << 22   @ bitWidth 1 (Stream x FIFO error interrupt flag  x=7..4)  
        .equ DMA1_HISR_TCIF6, 1 << 21   @ bitWidth 1 (Stream x transfer complete interrupt  flag x=7..4)  
        .equ DMA1_HISR_HTIF6, 1 << 20   @ bitWidth 1 (Stream x half transfer interrupt flag  x=7..4)  
        .equ DMA1_HISR_TEIF6, 1 << 19   @ bitWidth 1 (Stream x transfer error interrupt flag  x=7..4)  
        .equ DMA1_HISR_DMEIF6, 1 << 18   @ bitWidth 1 (Stream x direct mode error interrupt  flag x=7..4)  
        .equ DMA1_HISR_FEIF6, 1 << 16   @ bitWidth 1 (Stream x FIFO error interrupt flag  x=7..4)  
        .equ DMA1_HISR_TCIF5, 1 << 11   @ bitWidth 1 (Stream x transfer complete interrupt  flag x=7..4)  
        .equ DMA1_HISR_HTIF5, 1 << 10   @ bitWidth 1 (Stream x half transfer interrupt flag  x=7..4)  
        .equ DMA1_HISR_TEIF5, 1 << 9   @ bitWidth 1 (Stream x transfer error interrupt flag  x=7..4)  
        .equ DMA1_HISR_DMEIF5, 1 << 8   @ bitWidth 1 (Stream x direct mode error interrupt  flag x=7..4)  
        .equ DMA1_HISR_FEIF5, 1 << 6   @ bitWidth 1 (Stream x FIFO error interrupt flag  x=7..4)  
        .equ DMA1_HISR_TCIF4, 1 << 5   @ bitWidth 1 (Stream x transfer complete interrupt  flag x=7..4)  
        .equ DMA1_HISR_HTIF4, 1 << 4   @ bitWidth 1 (Stream x half transfer interrupt flag  x=7..4)  
        .equ DMA1_HISR_TEIF4, 1 << 3   @ bitWidth 1 (Stream x transfer error interrupt flag  x=7..4)  
        .equ DMA1_HISR_DMEIF4, 1 << 2   @ bitWidth 1 (Stream x direct mode error interrupt  flag x=7..4)  
        .equ DMA1_HISR_FEIF4, 1 << 0   @ bitWidth 1 (Stream x FIFO error interrupt flag  x=7..4)  
 
    .equ DMA1_LIFCR, DMA1_BASE + 0x8 @ (low interrupt flag clear  register) 
        .equ DMA1_LIFCR_CTCIF3, 1 << 27   @ bitWidth 1 (Stream x clear transfer complete  interrupt flag x = 3..0)  
        .equ DMA1_LIFCR_CHTIF3, 1 << 26   @ bitWidth 1 (Stream x clear half transfer interrupt  flag x = 3..0)  
        .equ DMA1_LIFCR_CTEIF3, 1 << 25   @ bitWidth 1 (Stream x clear transfer error interrupt  flag x = 3..0)  
        .equ DMA1_LIFCR_CDMEIF3, 1 << 24   @ bitWidth 1 (Stream x clear direct mode error  interrupt flag x = 3..0)  
        .equ DMA1_LIFCR_CFEIF3, 1 << 22   @ bitWidth 1 (Stream x clear FIFO error interrupt flag  x = 3..0)  
        .equ DMA1_LIFCR_CTCIF2, 1 << 21   @ bitWidth 1 (Stream x clear transfer complete  interrupt flag x = 3..0)  
        .equ DMA1_LIFCR_CHTIF2, 1 << 20   @ bitWidth 1 (Stream x clear half transfer interrupt  flag x = 3..0)  
        .equ DMA1_LIFCR_CTEIF2, 1 << 19   @ bitWidth 1 (Stream x clear transfer error interrupt  flag x = 3..0)  
        .equ DMA1_LIFCR_CDMEIF2, 1 << 18   @ bitWidth 1 (Stream x clear direct mode error  interrupt flag x = 3..0)  
        .equ DMA1_LIFCR_CFEIF2, 1 << 16   @ bitWidth 1 (Stream x clear FIFO error interrupt flag  x = 3..0)  
        .equ DMA1_LIFCR_CTCIF1, 1 << 11   @ bitWidth 1 (Stream x clear transfer complete  interrupt flag x = 3..0)  
        .equ DMA1_LIFCR_CHTIF1, 1 << 10   @ bitWidth 1 (Stream x clear half transfer interrupt  flag x = 3..0)  
        .equ DMA1_LIFCR_CTEIF1, 1 << 9   @ bitWidth 1 (Stream x clear transfer error interrupt  flag x = 3..0)  
        .equ DMA1_LIFCR_CDMEIF1, 1 << 8   @ bitWidth 1 (Stream x clear direct mode error  interrupt flag x = 3..0)  
        .equ DMA1_LIFCR_CFEIF1, 1 << 6   @ bitWidth 1 (Stream x clear FIFO error interrupt flag  x = 3..0)  
        .equ DMA1_LIFCR_CTCIF0, 1 << 5   @ bitWidth 1 (Stream x clear transfer complete  interrupt flag x = 3..0)  
        .equ DMA1_LIFCR_CHTIF0, 1 << 4   @ bitWidth 1 (Stream x clear half transfer interrupt  flag x = 3..0)  
        .equ DMA1_LIFCR_CTEIF0, 1 << 3   @ bitWidth 1 (Stream x clear transfer error interrupt  flag x = 3..0)  
        .equ DMA1_LIFCR_CDMEIF0, 1 << 2   @ bitWidth 1 (Stream x clear direct mode error  interrupt flag x = 3..0)  
        .equ DMA1_LIFCR_CFEIF0, 1 << 0   @ bitWidth 1 (Stream x clear FIFO error interrupt flag  x = 3..0)  
 
    .equ DMA1_HIFCR, DMA1_BASE + 0xC @ (high interrupt flag clear  register) 
        .equ DMA1_HIFCR_CTCIF7, 1 << 27   @ bitWidth 1 (Stream x clear transfer complete  interrupt flag x = 7..4)  
        .equ DMA1_HIFCR_CHTIF7, 1 << 26   @ bitWidth 1 (Stream x clear half transfer interrupt  flag x = 7..4)  
        .equ DMA1_HIFCR_CTEIF7, 1 << 25   @ bitWidth 1 (Stream x clear transfer error interrupt  flag x = 7..4)  
        .equ DMA1_HIFCR_CDMEIF7, 1 << 24   @ bitWidth 1 (Stream x clear direct mode error  interrupt flag x = 7..4)  
        .equ DMA1_HIFCR_CFEIF7, 1 << 22   @ bitWidth 1 (Stream x clear FIFO error interrupt flag  x = 7..4)  
        .equ DMA1_HIFCR_CTCIF6, 1 << 21   @ bitWidth 1 (Stream x clear transfer complete  interrupt flag x = 7..4)  
        .equ DMA1_HIFCR_CHTIF6, 1 << 20   @ bitWidth 1 (Stream x clear half transfer interrupt  flag x = 7..4)  
        .equ DMA1_HIFCR_CTEIF6, 1 << 19   @ bitWidth 1 (Stream x clear transfer error interrupt  flag x = 7..4)  
        .equ DMA1_HIFCR_CDMEIF6, 1 << 18   @ bitWidth 1 (Stream x clear direct mode error  interrupt flag x = 7..4)  
        .equ DMA1_HIFCR_CFEIF6, 1 << 16   @ bitWidth 1 (Stream x clear FIFO error interrupt flag  x = 7..4)  
        .equ DMA1_HIFCR_CTCIF5, 1 << 11   @ bitWidth 1 (Stream x clear transfer complete  interrupt flag x = 7..4)  
        .equ DMA1_HIFCR_CHTIF5, 1 << 10   @ bitWidth 1 (Stream x clear half transfer interrupt  flag x = 7..4)  
        .equ DMA1_HIFCR_CTEIF5, 1 << 9   @ bitWidth 1 (Stream x clear transfer error interrupt  flag x = 7..4)  
        .equ DMA1_HIFCR_CDMEIF5, 1 << 8   @ bitWidth 1 (Stream x clear direct mode error  interrupt flag x = 7..4)  
        .equ DMA1_HIFCR_CFEIF5, 1 << 6   @ bitWidth 1 (Stream x clear FIFO error interrupt flag  x = 7..4)  
        .equ DMA1_HIFCR_CTCIF4, 1 << 5   @ bitWidth 1 (Stream x clear transfer complete  interrupt flag x = 7..4)  
        .equ DMA1_HIFCR_CHTIF4, 1 << 4   @ bitWidth 1 (Stream x clear half transfer interrupt  flag x = 7..4)  
        .equ DMA1_HIFCR_CTEIF4, 1 << 3   @ bitWidth 1 (Stream x clear transfer error interrupt  flag x = 7..4)  
        .equ DMA1_HIFCR_CDMEIF4, 1 << 2   @ bitWidth 1 (Stream x clear direct mode error  interrupt flag x = 7..4)  
        .equ DMA1_HIFCR_CFEIF4, 1 << 0   @ bitWidth 1 (Stream x clear FIFO error interrupt flag  x = 7..4)  
 
    .equ DMA1_S0CR, DMA1_BASE + 0x10 @ (stream x configuration  register) 
        .equ DMA1_S0CR_MBURST_Shift, 23   @ bitWidth 2 (Memory burst transfer  configuration)  
        .equ DMA1_S0CR_PBURST_Shift, 21   @ bitWidth 2 (Peripheral burst transfer  configuration)  
        .equ DMA1_S0CR_CT, 1 << 19   @ bitWidth 1 (Current target only in double buffer  mode)  
        .equ DMA1_S0CR_DBM, 1 << 18   @ bitWidth 1 (Double buffer mode)  
        .equ DMA1_S0CR_PL_Shift, 16   @ bitWidth 2 (Priority level)  
        .equ DMA1_S0CR_PINCOS, 1 << 15   @ bitWidth 1 (Peripheral increment offset  size)  
        .equ DMA1_S0CR_MSIZE_Shift, 13   @ bitWidth 2 (Memory data size)  
        .equ DMA1_S0CR_PSIZE_Shift, 11   @ bitWidth 2 (Peripheral data size)  
        .equ DMA1_S0CR_MINC, 1 << 10   @ bitWidth 1 (Memory increment mode)  
        .equ DMA1_S0CR_PINC, 1 << 9   @ bitWidth 1 (Peripheral increment mode)  
        .equ DMA1_S0CR_CIRC, 1 << 8   @ bitWidth 1 (Circular mode)  
        .equ DMA1_S0CR_DIR_Shift, 6   @ bitWidth 2 (Data transfer direction)  
        .equ DMA1_S0CR_PFCTRL, 1 << 5   @ bitWidth 1 (Peripheral flow controller)  
        .equ DMA1_S0CR_TCIE, 1 << 4   @ bitWidth 1 (Transfer complete interrupt  enable)  
        .equ DMA1_S0CR_HTIE, 1 << 3   @ bitWidth 1 (Half transfer interrupt  enable)  
        .equ DMA1_S0CR_TEIE, 1 << 2   @ bitWidth 1 (Transfer error interrupt  enable)  
        .equ DMA1_S0CR_DMEIE, 1 << 1   @ bitWidth 1 (Direct mode error interrupt  enable)  
        .equ DMA1_S0CR_EN, 1 << 0   @ bitWidth 1 (Stream enable / flag stream ready when  read low)  
 
    .equ DMA1_S0NDTR, DMA1_BASE + 0x14 @ (stream x number of data  register) 
        .equ DMA1_S0NDTR_NDT_Shift, 0   @ bitWidth 16 (Number of data items to  transfer)  
 
    .equ DMA1_S0PAR, DMA1_BASE + 0x18 @ (stream x peripheral address  register) 
        .equ DMA1_S0PAR_PA_Shift, 0   @ bitWidth 32 (Peripheral address)  
 
    .equ DMA1_S0M0AR, DMA1_BASE + 0x1C @ (stream x memory 0 address  register) 
        .equ DMA1_S0M0AR_M0A_Shift, 0   @ bitWidth 32 (Memory 0 address)  
 
    .equ DMA1_S0M1AR, DMA1_BASE + 0x20 @ (stream x memory 1 address  register) 
        .equ DMA1_S0M1AR_M1A_Shift, 0   @ bitWidth 32 (Memory 1 address used in case of Double  buffer mode)  
 
    .equ DMA1_S0FCR, DMA1_BASE + 0x24 @ (stream x FIFO control register) 
        .equ DMA1_S0FCR_FEIE, 1 << 7   @ bitWidth 1 (FIFO error interrupt  enable)  
        .equ DMA1_S0FCR_FS_Shift, 3   @ bitWidth 3 (FIFO status)  
        .equ DMA1_S0FCR_DMDIS, 1 << 2   @ bitWidth 1 (Direct mode disable)  
        .equ DMA1_S0FCR_FTH_Shift, 0   @ bitWidth 2 (FIFO threshold selection)  
 
    .equ DMA1_S1CR, DMA1_BASE + 0x28 @ (stream x configuration  register) 
        .equ DMA1_S1CR_MBURST_Shift, 23   @ bitWidth 2 (Memory burst transfer  configuration)  
        .equ DMA1_S1CR_PBURST_Shift, 21   @ bitWidth 2 (Peripheral burst transfer  configuration)  
        .equ DMA1_S1CR_ACK, 1 << 20   @ bitWidth 1 (ACK)  
        .equ DMA1_S1CR_CT, 1 << 19   @ bitWidth 1 (Current target only in double buffer  mode)  
        .equ DMA1_S1CR_DBM, 1 << 18   @ bitWidth 1 (Double buffer mode)  
        .equ DMA1_S1CR_PL_Shift, 16   @ bitWidth 2 (Priority level)  
        .equ DMA1_S1CR_PINCOS, 1 << 15   @ bitWidth 1 (Peripheral increment offset  size)  
        .equ DMA1_S1CR_MSIZE_Shift, 13   @ bitWidth 2 (Memory data size)  
        .equ DMA1_S1CR_PSIZE_Shift, 11   @ bitWidth 2 (Peripheral data size)  
        .equ DMA1_S1CR_MINC, 1 << 10   @ bitWidth 1 (Memory increment mode)  
        .equ DMA1_S1CR_PINC, 1 << 9   @ bitWidth 1 (Peripheral increment mode)  
        .equ DMA1_S1CR_CIRC, 1 << 8   @ bitWidth 1 (Circular mode)  
        .equ DMA1_S1CR_DIR_Shift, 6   @ bitWidth 2 (Data transfer direction)  
        .equ DMA1_S1CR_PFCTRL, 1 << 5   @ bitWidth 1 (Peripheral flow controller)  
        .equ DMA1_S1CR_TCIE, 1 << 4   @ bitWidth 1 (Transfer complete interrupt  enable)  
        .equ DMA1_S1CR_HTIE, 1 << 3   @ bitWidth 1 (Half transfer interrupt  enable)  
        .equ DMA1_S1CR_TEIE, 1 << 2   @ bitWidth 1 (Transfer error interrupt  enable)  
        .equ DMA1_S1CR_DMEIE, 1 << 1   @ bitWidth 1 (Direct mode error interrupt  enable)  
        .equ DMA1_S1CR_EN, 1 << 0   @ bitWidth 1 (Stream enable / flag stream ready when  read low)  
 
    .equ DMA1_S1NDTR, DMA1_BASE + 0x2C @ (stream x number of data  register) 
        .equ DMA1_S1NDTR_NDT_Shift, 0   @ bitWidth 16 (Number of data items to  transfer)  
 
    .equ DMA1_S1PAR, DMA1_BASE + 0x30 @ (stream x peripheral address  register) 
        .equ DMA1_S1PAR_PA_Shift, 0   @ bitWidth 32 (Peripheral address)  
 
    .equ DMA1_S1M0AR, DMA1_BASE + 0x34 @ (stream x memory 0 address  register) 
        .equ DMA1_S1M0AR_M0A_Shift, 0   @ bitWidth 32 (Memory 0 address)  
 
    .equ DMA1_S1M1AR, DMA1_BASE + 0x38 @ (stream x memory 1 address  register) 
        .equ DMA1_S1M1AR_M1A_Shift, 0   @ bitWidth 32 (Memory 1 address used in case of Double  buffer mode)  
 
    .equ DMA1_S1FCR, DMA1_BASE + 0x3C @ (stream x FIFO control register) 
        .equ DMA1_S1FCR_FEIE, 1 << 7   @ bitWidth 1 (FIFO error interrupt  enable)  
        .equ DMA1_S1FCR_FS_Shift, 3   @ bitWidth 3 (FIFO status)  
        .equ DMA1_S1FCR_DMDIS, 1 << 2   @ bitWidth 1 (Direct mode disable)  
        .equ DMA1_S1FCR_FTH_Shift, 0   @ bitWidth 2 (FIFO threshold selection)  
 
    .equ DMA1_S2CR, DMA1_BASE + 0x40 @ (stream x configuration  register) 
        .equ DMA1_S2CR_MBURST_Shift, 23   @ bitWidth 2 (Memory burst transfer  configuration)  
        .equ DMA1_S2CR_PBURST_Shift, 21   @ bitWidth 2 (Peripheral burst transfer  configuration)  
        .equ DMA1_S2CR_ACK, 1 << 20   @ bitWidth 1 (ACK)  
        .equ DMA1_S2CR_CT, 1 << 19   @ bitWidth 1 (Current target only in double buffer  mode)  
        .equ DMA1_S2CR_DBM, 1 << 18   @ bitWidth 1 (Double buffer mode)  
        .equ DMA1_S2CR_PL_Shift, 16   @ bitWidth 2 (Priority level)  
        .equ DMA1_S2CR_PINCOS, 1 << 15   @ bitWidth 1 (Peripheral increment offset  size)  
        .equ DMA1_S2CR_MSIZE_Shift, 13   @ bitWidth 2 (Memory data size)  
        .equ DMA1_S2CR_PSIZE_Shift, 11   @ bitWidth 2 (Peripheral data size)  
        .equ DMA1_S2CR_MINC, 1 << 10   @ bitWidth 1 (Memory increment mode)  
        .equ DMA1_S2CR_PINC, 1 << 9   @ bitWidth 1 (Peripheral increment mode)  
        .equ DMA1_S2CR_CIRC, 1 << 8   @ bitWidth 1 (Circular mode)  
        .equ DMA1_S2CR_DIR_Shift, 6   @ bitWidth 2 (Data transfer direction)  
        .equ DMA1_S2CR_PFCTRL, 1 << 5   @ bitWidth 1 (Peripheral flow controller)  
        .equ DMA1_S2CR_TCIE, 1 << 4   @ bitWidth 1 (Transfer complete interrupt  enable)  
        .equ DMA1_S2CR_HTIE, 1 << 3   @ bitWidth 1 (Half transfer interrupt  enable)  
        .equ DMA1_S2CR_TEIE, 1 << 2   @ bitWidth 1 (Transfer error interrupt  enable)  
        .equ DMA1_S2CR_DMEIE, 1 << 1   @ bitWidth 1 (Direct mode error interrupt  enable)  
        .equ DMA1_S2CR_EN, 1 << 0   @ bitWidth 1 (Stream enable / flag stream ready when  read low)  
 
    .equ DMA1_S2NDTR, DMA1_BASE + 0x44 @ (stream x number of data  register) 
        .equ DMA1_S2NDTR_NDT_Shift, 0   @ bitWidth 16 (Number of data items to  transfer)  
 
    .equ DMA1_S2PAR, DMA1_BASE + 0x48 @ (stream x peripheral address  register) 
        .equ DMA1_S2PAR_PA_Shift, 0   @ bitWidth 32 (Peripheral address)  
 
    .equ DMA1_S2M0AR, DMA1_BASE + 0x4C @ (stream x memory 0 address  register) 
        .equ DMA1_S2M0AR_M0A_Shift, 0   @ bitWidth 32 (Memory 0 address)  
 
    .equ DMA1_S2M1AR, DMA1_BASE + 0x50 @ (stream x memory 1 address  register) 
        .equ DMA1_S2M1AR_M1A_Shift, 0   @ bitWidth 32 (Memory 1 address used in case of Double  buffer mode)  
 
    .equ DMA1_S2FCR, DMA1_BASE + 0x54 @ (stream x FIFO control register) 
        .equ DMA1_S2FCR_FEIE, 1 << 7   @ bitWidth 1 (FIFO error interrupt  enable)  
        .equ DMA1_S2FCR_FS_Shift, 3   @ bitWidth 3 (FIFO status)  
        .equ DMA1_S2FCR_DMDIS, 1 << 2   @ bitWidth 1 (Direct mode disable)  
        .equ DMA1_S2FCR_FTH_Shift, 0   @ bitWidth 2 (FIFO threshold selection)  
 
    .equ DMA1_S3CR, DMA1_BASE + 0x58 @ (stream x configuration  register) 
        .equ DMA1_S3CR_MBURST_Shift, 23   @ bitWidth 2 (Memory burst transfer  configuration)  
        .equ DMA1_S3CR_PBURST_Shift, 21   @ bitWidth 2 (Peripheral burst transfer  configuration)  
        .equ DMA1_S3CR_ACK, 1 << 20   @ bitWidth 1 (ACK)  
        .equ DMA1_S3CR_CT, 1 << 19   @ bitWidth 1 (Current target only in double buffer  mode)  
        .equ DMA1_S3CR_DBM, 1 << 18   @ bitWidth 1 (Double buffer mode)  
        .equ DMA1_S3CR_PL_Shift, 16   @ bitWidth 2 (Priority level)  
        .equ DMA1_S3CR_PINCOS, 1 << 15   @ bitWidth 1 (Peripheral increment offset  size)  
        .equ DMA1_S3CR_MSIZE_Shift, 13   @ bitWidth 2 (Memory data size)  
        .equ DMA1_S3CR_PSIZE_Shift, 11   @ bitWidth 2 (Peripheral data size)  
        .equ DMA1_S3CR_MINC, 1 << 10   @ bitWidth 1 (Memory increment mode)  
        .equ DMA1_S3CR_PINC, 1 << 9   @ bitWidth 1 (Peripheral increment mode)  
        .equ DMA1_S3CR_CIRC, 1 << 8   @ bitWidth 1 (Circular mode)  
        .equ DMA1_S3CR_DIR_Shift, 6   @ bitWidth 2 (Data transfer direction)  
        .equ DMA1_S3CR_PFCTRL, 1 << 5   @ bitWidth 1 (Peripheral flow controller)  
        .equ DMA1_S3CR_TCIE, 1 << 4   @ bitWidth 1 (Transfer complete interrupt  enable)  
        .equ DMA1_S3CR_HTIE, 1 << 3   @ bitWidth 1 (Half transfer interrupt  enable)  
        .equ DMA1_S3CR_TEIE, 1 << 2   @ bitWidth 1 (Transfer error interrupt  enable)  
        .equ DMA1_S3CR_DMEIE, 1 << 1   @ bitWidth 1 (Direct mode error interrupt  enable)  
        .equ DMA1_S3CR_EN, 1 << 0   @ bitWidth 1 (Stream enable / flag stream ready when  read low)  
 
    .equ DMA1_S3NDTR, DMA1_BASE + 0x5C @ (stream x number of data  register) 
        .equ DMA1_S3NDTR_NDT_Shift, 0   @ bitWidth 16 (Number of data items to  transfer)  
 
    .equ DMA1_S3PAR, DMA1_BASE + 0x60 @ (stream x peripheral address  register) 
        .equ DMA1_S3PAR_PA_Shift, 0   @ bitWidth 32 (Peripheral address)  
 
    .equ DMA1_S3M0AR, DMA1_BASE + 0x64 @ (stream x memory 0 address  register) 
        .equ DMA1_S3M0AR_M0A_Shift, 0   @ bitWidth 32 (Memory 0 address)  
 
    .equ DMA1_S3M1AR, DMA1_BASE + 0x68 @ (stream x memory 1 address  register) 
        .equ DMA1_S3M1AR_M1A_Shift, 0   @ bitWidth 32 (Memory 1 address used in case of Double  buffer mode)  
 
    .equ DMA1_S3FCR, DMA1_BASE + 0x6C @ (stream x FIFO control register) 
        .equ DMA1_S3FCR_FEIE, 1 << 7   @ bitWidth 1 (FIFO error interrupt  enable)  
        .equ DMA1_S3FCR_FS_Shift, 3   @ bitWidth 3 (FIFO status)  
        .equ DMA1_S3FCR_DMDIS, 1 << 2   @ bitWidth 1 (Direct mode disable)  
        .equ DMA1_S3FCR_FTH_Shift, 0   @ bitWidth 2 (FIFO threshold selection)  
 
    .equ DMA1_S4CR, DMA1_BASE + 0x70 @ (stream x configuration  register) 
        .equ DMA1_S4CR_MBURST_Shift, 23   @ bitWidth 2 (Memory burst transfer  configuration)  
        .equ DMA1_S4CR_PBURST_Shift, 21   @ bitWidth 2 (Peripheral burst transfer  configuration)  
        .equ DMA1_S4CR_ACK, 1 << 20   @ bitWidth 1 (ACK)  
        .equ DMA1_S4CR_CT, 1 << 19   @ bitWidth 1 (Current target only in double buffer  mode)  
        .equ DMA1_S4CR_DBM, 1 << 18   @ bitWidth 1 (Double buffer mode)  
        .equ DMA1_S4CR_PL_Shift, 16   @ bitWidth 2 (Priority level)  
        .equ DMA1_S4CR_PINCOS, 1 << 15   @ bitWidth 1 (Peripheral increment offset  size)  
        .equ DMA1_S4CR_MSIZE_Shift, 13   @ bitWidth 2 (Memory data size)  
        .equ DMA1_S4CR_PSIZE_Shift, 11   @ bitWidth 2 (Peripheral data size)  
        .equ DMA1_S4CR_MINC, 1 << 10   @ bitWidth 1 (Memory increment mode)  
        .equ DMA1_S4CR_PINC, 1 << 9   @ bitWidth 1 (Peripheral increment mode)  
        .equ DMA1_S4CR_CIRC, 1 << 8   @ bitWidth 1 (Circular mode)  
        .equ DMA1_S4CR_DIR_Shift, 6   @ bitWidth 2 (Data transfer direction)  
        .equ DMA1_S4CR_PFCTRL, 1 << 5   @ bitWidth 1 (Peripheral flow controller)  
        .equ DMA1_S4CR_TCIE, 1 << 4   @ bitWidth 1 (Transfer complete interrupt  enable)  
        .equ DMA1_S4CR_HTIE, 1 << 3   @ bitWidth 1 (Half transfer interrupt  enable)  
        .equ DMA1_S4CR_TEIE, 1 << 2   @ bitWidth 1 (Transfer error interrupt  enable)  
        .equ DMA1_S4CR_DMEIE, 1 << 1   @ bitWidth 1 (Direct mode error interrupt  enable)  
        .equ DMA1_S4CR_EN, 1 << 0   @ bitWidth 1 (Stream enable / flag stream ready when  read low)  
 
    .equ DMA1_S4NDTR, DMA1_BASE + 0x74 @ (stream x number of data  register) 
        .equ DMA1_S4NDTR_NDT_Shift, 0   @ bitWidth 16 (Number of data items to  transfer)  
 
    .equ DMA1_S4PAR, DMA1_BASE + 0x78 @ (stream x peripheral address  register) 
        .equ DMA1_S4PAR_PA_Shift, 0   @ bitWidth 32 (Peripheral address)  
 
    .equ DMA1_S4M0AR, DMA1_BASE + 0x7C @ (stream x memory 0 address  register) 
        .equ DMA1_S4M0AR_M0A_Shift, 0   @ bitWidth 32 (Memory 0 address)  
 
    .equ DMA1_S4M1AR, DMA1_BASE + 0x80 @ (stream x memory 1 address  register) 
        .equ DMA1_S4M1AR_M1A_Shift, 0   @ bitWidth 32 (Memory 1 address used in case of Double  buffer mode)  
 
    .equ DMA1_S4FCR, DMA1_BASE + 0x84 @ (stream x FIFO control register) 
        .equ DMA1_S4FCR_FEIE, 1 << 7   @ bitWidth 1 (FIFO error interrupt  enable)  
        .equ DMA1_S4FCR_FS_Shift, 3   @ bitWidth 3 (FIFO status)  
        .equ DMA1_S4FCR_DMDIS, 1 << 2   @ bitWidth 1 (Direct mode disable)  
        .equ DMA1_S4FCR_FTH_Shift, 0   @ bitWidth 2 (FIFO threshold selection)  
 
    .equ DMA1_S5CR, DMA1_BASE + 0x88 @ (stream x configuration  register) 
        .equ DMA1_S5CR_MBURST_Shift, 23   @ bitWidth 2 (Memory burst transfer  configuration)  
        .equ DMA1_S5CR_PBURST_Shift, 21   @ bitWidth 2 (Peripheral burst transfer  configuration)  
        .equ DMA1_S5CR_ACK, 1 << 20   @ bitWidth 1 (ACK)  
        .equ DMA1_S5CR_CT, 1 << 19   @ bitWidth 1 (Current target only in double buffer  mode)  
        .equ DMA1_S5CR_DBM, 1 << 18   @ bitWidth 1 (Double buffer mode)  
        .equ DMA1_S5CR_PL_Shift, 16   @ bitWidth 2 (Priority level)  
        .equ DMA1_S5CR_PINCOS, 1 << 15   @ bitWidth 1 (Peripheral increment offset  size)  
        .equ DMA1_S5CR_MSIZE_Shift, 13   @ bitWidth 2 (Memory data size)  
        .equ DMA1_S5CR_PSIZE_Shift, 11   @ bitWidth 2 (Peripheral data size)  
        .equ DMA1_S5CR_MINC, 1 << 10   @ bitWidth 1 (Memory increment mode)  
        .equ DMA1_S5CR_PINC, 1 << 9   @ bitWidth 1 (Peripheral increment mode)  
        .equ DMA1_S5CR_CIRC, 1 << 8   @ bitWidth 1 (Circular mode)  
        .equ DMA1_S5CR_DIR_Shift, 6   @ bitWidth 2 (Data transfer direction)  
        .equ DMA1_S5CR_PFCTRL, 1 << 5   @ bitWidth 1 (Peripheral flow controller)  
        .equ DMA1_S5CR_TCIE, 1 << 4   @ bitWidth 1 (Transfer complete interrupt  enable)  
        .equ DMA1_S5CR_HTIE, 1 << 3   @ bitWidth 1 (Half transfer interrupt  enable)  
        .equ DMA1_S5CR_TEIE, 1 << 2   @ bitWidth 1 (Transfer error interrupt  enable)  
        .equ DMA1_S5CR_DMEIE, 1 << 1   @ bitWidth 1 (Direct mode error interrupt  enable)  
        .equ DMA1_S5CR_EN, 1 << 0   @ bitWidth 1 (Stream enable / flag stream ready when  read low)  
 
    .equ DMA1_S5NDTR, DMA1_BASE + 0x8C @ (stream x number of data  register) 
        .equ DMA1_S5NDTR_NDT_Shift, 0   @ bitWidth 16 (Number of data items to  transfer)  
 
    .equ DMA1_S5PAR, DMA1_BASE + 0x90 @ (stream x peripheral address  register) 
        .equ DMA1_S5PAR_PA_Shift, 0   @ bitWidth 32 (Peripheral address)  
 
    .equ DMA1_S5M0AR, DMA1_BASE + 0x94 @ (stream x memory 0 address  register) 
        .equ DMA1_S5M0AR_M0A_Shift, 0   @ bitWidth 32 (Memory 0 address)  
 
    .equ DMA1_S5M1AR, DMA1_BASE + 0x98 @ (stream x memory 1 address  register) 
        .equ DMA1_S5M1AR_M1A_Shift, 0   @ bitWidth 32 (Memory 1 address used in case of Double  buffer mode)  
 
    .equ DMA1_S5FCR, DMA1_BASE + 0x9C @ (stream x FIFO control register) 
        .equ DMA1_S5FCR_FEIE, 1 << 7   @ bitWidth 1 (FIFO error interrupt  enable)  
        .equ DMA1_S5FCR_FS_Shift, 3   @ bitWidth 3 (FIFO status)  
        .equ DMA1_S5FCR_DMDIS, 1 << 2   @ bitWidth 1 (Direct mode disable)  
        .equ DMA1_S5FCR_FTH_Shift, 0   @ bitWidth 2 (FIFO threshold selection)  
 
    .equ DMA1_S6CR, DMA1_BASE + 0xA0 @ (stream x configuration  register) 
        .equ DMA1_S6CR_MBURST_Shift, 23   @ bitWidth 2 (Memory burst transfer  configuration)  
        .equ DMA1_S6CR_PBURST_Shift, 21   @ bitWidth 2 (Peripheral burst transfer  configuration)  
        .equ DMA1_S6CR_ACK, 1 << 20   @ bitWidth 1 (ACK)  
        .equ DMA1_S6CR_CT, 1 << 19   @ bitWidth 1 (Current target only in double buffer  mode)  
        .equ DMA1_S6CR_DBM, 1 << 18   @ bitWidth 1 (Double buffer mode)  
        .equ DMA1_S6CR_PL_Shift, 16   @ bitWidth 2 (Priority level)  
        .equ DMA1_S6CR_PINCOS, 1 << 15   @ bitWidth 1 (Peripheral increment offset  size)  
        .equ DMA1_S6CR_MSIZE_Shift, 13   @ bitWidth 2 (Memory data size)  
        .equ DMA1_S6CR_PSIZE_Shift, 11   @ bitWidth 2 (Peripheral data size)  
        .equ DMA1_S6CR_MINC, 1 << 10   @ bitWidth 1 (Memory increment mode)  
        .equ DMA1_S6CR_PINC, 1 << 9   @ bitWidth 1 (Peripheral increment mode)  
        .equ DMA1_S6CR_CIRC, 1 << 8   @ bitWidth 1 (Circular mode)  
        .equ DMA1_S6CR_DIR_Shift, 6   @ bitWidth 2 (Data transfer direction)  
        .equ DMA1_S6CR_PFCTRL, 1 << 5   @ bitWidth 1 (Peripheral flow controller)  
        .equ DMA1_S6CR_TCIE, 1 << 4   @ bitWidth 1 (Transfer complete interrupt  enable)  
        .equ DMA1_S6CR_HTIE, 1 << 3   @ bitWidth 1 (Half transfer interrupt  enable)  
        .equ DMA1_S6CR_TEIE, 1 << 2   @ bitWidth 1 (Transfer error interrupt  enable)  
        .equ DMA1_S6CR_DMEIE, 1 << 1   @ bitWidth 1 (Direct mode error interrupt  enable)  
        .equ DMA1_S6CR_EN, 1 << 0   @ bitWidth 1 (Stream enable / flag stream ready when  read low)  
 
    .equ DMA1_S6NDTR, DMA1_BASE + 0xA4 @ (stream x number of data  register) 
        .equ DMA1_S6NDTR_NDT_Shift, 0   @ bitWidth 16 (Number of data items to  transfer)  
 
    .equ DMA1_S6PAR, DMA1_BASE + 0xA8 @ (stream x peripheral address  register) 
        .equ DMA1_S6PAR_PA_Shift, 0   @ bitWidth 32 (Peripheral address)  
 
    .equ DMA1_S6M0AR, DMA1_BASE + 0xAC @ (stream x memory 0 address  register) 
        .equ DMA1_S6M0AR_M0A_Shift, 0   @ bitWidth 32 (Memory 0 address)  
 
    .equ DMA1_S6M1AR, DMA1_BASE + 0xB0 @ (stream x memory 1 address  register) 
        .equ DMA1_S6M1AR_M1A_Shift, 0   @ bitWidth 32 (Memory 1 address used in case of Double  buffer mode)  
 
    .equ DMA1_S6FCR, DMA1_BASE + 0xB4 @ (stream x FIFO control register) 
        .equ DMA1_S6FCR_FEIE, 1 << 7   @ bitWidth 1 (FIFO error interrupt  enable)  
        .equ DMA1_S6FCR_FS_Shift, 3   @ bitWidth 3 (FIFO status)  
        .equ DMA1_S6FCR_DMDIS, 1 << 2   @ bitWidth 1 (Direct mode disable)  
        .equ DMA1_S6FCR_FTH_Shift, 0   @ bitWidth 2 (FIFO threshold selection)  
 
    .equ DMA1_S7CR, DMA1_BASE + 0xB8 @ (stream x configuration  register) 
        .equ DMA1_S7CR_MBURST_Shift, 23   @ bitWidth 2 (Memory burst transfer  configuration)  
        .equ DMA1_S7CR_PBURST_Shift, 21   @ bitWidth 2 (Peripheral burst transfer  configuration)  
        .equ DMA1_S7CR_ACK, 1 << 20   @ bitWidth 1 (ACK)  
        .equ DMA1_S7CR_CT, 1 << 19   @ bitWidth 1 (Current target only in double buffer  mode)  
        .equ DMA1_S7CR_DBM, 1 << 18   @ bitWidth 1 (Double buffer mode)  
        .equ DMA1_S7CR_PL_Shift, 16   @ bitWidth 2 (Priority level)  
        .equ DMA1_S7CR_PINCOS, 1 << 15   @ bitWidth 1 (Peripheral increment offset  size)  
        .equ DMA1_S7CR_MSIZE_Shift, 13   @ bitWidth 2 (Memory data size)  
        .equ DMA1_S7CR_PSIZE_Shift, 11   @ bitWidth 2 (Peripheral data size)  
        .equ DMA1_S7CR_MINC, 1 << 10   @ bitWidth 1 (Memory increment mode)  
        .equ DMA1_S7CR_PINC, 1 << 9   @ bitWidth 1 (Peripheral increment mode)  
        .equ DMA1_S7CR_CIRC, 1 << 8   @ bitWidth 1 (Circular mode)  
        .equ DMA1_S7CR_DIR_Shift, 6   @ bitWidth 2 (Data transfer direction)  
        .equ DMA1_S7CR_PFCTRL, 1 << 5   @ bitWidth 1 (Peripheral flow controller)  
        .equ DMA1_S7CR_TCIE, 1 << 4   @ bitWidth 1 (Transfer complete interrupt  enable)  
        .equ DMA1_S7CR_HTIE, 1 << 3   @ bitWidth 1 (Half transfer interrupt  enable)  
        .equ DMA1_S7CR_TEIE, 1 << 2   @ bitWidth 1 (Transfer error interrupt  enable)  
        .equ DMA1_S7CR_DMEIE, 1 << 1   @ bitWidth 1 (Direct mode error interrupt  enable)  
        .equ DMA1_S7CR_EN, 1 << 0   @ bitWidth 1 (Stream enable / flag stream ready when  read low)  
 
    .equ DMA1_S7NDTR, DMA1_BASE + 0xBC @ (stream x number of data  register) 
        .equ DMA1_S7NDTR_NDT_Shift, 0   @ bitWidth 16 (Number of data items to  transfer)  
 
    .equ DMA1_S7PAR, DMA1_BASE + 0xC0 @ (stream x peripheral address  register) 
        .equ DMA1_S7PAR_PA_Shift, 0   @ bitWidth 32 (Peripheral address)  
 
    .equ DMA1_S7M0AR, DMA1_BASE + 0xC4 @ (stream x memory 0 address  register) 
        .equ DMA1_S7M0AR_M0A_Shift, 0   @ bitWidth 32 (Memory 0 address)  
 
    .equ DMA1_S7M1AR, DMA1_BASE + 0xC8 @ (stream x memory 1 address  register) 
        .equ DMA1_S7M1AR_M1A_Shift, 0   @ bitWidth 32 (Memory 1 address used in case of Double  buffer mode)  
 
    .equ DMA1_S7FCR, DMA1_BASE + 0xCC @ (stream x FIFO control register) 
        .equ DMA1_S7FCR_FEIE, 1 << 7   @ bitWidth 1 (FIFO error interrupt  enable)  
        .equ DMA1_S7FCR_FS_Shift, 3   @ bitWidth 3 (FIFO status)  
        .equ DMA1_S7FCR_DMDIS, 1 << 2   @ bitWidth 1 (Direct mode disable)  
        .equ DMA1_S7FCR_FTH_Shift, 0   @ bitWidth 2 (FIFO threshold selection)  
 

@=========================== DMA2 ===========================@
.equ DMA2_BASE, 0x40020400 @ (DMA controller) 
    .equ DMA2_LISR, DMA2_BASE + 0x0 @ (low interrupt status register) 
        .equ DMA2_LISR_TCIF3, 1 << 27   @ bitWidth 1 (Stream x transfer complete interrupt  flag x = 3..0)  
        .equ DMA2_LISR_HTIF3, 1 << 26   @ bitWidth 1 (Stream x half transfer interrupt flag  x=3..0)  
        .equ DMA2_LISR_TEIF3, 1 << 25   @ bitWidth 1 (Stream x transfer error interrupt flag  x=3..0)  
        .equ DMA2_LISR_DMEIF3, 1 << 24   @ bitWidth 1 (Stream x direct mode error interrupt  flag x=3..0)  
        .equ DMA2_LISR_FEIF3, 1 << 22   @ bitWidth 1 (Stream x FIFO error interrupt flag  x=3..0)  
        .equ DMA2_LISR_TCIF2, 1 << 21   @ bitWidth 1 (Stream x transfer complete interrupt  flag x = 3..0)  
        .equ DMA2_LISR_HTIF2, 1 << 20   @ bitWidth 1 (Stream x half transfer interrupt flag  x=3..0)  
        .equ DMA2_LISR_TEIF2, 1 << 19   @ bitWidth 1 (Stream x transfer error interrupt flag  x=3..0)  
        .equ DMA2_LISR_DMEIF2, 1 << 18   @ bitWidth 1 (Stream x direct mode error interrupt  flag x=3..0)  
        .equ DMA2_LISR_FEIF2, 1 << 16   @ bitWidth 1 (Stream x FIFO error interrupt flag  x=3..0)  
        .equ DMA2_LISR_TCIF1, 1 << 11   @ bitWidth 1 (Stream x transfer complete interrupt  flag x = 3..0)  
        .equ DMA2_LISR_HTIF1, 1 << 10   @ bitWidth 1 (Stream x half transfer interrupt flag  x=3..0)  
        .equ DMA2_LISR_TEIF1, 1 << 9   @ bitWidth 1 (Stream x transfer error interrupt flag  x=3..0)  
        .equ DMA2_LISR_DMEIF1, 1 << 8   @ bitWidth 1 (Stream x direct mode error interrupt  flag x=3..0)  
        .equ DMA2_LISR_FEIF1, 1 << 6   @ bitWidth 1 (Stream x FIFO error interrupt flag  x=3..0)  
        .equ DMA2_LISR_TCIF0, 1 << 5   @ bitWidth 1 (Stream x transfer complete interrupt  flag x = 3..0)  
        .equ DMA2_LISR_HTIF0, 1 << 4   @ bitWidth 1 (Stream x half transfer interrupt flag  x=3..0)  
        .equ DMA2_LISR_TEIF0, 1 << 3   @ bitWidth 1 (Stream x transfer error interrupt flag  x=3..0)  
        .equ DMA2_LISR_DMEIF0, 1 << 2   @ bitWidth 1 (Stream x direct mode error interrupt  flag x=3..0)  
        .equ DMA2_LISR_FEIF0, 1 << 0   @ bitWidth 1 (Stream x FIFO error interrupt flag  x=3..0)  
 
    .equ DMA2_HISR, DMA2_BASE + 0x4 @ (high interrupt status register) 
        .equ DMA2_HISR_TCIF7, 1 << 27   @ bitWidth 1 (Stream x transfer complete interrupt  flag x=7..4)  
        .equ DMA2_HISR_HTIF7, 1 << 26   @ bitWidth 1 (Stream x half transfer interrupt flag  x=7..4)  
        .equ DMA2_HISR_TEIF7, 1 << 25   @ bitWidth 1 (Stream x transfer error interrupt flag  x=7..4)  
        .equ DMA2_HISR_DMEIF7, 1 << 24   @ bitWidth 1 (Stream x direct mode error interrupt  flag x=7..4)  
        .equ DMA2_HISR_FEIF7, 1 << 22   @ bitWidth 1 (Stream x FIFO error interrupt flag  x=7..4)  
        .equ DMA2_HISR_TCIF6, 1 << 21   @ bitWidth 1 (Stream x transfer complete interrupt  flag x=7..4)  
        .equ DMA2_HISR_HTIF6, 1 << 20   @ bitWidth 1 (Stream x half transfer interrupt flag  x=7..4)  
        .equ DMA2_HISR_TEIF6, 1 << 19   @ bitWidth 1 (Stream x transfer error interrupt flag  x=7..4)  
        .equ DMA2_HISR_DMEIF6, 1 << 18   @ bitWidth 1 (Stream x direct mode error interrupt  flag x=7..4)  
        .equ DMA2_HISR_FEIF6, 1 << 16   @ bitWidth 1 (Stream x FIFO error interrupt flag  x=7..4)  
        .equ DMA2_HISR_TCIF5, 1 << 11   @ bitWidth 1 (Stream x transfer complete interrupt  flag x=7..4)  
        .equ DMA2_HISR_HTIF5, 1 << 10   @ bitWidth 1 (Stream x half transfer interrupt flag  x=7..4)  
        .equ DMA2_HISR_TEIF5, 1 << 9   @ bitWidth 1 (Stream x transfer error interrupt flag  x=7..4)  
        .equ DMA2_HISR_DMEIF5, 1 << 8   @ bitWidth 1 (Stream x direct mode error interrupt  flag x=7..4)  
        .equ DMA2_HISR_FEIF5, 1 << 6   @ bitWidth 1 (Stream x FIFO error interrupt flag  x=7..4)  
        .equ DMA2_HISR_TCIF4, 1 << 5   @ bitWidth 1 (Stream x transfer complete interrupt  flag x=7..4)  
        .equ DMA2_HISR_HTIF4, 1 << 4   @ bitWidth 1 (Stream x half transfer interrupt flag  x=7..4)  
        .equ DMA2_HISR_TEIF4, 1 << 3   @ bitWidth 1 (Stream x transfer error interrupt flag  x=7..4)  
        .equ DMA2_HISR_DMEIF4, 1 << 2   @ bitWidth 1 (Stream x direct mode error interrupt  flag x=7..4)  
        .equ DMA2_HISR_FEIF4, 1 << 0   @ bitWidth 1 (Stream x FIFO error interrupt flag  x=7..4)  
 
    .equ DMA2_LIFCR, DMA2_BASE + 0x8 @ (low interrupt flag clear  register) 
        .equ DMA2_LIFCR_CTCIF3, 1 << 27   @ bitWidth 1 (Stream x clear transfer complete  interrupt flag x = 3..0)  
        .equ DMA2_LIFCR_CHTIF3, 1 << 26   @ bitWidth 1 (Stream x clear half transfer interrupt  flag x = 3..0)  
        .equ DMA2_LIFCR_CTEIF3, 1 << 25   @ bitWidth 1 (Stream x clear transfer error interrupt  flag x = 3..0)  
        .equ DMA2_LIFCR_CDMEIF3, 1 << 24   @ bitWidth 1 (Stream x clear direct mode error  interrupt flag x = 3..0)  
        .equ DMA2_LIFCR_CFEIF3, 1 << 22   @ bitWidth 1 (Stream x clear FIFO error interrupt flag  x = 3..0)  
        .equ DMA2_LIFCR_CTCIF2, 1 << 21   @ bitWidth 1 (Stream x clear transfer complete  interrupt flag x = 3..0)  
        .equ DMA2_LIFCR_CHTIF2, 1 << 20   @ bitWidth 1 (Stream x clear half transfer interrupt  flag x = 3..0)  
        .equ DMA2_LIFCR_CTEIF2, 1 << 19   @ bitWidth 1 (Stream x clear transfer error interrupt  flag x = 3..0)  
        .equ DMA2_LIFCR_CDMEIF2, 1 << 18   @ bitWidth 1 (Stream x clear direct mode error  interrupt flag x = 3..0)  
        .equ DMA2_LIFCR_CFEIF2, 1 << 16   @ bitWidth 1 (Stream x clear FIFO error interrupt flag  x = 3..0)  
        .equ DMA2_LIFCR_CTCIF1, 1 << 11   @ bitWidth 1 (Stream x clear transfer complete  interrupt flag x = 3..0)  
        .equ DMA2_LIFCR_CHTIF1, 1 << 10   @ bitWidth 1 (Stream x clear half transfer interrupt  flag x = 3..0)  
        .equ DMA2_LIFCR_CTEIF1, 1 << 9   @ bitWidth 1 (Stream x clear transfer error interrupt  flag x = 3..0)  
        .equ DMA2_LIFCR_CDMEIF1, 1 << 8   @ bitWidth 1 (Stream x clear direct mode error  interrupt flag x = 3..0)  
        .equ DMA2_LIFCR_CFEIF1, 1 << 6   @ bitWidth 1 (Stream x clear FIFO error interrupt flag  x = 3..0)  
        .equ DMA2_LIFCR_CTCIF0, 1 << 5   @ bitWidth 1 (Stream x clear transfer complete  interrupt flag x = 3..0)  
        .equ DMA2_LIFCR_CHTIF0, 1 << 4   @ bitWidth 1 (Stream x clear half transfer interrupt  flag x = 3..0)  
        .equ DMA2_LIFCR_CTEIF0, 1 << 3   @ bitWidth 1 (Stream x clear transfer error interrupt  flag x = 3..0)  
        .equ DMA2_LIFCR_CDMEIF0, 1 << 2   @ bitWidth 1 (Stream x clear direct mode error  interrupt flag x = 3..0)  
        .equ DMA2_LIFCR_CFEIF0, 1 << 0   @ bitWidth 1 (Stream x clear FIFO error interrupt flag  x = 3..0)  
 
    .equ DMA2_HIFCR, DMA2_BASE + 0xC @ (high interrupt flag clear  register) 
        .equ DMA2_HIFCR_CTCIF7, 1 << 27   @ bitWidth 1 (Stream x clear transfer complete  interrupt flag x = 7..4)  
        .equ DMA2_HIFCR_CHTIF7, 1 << 26   @ bitWidth 1 (Stream x clear half transfer interrupt  flag x = 7..4)  
        .equ DMA2_HIFCR_CTEIF7, 1 << 25   @ bitWidth 1 (Stream x clear transfer error interrupt  flag x = 7..4)  
        .equ DMA2_HIFCR_CDMEIF7, 1 << 24   @ bitWidth 1 (Stream x clear direct mode error  interrupt flag x = 7..4)  
        .equ DMA2_HIFCR_CFEIF7, 1 << 22   @ bitWidth 1 (Stream x clear FIFO error interrupt flag  x = 7..4)  
        .equ DMA2_HIFCR_CTCIF6, 1 << 21   @ bitWidth 1 (Stream x clear transfer complete  interrupt flag x = 7..4)  
        .equ DMA2_HIFCR_CHTIF6, 1 << 20   @ bitWidth 1 (Stream x clear half transfer interrupt  flag x = 7..4)  
        .equ DMA2_HIFCR_CTEIF6, 1 << 19   @ bitWidth 1 (Stream x clear transfer error interrupt  flag x = 7..4)  
        .equ DMA2_HIFCR_CDMEIF6, 1 << 18   @ bitWidth 1 (Stream x clear direct mode error  interrupt flag x = 7..4)  
        .equ DMA2_HIFCR_CFEIF6, 1 << 16   @ bitWidth 1 (Stream x clear FIFO error interrupt flag  x = 7..4)  
        .equ DMA2_HIFCR_CTCIF5, 1 << 11   @ bitWidth 1 (Stream x clear transfer complete  interrupt flag x = 7..4)  
        .equ DMA2_HIFCR_CHTIF5, 1 << 10   @ bitWidth 1 (Stream x clear half transfer interrupt  flag x = 7..4)  
        .equ DMA2_HIFCR_CTEIF5, 1 << 9   @ bitWidth 1 (Stream x clear transfer error interrupt  flag x = 7..4)  
        .equ DMA2_HIFCR_CDMEIF5, 1 << 8   @ bitWidth 1 (Stream x clear direct mode error  interrupt flag x = 7..4)  
        .equ DMA2_HIFCR_CFEIF5, 1 << 6   @ bitWidth 1 (Stream x clear FIFO error interrupt flag  x = 7..4)  
        .equ DMA2_HIFCR_CTCIF4, 1 << 5   @ bitWidth 1 (Stream x clear transfer complete  interrupt flag x = 7..4)  
        .equ DMA2_HIFCR_CHTIF4, 1 << 4   @ bitWidth 1 (Stream x clear half transfer interrupt  flag x = 7..4)  
        .equ DMA2_HIFCR_CTEIF4, 1 << 3   @ bitWidth 1 (Stream x clear transfer error interrupt  flag x = 7..4)  
        .equ DMA2_HIFCR_CDMEIF4, 1 << 2   @ bitWidth 1 (Stream x clear direct mode error  interrupt flag x = 7..4)  
        .equ DMA2_HIFCR_CFEIF4, 1 << 0   @ bitWidth 1 (Stream x clear FIFO error interrupt flag  x = 7..4)  
 
    .equ DMA2_S0CR, DMA2_BASE + 0x10 @ (stream x configuration  register) 
        .equ DMA2_S0CR_MBURST_Shift, 23   @ bitWidth 2 (Memory burst transfer  configuration)  
        .equ DMA2_S0CR_PBURST_Shift, 21   @ bitWidth 2 (Peripheral burst transfer  configuration)  
        .equ DMA2_S0CR_CT, 1 << 19   @ bitWidth 1 (Current target only in double buffer  mode)  
        .equ DMA2_S0CR_DBM, 1 << 18   @ bitWidth 1 (Double buffer mode)  
        .equ DMA2_S0CR_PL_Shift, 16   @ bitWidth 2 (Priority level)  
        .equ DMA2_S0CR_PINCOS, 1 << 15   @ bitWidth 1 (Peripheral increment offset  size)  
        .equ DMA2_S0CR_MSIZE_Shift, 13   @ bitWidth 2 (Memory data size)  
        .equ DMA2_S0CR_PSIZE_Shift, 11   @ bitWidth 2 (Peripheral data size)  
        .equ DMA2_S0CR_MINC, 1 << 10   @ bitWidth 1 (Memory increment mode)  
        .equ DMA2_S0CR_PINC, 1 << 9   @ bitWidth 1 (Peripheral increment mode)  
        .equ DMA2_S0CR_CIRC, 1 << 8   @ bitWidth 1 (Circular mode)  
        .equ DMA2_S0CR_DIR_Shift, 6   @ bitWidth 2 (Data transfer direction)  
        .equ DMA2_S0CR_PFCTRL, 1 << 5   @ bitWidth 1 (Peripheral flow controller)  
        .equ DMA2_S0CR_TCIE, 1 << 4   @ bitWidth 1 (Transfer complete interrupt  enable)  
        .equ DMA2_S0CR_HTIE, 1 << 3   @ bitWidth 1 (Half transfer interrupt  enable)  
        .equ DMA2_S0CR_TEIE, 1 << 2   @ bitWidth 1 (Transfer error interrupt  enable)  
        .equ DMA2_S0CR_DMEIE, 1 << 1   @ bitWidth 1 (Direct mode error interrupt  enable)  
        .equ DMA2_S0CR_EN, 1 << 0   @ bitWidth 1 (Stream enable / flag stream ready when  read low)  
 
    .equ DMA2_S0NDTR, DMA2_BASE + 0x14 @ (stream x number of data  register) 
        .equ DMA2_S0NDTR_NDT_Shift, 0   @ bitWidth 16 (Number of data items to  transfer)  
 
    .equ DMA2_S0PAR, DMA2_BASE + 0x18 @ (stream x peripheral address  register) 
        .equ DMA2_S0PAR_PA_Shift, 0   @ bitWidth 32 (Peripheral address)  
 
    .equ DMA2_S0M0AR, DMA2_BASE + 0x1C @ (stream x memory 0 address  register) 
        .equ DMA2_S0M0AR_M0A_Shift, 0   @ bitWidth 32 (Memory 0 address)  
 
    .equ DMA2_S0M1AR, DMA2_BASE + 0x20 @ (stream x memory 1 address  register) 
        .equ DMA2_S0M1AR_M1A_Shift, 0   @ bitWidth 32 (Memory 1 address used in case of Double  buffer mode)  
 
    .equ DMA2_S0FCR, DMA2_BASE + 0x24 @ (stream x FIFO control register) 
        .equ DMA2_S0FCR_FEIE, 1 << 7   @ bitWidth 1 (FIFO error interrupt  enable)  
        .equ DMA2_S0FCR_FS_Shift, 3   @ bitWidth 3 (FIFO status)  
        .equ DMA2_S0FCR_DMDIS, 1 << 2   @ bitWidth 1 (Direct mode disable)  
        .equ DMA2_S0FCR_FTH_Shift, 0   @ bitWidth 2 (FIFO threshold selection)  
 
    .equ DMA2_S1CR, DMA2_BASE + 0x28 @ (stream x configuration  register) 
        .equ DMA2_S1CR_MBURST_Shift, 23   @ bitWidth 2 (Memory burst transfer  configuration)  
        .equ DMA2_S1CR_PBURST_Shift, 21   @ bitWidth 2 (Peripheral burst transfer  configuration)  
        .equ DMA2_S1CR_ACK, 1 << 20   @ bitWidth 1 (ACK)  
        .equ DMA2_S1CR_CT, 1 << 19   @ bitWidth 1 (Current target only in double buffer  mode)  
        .equ DMA2_S1CR_DBM, 1 << 18   @ bitWidth 1 (Double buffer mode)  
        .equ DMA2_S1CR_PL_Shift, 16   @ bitWidth 2 (Priority level)  
        .equ DMA2_S1CR_PINCOS, 1 << 15   @ bitWidth 1 (Peripheral increment offset  size)  
        .equ DMA2_S1CR_MSIZE_Shift, 13   @ bitWidth 2 (Memory data size)  
        .equ DMA2_S1CR_PSIZE_Shift, 11   @ bitWidth 2 (Peripheral data size)  
        .equ DMA2_S1CR_MINC, 1 << 10   @ bitWidth 1 (Memory increment mode)  
        .equ DMA2_S1CR_PINC, 1 << 9   @ bitWidth 1 (Peripheral increment mode)  
        .equ DMA2_S1CR_CIRC, 1 << 8   @ bitWidth 1 (Circular mode)  
        .equ DMA2_S1CR_DIR_Shift, 6   @ bitWidth 2 (Data transfer direction)  
        .equ DMA2_S1CR_PFCTRL, 1 << 5   @ bitWidth 1 (Peripheral flow controller)  
        .equ DMA2_S1CR_TCIE, 1 << 4   @ bitWidth 1 (Transfer complete interrupt  enable)  
        .equ DMA2_S1CR_HTIE, 1 << 3   @ bitWidth 1 (Half transfer interrupt  enable)  
        .equ DMA2_S1CR_TEIE, 1 << 2   @ bitWidth 1 (Transfer error interrupt  enable)  
        .equ DMA2_S1CR_DMEIE, 1 << 1   @ bitWidth 1 (Direct mode error interrupt  enable)  
        .equ DMA2_S1CR_EN, 1 << 0   @ bitWidth 1 (Stream enable / flag stream ready when  read low)  
 
    .equ DMA2_S1NDTR, DMA2_BASE + 0x2C @ (stream x number of data  register) 
        .equ DMA2_S1NDTR_NDT_Shift, 0   @ bitWidth 16 (Number of data items to  transfer)  
 
    .equ DMA2_S1PAR, DMA2_BASE + 0x30 @ (stream x peripheral address  register) 
        .equ DMA2_S1PAR_PA_Shift, 0   @ bitWidth 32 (Peripheral address)  
 
    .equ DMA2_S1M0AR, DMA2_BASE + 0x34 @ (stream x memory 0 address  register) 
        .equ DMA2_S1M0AR_M0A_Shift, 0   @ bitWidth 32 (Memory 0 address)  
 
    .equ DMA2_S1M1AR, DMA2_BASE + 0x38 @ (stream x memory 1 address  register) 
        .equ DMA2_S1M1AR_M1A_Shift, 0   @ bitWidth 32 (Memory 1 address used in case of Double  buffer mode)  
 
    .equ DMA2_S1FCR, DMA2_BASE + 0x3C @ (stream x FIFO control register) 
        .equ DMA2_S1FCR_FEIE, 1 << 7   @ bitWidth 1 (FIFO error interrupt  enable)  
        .equ DMA2_S1FCR_FS_Shift, 3   @ bitWidth 3 (FIFO status)  
        .equ DMA2_S1FCR_DMDIS, 1 << 2   @ bitWidth 1 (Direct mode disable)  
        .equ DMA2_S1FCR_FTH_Shift, 0   @ bitWidth 2 (FIFO threshold selection)  
 
    .equ DMA2_S2CR, DMA2_BASE + 0x40 @ (stream x configuration  register) 
        .equ DMA2_S2CR_MBURST_Shift, 23   @ bitWidth 2 (Memory burst transfer  configuration)  
        .equ DMA2_S2CR_PBURST_Shift, 21   @ bitWidth 2 (Peripheral burst transfer  configuration)  
        .equ DMA2_S2CR_ACK, 1 << 20   @ bitWidth 1 (ACK)  
        .equ DMA2_S2CR_CT, 1 << 19   @ bitWidth 1 (Current target only in double buffer  mode)  
        .equ DMA2_S2CR_DBM, 1 << 18   @ bitWidth 1 (Double buffer mode)  
        .equ DMA2_S2CR_PL_Shift, 16   @ bitWidth 2 (Priority level)  
        .equ DMA2_S2CR_PINCOS, 1 << 15   @ bitWidth 1 (Peripheral increment offset  size)  
        .equ DMA2_S2CR_MSIZE_Shift, 13   @ bitWidth 2 (Memory data size)  
        .equ DMA2_S2CR_PSIZE_Shift, 11   @ bitWidth 2 (Peripheral data size)  
        .equ DMA2_S2CR_MINC, 1 << 10   @ bitWidth 1 (Memory increment mode)  
        .equ DMA2_S2CR_PINC, 1 << 9   @ bitWidth 1 (Peripheral increment mode)  
        .equ DMA2_S2CR_CIRC, 1 << 8   @ bitWidth 1 (Circular mode)  
        .equ DMA2_S2CR_DIR_Shift, 6   @ bitWidth 2 (Data transfer direction)  
        .equ DMA2_S2CR_PFCTRL, 1 << 5   @ bitWidth 1 (Peripheral flow controller)  
        .equ DMA2_S2CR_TCIE, 1 << 4   @ bitWidth 1 (Transfer complete interrupt  enable)  
        .equ DMA2_S2CR_HTIE, 1 << 3   @ bitWidth 1 (Half transfer interrupt  enable)  
        .equ DMA2_S2CR_TEIE, 1 << 2   @ bitWidth 1 (Transfer error interrupt  enable)  
        .equ DMA2_S2CR_DMEIE, 1 << 1   @ bitWidth 1 (Direct mode error interrupt  enable)  
        .equ DMA2_S2CR_EN, 1 << 0   @ bitWidth 1 (Stream enable / flag stream ready when  read low)  
 
    .equ DMA2_S2NDTR, DMA2_BASE + 0x44 @ (stream x number of data  register) 
        .equ DMA2_S2NDTR_NDT_Shift, 0   @ bitWidth 16 (Number of data items to  transfer)  
 
    .equ DMA2_S2PAR, DMA2_BASE + 0x48 @ (stream x peripheral address  register) 
        .equ DMA2_S2PAR_PA_Shift, 0   @ bitWidth 32 (Peripheral address)  
 
    .equ DMA2_S2M0AR, DMA2_BASE + 0x4C @ (stream x memory 0 address  register) 
        .equ DMA2_S2M0AR_M0A_Shift, 0   @ bitWidth 32 (Memory 0 address)  
 
    .equ DMA2_S2M1AR, DMA2_BASE + 0x50 @ (stream x memory 1 address  register) 
        .equ DMA2_S2M1AR_M1A_Shift, 0   @ bitWidth 32 (Memory 1 address used in case of Double  buffer mode)  
 
    .equ DMA2_S2FCR, DMA2_BASE + 0x54 @ (stream x FIFO control register) 
        .equ DMA2_S2FCR_FEIE, 1 << 7   @ bitWidth 1 (FIFO error interrupt  enable)  
        .equ DMA2_S2FCR_FS_Shift, 3   @ bitWidth 3 (FIFO status)  
        .equ DMA2_S2FCR_DMDIS, 1 << 2   @ bitWidth 1 (Direct mode disable)  
        .equ DMA2_S2FCR_FTH_Shift, 0   @ bitWidth 2 (FIFO threshold selection)  
 
    .equ DMA2_S3CR, DMA2_BASE + 0x58 @ (stream x configuration  register) 
        .equ DMA2_S3CR_MBURST_Shift, 23   @ bitWidth 2 (Memory burst transfer  configuration)  
        .equ DMA2_S3CR_PBURST_Shift, 21   @ bitWidth 2 (Peripheral burst transfer  configuration)  
        .equ DMA2_S3CR_ACK, 1 << 20   @ bitWidth 1 (ACK)  
        .equ DMA2_S3CR_CT, 1 << 19   @ bitWidth 1 (Current target only in double buffer  mode)  
        .equ DMA2_S3CR_DBM, 1 << 18   @ bitWidth 1 (Double buffer mode)  
        .equ DMA2_S3CR_PL_Shift, 16   @ bitWidth 2 (Priority level)  
        .equ DMA2_S3CR_PINCOS, 1 << 15   @ bitWidth 1 (Peripheral increment offset  size)  
        .equ DMA2_S3CR_MSIZE_Shift, 13   @ bitWidth 2 (Memory data size)  
        .equ DMA2_S3CR_PSIZE_Shift, 11   @ bitWidth 2 (Peripheral data size)  
        .equ DMA2_S3CR_MINC, 1 << 10   @ bitWidth 1 (Memory increment mode)  
        .equ DMA2_S3CR_PINC, 1 << 9   @ bitWidth 1 (Peripheral increment mode)  
        .equ DMA2_S3CR_CIRC, 1 << 8   @ bitWidth 1 (Circular mode)  
        .equ DMA2_S3CR_DIR_Shift, 6   @ bitWidth 2 (Data transfer direction)  
        .equ DMA2_S3CR_PFCTRL, 1 << 5   @ bitWidth 1 (Peripheral flow controller)  
        .equ DMA2_S3CR_TCIE, 1 << 4   @ bitWidth 1 (Transfer complete interrupt  enable)  
        .equ DMA2_S3CR_HTIE, 1 << 3   @ bitWidth 1 (Half transfer interrupt  enable)  
        .equ DMA2_S3CR_TEIE, 1 << 2   @ bitWidth 1 (Transfer error interrupt  enable)  
        .equ DMA2_S3CR_DMEIE, 1 << 1   @ bitWidth 1 (Direct mode error interrupt  enable)  
        .equ DMA2_S3CR_EN, 1 << 0   @ bitWidth 1 (Stream enable / flag stream ready when  read low)  
 
    .equ DMA2_S3NDTR, DMA2_BASE + 0x5C @ (stream x number of data  register) 
        .equ DMA2_S3NDTR_NDT_Shift, 0   @ bitWidth 16 (Number of data items to  transfer)  
 
    .equ DMA2_S3PAR, DMA2_BASE + 0x60 @ (stream x peripheral address  register) 
        .equ DMA2_S3PAR_PA_Shift, 0   @ bitWidth 32 (Peripheral address)  
 
    .equ DMA2_S3M0AR, DMA2_BASE + 0x64 @ (stream x memory 0 address  register) 
        .equ DMA2_S3M0AR_M0A_Shift, 0   @ bitWidth 32 (Memory 0 address)  
 
    .equ DMA2_S3M1AR, DMA2_BASE + 0x68 @ (stream x memory 1 address  register) 
        .equ DMA2_S3M1AR_M1A_Shift, 0   @ bitWidth 32 (Memory 1 address used in case of Double  buffer mode)  
 
    .equ DMA2_S3FCR, DMA2_BASE + 0x6C @ (stream x FIFO control register) 
        .equ DMA2_S3FCR_FEIE, 1 << 7   @ bitWidth 1 (FIFO error interrupt  enable)  
        .equ DMA2_S3FCR_FS_Shift, 3   @ bitWidth 3 (FIFO status)  
        .equ DMA2_S3FCR_DMDIS, 1 << 2   @ bitWidth 1 (Direct mode disable)  
        .equ DMA2_S3FCR_FTH_Shift, 0   @ bitWidth 2 (FIFO threshold selection)  
 
    .equ DMA2_S4CR, DMA2_BASE + 0x70 @ (stream x configuration  register) 
        .equ DMA2_S4CR_MBURST_Shift, 23   @ bitWidth 2 (Memory burst transfer  configuration)  
        .equ DMA2_S4CR_PBURST_Shift, 21   @ bitWidth 2 (Peripheral burst transfer  configuration)  
        .equ DMA2_S4CR_ACK, 1 << 20   @ bitWidth 1 (ACK)  
        .equ DMA2_S4CR_CT, 1 << 19   @ bitWidth 1 (Current target only in double buffer  mode)  
        .equ DMA2_S4CR_DBM, 1 << 18   @ bitWidth 1 (Double buffer mode)  
        .equ DMA2_S4CR_PL_Shift, 16   @ bitWidth 2 (Priority level)  
        .equ DMA2_S4CR_PINCOS, 1 << 15   @ bitWidth 1 (Peripheral increment offset  size)  
        .equ DMA2_S4CR_MSIZE_Shift, 13   @ bitWidth 2 (Memory data size)  
        .equ DMA2_S4CR_PSIZE_Shift, 11   @ bitWidth 2 (Peripheral data size)  
        .equ DMA2_S4CR_MINC, 1 << 10   @ bitWidth 1 (Memory increment mode)  
        .equ DMA2_S4CR_PINC, 1 << 9   @ bitWidth 1 (Peripheral increment mode)  
        .equ DMA2_S4CR_CIRC, 1 << 8   @ bitWidth 1 (Circular mode)  
        .equ DMA2_S4CR_DIR_Shift, 6   @ bitWidth 2 (Data transfer direction)  
        .equ DMA2_S4CR_PFCTRL, 1 << 5   @ bitWidth 1 (Peripheral flow controller)  
        .equ DMA2_S4CR_TCIE, 1 << 4   @ bitWidth 1 (Transfer complete interrupt  enable)  
        .equ DMA2_S4CR_HTIE, 1 << 3   @ bitWidth 1 (Half transfer interrupt  enable)  
        .equ DMA2_S4CR_TEIE, 1 << 2   @ bitWidth 1 (Transfer error interrupt  enable)  
        .equ DMA2_S4CR_DMEIE, 1 << 1   @ bitWidth 1 (Direct mode error interrupt  enable)  
        .equ DMA2_S4CR_EN, 1 << 0   @ bitWidth 1 (Stream enable / flag stream ready when  read low)  
 
    .equ DMA2_S4NDTR, DMA2_BASE + 0x74 @ (stream x number of data  register) 
        .equ DMA2_S4NDTR_NDT_Shift, 0   @ bitWidth 16 (Number of data items to  transfer)  
 
    .equ DMA2_S4PAR, DMA2_BASE + 0x78 @ (stream x peripheral address  register) 
        .equ DMA2_S4PAR_PA_Shift, 0   @ bitWidth 32 (Peripheral address)  
 
    .equ DMA2_S4M0AR, DMA2_BASE + 0x7C @ (stream x memory 0 address  register) 
        .equ DMA2_S4M0AR_M0A_Shift, 0   @ bitWidth 32 (Memory 0 address)  
 
    .equ DMA2_S4M1AR, DMA2_BASE + 0x80 @ (stream x memory 1 address  register) 
        .equ DMA2_S4M1AR_M1A_Shift, 0   @ bitWidth 32 (Memory 1 address used in case of Double  buffer mode)  
 
    .equ DMA2_S4FCR, DMA2_BASE + 0x84 @ (stream x FIFO control register) 
        .equ DMA2_S4FCR_FEIE, 1 << 7   @ bitWidth 1 (FIFO error interrupt  enable)  
        .equ DMA2_S4FCR_FS_Shift, 3   @ bitWidth 3 (FIFO status)  
        .equ DMA2_S4FCR_DMDIS, 1 << 2   @ bitWidth 1 (Direct mode disable)  
        .equ DMA2_S4FCR_FTH_Shift, 0   @ bitWidth 2 (FIFO threshold selection)  
 
    .equ DMA2_S5CR, DMA2_BASE + 0x88 @ (stream x configuration  register) 
        .equ DMA2_S5CR_MBURST_Shift, 23   @ bitWidth 2 (Memory burst transfer  configuration)  
        .equ DMA2_S5CR_PBURST_Shift, 21   @ bitWidth 2 (Peripheral burst transfer  configuration)  
        .equ DMA2_S5CR_ACK, 1 << 20   @ bitWidth 1 (ACK)  
        .equ DMA2_S5CR_CT, 1 << 19   @ bitWidth 1 (Current target only in double buffer  mode)  
        .equ DMA2_S5CR_DBM, 1 << 18   @ bitWidth 1 (Double buffer mode)  
        .equ DMA2_S5CR_PL_Shift, 16   @ bitWidth 2 (Priority level)  
        .equ DMA2_S5CR_PINCOS, 1 << 15   @ bitWidth 1 (Peripheral increment offset  size)  
        .equ DMA2_S5CR_MSIZE_Shift, 13   @ bitWidth 2 (Memory data size)  
        .equ DMA2_S5CR_PSIZE_Shift, 11   @ bitWidth 2 (Peripheral data size)  
        .equ DMA2_S5CR_MINC, 1 << 10   @ bitWidth 1 (Memory increment mode)  
        .equ DMA2_S5CR_PINC, 1 << 9   @ bitWidth 1 (Peripheral increment mode)  
        .equ DMA2_S5CR_CIRC, 1 << 8   @ bitWidth 1 (Circular mode)  
        .equ DMA2_S5CR_DIR_Shift, 6   @ bitWidth 2 (Data transfer direction)  
        .equ DMA2_S5CR_PFCTRL, 1 << 5   @ bitWidth 1 (Peripheral flow controller)  
        .equ DMA2_S5CR_TCIE, 1 << 4   @ bitWidth 1 (Transfer complete interrupt  enable)  
        .equ DMA2_S5CR_HTIE, 1 << 3   @ bitWidth 1 (Half transfer interrupt  enable)  
        .equ DMA2_S5CR_TEIE, 1 << 2   @ bitWidth 1 (Transfer error interrupt  enable)  
        .equ DMA2_S5CR_DMEIE, 1 << 1   @ bitWidth 1 (Direct mode error interrupt  enable)  
        .equ DMA2_S5CR_EN, 1 << 0   @ bitWidth 1 (Stream enable / flag stream ready when  read low)  
 
    .equ DMA2_S5NDTR, DMA2_BASE + 0x8C @ (stream x number of data  register) 
        .equ DMA2_S5NDTR_NDT_Shift, 0   @ bitWidth 16 (Number of data items to  transfer)  
 
    .equ DMA2_S5PAR, DMA2_BASE + 0x90 @ (stream x peripheral address  register) 
        .equ DMA2_S5PAR_PA_Shift, 0   @ bitWidth 32 (Peripheral address)  
 
    .equ DMA2_S5M0AR, DMA2_BASE + 0x94 @ (stream x memory 0 address  register) 
        .equ DMA2_S5M0AR_M0A_Shift, 0   @ bitWidth 32 (Memory 0 address)  
 
    .equ DMA2_S5M1AR, DMA2_BASE + 0x98 @ (stream x memory 1 address  register) 
        .equ DMA2_S5M1AR_M1A_Shift, 0   @ bitWidth 32 (Memory 1 address used in case of Double  buffer mode)  
 
    .equ DMA2_S5FCR, DMA2_BASE + 0x9C @ (stream x FIFO control register) 
        .equ DMA2_S5FCR_FEIE, 1 << 7   @ bitWidth 1 (FIFO error interrupt  enable)  
        .equ DMA2_S5FCR_FS_Shift, 3   @ bitWidth 3 (FIFO status)  
        .equ DMA2_S5FCR_DMDIS, 1 << 2   @ bitWidth 1 (Direct mode disable)  
        .equ DMA2_S5FCR_FTH_Shift, 0   @ bitWidth 2 (FIFO threshold selection)  
 
    .equ DMA2_S6CR, DMA2_BASE + 0xA0 @ (stream x configuration  register) 
        .equ DMA2_S6CR_MBURST_Shift, 23   @ bitWidth 2 (Memory burst transfer  configuration)  
        .equ DMA2_S6CR_PBURST_Shift, 21   @ bitWidth 2 (Peripheral burst transfer  configuration)  
        .equ DMA2_S6CR_ACK, 1 << 20   @ bitWidth 1 (ACK)  
        .equ DMA2_S6CR_CT, 1 << 19   @ bitWidth 1 (Current target only in double buffer  mode)  
        .equ DMA2_S6CR_DBM, 1 << 18   @ bitWidth 1 (Double buffer mode)  
        .equ DMA2_S6CR_PL_Shift, 16   @ bitWidth 2 (Priority level)  
        .equ DMA2_S6CR_PINCOS, 1 << 15   @ bitWidth 1 (Peripheral increment offset  size)  
        .equ DMA2_S6CR_MSIZE_Shift, 13   @ bitWidth 2 (Memory data size)  
        .equ DMA2_S6CR_PSIZE_Shift, 11   @ bitWidth 2 (Peripheral data size)  
        .equ DMA2_S6CR_MINC, 1 << 10   @ bitWidth 1 (Memory increment mode)  
        .equ DMA2_S6CR_PINC, 1 << 9   @ bitWidth 1 (Peripheral increment mode)  
        .equ DMA2_S6CR_CIRC, 1 << 8   @ bitWidth 1 (Circular mode)  
        .equ DMA2_S6CR_DIR_Shift, 6   @ bitWidth 2 (Data transfer direction)  
        .equ DMA2_S6CR_PFCTRL, 1 << 5   @ bitWidth 1 (Peripheral flow controller)  
        .equ DMA2_S6CR_TCIE, 1 << 4   @ bitWidth 1 (Transfer complete interrupt  enable)  
        .equ DMA2_S6CR_HTIE, 1 << 3   @ bitWidth 1 (Half transfer interrupt  enable)  
        .equ DMA2_S6CR_TEIE, 1 << 2   @ bitWidth 1 (Transfer error interrupt  enable)  
        .equ DMA2_S6CR_DMEIE, 1 << 1   @ bitWidth 1 (Direct mode error interrupt  enable)  
        .equ DMA2_S6CR_EN, 1 << 0   @ bitWidth 1 (Stream enable / flag stream ready when  read low)  
 
    .equ DMA2_S6NDTR, DMA2_BASE + 0xA4 @ (stream x number of data  register) 
        .equ DMA2_S6NDTR_NDT_Shift, 0   @ bitWidth 16 (Number of data items to  transfer)  
 
    .equ DMA2_S6PAR, DMA2_BASE + 0xA8 @ (stream x peripheral address  register) 
        .equ DMA2_S6PAR_PA_Shift, 0   @ bitWidth 32 (Peripheral address)  
 
    .equ DMA2_S6M0AR, DMA2_BASE + 0xAC @ (stream x memory 0 address  register) 
        .equ DMA2_S6M0AR_M0A_Shift, 0   @ bitWidth 32 (Memory 0 address)  
 
    .equ DMA2_S6M1AR, DMA2_BASE + 0xB0 @ (stream x memory 1 address  register) 
        .equ DMA2_S6M1AR_M1A_Shift, 0   @ bitWidth 32 (Memory 1 address used in case of Double  buffer mode)  
 
    .equ DMA2_S6FCR, DMA2_BASE + 0xB4 @ (stream x FIFO control register) 
        .equ DMA2_S6FCR_FEIE, 1 << 7   @ bitWidth 1 (FIFO error interrupt  enable)  
        .equ DMA2_S6FCR_FS_Shift, 3   @ bitWidth 3 (FIFO status)  
        .equ DMA2_S6FCR_DMDIS, 1 << 2   @ bitWidth 1 (Direct mode disable)  
        .equ DMA2_S6FCR_FTH_Shift, 0   @ bitWidth 2 (FIFO threshold selection)  
 
    .equ DMA2_S7CR, DMA2_BASE + 0xB8 @ (stream x configuration  register) 
        .equ DMA2_S7CR_MBURST_Shift, 23   @ bitWidth 2 (Memory burst transfer  configuration)  
        .equ DMA2_S7CR_PBURST_Shift, 21   @ bitWidth 2 (Peripheral burst transfer  configuration)  
        .equ DMA2_S7CR_ACK, 1 << 20   @ bitWidth 1 (ACK)  
        .equ DMA2_S7CR_CT, 1 << 19   @ bitWidth 1 (Current target only in double buffer  mode)  
        .equ DMA2_S7CR_DBM, 1 << 18   @ bitWidth 1 (Double buffer mode)  
        .equ DMA2_S7CR_PL_Shift, 16   @ bitWidth 2 (Priority level)  
        .equ DMA2_S7CR_PINCOS, 1 << 15   @ bitWidth 1 (Peripheral increment offset  size)  
        .equ DMA2_S7CR_MSIZE_Shift, 13   @ bitWidth 2 (Memory data size)  
        .equ DMA2_S7CR_PSIZE_Shift, 11   @ bitWidth 2 (Peripheral data size)  
        .equ DMA2_S7CR_MINC, 1 << 10   @ bitWidth 1 (Memory increment mode)  
        .equ DMA2_S7CR_PINC, 1 << 9   @ bitWidth 1 (Peripheral increment mode)  
        .equ DMA2_S7CR_CIRC, 1 << 8   @ bitWidth 1 (Circular mode)  
        .equ DMA2_S7CR_DIR_Shift, 6   @ bitWidth 2 (Data transfer direction)  
        .equ DMA2_S7CR_PFCTRL, 1 << 5   @ bitWidth 1 (Peripheral flow controller)  
        .equ DMA2_S7CR_TCIE, 1 << 4   @ bitWidth 1 (Transfer complete interrupt  enable)  
        .equ DMA2_S7CR_HTIE, 1 << 3   @ bitWidth 1 (Half transfer interrupt  enable)  
        .equ DMA2_S7CR_TEIE, 1 << 2   @ bitWidth 1 (Transfer error interrupt  enable)  
        .equ DMA2_S7CR_DMEIE, 1 << 1   @ bitWidth 1 (Direct mode error interrupt  enable)  
        .equ DMA2_S7CR_EN, 1 << 0   @ bitWidth 1 (Stream enable / flag stream ready when  read low)  
 
    .equ DMA2_S7NDTR, DMA2_BASE + 0xBC @ (stream x number of data  register) 
        .equ DMA2_S7NDTR_NDT_Shift, 0   @ bitWidth 16 (Number of data items to  transfer)  
 
    .equ DMA2_S7PAR, DMA2_BASE + 0xC0 @ (stream x peripheral address  register) 
        .equ DMA2_S7PAR_PA_Shift, 0   @ bitWidth 32 (Peripheral address)  
 
    .equ DMA2_S7M0AR, DMA2_BASE + 0xC4 @ (stream x memory 0 address  register) 
        .equ DMA2_S7M0AR_M0A_Shift, 0   @ bitWidth 32 (Memory 0 address)  
 
    .equ DMA2_S7M1AR, DMA2_BASE + 0xC8 @ (stream x memory 1 address  register) 
        .equ DMA2_S7M1AR_M1A_Shift, 0   @ bitWidth 32 (Memory 1 address used in case of Double  buffer mode)  
 
    .equ DMA2_S7FCR, DMA2_BASE + 0xCC @ (stream x FIFO control register) 
        .equ DMA2_S7FCR_FEIE, 1 << 7   @ bitWidth 1 (FIFO error interrupt  enable)  
        .equ DMA2_S7FCR_FS_Shift, 3   @ bitWidth 3 (FIFO status)  
        .equ DMA2_S7FCR_DMDIS, 1 << 2   @ bitWidth 1 (Direct mode disable)  
        .equ DMA2_S7FCR_FTH_Shift, 0   @ bitWidth 2 (FIFO threshold selection)  
 

@=========================== HRTIM_Master ===========================@
.equ HRTIM_Master_BASE, 0x40017400 @ (High Resolution Timer: Master  Timers) 
    .equ HRTIM_Master_MCR, HRTIM_Master_BASE + 0x0 @ (Master Timer Control Register) 
        .equ HRTIM_Master_MCR_BRSTDMA_Shift, 30   @ bitWidth 2 (Burst DMA Update)  
        .equ HRTIM_Master_MCR_MREPU, 1 << 29   @ bitWidth 1 (Master Timer Repetition  update)  
        .equ HRTIM_Master_MCR_PREEN, 1 << 27   @ bitWidth 1 (Preload enable)  
        .equ HRTIM_Master_MCR_DACSYNC_Shift, 25   @ bitWidth 2 (AC Synchronization)  
        .equ HRTIM_Master_MCR_TECEN, 1 << 21   @ bitWidth 1 (Timer E counter enable)  
        .equ HRTIM_Master_MCR_TDCEN, 1 << 20   @ bitWidth 1 (Timer D counter enable)  
        .equ HRTIM_Master_MCR_TCCEN, 1 << 19   @ bitWidth 1 (Timer C counter enable)  
        .equ HRTIM_Master_MCR_TBCEN, 1 << 18   @ bitWidth 1 (Timer B counter enable)  
        .equ HRTIM_Master_MCR_TACEN, 1 << 17   @ bitWidth 1 (Timer A counter enable)  
        .equ HRTIM_Master_MCR_MCEN, 1 << 16   @ bitWidth 1 (Master Counter enable)  
        .equ HRTIM_Master_MCR_SYNC_SRC_Shift, 14   @ bitWidth 2 (Synchronization source)  
        .equ HRTIM_Master_MCR_SYNC_OUT_Shift, 12   @ bitWidth 2 (Synchronization output)  
        .equ HRTIM_Master_MCR_SYNCSTRTM, 1 << 11   @ bitWidth 1 (Synchronization Starts  Master)  
        .equ HRTIM_Master_MCR_SYNCRSTM, 1 << 10   @ bitWidth 1 (Synchronization Resets  Master)  
        .equ HRTIM_Master_MCR_SYNC_IN_Shift, 8   @ bitWidth 2 (ynchronization input)  
        .equ HRTIM_Master_MCR_HALF, 1 << 5   @ bitWidth 1 (Half mode enable)  
        .equ HRTIM_Master_MCR_RETRIG, 1 << 4   @ bitWidth 1 (Master Re-triggerable mode)  
        .equ HRTIM_Master_MCR_CONT, 1 << 3   @ bitWidth 1 (Master Continuous mode)  
        .equ HRTIM_Master_MCR_CK_PSC_Shift, 0   @ bitWidth 3 (HRTIM Master Clock  prescaler)  
 
    .equ HRTIM_Master_MISR, HRTIM_Master_BASE + 0x4 @ (Master Timer Interrupt Status  Register) 
        .equ HRTIM_Master_MISR_MUPD, 1 << 6   @ bitWidth 1 (Master Update Interrupt  Flag)  
        .equ HRTIM_Master_MISR_SYNC, 1 << 5   @ bitWidth 1 (Sync Input Interrupt Flag)  
        .equ HRTIM_Master_MISR_MREP, 1 << 4   @ bitWidth 1 (Master Repetition Interrupt  Flag)  
        .equ HRTIM_Master_MISR_MCMP4, 1 << 3   @ bitWidth 1 (Master Compare 4 Interrupt  Flag)  
        .equ HRTIM_Master_MISR_MCMP3, 1 << 2   @ bitWidth 1 (Master Compare 3 Interrupt  Flag)  
        .equ HRTIM_Master_MISR_MCMP2, 1 << 1   @ bitWidth 1 (Master Compare 2 Interrupt  Flag)  
        .equ HRTIM_Master_MISR_MCMP1, 1 << 0   @ bitWidth 1 (Master Compare 1 Interrupt  Flag)  
 
    .equ HRTIM_Master_MICR, HRTIM_Master_BASE + 0x8 @ (Master Timer Interrupt Clear  Register) 
        .equ HRTIM_Master_MICR_MUPDC, 1 << 6   @ bitWidth 1 (Master update Interrupt flag  clear)  
        .equ HRTIM_Master_MICR_SYNCC, 1 << 5   @ bitWidth 1 (Sync Input Interrupt flag  clear)  
        .equ HRTIM_Master_MICR_MREPC, 1 << 4   @ bitWidth 1 (Repetition Interrupt flag  clear)  
        .equ HRTIM_Master_MICR_MCMP4C, 1 << 3   @ bitWidth 1 (Master Compare 4 Interrupt flag  clear)  
        .equ HRTIM_Master_MICR_MCMP3C, 1 << 2   @ bitWidth 1 (Master Compare 3 Interrupt flag  clear)  
        .equ HRTIM_Master_MICR_MCMP2C, 1 << 1   @ bitWidth 1 (Master Compare 2 Interrupt flag  clear)  
        .equ HRTIM_Master_MICR_MCMP1C, 1 << 0   @ bitWidth 1 (Master Compare 1 Interrupt flag  clear)  
 
    .equ HRTIM_Master_MDIER4, HRTIM_Master_BASE + 0xC @ (MDIER4) 
        .equ HRTIM_Master_MDIER4_MUPDDE, 1 << 22   @ bitWidth 1 (MUPDDE)  
        .equ HRTIM_Master_MDIER4_SYNCDE, 1 << 21   @ bitWidth 1 (SYNCDE)  
        .equ HRTIM_Master_MDIER4_MREPDE, 1 << 20   @ bitWidth 1 (MREPDE)  
        .equ HRTIM_Master_MDIER4_MCMP4DE, 1 << 19   @ bitWidth 1 (MCMP4DE)  
        .equ HRTIM_Master_MDIER4_MCMP3DE, 1 << 18   @ bitWidth 1 (MCMP3DE)  
        .equ HRTIM_Master_MDIER4_MCMP2DE, 1 << 17   @ bitWidth 1 (MCMP2DE)  
        .equ HRTIM_Master_MDIER4_MCMP1DE, 1 << 16   @ bitWidth 1 (MCMP1DE)  
        .equ HRTIM_Master_MDIER4_MUPDIE, 1 << 6   @ bitWidth 1 (MUPDIE)  
        .equ HRTIM_Master_MDIER4_SYNCIE, 1 << 5   @ bitWidth 1 (SYNCIE)  
        .equ HRTIM_Master_MDIER4_MREPIE, 1 << 4   @ bitWidth 1 (MREPIE)  
        .equ HRTIM_Master_MDIER4_MCMP4IE, 1 << 3   @ bitWidth 1 (MCMP4IE)  
        .equ HRTIM_Master_MDIER4_MCMP3IE, 1 << 2   @ bitWidth 1 (MCMP3IE)  
        .equ HRTIM_Master_MDIER4_MCMP2IE, 1 << 1   @ bitWidth 1 (MCMP2IE)  
        .equ HRTIM_Master_MDIER4_MCMP1IE, 1 << 0   @ bitWidth 1 (MCMP1IE)  
 
    .equ HRTIM_Master_MCNTR, HRTIM_Master_BASE + 0x10 @ (Master Timer Counter Register) 
        .equ HRTIM_Master_MCNTR_MCNT_Shift, 0   @ bitWidth 16 (Counter value)  
 
    .equ HRTIM_Master_MPER, HRTIM_Master_BASE + 0x14 @ (Master Timer Period Register) 
        .equ HRTIM_Master_MPER_MPER_Shift, 0   @ bitWidth 16 (Master Timer Period value)  
 
    .equ HRTIM_Master_MREP, HRTIM_Master_BASE + 0x18 @ (Master Timer Repetition  Register) 
        .equ HRTIM_Master_MREP_MREP_Shift, 0   @ bitWidth 8 (Master Timer Repetition counter  value)  
 
    .equ HRTIM_Master_MCMP1R, HRTIM_Master_BASE + 0x1C @ (Master Timer Compare 1  Register) 
        .equ HRTIM_Master_MCMP1R_MCMP1_Shift, 0   @ bitWidth 16 (Master Timer Compare 1  value)  
 
    .equ HRTIM_Master_MCMP2R, HRTIM_Master_BASE + 0x24 @ (Master Timer Compare 2  Register) 
        .equ HRTIM_Master_MCMP2R_MCMP2_Shift, 0   @ bitWidth 16 (Master Timer Compare 2  value)  
 
    .equ HRTIM_Master_MCMP3R, HRTIM_Master_BASE + 0x28 @ (Master Timer Compare 3  Register) 
        .equ HRTIM_Master_MCMP3R_MCMP3_Shift, 0   @ bitWidth 16 (Master Timer Compare 3  value)  
 
    .equ HRTIM_Master_MCMP4R, HRTIM_Master_BASE + 0x2C @ (Master Timer Compare 4  Register) 
        .equ HRTIM_Master_MCMP4R_MCMP4_Shift, 0   @ bitWidth 16 (Master Timer Compare 4  value)  
 

@=========================== HRTIM_TIMA ===========================@
.equ HRTIM_TIMA_BASE, 0x40017480 @ (High Resolution Timer: TIMA) 
    .equ HRTIM_TIMA_TIMACR, HRTIM_TIMA_BASE + 0x0 @ (Timerx Control Register) 
        .equ HRTIM_TIMA_TIMACR_UPDGAT_Shift, 28   @ bitWidth 4 (Update Gating)  
        .equ HRTIM_TIMA_TIMACR_PREEN, 1 << 27   @ bitWidth 1 (Preload enable)  
        .equ HRTIM_TIMA_TIMACR_DACSYNC_Shift, 25   @ bitWidth 2 (AC Synchronization)  
        .equ HRTIM_TIMA_TIMACR_MSTU, 1 << 24   @ bitWidth 1 (Master Timer update)  
        .equ HRTIM_TIMA_TIMACR_TEU, 1 << 23   @ bitWidth 1 (TEU)  
        .equ HRTIM_TIMA_TIMACR_TDU, 1 << 22   @ bitWidth 1 (TDU)  
        .equ HRTIM_TIMA_TIMACR_TCU, 1 << 21   @ bitWidth 1 (TCU)  
        .equ HRTIM_TIMA_TIMACR_TBU, 1 << 20   @ bitWidth 1 (TBU)  
        .equ HRTIM_TIMA_TIMACR_TxRSTU, 1 << 18   @ bitWidth 1 (Timerx reset update)  
        .equ HRTIM_TIMA_TIMACR_TxREPU, 1 << 17   @ bitWidth 1 (Timer x Repetition update)  
        .equ HRTIM_TIMA_TIMACR_DELCMP4_Shift, 14   @ bitWidth 2 (Delayed CMP4 mode)  
        .equ HRTIM_TIMA_TIMACR_DELCMP2_Shift, 12   @ bitWidth 2 (Delayed CMP2 mode)  
        .equ HRTIM_TIMA_TIMACR_SYNCSTRTx, 1 << 11   @ bitWidth 1 (Synchronization Starts Timer  x)  
        .equ HRTIM_TIMA_TIMACR_SYNCRSTx, 1 << 10   @ bitWidth 1 (Synchronization Resets Timer  x)  
        .equ HRTIM_TIMA_TIMACR_PSHPLL, 1 << 6   @ bitWidth 1 (Push-Pull mode enable)  
        .equ HRTIM_TIMA_TIMACR_HALF, 1 << 5   @ bitWidth 1 (Half mode enable)  
        .equ HRTIM_TIMA_TIMACR_RETRIG, 1 << 4   @ bitWidth 1 (Re-triggerable mode)  
        .equ HRTIM_TIMA_TIMACR_CONT, 1 << 3   @ bitWidth 1 (Continuous mode)  
        .equ HRTIM_TIMA_TIMACR_CK_PSCx_Shift, 0   @ bitWidth 3 (HRTIM Timer x Clock  prescaler)  
 
    .equ HRTIM_TIMA_TIMAISR, HRTIM_TIMA_BASE + 0x4 @ (Timerx Interrupt Status  Register) 
        .equ HRTIM_TIMA_TIMAISR_O2STAT, 1 << 19   @ bitWidth 1 (Output 2 State)  
        .equ HRTIM_TIMA_TIMAISR_O1STAT, 1 << 18   @ bitWidth 1 (Output 1 State)  
        .equ HRTIM_TIMA_TIMAISR_IPPSTAT, 1 << 17   @ bitWidth 1 (Idle Push Pull Status)  
        .equ HRTIM_TIMA_TIMAISR_CPPSTAT, 1 << 16   @ bitWidth 1 (Current Push Pull Status)  
        .equ HRTIM_TIMA_TIMAISR_DLYPRT, 1 << 14   @ bitWidth 1 (Delayed Protection Flag)  
        .equ HRTIM_TIMA_TIMAISR_RST, 1 << 13   @ bitWidth 1 (Reset Interrupt Flag)  
        .equ HRTIM_TIMA_TIMAISR_RSTx2, 1 << 12   @ bitWidth 1 (Output 2 Reset Interrupt  Flag)  
        .equ HRTIM_TIMA_TIMAISR_SETx2, 1 << 11   @ bitWidth 1 (Output 2 Set Interrupt  Flag)  
        .equ HRTIM_TIMA_TIMAISR_RSTx1, 1 << 10   @ bitWidth 1 (Output 1 Reset Interrupt  Flag)  
        .equ HRTIM_TIMA_TIMAISR_SETx1, 1 << 9   @ bitWidth 1 (Output 1 Set Interrupt  Flag)  
        .equ HRTIM_TIMA_TIMAISR_CPT2, 1 << 8   @ bitWidth 1 (Capture2 Interrupt Flag)  
        .equ HRTIM_TIMA_TIMAISR_CPT1, 1 << 7   @ bitWidth 1 (Capture1 Interrupt Flag)  
        .equ HRTIM_TIMA_TIMAISR_UPD, 1 << 6   @ bitWidth 1 (Update Interrupt Flag)  
        .equ HRTIM_TIMA_TIMAISR_REP, 1 << 4   @ bitWidth 1 (Repetition Interrupt Flag)  
        .equ HRTIM_TIMA_TIMAISR_CMP4, 1 << 3   @ bitWidth 1 (Compare 4 Interrupt Flag)  
        .equ HRTIM_TIMA_TIMAISR_CMP3, 1 << 2   @ bitWidth 1 (Compare 3 Interrupt Flag)  
        .equ HRTIM_TIMA_TIMAISR_CMP2, 1 << 1   @ bitWidth 1 (Compare 2 Interrupt Flag)  
        .equ HRTIM_TIMA_TIMAISR_CMP1, 1 << 0   @ bitWidth 1 (Compare 1 Interrupt Flag)  
 
    .equ HRTIM_TIMA_TIMAICR, HRTIM_TIMA_BASE + 0x8 @ (Timerx Interrupt Clear  Register) 
        .equ HRTIM_TIMA_TIMAICR_DLYPRTC, 1 << 14   @ bitWidth 1 (Delayed Protection Flag  Clear)  
        .equ HRTIM_TIMA_TIMAICR_RSTC, 1 << 13   @ bitWidth 1 (Reset Interrupt flag Clear)  
        .equ HRTIM_TIMA_TIMAICR_RSTx2C, 1 << 12   @ bitWidth 1 (Output 2 Reset flag Clear)  
        .equ HRTIM_TIMA_TIMAICR_SET2xC, 1 << 11   @ bitWidth 1 (Output 2 Set flag Clear)  
        .equ HRTIM_TIMA_TIMAICR_RSTx1C, 1 << 10   @ bitWidth 1 (Output 1 Reset flag Clear)  
        .equ HRTIM_TIMA_TIMAICR_SET1xC, 1 << 9   @ bitWidth 1 (Output 1 Set flag Clear)  
        .equ HRTIM_TIMA_TIMAICR_CPT2C, 1 << 8   @ bitWidth 1 (Capture2 Interrupt flag  Clear)  
        .equ HRTIM_TIMA_TIMAICR_CPT1C, 1 << 7   @ bitWidth 1 (Capture1 Interrupt flag  Clear)  
        .equ HRTIM_TIMA_TIMAICR_UPDC, 1 << 6   @ bitWidth 1 (Update Interrupt flag  Clear)  
        .equ HRTIM_TIMA_TIMAICR_REPC, 1 << 4   @ bitWidth 1 (Repetition Interrupt flag  Clear)  
        .equ HRTIM_TIMA_TIMAICR_CMP4C, 1 << 3   @ bitWidth 1 (Compare 4 Interrupt flag  Clear)  
        .equ HRTIM_TIMA_TIMAICR_CMP3C, 1 << 2   @ bitWidth 1 (Compare 3 Interrupt flag  Clear)  
        .equ HRTIM_TIMA_TIMAICR_CMP2C, 1 << 1   @ bitWidth 1 (Compare 2 Interrupt flag  Clear)  
        .equ HRTIM_TIMA_TIMAICR_CMP1C, 1 << 0   @ bitWidth 1 (Compare 1 Interrupt flag  Clear)  
 
    .equ HRTIM_TIMA_TIMADIER5, HRTIM_TIMA_BASE + 0xC @ (TIMxDIER5) 
        .equ HRTIM_TIMA_TIMADIER5_DLYPRTDE, 1 << 30   @ bitWidth 1 (DLYPRTDE)  
        .equ HRTIM_TIMA_TIMADIER5_RSTDE, 1 << 29   @ bitWidth 1 (RSTDE)  
        .equ HRTIM_TIMA_TIMADIER5_RSTx2DE, 1 << 28   @ bitWidth 1 (RSTx2DE)  
        .equ HRTIM_TIMA_TIMADIER5_SETx2DE, 1 << 27   @ bitWidth 1 (SETx2DE)  
        .equ HRTIM_TIMA_TIMADIER5_RSTx1DE, 1 << 26   @ bitWidth 1 (RSTx1DE)  
        .equ HRTIM_TIMA_TIMADIER5_SET1xDE, 1 << 25   @ bitWidth 1 (SET1xDE)  
        .equ HRTIM_TIMA_TIMADIER5_CPT2DE, 1 << 24   @ bitWidth 1 (CPT2DE)  
        .equ HRTIM_TIMA_TIMADIER5_CPT1DE, 1 << 23   @ bitWidth 1 (CPT1DE)  
        .equ HRTIM_TIMA_TIMADIER5_UPDDE, 1 << 22   @ bitWidth 1 (UPDDE)  
        .equ HRTIM_TIMA_TIMADIER5_REPDE, 1 << 20   @ bitWidth 1 (REPDE)  
        .equ HRTIM_TIMA_TIMADIER5_CMP4DE, 1 << 19   @ bitWidth 1 (CMP4DE)  
        .equ HRTIM_TIMA_TIMADIER5_CMP3DE, 1 << 18   @ bitWidth 1 (CMP3DE)  
        .equ HRTIM_TIMA_TIMADIER5_CMP2DE, 1 << 17   @ bitWidth 1 (CMP2DE)  
        .equ HRTIM_TIMA_TIMADIER5_CMP1DE, 1 << 16   @ bitWidth 1 (CMP1DE)  
        .equ HRTIM_TIMA_TIMADIER5_DLYPRTIE, 1 << 14   @ bitWidth 1 (DLYPRTIE)  
        .equ HRTIM_TIMA_TIMADIER5_RSTIE, 1 << 13   @ bitWidth 1 (RSTIE)  
        .equ HRTIM_TIMA_TIMADIER5_RSTx2IE, 1 << 12   @ bitWidth 1 (RSTx2IE)  
        .equ HRTIM_TIMA_TIMADIER5_SETx2IE, 1 << 11   @ bitWidth 1 (SETx2IE)  
        .equ HRTIM_TIMA_TIMADIER5_RSTx1IE, 1 << 10   @ bitWidth 1 (RSTx1IE)  
        .equ HRTIM_TIMA_TIMADIER5_SET1xIE, 1 << 9   @ bitWidth 1 (SET1xIE)  
        .equ HRTIM_TIMA_TIMADIER5_CPT2IE, 1 << 8   @ bitWidth 1 (CPT2IE)  
        .equ HRTIM_TIMA_TIMADIER5_CPT1IE, 1 << 7   @ bitWidth 1 (CPT1IE)  
        .equ HRTIM_TIMA_TIMADIER5_UPDIE, 1 << 6   @ bitWidth 1 (UPDIE)  
        .equ HRTIM_TIMA_TIMADIER5_REPIE, 1 << 4   @ bitWidth 1 (REPIE)  
        .equ HRTIM_TIMA_TIMADIER5_CMP4IE, 1 << 3   @ bitWidth 1 (CMP4IE)  
        .equ HRTIM_TIMA_TIMADIER5_CMP3IE, 1 << 2   @ bitWidth 1 (CMP3IE)  
        .equ HRTIM_TIMA_TIMADIER5_CMP2IE, 1 << 1   @ bitWidth 1 (CMP2IE)  
        .equ HRTIM_TIMA_TIMADIER5_CMP1IE, 1 << 0   @ bitWidth 1 (CMP1IE)  
 
    .equ HRTIM_TIMA_CNTAR, HRTIM_TIMA_BASE + 0x10 @ (Timerx Counter Register) 
        .equ HRTIM_TIMA_CNTAR_CNTx_Shift, 0   @ bitWidth 16 (Timerx Counter value)  
 
    .equ HRTIM_TIMA_PERAR, HRTIM_TIMA_BASE + 0x14 @ (Timerx Period Register) 
        .equ HRTIM_TIMA_PERAR_PERx_Shift, 0   @ bitWidth 16 (Timerx Period value)  
 
    .equ HRTIM_TIMA_REPAR, HRTIM_TIMA_BASE + 0x18 @ (Timerx Repetition Register) 
        .equ HRTIM_TIMA_REPAR_REPx_Shift, 0   @ bitWidth 8 (Timerx Repetition counter  value)  
 
    .equ HRTIM_TIMA_CMP1AR, HRTIM_TIMA_BASE + 0x1C @ (Timerx Compare 1 Register) 
        .equ HRTIM_TIMA_CMP1AR_CMP1x_Shift, 0   @ bitWidth 16 (Timerx Compare 1 value)  
 
    .equ HRTIM_TIMA_CMP1CAR, HRTIM_TIMA_BASE + 0x20 @ (Timerx Compare 1 Compound  Register) 
        .equ HRTIM_TIMA_CMP1CAR_REPx_Shift, 16   @ bitWidth 8 (Timerx Repetition value aliased from  HRTIM_REPx register)  
        .equ HRTIM_TIMA_CMP1CAR_CMP1x_Shift, 0   @ bitWidth 16 (Timerx Compare 1 value)  
 
    .equ HRTIM_TIMA_CMP2AR, HRTIM_TIMA_BASE + 0x24 @ (Timerx Compare 2 Register) 
        .equ HRTIM_TIMA_CMP2AR_CMP2x_Shift, 0   @ bitWidth 16 (Timerx Compare 2 value)  
 
    .equ HRTIM_TIMA_CMP3AR, HRTIM_TIMA_BASE + 0x28 @ (Timerx Compare 3 Register) 
        .equ HRTIM_TIMA_CMP3AR_CMP3x_Shift, 0   @ bitWidth 16 (Timerx Compare 3 value)  
 
    .equ HRTIM_TIMA_CMP4AR, HRTIM_TIMA_BASE + 0x2C @ (Timerx Compare 4 Register) 
        .equ HRTIM_TIMA_CMP4AR_CMP4x_Shift, 0   @ bitWidth 16 (Timerx Compare 4 value)  
 
    .equ HRTIM_TIMA_CPT1AR, HRTIM_TIMA_BASE + 0x30 @ (Timerx Capture 1 Register) 
        .equ HRTIM_TIMA_CPT1AR_CPT1x_Shift, 0   @ bitWidth 16 (Timerx Capture 1 value)  
 
    .equ HRTIM_TIMA_CPT2AR, HRTIM_TIMA_BASE + 0x34 @ (Timerx Capture 2 Register) 
        .equ HRTIM_TIMA_CPT2AR_CPT2x_Shift, 0   @ bitWidth 16 (Timerx Capture 2 value)  
 
    .equ HRTIM_TIMA_DTAR, HRTIM_TIMA_BASE + 0x38 @ (Timerx Deadtime Register) 
        .equ HRTIM_TIMA_DTAR_DTFLKx, 1 << 31   @ bitWidth 1 (Deadtime Falling Lock)  
        .equ HRTIM_TIMA_DTAR_DTFSLKx, 1 << 30   @ bitWidth 1 (Deadtime Falling Sign Lock)  
        .equ HRTIM_TIMA_DTAR_SDTFx, 1 << 25   @ bitWidth 1 (Sign Deadtime Falling  value)  
        .equ HRTIM_TIMA_DTAR_DTFx_Shift, 16   @ bitWidth 9 (Deadtime Falling value)  
        .equ HRTIM_TIMA_DTAR_DTRLKx, 1 << 15   @ bitWidth 1 (Deadtime Rising Lock)  
        .equ HRTIM_TIMA_DTAR_DTRSLKx, 1 << 14   @ bitWidth 1 (Deadtime Rising Sign Lock)  
        .equ HRTIM_TIMA_DTAR_DTPRSC_Shift, 10   @ bitWidth 3 (Deadtime Prescaler)  
        .equ HRTIM_TIMA_DTAR_SDTRx, 1 << 9   @ bitWidth 1 (Sign Deadtime Rising value)  
        .equ HRTIM_TIMA_DTAR_DTRx_Shift, 0   @ bitWidth 9 (Deadtime Rising value)  
 
    .equ HRTIM_TIMA_SETA1R, HRTIM_TIMA_BASE + 0x3C @ (Timerx Output1 Set Register) 
        .equ HRTIM_TIMA_SETA1R_UPDATE, 1 << 31   @ bitWidth 1 (Registers update transfer preload to  active)  
        .equ HRTIM_TIMA_SETA1R_EXTEVNT10, 1 << 30   @ bitWidth 1 (External Event 10)  
        .equ HRTIM_TIMA_SETA1R_EXTEVNT9, 1 << 29   @ bitWidth 1 (External Event 9)  
        .equ HRTIM_TIMA_SETA1R_EXTEVNT8, 1 << 28   @ bitWidth 1 (External Event 8)  
        .equ HRTIM_TIMA_SETA1R_EXTEVNT7, 1 << 27   @ bitWidth 1 (External Event 7)  
        .equ HRTIM_TIMA_SETA1R_EXTEVNT6, 1 << 26   @ bitWidth 1 (External Event 6)  
        .equ HRTIM_TIMA_SETA1R_EXTEVNT5, 1 << 25   @ bitWidth 1 (External Event 5)  
        .equ HRTIM_TIMA_SETA1R_EXTEVNT4, 1 << 24   @ bitWidth 1 (External Event 4)  
        .equ HRTIM_TIMA_SETA1R_EXTEVNT3, 1 << 23   @ bitWidth 1 (External Event 3)  
        .equ HRTIM_TIMA_SETA1R_EXTEVNT2, 1 << 22   @ bitWidth 1 (External Event 2)  
        .equ HRTIM_TIMA_SETA1R_EXTEVNT1, 1 << 21   @ bitWidth 1 (External Event 1)  
        .equ HRTIM_TIMA_SETA1R_TIMEVNT9, 1 << 20   @ bitWidth 1 (Timer Event 9)  
        .equ HRTIM_TIMA_SETA1R_TIMEVNT8, 1 << 19   @ bitWidth 1 (Timer Event 8)  
        .equ HRTIM_TIMA_SETA1R_TIMEVNT7, 1 << 18   @ bitWidth 1 (Timer Event 7)  
        .equ HRTIM_TIMA_SETA1R_TIMEVNT6, 1 << 17   @ bitWidth 1 (Timer Event 6)  
        .equ HRTIM_TIMA_SETA1R_TIMEVNT5, 1 << 16   @ bitWidth 1 (Timer Event 5)  
        .equ HRTIM_TIMA_SETA1R_TIMEVNT4, 1 << 15   @ bitWidth 1 (Timer Event 4)  
        .equ HRTIM_TIMA_SETA1R_TIMEVNT3, 1 << 14   @ bitWidth 1 (Timer Event 3)  
        .equ HRTIM_TIMA_SETA1R_TIMEVNT2, 1 << 13   @ bitWidth 1 (Timer Event 2)  
        .equ HRTIM_TIMA_SETA1R_TIMEVNT1, 1 << 12   @ bitWidth 1 (Timer Event 1)  
        .equ HRTIM_TIMA_SETA1R_MSTCMP4, 1 << 11   @ bitWidth 1 (Master Compare 4)  
        .equ HRTIM_TIMA_SETA1R_MSTCMP3, 1 << 10   @ bitWidth 1 (Master Compare 3)  
        .equ HRTIM_TIMA_SETA1R_MSTCMP2, 1 << 9   @ bitWidth 1 (Master Compare 2)  
        .equ HRTIM_TIMA_SETA1R_MSTCMP1, 1 << 8   @ bitWidth 1 (Master Compare 1)  
        .equ HRTIM_TIMA_SETA1R_MSTPER, 1 << 7   @ bitWidth 1 (Master Period)  
        .equ HRTIM_TIMA_SETA1R_CMP4, 1 << 6   @ bitWidth 1 (Timer A compare 4)  
        .equ HRTIM_TIMA_SETA1R_CMP3, 1 << 5   @ bitWidth 1 (Timer A compare 3)  
        .equ HRTIM_TIMA_SETA1R_CMP2, 1 << 4   @ bitWidth 1 (Timer A compare 2)  
        .equ HRTIM_TIMA_SETA1R_CMP1, 1 << 3   @ bitWidth 1 (Timer A compare 1)  
        .equ HRTIM_TIMA_SETA1R_PER, 1 << 2   @ bitWidth 1 (Timer A Period)  
        .equ HRTIM_TIMA_SETA1R_RESYNC, 1 << 1   @ bitWidth 1 (Timer A resynchronizaton)  
        .equ HRTIM_TIMA_SETA1R_SST, 1 << 0   @ bitWidth 1 (Software Set trigger)  
 
    .equ HRTIM_TIMA_RSTA1R, HRTIM_TIMA_BASE + 0x40 @ (Timerx Output1 Reset Register) 
        .equ HRTIM_TIMA_RSTA1R_UPDATE, 1 << 31   @ bitWidth 1 (UPDATE)  
        .equ HRTIM_TIMA_RSTA1R_EXTEVNT10, 1 << 30   @ bitWidth 1 (EXTEVNT10)  
        .equ HRTIM_TIMA_RSTA1R_EXTEVNT9, 1 << 29   @ bitWidth 1 (EXTEVNT9)  
        .equ HRTIM_TIMA_RSTA1R_EXTEVNT8, 1 << 28   @ bitWidth 1 (EXTEVNT8)  
        .equ HRTIM_TIMA_RSTA1R_EXTEVNT7, 1 << 27   @ bitWidth 1 (EXTEVNT7)  
        .equ HRTIM_TIMA_RSTA1R_EXTEVNT6, 1 << 26   @ bitWidth 1 (EXTEVNT6)  
        .equ HRTIM_TIMA_RSTA1R_EXTEVNT5, 1 << 25   @ bitWidth 1 (EXTEVNT5)  
        .equ HRTIM_TIMA_RSTA1R_EXTEVNT4, 1 << 24   @ bitWidth 1 (EXTEVNT4)  
        .equ HRTIM_TIMA_RSTA1R_EXTEVNT3, 1 << 23   @ bitWidth 1 (EXTEVNT3)  
        .equ HRTIM_TIMA_RSTA1R_EXTEVNT2, 1 << 22   @ bitWidth 1 (EXTEVNT2)  
        .equ HRTIM_TIMA_RSTA1R_EXTEVNT1, 1 << 21   @ bitWidth 1 (EXTEVNT1)  
        .equ HRTIM_TIMA_RSTA1R_TIMEVNT9, 1 << 20   @ bitWidth 1 (TIMEVNT9)  
        .equ HRTIM_TIMA_RSTA1R_TIMEVNT8, 1 << 19   @ bitWidth 1 (TIMEVNT8)  
        .equ HRTIM_TIMA_RSTA1R_TIMEVNT7, 1 << 18   @ bitWidth 1 (TIMEVNT7)  
        .equ HRTIM_TIMA_RSTA1R_TIMEVNT6, 1 << 17   @ bitWidth 1 (TIMEVNT6)  
        .equ HRTIM_TIMA_RSTA1R_TIMEVNT5, 1 << 16   @ bitWidth 1 (TIMEVNT5)  
        .equ HRTIM_TIMA_RSTA1R_TIMEVNT4, 1 << 15   @ bitWidth 1 (TIMEVNT4)  
        .equ HRTIM_TIMA_RSTA1R_TIMEVNT3, 1 << 14   @ bitWidth 1 (TIMEVNT3)  
        .equ HRTIM_TIMA_RSTA1R_TIMEVNT2, 1 << 13   @ bitWidth 1 (TIMEVNT2)  
        .equ HRTIM_TIMA_RSTA1R_TIMEVNT1, 1 << 12   @ bitWidth 1 (TIMEVNT1)  
        .equ HRTIM_TIMA_RSTA1R_MSTCMP4, 1 << 11   @ bitWidth 1 (MSTCMP4)  
        .equ HRTIM_TIMA_RSTA1R_MSTCMP3, 1 << 10   @ bitWidth 1 (MSTCMP3)  
        .equ HRTIM_TIMA_RSTA1R_MSTCMP2, 1 << 9   @ bitWidth 1 (MSTCMP2)  
        .equ HRTIM_TIMA_RSTA1R_MSTCMP1, 1 << 8   @ bitWidth 1 (MSTCMP1)  
        .equ HRTIM_TIMA_RSTA1R_MSTPER, 1 << 7   @ bitWidth 1 (MSTPER)  
        .equ HRTIM_TIMA_RSTA1R_CMP4, 1 << 6   @ bitWidth 1 (CMP4)  
        .equ HRTIM_TIMA_RSTA1R_CMP3, 1 << 5   @ bitWidth 1 (CMP3)  
        .equ HRTIM_TIMA_RSTA1R_CMP2, 1 << 4   @ bitWidth 1 (CMP2)  
        .equ HRTIM_TIMA_RSTA1R_CMP1, 1 << 3   @ bitWidth 1 (CMP1)  
        .equ HRTIM_TIMA_RSTA1R_PER, 1 << 2   @ bitWidth 1 (PER)  
        .equ HRTIM_TIMA_RSTA1R_RESYNC, 1 << 1   @ bitWidth 1 (RESYNC)  
        .equ HRTIM_TIMA_RSTA1R_SRT, 1 << 0   @ bitWidth 1 (SRT)  
 
    .equ HRTIM_TIMA_SETA2R, HRTIM_TIMA_BASE + 0x44 @ (Timerx Output2 Set Register) 
        .equ HRTIM_TIMA_SETA2R_UPDATE, 1 << 31   @ bitWidth 1 (UPDATE)  
        .equ HRTIM_TIMA_SETA2R_EXTEVNT10, 1 << 30   @ bitWidth 1 (EXTEVNT10)  
        .equ HRTIM_TIMA_SETA2R_EXTEVNT9, 1 << 29   @ bitWidth 1 (EXTEVNT9)  
        .equ HRTIM_TIMA_SETA2R_EXTEVNT8, 1 << 28   @ bitWidth 1 (EXTEVNT8)  
        .equ HRTIM_TIMA_SETA2R_EXTEVNT7, 1 << 27   @ bitWidth 1 (EXTEVNT7)  
        .equ HRTIM_TIMA_SETA2R_EXTEVNT6, 1 << 26   @ bitWidth 1 (EXTEVNT6)  
        .equ HRTIM_TIMA_SETA2R_EXTEVNT5, 1 << 25   @ bitWidth 1 (EXTEVNT5)  
        .equ HRTIM_TIMA_SETA2R_EXTEVNT4, 1 << 24   @ bitWidth 1 (EXTEVNT4)  
        .equ HRTIM_TIMA_SETA2R_EXTEVNT3, 1 << 23   @ bitWidth 1 (EXTEVNT3)  
        .equ HRTIM_TIMA_SETA2R_EXTEVNT2, 1 << 22   @ bitWidth 1 (EXTEVNT2)  
        .equ HRTIM_TIMA_SETA2R_EXTEVNT1, 1 << 21   @ bitWidth 1 (EXTEVNT1)  
        .equ HRTIM_TIMA_SETA2R_TIMEVNT9, 1 << 20   @ bitWidth 1 (TIMEVNT9)  
        .equ HRTIM_TIMA_SETA2R_TIMEVNT8, 1 << 19   @ bitWidth 1 (TIMEVNT8)  
        .equ HRTIM_TIMA_SETA2R_TIMEVNT7, 1 << 18   @ bitWidth 1 (TIMEVNT7)  
        .equ HRTIM_TIMA_SETA2R_TIMEVNT6, 1 << 17   @ bitWidth 1 (TIMEVNT6)  
        .equ HRTIM_TIMA_SETA2R_TIMEVNT5, 1 << 16   @ bitWidth 1 (TIMEVNT5)  
        .equ HRTIM_TIMA_SETA2R_TIMEVNT4, 1 << 15   @ bitWidth 1 (TIMEVNT4)  
        .equ HRTIM_TIMA_SETA2R_TIMEVNT3, 1 << 14   @ bitWidth 1 (TIMEVNT3)  
        .equ HRTIM_TIMA_SETA2R_TIMEVNT2, 1 << 13   @ bitWidth 1 (TIMEVNT2)  
        .equ HRTIM_TIMA_SETA2R_TIMEVNT1, 1 << 12   @ bitWidth 1 (TIMEVNT1)  
        .equ HRTIM_TIMA_SETA2R_MSTCMP4, 1 << 11   @ bitWidth 1 (MSTCMP4)  
        .equ HRTIM_TIMA_SETA2R_MSTCMP3, 1 << 10   @ bitWidth 1 (MSTCMP3)  
        .equ HRTIM_TIMA_SETA2R_MSTCMP2, 1 << 9   @ bitWidth 1 (MSTCMP2)  
        .equ HRTIM_TIMA_SETA2R_MSTCMP1, 1 << 8   @ bitWidth 1 (MSTCMP1)  
        .equ HRTIM_TIMA_SETA2R_MSTPER, 1 << 7   @ bitWidth 1 (MSTPER)  
        .equ HRTIM_TIMA_SETA2R_CMP4, 1 << 6   @ bitWidth 1 (CMP4)  
        .equ HRTIM_TIMA_SETA2R_CMP3, 1 << 5   @ bitWidth 1 (CMP3)  
        .equ HRTIM_TIMA_SETA2R_CMP2, 1 << 4   @ bitWidth 1 (CMP2)  
        .equ HRTIM_TIMA_SETA2R_CMP1, 1 << 3   @ bitWidth 1 (CMP1)  
        .equ HRTIM_TIMA_SETA2R_PER, 1 << 2   @ bitWidth 1 (PER)  
        .equ HRTIM_TIMA_SETA2R_RESYNC, 1 << 1   @ bitWidth 1 (RESYNC)  
        .equ HRTIM_TIMA_SETA2R_SST, 1 << 0   @ bitWidth 1 (SST)  
 
    .equ HRTIM_TIMA_RSTA2R, HRTIM_TIMA_BASE + 0x48 @ (Timerx Output2 Reset Register) 
        .equ HRTIM_TIMA_RSTA2R_UPDATE, 1 << 31   @ bitWidth 1 (UPDATE)  
        .equ HRTIM_TIMA_RSTA2R_EXTEVNT10, 1 << 30   @ bitWidth 1 (EXTEVNT10)  
        .equ HRTIM_TIMA_RSTA2R_EXTEVNT9, 1 << 29   @ bitWidth 1 (EXTEVNT9)  
        .equ HRTIM_TIMA_RSTA2R_EXTEVNT8, 1 << 28   @ bitWidth 1 (EXTEVNT8)  
        .equ HRTIM_TIMA_RSTA2R_EXTEVNT7, 1 << 27   @ bitWidth 1 (EXTEVNT7)  
        .equ HRTIM_TIMA_RSTA2R_EXTEVNT6, 1 << 26   @ bitWidth 1 (EXTEVNT6)  
        .equ HRTIM_TIMA_RSTA2R_EXTEVNT5, 1 << 25   @ bitWidth 1 (EXTEVNT5)  
        .equ HRTIM_TIMA_RSTA2R_EXTEVNT4, 1 << 24   @ bitWidth 1 (EXTEVNT4)  
        .equ HRTIM_TIMA_RSTA2R_EXTEVNT3, 1 << 23   @ bitWidth 1 (EXTEVNT3)  
        .equ HRTIM_TIMA_RSTA2R_EXTEVNT2, 1 << 22   @ bitWidth 1 (EXTEVNT2)  
        .equ HRTIM_TIMA_RSTA2R_EXTEVNT1, 1 << 21   @ bitWidth 1 (EXTEVNT1)  
        .equ HRTIM_TIMA_RSTA2R_TIMEVNT9, 1 << 20   @ bitWidth 1 (TIMEVNT9)  
        .equ HRTIM_TIMA_RSTA2R_TIMEVNT8, 1 << 19   @ bitWidth 1 (TIMEVNT8)  
        .equ HRTIM_TIMA_RSTA2R_TIMEVNT7, 1 << 18   @ bitWidth 1 (TIMEVNT7)  
        .equ HRTIM_TIMA_RSTA2R_TIMEVNT6, 1 << 17   @ bitWidth 1 (TIMEVNT6)  
        .equ HRTIM_TIMA_RSTA2R_TIMEVNT5, 1 << 16   @ bitWidth 1 (TIMEVNT5)  
        .equ HRTIM_TIMA_RSTA2R_TIMEVNT4, 1 << 15   @ bitWidth 1 (TIMEVNT4)  
        .equ HRTIM_TIMA_RSTA2R_TIMEVNT3, 1 << 14   @ bitWidth 1 (TIMEVNT3)  
        .equ HRTIM_TIMA_RSTA2R_TIMEVNT2, 1 << 13   @ bitWidth 1 (TIMEVNT2)  
        .equ HRTIM_TIMA_RSTA2R_TIMEVNT1, 1 << 12   @ bitWidth 1 (TIMEVNT1)  
        .equ HRTIM_TIMA_RSTA2R_MSTCMP4, 1 << 11   @ bitWidth 1 (MSTCMP4)  
        .equ HRTIM_TIMA_RSTA2R_MSTCMP3, 1 << 10   @ bitWidth 1 (MSTCMP3)  
        .equ HRTIM_TIMA_RSTA2R_MSTCMP2, 1 << 9   @ bitWidth 1 (MSTCMP2)  
        .equ HRTIM_TIMA_RSTA2R_MSTCMP1, 1 << 8   @ bitWidth 1 (MSTCMP1)  
        .equ HRTIM_TIMA_RSTA2R_MSTPER, 1 << 7   @ bitWidth 1 (MSTPER)  
        .equ HRTIM_TIMA_RSTA2R_CMP4, 1 << 6   @ bitWidth 1 (CMP4)  
        .equ HRTIM_TIMA_RSTA2R_CMP3, 1 << 5   @ bitWidth 1 (CMP3)  
        .equ HRTIM_TIMA_RSTA2R_CMP2, 1 << 4   @ bitWidth 1 (CMP2)  
        .equ HRTIM_TIMA_RSTA2R_CMP1, 1 << 3   @ bitWidth 1 (CMP1)  
        .equ HRTIM_TIMA_RSTA2R_PER, 1 << 2   @ bitWidth 1 (PER)  
        .equ HRTIM_TIMA_RSTA2R_RESYNC, 1 << 1   @ bitWidth 1 (RESYNC)  
        .equ HRTIM_TIMA_RSTA2R_SRT, 1 << 0   @ bitWidth 1 (SRT)  
 
    .equ HRTIM_TIMA_EEFAR1, HRTIM_TIMA_BASE + 0x4C @ (Timerx External Event Filtering Register  1) 
        .equ HRTIM_TIMA_EEFAR1_EE5FLTR_Shift, 25   @ bitWidth 4 (External Event 5 filter)  
        .equ HRTIM_TIMA_EEFAR1_EE5LTCH, 1 << 24   @ bitWidth 1 (External Event 5 latch)  
        .equ HRTIM_TIMA_EEFAR1_EE4FLTR_Shift, 19   @ bitWidth 4 (External Event 4 filter)  
        .equ HRTIM_TIMA_EEFAR1_EE4LTCH, 1 << 18   @ bitWidth 1 (External Event 4 latch)  
        .equ HRTIM_TIMA_EEFAR1_EE3FLTR_Shift, 13   @ bitWidth 4 (External Event 3 filter)  
        .equ HRTIM_TIMA_EEFAR1_EE3LTCH, 1 << 12   @ bitWidth 1 (External Event 3 latch)  
        .equ HRTIM_TIMA_EEFAR1_EE2FLTR_Shift, 7   @ bitWidth 4 (External Event 2 filter)  
        .equ HRTIM_TIMA_EEFAR1_EE2LTCH, 1 << 6   @ bitWidth 1 (External Event 2 latch)  
        .equ HRTIM_TIMA_EEFAR1_EE1FLTR_Shift, 1   @ bitWidth 4 (External Event 1 filter)  
        .equ HRTIM_TIMA_EEFAR1_EE1LTCH, 1 << 0   @ bitWidth 1 (External Event 1 latch)  
 
    .equ HRTIM_TIMA_EEFAR2, HRTIM_TIMA_BASE + 0x50 @ (Timerx External Event Filtering Register  2) 
        .equ HRTIM_TIMA_EEFAR2_EE10FLTR_Shift, 25   @ bitWidth 4 (External Event 10 filter)  
        .equ HRTIM_TIMA_EEFAR2_EE10LTCH, 1 << 24   @ bitWidth 1 (External Event 10 latch)  
        .equ HRTIM_TIMA_EEFAR2_EE9FLTR_Shift, 19   @ bitWidth 4 (External Event 9 filter)  
        .equ HRTIM_TIMA_EEFAR2_EE9LTCH, 1 << 18   @ bitWidth 1 (External Event 9 latch)  
        .equ HRTIM_TIMA_EEFAR2_EE8FLTR_Shift, 13   @ bitWidth 4 (External Event 8 filter)  
        .equ HRTIM_TIMA_EEFAR2_EE8LTCH, 1 << 12   @ bitWidth 1 (External Event 8 latch)  
        .equ HRTIM_TIMA_EEFAR2_EE7FLTR_Shift, 7   @ bitWidth 4 (External Event 7 filter)  
        .equ HRTIM_TIMA_EEFAR2_EE7LTCH, 1 << 6   @ bitWidth 1 (External Event 7 latch)  
        .equ HRTIM_TIMA_EEFAR2_EE6FLTR_Shift, 1   @ bitWidth 4 (External Event 6 filter)  
        .equ HRTIM_TIMA_EEFAR2_EE6LTCH, 1 << 0   @ bitWidth 1 (External Event 6 latch)  
 
    .equ HRTIM_TIMA_RSTAR, HRTIM_TIMA_BASE + 0x54 @ (TimerA Reset Register) 
        .equ HRTIM_TIMA_RSTAR_TIMECMP4, 1 << 30   @ bitWidth 1 (Timer E Compare 4)  
        .equ HRTIM_TIMA_RSTAR_TIMECMP2, 1 << 29   @ bitWidth 1 (Timer E Compare 2)  
        .equ HRTIM_TIMA_RSTAR_TIMECMP1, 1 << 28   @ bitWidth 1 (Timer E Compare 1)  
        .equ HRTIM_TIMA_RSTAR_TIMDCMP4, 1 << 27   @ bitWidth 1 (Timer D Compare 4)  
        .equ HRTIM_TIMA_RSTAR_TIMDCMP2, 1 << 26   @ bitWidth 1 (Timer D Compare 2)  
        .equ HRTIM_TIMA_RSTAR_TIMDCMP1, 1 << 25   @ bitWidth 1 (Timer D Compare 1)  
        .equ HRTIM_TIMA_RSTAR_TIMCCMP4, 1 << 24   @ bitWidth 1 (Timer C Compare 4)  
        .equ HRTIM_TIMA_RSTAR_TIMCCMP2, 1 << 23   @ bitWidth 1 (Timer C Compare 2)  
        .equ HRTIM_TIMA_RSTAR_TIMCCMP1, 1 << 22   @ bitWidth 1 (Timer C Compare 1)  
        .equ HRTIM_TIMA_RSTAR_TIMBCMP4, 1 << 21   @ bitWidth 1 (Timer B Compare 4)  
        .equ HRTIM_TIMA_RSTAR_TIMBCMP2, 1 << 20   @ bitWidth 1 (Timer B Compare 2)  
        .equ HRTIM_TIMA_RSTAR_TIMBCMP1, 1 << 19   @ bitWidth 1 (Timer B Compare 1)  
        .equ HRTIM_TIMA_RSTAR_EXTEVNT10, 1 << 18   @ bitWidth 1 (External Event 10)  
        .equ HRTIM_TIMA_RSTAR_EXTEVNT9, 1 << 17   @ bitWidth 1 (External Event 9)  
        .equ HRTIM_TIMA_RSTAR_EXTEVNT8, 1 << 16   @ bitWidth 1 (External Event 8)  
        .equ HRTIM_TIMA_RSTAR_EXTEVNT7, 1 << 15   @ bitWidth 1 (External Event 7)  
        .equ HRTIM_TIMA_RSTAR_EXTEVNT6, 1 << 14   @ bitWidth 1 (External Event 6)  
        .equ HRTIM_TIMA_RSTAR_EXTEVNT5, 1 << 13   @ bitWidth 1 (External Event 5)  
        .equ HRTIM_TIMA_RSTAR_EXTEVNT4, 1 << 12   @ bitWidth 1 (External Event 4)  
        .equ HRTIM_TIMA_RSTAR_EXTEVNT3, 1 << 11   @ bitWidth 1 (External Event 3)  
        .equ HRTIM_TIMA_RSTAR_EXTEVNT2, 1 << 10   @ bitWidth 1 (External Event 2)  
        .equ HRTIM_TIMA_RSTAR_EXTEVNT1, 1 << 9   @ bitWidth 1 (External Event 1)  
        .equ HRTIM_TIMA_RSTAR_MSTCMP4, 1 << 8   @ bitWidth 1 (Master compare 4)  
        .equ HRTIM_TIMA_RSTAR_MSTCMP3, 1 << 7   @ bitWidth 1 (Master compare 3)  
        .equ HRTIM_TIMA_RSTAR_MSTCMP2, 1 << 6   @ bitWidth 1 (Master compare 2)  
        .equ HRTIM_TIMA_RSTAR_MSTCMP1, 1 << 5   @ bitWidth 1 (Master compare 1)  
        .equ HRTIM_TIMA_RSTAR_MSTPER, 1 << 4   @ bitWidth 1 (Master timer Period)  
        .equ HRTIM_TIMA_RSTAR_CMP4, 1 << 3   @ bitWidth 1 (Timer A compare 4 reset)  
        .equ HRTIM_TIMA_RSTAR_CMP2, 1 << 2   @ bitWidth 1 (Timer A compare 2 reset)  
        .equ HRTIM_TIMA_RSTAR_UPDT, 1 << 1   @ bitWidth 1 (Timer A Update reset)  
 
    .equ HRTIM_TIMA_CHPAR, HRTIM_TIMA_BASE + 0x58 @ (Timerx Chopper Register) 
        .equ HRTIM_TIMA_CHPAR_STRTPW_Shift, 7   @ bitWidth 4 (STRTPW)  
        .equ HRTIM_TIMA_CHPAR_CHPDTY_Shift, 4   @ bitWidth 3 (Timerx chopper duty cycle  value)  
        .equ HRTIM_TIMA_CHPAR_CHPFRQ_Shift, 0   @ bitWidth 4 (Timerx carrier frequency  value)  
 
    .equ HRTIM_TIMA_CPT1ACR, HRTIM_TIMA_BASE + 0x5C @ (Timerx Capture 2 Control  Register) 
        .equ HRTIM_TIMA_CPT1ACR_TECMP2, 1 << 31   @ bitWidth 1 (Timer E Compare 2)  
        .equ HRTIM_TIMA_CPT1ACR_TECMP1, 1 << 30   @ bitWidth 1 (Timer E Compare 1)  
        .equ HRTIM_TIMA_CPT1ACR_TE1RST, 1 << 29   @ bitWidth 1 (Timer E output 1 Reset)  
        .equ HRTIM_TIMA_CPT1ACR_TE1SET, 1 << 28   @ bitWidth 1 (Timer E output 1 Set)  
        .equ HRTIM_TIMA_CPT1ACR_TDCMP2, 1 << 27   @ bitWidth 1 (Timer D Compare 2)  
        .equ HRTIM_TIMA_CPT1ACR_TDCMP1, 1 << 26   @ bitWidth 1 (Timer D Compare 1)  
        .equ HRTIM_TIMA_CPT1ACR_TD1RST, 1 << 25   @ bitWidth 1 (Timer D output 1 Reset)  
        .equ HRTIM_TIMA_CPT1ACR_TD1SET, 1 << 24   @ bitWidth 1 (Timer D output 1 Set)  
        .equ HRTIM_TIMA_CPT1ACR_TCCMP2, 1 << 23   @ bitWidth 1 (Timer C Compare 2)  
        .equ HRTIM_TIMA_CPT1ACR_TCCMP1, 1 << 22   @ bitWidth 1 (Timer C Compare 1)  
        .equ HRTIM_TIMA_CPT1ACR_TC1RST, 1 << 21   @ bitWidth 1 (Timer C output 1 Reset)  
        .equ HRTIM_TIMA_CPT1ACR_TC1SET, 1 << 20   @ bitWidth 1 (Timer C output 1 Set)  
        .equ HRTIM_TIMA_CPT1ACR_TBCMP2, 1 << 19   @ bitWidth 1 (Timer B Compare 2)  
        .equ HRTIM_TIMA_CPT1ACR_TBCMP1, 1 << 18   @ bitWidth 1 (Timer B Compare 1)  
        .equ HRTIM_TIMA_CPT1ACR_TB1RST, 1 << 17   @ bitWidth 1 (Timer B output 1 Reset)  
        .equ HRTIM_TIMA_CPT1ACR_TB1SET, 1 << 16   @ bitWidth 1 (Timer B output 1 Set)  
        .equ HRTIM_TIMA_CPT1ACR_EXEV10CPT, 1 << 11   @ bitWidth 1 (External Event 10 Capture)  
        .equ HRTIM_TIMA_CPT1ACR_EXEV9CPT, 1 << 10   @ bitWidth 1 (External Event 9 Capture)  
        .equ HRTIM_TIMA_CPT1ACR_EXEV8CPT, 1 << 9   @ bitWidth 1 (External Event 8 Capture)  
        .equ HRTIM_TIMA_CPT1ACR_EXEV7CPT, 1 << 8   @ bitWidth 1 (External Event 7 Capture)  
        .equ HRTIM_TIMA_CPT1ACR_EXEV6CPT, 1 << 7   @ bitWidth 1 (External Event 6 Capture)  
        .equ HRTIM_TIMA_CPT1ACR_EXEV5CPT, 1 << 6   @ bitWidth 1 (External Event 5 Capture)  
        .equ HRTIM_TIMA_CPT1ACR_EXEV4CPT, 1 << 5   @ bitWidth 1 (External Event 4 Capture)  
        .equ HRTIM_TIMA_CPT1ACR_EXEV3CPT, 1 << 4   @ bitWidth 1 (External Event 3 Capture)  
        .equ HRTIM_TIMA_CPT1ACR_EXEV2CPT, 1 << 3   @ bitWidth 1 (External Event 2 Capture)  
        .equ HRTIM_TIMA_CPT1ACR_EXEV1CPT, 1 << 2   @ bitWidth 1 (External Event 1 Capture)  
        .equ HRTIM_TIMA_CPT1ACR_UDPCPT, 1 << 1   @ bitWidth 1 (Update Capture)  
        .equ HRTIM_TIMA_CPT1ACR_SWCPT, 1 << 0   @ bitWidth 1 (Software Capture)  
 
    .equ HRTIM_TIMA_CPT2ACR, HRTIM_TIMA_BASE + 0x60 @ (CPT2xCR) 
        .equ HRTIM_TIMA_CPT2ACR_TECMP2, 1 << 31   @ bitWidth 1 (Timer E Compare 2)  
        .equ HRTIM_TIMA_CPT2ACR_TECMP1, 1 << 30   @ bitWidth 1 (Timer E Compare 1)  
        .equ HRTIM_TIMA_CPT2ACR_TE1RST, 1 << 29   @ bitWidth 1 (Timer E output 1 Reset)  
        .equ HRTIM_TIMA_CPT2ACR_TE1SET, 1 << 28   @ bitWidth 1 (Timer E output 1 Set)  
        .equ HRTIM_TIMA_CPT2ACR_TDCMP2, 1 << 27   @ bitWidth 1 (Timer D Compare 2)  
        .equ HRTIM_TIMA_CPT2ACR_TDCMP1, 1 << 26   @ bitWidth 1 (Timer D Compare 1)  
        .equ HRTIM_TIMA_CPT2ACR_TD1RST, 1 << 25   @ bitWidth 1 (Timer D output 1 Reset)  
        .equ HRTIM_TIMA_CPT2ACR_TD1SET, 1 << 24   @ bitWidth 1 (Timer D output 1 Set)  
        .equ HRTIM_TIMA_CPT2ACR_TCCMP2, 1 << 23   @ bitWidth 1 (Timer C Compare 2)  
        .equ HRTIM_TIMA_CPT2ACR_TCCMP1, 1 << 22   @ bitWidth 1 (Timer C Compare 1)  
        .equ HRTIM_TIMA_CPT2ACR_TC1RST, 1 << 21   @ bitWidth 1 (Timer C output 1 Reset)  
        .equ HRTIM_TIMA_CPT2ACR_TC1SET, 1 << 20   @ bitWidth 1 (Timer C output 1 Set)  
        .equ HRTIM_TIMA_CPT2ACR_TBCMP2, 1 << 19   @ bitWidth 1 (Timer B Compare 2)  
        .equ HRTIM_TIMA_CPT2ACR_TBCMP1, 1 << 18   @ bitWidth 1 (Timer B Compare 1)  
        .equ HRTIM_TIMA_CPT2ACR_TB1RST, 1 << 17   @ bitWidth 1 (Timer B output 1 Reset)  
        .equ HRTIM_TIMA_CPT2ACR_TB1SET, 1 << 16   @ bitWidth 1 (Timer B output 1 Set)  
        .equ HRTIM_TIMA_CPT2ACR_EXEV10CPT, 1 << 11   @ bitWidth 1 (External Event 10 Capture)  
        .equ HRTIM_TIMA_CPT2ACR_EXEV9CPT, 1 << 10   @ bitWidth 1 (External Event 9 Capture)  
        .equ HRTIM_TIMA_CPT2ACR_EXEV8CPT, 1 << 9   @ bitWidth 1 (External Event 8 Capture)  
        .equ HRTIM_TIMA_CPT2ACR_EXEV7CPT, 1 << 8   @ bitWidth 1 (External Event 7 Capture)  
        .equ HRTIM_TIMA_CPT2ACR_EXEV6CPT, 1 << 7   @ bitWidth 1 (External Event 6 Capture)  
        .equ HRTIM_TIMA_CPT2ACR_EXEV5CPT, 1 << 6   @ bitWidth 1 (External Event 5 Capture)  
        .equ HRTIM_TIMA_CPT2ACR_EXEV4CPT, 1 << 5   @ bitWidth 1 (External Event 4 Capture)  
        .equ HRTIM_TIMA_CPT2ACR_EXEV3CPT, 1 << 4   @ bitWidth 1 (External Event 3 Capture)  
        .equ HRTIM_TIMA_CPT2ACR_EXEV2CPT, 1 << 3   @ bitWidth 1 (External Event 2 Capture)  
        .equ HRTIM_TIMA_CPT2ACR_EXEV1CPT, 1 << 2   @ bitWidth 1 (External Event 1 Capture)  
        .equ HRTIM_TIMA_CPT2ACR_UDPCPT, 1 << 1   @ bitWidth 1 (Update Capture)  
        .equ HRTIM_TIMA_CPT2ACR_SWCPT, 1 << 0   @ bitWidth 1 (Software Capture)  
 
    .equ HRTIM_TIMA_OUTAR, HRTIM_TIMA_BASE + 0x64 @ (Timerx Output Register) 
        .equ HRTIM_TIMA_OUTAR_DIDL2, 1 << 23   @ bitWidth 1 (Output 2 Deadtime upon burst mode Idle  entry)  
        .equ HRTIM_TIMA_OUTAR_CHP2, 1 << 22   @ bitWidth 1 (Output 2 Chopper enable)  
        .equ HRTIM_TIMA_OUTAR_FAULT2_Shift, 20   @ bitWidth 2 (Output 2 Fault state)  
        .equ HRTIM_TIMA_OUTAR_IDLES2, 1 << 19   @ bitWidth 1 (Output 2 Idle State)  
        .equ HRTIM_TIMA_OUTAR_IDLEM2, 1 << 18   @ bitWidth 1 (Output 2 Idle mode)  
        .equ HRTIM_TIMA_OUTAR_POL2, 1 << 17   @ bitWidth 1 (Output 2 polarity)  
        .equ HRTIM_TIMA_OUTAR_DLYPRT_Shift, 10   @ bitWidth 3 (Delayed Protection)  
        .equ HRTIM_TIMA_OUTAR_DLYPRTEN, 1 << 9   @ bitWidth 1 (Delayed Protection Enable)  
        .equ HRTIM_TIMA_OUTAR_DTEN, 1 << 8   @ bitWidth 1 (Deadtime enable)  
        .equ HRTIM_TIMA_OUTAR_DIDL1, 1 << 7   @ bitWidth 1 (Output 1 Deadtime upon burst mode Idle  entry)  
        .equ HRTIM_TIMA_OUTAR_CHP1, 1 << 6   @ bitWidth 1 (Output 1 Chopper enable)  
        .equ HRTIM_TIMA_OUTAR_FAULT1_Shift, 4   @ bitWidth 2 (Output 1 Fault state)  
        .equ HRTIM_TIMA_OUTAR_IDLES1, 1 << 3   @ bitWidth 1 (Output 1 Idle State)  
        .equ HRTIM_TIMA_OUTAR_IDLEM1, 1 << 2   @ bitWidth 1 (Output 1 Idle mode)  
        .equ HRTIM_TIMA_OUTAR_POL1, 1 << 1   @ bitWidth 1 (Output 1 polarity)  
 
    .equ HRTIM_TIMA_FLTAR, HRTIM_TIMA_BASE + 0x68 @ (Timerx Fault Register) 
        .equ HRTIM_TIMA_FLTAR_FLTLCK, 1 << 31   @ bitWidth 1 (Fault sources Lock)  
        .equ HRTIM_TIMA_FLTAR_FLT5EN, 1 << 4   @ bitWidth 1 (Fault 5 enable)  
        .equ HRTIM_TIMA_FLTAR_FLT4EN, 1 << 3   @ bitWidth 1 (Fault 4 enable)  
        .equ HRTIM_TIMA_FLTAR_FLT3EN, 1 << 2   @ bitWidth 1 (Fault 3 enable)  
        .equ HRTIM_TIMA_FLTAR_FLT2EN, 1 << 1   @ bitWidth 1 (Fault 2 enable)  
        .equ HRTIM_TIMA_FLTAR_FLT1EN, 1 << 0   @ bitWidth 1 (Fault 1 enable)  
 

@=========================== HRTIM_TIMB ===========================@
.equ HRTIM_TIMB_BASE, 0x40017500 @ (High Resolution Timer: TIMB) 
    .equ HRTIM_TIMB_TIMBCR, HRTIM_TIMB_BASE + 0x0 @ (Timerx Control Register) 
        .equ HRTIM_TIMB_TIMBCR_UPDGAT_Shift, 28   @ bitWidth 4 (Update Gating)  
        .equ HRTIM_TIMB_TIMBCR_PREEN, 1 << 27   @ bitWidth 1 (Preload enable)  
        .equ HRTIM_TIMB_TIMBCR_DACSYNC_Shift, 25   @ bitWidth 2 (AC Synchronization)  
        .equ HRTIM_TIMB_TIMBCR_MSTU, 1 << 24   @ bitWidth 1 (Master Timer update)  
        .equ HRTIM_TIMB_TIMBCR_TEU, 1 << 23   @ bitWidth 1 (TEU)  
        .equ HRTIM_TIMB_TIMBCR_TDU, 1 << 22   @ bitWidth 1 (TDU)  
        .equ HRTIM_TIMB_TIMBCR_TCU, 1 << 21   @ bitWidth 1 (TCU)  
        .equ HRTIM_TIMB_TIMBCR_TBU, 1 << 20   @ bitWidth 1 (TBU)  
        .equ HRTIM_TIMB_TIMBCR_TxRSTU, 1 << 18   @ bitWidth 1 (Timerx reset update)  
        .equ HRTIM_TIMB_TIMBCR_TxREPU, 1 << 17   @ bitWidth 1 (Timer x Repetition update)  
        .equ HRTIM_TIMB_TIMBCR_DELCMP4_Shift, 14   @ bitWidth 2 (Delayed CMP4 mode)  
        .equ HRTIM_TIMB_TIMBCR_DELCMP2_Shift, 12   @ bitWidth 2 (Delayed CMP2 mode)  
        .equ HRTIM_TIMB_TIMBCR_SYNCSTRTx, 1 << 11   @ bitWidth 1 (Synchronization Starts Timer  x)  
        .equ HRTIM_TIMB_TIMBCR_SYNCRSTx, 1 << 10   @ bitWidth 1 (Synchronization Resets Timer  x)  
        .equ HRTIM_TIMB_TIMBCR_PSHPLL, 1 << 6   @ bitWidth 1 (Push-Pull mode enable)  
        .equ HRTIM_TIMB_TIMBCR_HALF, 1 << 5   @ bitWidth 1 (Half mode enable)  
        .equ HRTIM_TIMB_TIMBCR_RETRIG, 1 << 4   @ bitWidth 1 (Re-triggerable mode)  
        .equ HRTIM_TIMB_TIMBCR_CONT, 1 << 3   @ bitWidth 1 (Continuous mode)  
        .equ HRTIM_TIMB_TIMBCR_CK_PSCx_Shift, 0   @ bitWidth 3 (HRTIM Timer x Clock  prescaler)  
 
    .equ HRTIM_TIMB_TIMBISR, HRTIM_TIMB_BASE + 0x4 @ (Timerx Interrupt Status  Register) 
        .equ HRTIM_TIMB_TIMBISR_O2STAT, 1 << 19   @ bitWidth 1 (Output 2 State)  
        .equ HRTIM_TIMB_TIMBISR_O1STAT, 1 << 18   @ bitWidth 1 (Output 1 State)  
        .equ HRTIM_TIMB_TIMBISR_IPPSTAT, 1 << 17   @ bitWidth 1 (Idle Push Pull Status)  
        .equ HRTIM_TIMB_TIMBISR_CPPSTAT, 1 << 16   @ bitWidth 1 (Current Push Pull Status)  
        .equ HRTIM_TIMB_TIMBISR_DLYPRT, 1 << 14   @ bitWidth 1 (Delayed Protection Flag)  
        .equ HRTIM_TIMB_TIMBISR_RST, 1 << 13   @ bitWidth 1 (Reset Interrupt Flag)  
        .equ HRTIM_TIMB_TIMBISR_RSTx2, 1 << 12   @ bitWidth 1 (Output 2 Reset Interrupt  Flag)  
        .equ HRTIM_TIMB_TIMBISR_SETx2, 1 << 11   @ bitWidth 1 (Output 2 Set Interrupt  Flag)  
        .equ HRTIM_TIMB_TIMBISR_RSTx1, 1 << 10   @ bitWidth 1 (Output 1 Reset Interrupt  Flag)  
        .equ HRTIM_TIMB_TIMBISR_SETx1, 1 << 9   @ bitWidth 1 (Output 1 Set Interrupt  Flag)  
        .equ HRTIM_TIMB_TIMBISR_CPT2, 1 << 8   @ bitWidth 1 (Capture2 Interrupt Flag)  
        .equ HRTIM_TIMB_TIMBISR_CPT1, 1 << 7   @ bitWidth 1 (Capture1 Interrupt Flag)  
        .equ HRTIM_TIMB_TIMBISR_UPD, 1 << 6   @ bitWidth 1 (Update Interrupt Flag)  
        .equ HRTIM_TIMB_TIMBISR_REP, 1 << 4   @ bitWidth 1 (Repetition Interrupt Flag)  
        .equ HRTIM_TIMB_TIMBISR_CMP4, 1 << 3   @ bitWidth 1 (Compare 4 Interrupt Flag)  
        .equ HRTIM_TIMB_TIMBISR_CMP3, 1 << 2   @ bitWidth 1 (Compare 3 Interrupt Flag)  
        .equ HRTIM_TIMB_TIMBISR_CMP2, 1 << 1   @ bitWidth 1 (Compare 2 Interrupt Flag)  
        .equ HRTIM_TIMB_TIMBISR_CMP1, 1 << 0   @ bitWidth 1 (Compare 1 Interrupt Flag)  
 
    .equ HRTIM_TIMB_TIMBICR, HRTIM_TIMB_BASE + 0x8 @ (Timerx Interrupt Clear  Register) 
        .equ HRTIM_TIMB_TIMBICR_DLYPRTC, 1 << 14   @ bitWidth 1 (Delayed Protection Flag  Clear)  
        .equ HRTIM_TIMB_TIMBICR_RSTC, 1 << 13   @ bitWidth 1 (Reset Interrupt flag Clear)  
        .equ HRTIM_TIMB_TIMBICR_RSTx2C, 1 << 12   @ bitWidth 1 (Output 2 Reset flag Clear)  
        .equ HRTIM_TIMB_TIMBICR_SET2xC, 1 << 11   @ bitWidth 1 (Output 2 Set flag Clear)  
        .equ HRTIM_TIMB_TIMBICR_RSTx1C, 1 << 10   @ bitWidth 1 (Output 1 Reset flag Clear)  
        .equ HRTIM_TIMB_TIMBICR_SET1xC, 1 << 9   @ bitWidth 1 (Output 1 Set flag Clear)  
        .equ HRTIM_TIMB_TIMBICR_CPT2C, 1 << 8   @ bitWidth 1 (Capture2 Interrupt flag  Clear)  
        .equ HRTIM_TIMB_TIMBICR_CPT1C, 1 << 7   @ bitWidth 1 (Capture1 Interrupt flag  Clear)  
        .equ HRTIM_TIMB_TIMBICR_UPDC, 1 << 6   @ bitWidth 1 (Update Interrupt flag  Clear)  
        .equ HRTIM_TIMB_TIMBICR_REPC, 1 << 4   @ bitWidth 1 (Repetition Interrupt flag  Clear)  
        .equ HRTIM_TIMB_TIMBICR_CMP4C, 1 << 3   @ bitWidth 1 (Compare 4 Interrupt flag  Clear)  
        .equ HRTIM_TIMB_TIMBICR_CMP3C, 1 << 2   @ bitWidth 1 (Compare 3 Interrupt flag  Clear)  
        .equ HRTIM_TIMB_TIMBICR_CMP2C, 1 << 1   @ bitWidth 1 (Compare 2 Interrupt flag  Clear)  
        .equ HRTIM_TIMB_TIMBICR_CMP1C, 1 << 0   @ bitWidth 1 (Compare 1 Interrupt flag  Clear)  
 
    .equ HRTIM_TIMB_TIMBDIER5, HRTIM_TIMB_BASE + 0xC @ (TIMxDIER5) 
        .equ HRTIM_TIMB_TIMBDIER5_DLYPRTDE, 1 << 30   @ bitWidth 1 (DLYPRTDE)  
        .equ HRTIM_TIMB_TIMBDIER5_RSTDE, 1 << 29   @ bitWidth 1 (RSTDE)  
        .equ HRTIM_TIMB_TIMBDIER5_RSTx2DE, 1 << 28   @ bitWidth 1 (RSTx2DE)  
        .equ HRTIM_TIMB_TIMBDIER5_SETx2DE, 1 << 27   @ bitWidth 1 (SETx2DE)  
        .equ HRTIM_TIMB_TIMBDIER5_RSTx1DE, 1 << 26   @ bitWidth 1 (RSTx1DE)  
        .equ HRTIM_TIMB_TIMBDIER5_SET1xDE, 1 << 25   @ bitWidth 1 (SET1xDE)  
        .equ HRTIM_TIMB_TIMBDIER5_CPT2DE, 1 << 24   @ bitWidth 1 (CPT2DE)  
        .equ HRTIM_TIMB_TIMBDIER5_CPT1DE, 1 << 23   @ bitWidth 1 (CPT1DE)  
        .equ HRTIM_TIMB_TIMBDIER5_UPDDE, 1 << 22   @ bitWidth 1 (UPDDE)  
        .equ HRTIM_TIMB_TIMBDIER5_REPDE, 1 << 20   @ bitWidth 1 (REPDE)  
        .equ HRTIM_TIMB_TIMBDIER5_CMP4DE, 1 << 19   @ bitWidth 1 (CMP4DE)  
        .equ HRTIM_TIMB_TIMBDIER5_CMP3DE, 1 << 18   @ bitWidth 1 (CMP3DE)  
        .equ HRTIM_TIMB_TIMBDIER5_CMP2DE, 1 << 17   @ bitWidth 1 (CMP2DE)  
        .equ HRTIM_TIMB_TIMBDIER5_CMP1DE, 1 << 16   @ bitWidth 1 (CMP1DE)  
        .equ HRTIM_TIMB_TIMBDIER5_DLYPRTIE, 1 << 14   @ bitWidth 1 (DLYPRTIE)  
        .equ HRTIM_TIMB_TIMBDIER5_RSTIE, 1 << 13   @ bitWidth 1 (RSTIE)  
        .equ HRTIM_TIMB_TIMBDIER5_RSTx2IE, 1 << 12   @ bitWidth 1 (RSTx2IE)  
        .equ HRTIM_TIMB_TIMBDIER5_SETx2IE, 1 << 11   @ bitWidth 1 (SETx2IE)  
        .equ HRTIM_TIMB_TIMBDIER5_RSTx1IE, 1 << 10   @ bitWidth 1 (RSTx1IE)  
        .equ HRTIM_TIMB_TIMBDIER5_SET1xIE, 1 << 9   @ bitWidth 1 (SET1xIE)  
        .equ HRTIM_TIMB_TIMBDIER5_CPT2IE, 1 << 8   @ bitWidth 1 (CPT2IE)  
        .equ HRTIM_TIMB_TIMBDIER5_CPT1IE, 1 << 7   @ bitWidth 1 (CPT1IE)  
        .equ HRTIM_TIMB_TIMBDIER5_UPDIE, 1 << 6   @ bitWidth 1 (UPDIE)  
        .equ HRTIM_TIMB_TIMBDIER5_REPIE, 1 << 4   @ bitWidth 1 (REPIE)  
        .equ HRTIM_TIMB_TIMBDIER5_CMP4IE, 1 << 3   @ bitWidth 1 (CMP4IE)  
        .equ HRTIM_TIMB_TIMBDIER5_CMP3IE, 1 << 2   @ bitWidth 1 (CMP3IE)  
        .equ HRTIM_TIMB_TIMBDIER5_CMP2IE, 1 << 1   @ bitWidth 1 (CMP2IE)  
        .equ HRTIM_TIMB_TIMBDIER5_CMP1IE, 1 << 0   @ bitWidth 1 (CMP1IE)  
 
    .equ HRTIM_TIMB_CNTR, HRTIM_TIMB_BASE + 0x10 @ (Timerx Counter Register) 
        .equ HRTIM_TIMB_CNTR_CNTx_Shift, 0   @ bitWidth 16 (Timerx Counter value)  
 
    .equ HRTIM_TIMB_PERBR, HRTIM_TIMB_BASE + 0x14 @ (Timerx Period Register) 
        .equ HRTIM_TIMB_PERBR_PERx_Shift, 0   @ bitWidth 16 (Timerx Period value)  
 
    .equ HRTIM_TIMB_REPBR, HRTIM_TIMB_BASE + 0x18 @ (Timerx Repetition Register) 
        .equ HRTIM_TIMB_REPBR_REPx_Shift, 0   @ bitWidth 8 (Timerx Repetition counter  value)  
 
    .equ HRTIM_TIMB_CMP1BR, HRTIM_TIMB_BASE + 0x1C @ (Timerx Compare 1 Register) 
        .equ HRTIM_TIMB_CMP1BR_CMP1x_Shift, 0   @ bitWidth 16 (Timerx Compare 1 value)  
 
    .equ HRTIM_TIMB_CMP1CBR, HRTIM_TIMB_BASE + 0x20 @ (Timerx Compare 1 Compound  Register) 
        .equ HRTIM_TIMB_CMP1CBR_REPx_Shift, 16   @ bitWidth 8 (Timerx Repetition value aliased from  HRTIM_REPx register)  
        .equ HRTIM_TIMB_CMP1CBR_CMP1x_Shift, 0   @ bitWidth 16 (Timerx Compare 1 value)  
 
    .equ HRTIM_TIMB_CMP2BR, HRTIM_TIMB_BASE + 0x24 @ (Timerx Compare 2 Register) 
        .equ HRTIM_TIMB_CMP2BR_CMP2x_Shift, 0   @ bitWidth 16 (Timerx Compare 2 value)  
 
    .equ HRTIM_TIMB_CMP3BR, HRTIM_TIMB_BASE + 0x28 @ (Timerx Compare 3 Register) 
        .equ HRTIM_TIMB_CMP3BR_CMP3x_Shift, 0   @ bitWidth 16 (Timerx Compare 3 value)  
 
    .equ HRTIM_TIMB_CMP4BR, HRTIM_TIMB_BASE + 0x2C @ (Timerx Compare 4 Register) 
        .equ HRTIM_TIMB_CMP4BR_CMP4x_Shift, 0   @ bitWidth 16 (Timerx Compare 4 value)  
 
    .equ HRTIM_TIMB_CPT1BR, HRTIM_TIMB_BASE + 0x30 @ (Timerx Capture 1 Register) 
        .equ HRTIM_TIMB_CPT1BR_CPT1x_Shift, 0   @ bitWidth 16 (Timerx Capture 1 value)  
 
    .equ HRTIM_TIMB_CPT2BR, HRTIM_TIMB_BASE + 0x34 @ (Timerx Capture 2 Register) 
        .equ HRTIM_TIMB_CPT2BR_CPT2x_Shift, 0   @ bitWidth 16 (Timerx Capture 2 value)  
 
    .equ HRTIM_TIMB_DTBR, HRTIM_TIMB_BASE + 0x38 @ (Timerx Deadtime Register) 
        .equ HRTIM_TIMB_DTBR_DTFLKx, 1 << 31   @ bitWidth 1 (Deadtime Falling Lock)  
        .equ HRTIM_TIMB_DTBR_DTFSLKx, 1 << 30   @ bitWidth 1 (Deadtime Falling Sign Lock)  
        .equ HRTIM_TIMB_DTBR_SDTFx, 1 << 25   @ bitWidth 1 (Sign Deadtime Falling  value)  
        .equ HRTIM_TIMB_DTBR_DTFx_Shift, 16   @ bitWidth 9 (Deadtime Falling value)  
        .equ HRTIM_TIMB_DTBR_DTRLKx, 1 << 15   @ bitWidth 1 (Deadtime Rising Lock)  
        .equ HRTIM_TIMB_DTBR_DTRSLKx, 1 << 14   @ bitWidth 1 (Deadtime Rising Sign Lock)  
        .equ HRTIM_TIMB_DTBR_DTPRSC_Shift, 10   @ bitWidth 3 (Deadtime Prescaler)  
        .equ HRTIM_TIMB_DTBR_SDTRx, 1 << 9   @ bitWidth 1 (Sign Deadtime Rising value)  
        .equ HRTIM_TIMB_DTBR_DTRx_Shift, 0   @ bitWidth 9 (Deadtime Rising value)  
 
    .equ HRTIM_TIMB_SETB1R, HRTIM_TIMB_BASE + 0x3C @ (Timerx Output1 Set Register) 
        .equ HRTIM_TIMB_SETB1R_UPDATE, 1 << 31   @ bitWidth 1 (Registers update transfer preload to  active)  
        .equ HRTIM_TIMB_SETB1R_EXTEVNT10, 1 << 30   @ bitWidth 1 (External Event 10)  
        .equ HRTIM_TIMB_SETB1R_EXTEVNT9, 1 << 29   @ bitWidth 1 (External Event 9)  
        .equ HRTIM_TIMB_SETB1R_EXTEVNT8, 1 << 28   @ bitWidth 1 (External Event 8)  
        .equ HRTIM_TIMB_SETB1R_EXTEVNT7, 1 << 27   @ bitWidth 1 (External Event 7)  
        .equ HRTIM_TIMB_SETB1R_EXTEVNT6, 1 << 26   @ bitWidth 1 (External Event 6)  
        .equ HRTIM_TIMB_SETB1R_EXTEVNT5, 1 << 25   @ bitWidth 1 (External Event 5)  
        .equ HRTIM_TIMB_SETB1R_EXTEVNT4, 1 << 24   @ bitWidth 1 (External Event 4)  
        .equ HRTIM_TIMB_SETB1R_EXTEVNT3, 1 << 23   @ bitWidth 1 (External Event 3)  
        .equ HRTIM_TIMB_SETB1R_EXTEVNT2, 1 << 22   @ bitWidth 1 (External Event 2)  
        .equ HRTIM_TIMB_SETB1R_EXTEVNT1, 1 << 21   @ bitWidth 1 (External Event 1)  
        .equ HRTIM_TIMB_SETB1R_TIMEVNT9, 1 << 20   @ bitWidth 1 (Timer Event 9)  
        .equ HRTIM_TIMB_SETB1R_TIMEVNT8, 1 << 19   @ bitWidth 1 (Timer Event 8)  
        .equ HRTIM_TIMB_SETB1R_TIMEVNT7, 1 << 18   @ bitWidth 1 (Timer Event 7)  
        .equ HRTIM_TIMB_SETB1R_TIMEVNT6, 1 << 17   @ bitWidth 1 (Timer Event 6)  
        .equ HRTIM_TIMB_SETB1R_TIMEVNT5, 1 << 16   @ bitWidth 1 (Timer Event 5)  
        .equ HRTIM_TIMB_SETB1R_TIMEVNT4, 1 << 15   @ bitWidth 1 (Timer Event 4)  
        .equ HRTIM_TIMB_SETB1R_TIMEVNT3, 1 << 14   @ bitWidth 1 (Timer Event 3)  
        .equ HRTIM_TIMB_SETB1R_TIMEVNT2, 1 << 13   @ bitWidth 1 (Timer Event 2)  
        .equ HRTIM_TIMB_SETB1R_TIMEVNT1, 1 << 12   @ bitWidth 1 (Timer Event 1)  
        .equ HRTIM_TIMB_SETB1R_MSTCMP4, 1 << 11   @ bitWidth 1 (Master Compare 4)  
        .equ HRTIM_TIMB_SETB1R_MSTCMP3, 1 << 10   @ bitWidth 1 (Master Compare 3)  
        .equ HRTIM_TIMB_SETB1R_MSTCMP2, 1 << 9   @ bitWidth 1 (Master Compare 2)  
        .equ HRTIM_TIMB_SETB1R_MSTCMP1, 1 << 8   @ bitWidth 1 (Master Compare 1)  
        .equ HRTIM_TIMB_SETB1R_MSTPER, 1 << 7   @ bitWidth 1 (Master Period)  
        .equ HRTIM_TIMB_SETB1R_CMP4, 1 << 6   @ bitWidth 1 (Timer A compare 4)  
        .equ HRTIM_TIMB_SETB1R_CMP3, 1 << 5   @ bitWidth 1 (Timer A compare 3)  
        .equ HRTIM_TIMB_SETB1R_CMP2, 1 << 4   @ bitWidth 1 (Timer A compare 2)  
        .equ HRTIM_TIMB_SETB1R_CMP1, 1 << 3   @ bitWidth 1 (Timer A compare 1)  
        .equ HRTIM_TIMB_SETB1R_PER, 1 << 2   @ bitWidth 1 (Timer A Period)  
        .equ HRTIM_TIMB_SETB1R_RESYNC, 1 << 1   @ bitWidth 1 (Timer A resynchronizaton)  
        .equ HRTIM_TIMB_SETB1R_SST, 1 << 0   @ bitWidth 1 (Software Set trigger)  
 
    .equ HRTIM_TIMB_RSTB1R, HRTIM_TIMB_BASE + 0x40 @ (Timerx Output1 Reset Register) 
        .equ HRTIM_TIMB_RSTB1R_UPDATE, 1 << 31   @ bitWidth 1 (UPDATE)  
        .equ HRTIM_TIMB_RSTB1R_EXTEVNT10, 1 << 30   @ bitWidth 1 (EXTEVNT10)  
        .equ HRTIM_TIMB_RSTB1R_EXTEVNT9, 1 << 29   @ bitWidth 1 (EXTEVNT9)  
        .equ HRTIM_TIMB_RSTB1R_EXTEVNT8, 1 << 28   @ bitWidth 1 (EXTEVNT8)  
        .equ HRTIM_TIMB_RSTB1R_EXTEVNT7, 1 << 27   @ bitWidth 1 (EXTEVNT7)  
        .equ HRTIM_TIMB_RSTB1R_EXTEVNT6, 1 << 26   @ bitWidth 1 (EXTEVNT6)  
        .equ HRTIM_TIMB_RSTB1R_EXTEVNT5, 1 << 25   @ bitWidth 1 (EXTEVNT5)  
        .equ HRTIM_TIMB_RSTB1R_EXTEVNT4, 1 << 24   @ bitWidth 1 (EXTEVNT4)  
        .equ HRTIM_TIMB_RSTB1R_EXTEVNT3, 1 << 23   @ bitWidth 1 (EXTEVNT3)  
        .equ HRTIM_TIMB_RSTB1R_EXTEVNT2, 1 << 22   @ bitWidth 1 (EXTEVNT2)  
        .equ HRTIM_TIMB_RSTB1R_EXTEVNT1, 1 << 21   @ bitWidth 1 (EXTEVNT1)  
        .equ HRTIM_TIMB_RSTB1R_TIMEVNT9, 1 << 20   @ bitWidth 1 (TIMEVNT9)  
        .equ HRTIM_TIMB_RSTB1R_TIMEVNT8, 1 << 19   @ bitWidth 1 (TIMEVNT8)  
        .equ HRTIM_TIMB_RSTB1R_TIMEVNT7, 1 << 18   @ bitWidth 1 (TIMEVNT7)  
        .equ HRTIM_TIMB_RSTB1R_TIMEVNT6, 1 << 17   @ bitWidth 1 (TIMEVNT6)  
        .equ HRTIM_TIMB_RSTB1R_TIMEVNT5, 1 << 16   @ bitWidth 1 (TIMEVNT5)  
        .equ HRTIM_TIMB_RSTB1R_TIMEVNT4, 1 << 15   @ bitWidth 1 (TIMEVNT4)  
        .equ HRTIM_TIMB_RSTB1R_TIMEVNT3, 1 << 14   @ bitWidth 1 (TIMEVNT3)  
        .equ HRTIM_TIMB_RSTB1R_TIMEVNT2, 1 << 13   @ bitWidth 1 (TIMEVNT2)  
        .equ HRTIM_TIMB_RSTB1R_TIMEVNT1, 1 << 12   @ bitWidth 1 (TIMEVNT1)  
        .equ HRTIM_TIMB_RSTB1R_MSTCMP4, 1 << 11   @ bitWidth 1 (MSTCMP4)  
        .equ HRTIM_TIMB_RSTB1R_MSTCMP3, 1 << 10   @ bitWidth 1 (MSTCMP3)  
        .equ HRTIM_TIMB_RSTB1R_MSTCMP2, 1 << 9   @ bitWidth 1 (MSTCMP2)  
        .equ HRTIM_TIMB_RSTB1R_MSTCMP1, 1 << 8   @ bitWidth 1 (MSTCMP1)  
        .equ HRTIM_TIMB_RSTB1R_MSTPER, 1 << 7   @ bitWidth 1 (MSTPER)  
        .equ HRTIM_TIMB_RSTB1R_CMP4, 1 << 6   @ bitWidth 1 (CMP4)  
        .equ HRTIM_TIMB_RSTB1R_CMP3, 1 << 5   @ bitWidth 1 (CMP3)  
        .equ HRTIM_TIMB_RSTB1R_CMP2, 1 << 4   @ bitWidth 1 (CMP2)  
        .equ HRTIM_TIMB_RSTB1R_CMP1, 1 << 3   @ bitWidth 1 (CMP1)  
        .equ HRTIM_TIMB_RSTB1R_PER, 1 << 2   @ bitWidth 1 (PER)  
        .equ HRTIM_TIMB_RSTB1R_RESYNC, 1 << 1   @ bitWidth 1 (RESYNC)  
        .equ HRTIM_TIMB_RSTB1R_SRT, 1 << 0   @ bitWidth 1 (SRT)  
 
    .equ HRTIM_TIMB_SETB2R, HRTIM_TIMB_BASE + 0x44 @ (Timerx Output2 Set Register) 
        .equ HRTIM_TIMB_SETB2R_UPDATE, 1 << 31   @ bitWidth 1 (UPDATE)  
        .equ HRTIM_TIMB_SETB2R_EXTEVNT10, 1 << 30   @ bitWidth 1 (EXTEVNT10)  
        .equ HRTIM_TIMB_SETB2R_EXTEVNT9, 1 << 29   @ bitWidth 1 (EXTEVNT9)  
        .equ HRTIM_TIMB_SETB2R_EXTEVNT8, 1 << 28   @ bitWidth 1 (EXTEVNT8)  
        .equ HRTIM_TIMB_SETB2R_EXTEVNT7, 1 << 27   @ bitWidth 1 (EXTEVNT7)  
        .equ HRTIM_TIMB_SETB2R_EXTEVNT6, 1 << 26   @ bitWidth 1 (EXTEVNT6)  
        .equ HRTIM_TIMB_SETB2R_EXTEVNT5, 1 << 25   @ bitWidth 1 (EXTEVNT5)  
        .equ HRTIM_TIMB_SETB2R_EXTEVNT4, 1 << 24   @ bitWidth 1 (EXTEVNT4)  
        .equ HRTIM_TIMB_SETB2R_EXTEVNT3, 1 << 23   @ bitWidth 1 (EXTEVNT3)  
        .equ HRTIM_TIMB_SETB2R_EXTEVNT2, 1 << 22   @ bitWidth 1 (EXTEVNT2)  
        .equ HRTIM_TIMB_SETB2R_EXTEVNT1, 1 << 21   @ bitWidth 1 (EXTEVNT1)  
        .equ HRTIM_TIMB_SETB2R_TIMEVNT9, 1 << 20   @ bitWidth 1 (TIMEVNT9)  
        .equ HRTIM_TIMB_SETB2R_TIMEVNT8, 1 << 19   @ bitWidth 1 (TIMEVNT8)  
        .equ HRTIM_TIMB_SETB2R_TIMEVNT7, 1 << 18   @ bitWidth 1 (TIMEVNT7)  
        .equ HRTIM_TIMB_SETB2R_TIMEVNT6, 1 << 17   @ bitWidth 1 (TIMEVNT6)  
        .equ HRTIM_TIMB_SETB2R_TIMEVNT5, 1 << 16   @ bitWidth 1 (TIMEVNT5)  
        .equ HRTIM_TIMB_SETB2R_TIMEVNT4, 1 << 15   @ bitWidth 1 (TIMEVNT4)  
        .equ HRTIM_TIMB_SETB2R_TIMEVNT3, 1 << 14   @ bitWidth 1 (TIMEVNT3)  
        .equ HRTIM_TIMB_SETB2R_TIMEVNT2, 1 << 13   @ bitWidth 1 (TIMEVNT2)  
        .equ HRTIM_TIMB_SETB2R_TIMEVNT1, 1 << 12   @ bitWidth 1 (TIMEVNT1)  
        .equ HRTIM_TIMB_SETB2R_MSTCMP4, 1 << 11   @ bitWidth 1 (MSTCMP4)  
        .equ HRTIM_TIMB_SETB2R_MSTCMP3, 1 << 10   @ bitWidth 1 (MSTCMP3)  
        .equ HRTIM_TIMB_SETB2R_MSTCMP2, 1 << 9   @ bitWidth 1 (MSTCMP2)  
        .equ HRTIM_TIMB_SETB2R_MSTCMP1, 1 << 8   @ bitWidth 1 (MSTCMP1)  
        .equ HRTIM_TIMB_SETB2R_MSTPER, 1 << 7   @ bitWidth 1 (MSTPER)  
        .equ HRTIM_TIMB_SETB2R_CMP4, 1 << 6   @ bitWidth 1 (CMP4)  
        .equ HRTIM_TIMB_SETB2R_CMP3, 1 << 5   @ bitWidth 1 (CMP3)  
        .equ HRTIM_TIMB_SETB2R_CMP2, 1 << 4   @ bitWidth 1 (CMP2)  
        .equ HRTIM_TIMB_SETB2R_CMP1, 1 << 3   @ bitWidth 1 (CMP1)  
        .equ HRTIM_TIMB_SETB2R_PER, 1 << 2   @ bitWidth 1 (PER)  
        .equ HRTIM_TIMB_SETB2R_RESYNC, 1 << 1   @ bitWidth 1 (RESYNC)  
        .equ HRTIM_TIMB_SETB2R_SST, 1 << 0   @ bitWidth 1 (SST)  
 
    .equ HRTIM_TIMB_RSTB2R, HRTIM_TIMB_BASE + 0x48 @ (Timerx Output2 Reset Register) 
        .equ HRTIM_TIMB_RSTB2R_UPDATE, 1 << 31   @ bitWidth 1 (UPDATE)  
        .equ HRTIM_TIMB_RSTB2R_EXTEVNT10, 1 << 30   @ bitWidth 1 (EXTEVNT10)  
        .equ HRTIM_TIMB_RSTB2R_EXTEVNT9, 1 << 29   @ bitWidth 1 (EXTEVNT9)  
        .equ HRTIM_TIMB_RSTB2R_EXTEVNT8, 1 << 28   @ bitWidth 1 (EXTEVNT8)  
        .equ HRTIM_TIMB_RSTB2R_EXTEVNT7, 1 << 27   @ bitWidth 1 (EXTEVNT7)  
        .equ HRTIM_TIMB_RSTB2R_EXTEVNT6, 1 << 26   @ bitWidth 1 (EXTEVNT6)  
        .equ HRTIM_TIMB_RSTB2R_EXTEVNT5, 1 << 25   @ bitWidth 1 (EXTEVNT5)  
        .equ HRTIM_TIMB_RSTB2R_EXTEVNT4, 1 << 24   @ bitWidth 1 (EXTEVNT4)  
        .equ HRTIM_TIMB_RSTB2R_EXTEVNT3, 1 << 23   @ bitWidth 1 (EXTEVNT3)  
        .equ HRTIM_TIMB_RSTB2R_EXTEVNT2, 1 << 22   @ bitWidth 1 (EXTEVNT2)  
        .equ HRTIM_TIMB_RSTB2R_EXTEVNT1, 1 << 21   @ bitWidth 1 (EXTEVNT1)  
        .equ HRTIM_TIMB_RSTB2R_TIMEVNT9, 1 << 20   @ bitWidth 1 (TIMEVNT9)  
        .equ HRTIM_TIMB_RSTB2R_TIMEVNT8, 1 << 19   @ bitWidth 1 (TIMEVNT8)  
        .equ HRTIM_TIMB_RSTB2R_TIMEVNT7, 1 << 18   @ bitWidth 1 (TIMEVNT7)  
        .equ HRTIM_TIMB_RSTB2R_TIMEVNT6, 1 << 17   @ bitWidth 1 (TIMEVNT6)  
        .equ HRTIM_TIMB_RSTB2R_TIMEVNT5, 1 << 16   @ bitWidth 1 (TIMEVNT5)  
        .equ HRTIM_TIMB_RSTB2R_TIMEVNT4, 1 << 15   @ bitWidth 1 (TIMEVNT4)  
        .equ HRTIM_TIMB_RSTB2R_TIMEVNT3, 1 << 14   @ bitWidth 1 (TIMEVNT3)  
        .equ HRTIM_TIMB_RSTB2R_TIMEVNT2, 1 << 13   @ bitWidth 1 (TIMEVNT2)  
        .equ HRTIM_TIMB_RSTB2R_TIMEVNT1, 1 << 12   @ bitWidth 1 (TIMEVNT1)  
        .equ HRTIM_TIMB_RSTB2R_MSTCMP4, 1 << 11   @ bitWidth 1 (MSTCMP4)  
        .equ HRTIM_TIMB_RSTB2R_MSTCMP3, 1 << 10   @ bitWidth 1 (MSTCMP3)  
        .equ HRTIM_TIMB_RSTB2R_MSTCMP2, 1 << 9   @ bitWidth 1 (MSTCMP2)  
        .equ HRTIM_TIMB_RSTB2R_MSTCMP1, 1 << 8   @ bitWidth 1 (MSTCMP1)  
        .equ HRTIM_TIMB_RSTB2R_MSTPER, 1 << 7   @ bitWidth 1 (MSTPER)  
        .equ HRTIM_TIMB_RSTB2R_CMP4, 1 << 6   @ bitWidth 1 (CMP4)  
        .equ HRTIM_TIMB_RSTB2R_CMP3, 1 << 5   @ bitWidth 1 (CMP3)  
        .equ HRTIM_TIMB_RSTB2R_CMP2, 1 << 4   @ bitWidth 1 (CMP2)  
        .equ HRTIM_TIMB_RSTB2R_CMP1, 1 << 3   @ bitWidth 1 (CMP1)  
        .equ HRTIM_TIMB_RSTB2R_PER, 1 << 2   @ bitWidth 1 (PER)  
        .equ HRTIM_TIMB_RSTB2R_RESYNC, 1 << 1   @ bitWidth 1 (RESYNC)  
        .equ HRTIM_TIMB_RSTB2R_SRT, 1 << 0   @ bitWidth 1 (SRT)  
 
    .equ HRTIM_TIMB_EEFBR1, HRTIM_TIMB_BASE + 0x4C @ (Timerx External Event Filtering Register  1) 
        .equ HRTIM_TIMB_EEFBR1_EE5FLTR_Shift, 25   @ bitWidth 4 (External Event 5 filter)  
        .equ HRTIM_TIMB_EEFBR1_EE5LTCH, 1 << 24   @ bitWidth 1 (External Event 5 latch)  
        .equ HRTIM_TIMB_EEFBR1_EE4FLTR_Shift, 19   @ bitWidth 4 (External Event 4 filter)  
        .equ HRTIM_TIMB_EEFBR1_EE4LTCH, 1 << 18   @ bitWidth 1 (External Event 4 latch)  
        .equ HRTIM_TIMB_EEFBR1_EE3FLTR_Shift, 13   @ bitWidth 4 (External Event 3 filter)  
        .equ HRTIM_TIMB_EEFBR1_EE3LTCH, 1 << 12   @ bitWidth 1 (External Event 3 latch)  
        .equ HRTIM_TIMB_EEFBR1_EE2FLTR_Shift, 7   @ bitWidth 4 (External Event 2 filter)  
        .equ HRTIM_TIMB_EEFBR1_EE2LTCH, 1 << 6   @ bitWidth 1 (External Event 2 latch)  
        .equ HRTIM_TIMB_EEFBR1_EE1FLTR_Shift, 1   @ bitWidth 4 (External Event 1 filter)  
        .equ HRTIM_TIMB_EEFBR1_EE1LTCH, 1 << 0   @ bitWidth 1 (External Event 1 latch)  
 
    .equ HRTIM_TIMB_EEFBR2, HRTIM_TIMB_BASE + 0x50 @ (Timerx External Event Filtering Register  2) 
        .equ HRTIM_TIMB_EEFBR2_EE10FLTR_Shift, 25   @ bitWidth 4 (External Event 10 filter)  
        .equ HRTIM_TIMB_EEFBR2_EE10LTCH, 1 << 24   @ bitWidth 1 (External Event 10 latch)  
        .equ HRTIM_TIMB_EEFBR2_EE9FLTR_Shift, 19   @ bitWidth 4 (External Event 9 filter)  
        .equ HRTIM_TIMB_EEFBR2_EE9LTCH, 1 << 18   @ bitWidth 1 (External Event 9 latch)  
        .equ HRTIM_TIMB_EEFBR2_EE8FLTR_Shift, 13   @ bitWidth 4 (External Event 8 filter)  
        .equ HRTIM_TIMB_EEFBR2_EE8LTCH, 1 << 12   @ bitWidth 1 (External Event 8 latch)  
        .equ HRTIM_TIMB_EEFBR2_EE7FLTR_Shift, 7   @ bitWidth 4 (External Event 7 filter)  
        .equ HRTIM_TIMB_EEFBR2_EE7LTCH, 1 << 6   @ bitWidth 1 (External Event 7 latch)  
        .equ HRTIM_TIMB_EEFBR2_EE6FLTR_Shift, 1   @ bitWidth 4 (External Event 6 filter)  
        .equ HRTIM_TIMB_EEFBR2_EE6LTCH, 1 << 0   @ bitWidth 1 (External Event 6 latch)  
 
    .equ HRTIM_TIMB_RSTBR, HRTIM_TIMB_BASE + 0x54 @ (TimerA Reset Register) 
        .equ HRTIM_TIMB_RSTBR_TIMECMP4, 1 << 30   @ bitWidth 1 (Timer E Compare 4)  
        .equ HRTIM_TIMB_RSTBR_TIMECMP2, 1 << 29   @ bitWidth 1 (Timer E Compare 2)  
        .equ HRTIM_TIMB_RSTBR_TIMECMP1, 1 << 28   @ bitWidth 1 (Timer E Compare 1)  
        .equ HRTIM_TIMB_RSTBR_TIMDCMP4, 1 << 27   @ bitWidth 1 (Timer D Compare 4)  
        .equ HRTIM_TIMB_RSTBR_TIMDCMP2, 1 << 26   @ bitWidth 1 (Timer D Compare 2)  
        .equ HRTIM_TIMB_RSTBR_TIMDCMP1, 1 << 25   @ bitWidth 1 (Timer D Compare 1)  
        .equ HRTIM_TIMB_RSTBR_TIMCCMP4, 1 << 24   @ bitWidth 1 (Timer C Compare 4)  
        .equ HRTIM_TIMB_RSTBR_TIMCCMP2, 1 << 23   @ bitWidth 1 (Timer C Compare 2)  
        .equ HRTIM_TIMB_RSTBR_TIMCCMP1, 1 << 22   @ bitWidth 1 (Timer C Compare 1)  
        .equ HRTIM_TIMB_RSTBR_TIMACMP4, 1 << 21   @ bitWidth 1 (Timer A Compare 4)  
        .equ HRTIM_TIMB_RSTBR_TIMACMP2, 1 << 20   @ bitWidth 1 (Timer A Compare 2)  
        .equ HRTIM_TIMB_RSTBR_TIMACMP1, 1 << 19   @ bitWidth 1 (Timer A Compare 1)  
        .equ HRTIM_TIMB_RSTBR_EXTEVNT10, 1 << 18   @ bitWidth 1 (External Event 10)  
        .equ HRTIM_TIMB_RSTBR_EXTEVNT9, 1 << 17   @ bitWidth 1 (External Event 9)  
        .equ HRTIM_TIMB_RSTBR_EXTEVNT8, 1 << 16   @ bitWidth 1 (External Event 8)  
        .equ HRTIM_TIMB_RSTBR_EXTEVNT7, 1 << 15   @ bitWidth 1 (External Event 7)  
        .equ HRTIM_TIMB_RSTBR_EXTEVNT6, 1 << 14   @ bitWidth 1 (External Event 6)  
        .equ HRTIM_TIMB_RSTBR_EXTEVNT5, 1 << 13   @ bitWidth 1 (External Event 5)  
        .equ HRTIM_TIMB_RSTBR_EXTEVNT4, 1 << 12   @ bitWidth 1 (External Event 4)  
        .equ HRTIM_TIMB_RSTBR_EXTEVNT3, 1 << 11   @ bitWidth 1 (External Event 3)  
        .equ HRTIM_TIMB_RSTBR_EXTEVNT2, 1 << 10   @ bitWidth 1 (External Event 2)  
        .equ HRTIM_TIMB_RSTBR_EXTEVNT1, 1 << 9   @ bitWidth 1 (External Event 1)  
        .equ HRTIM_TIMB_RSTBR_MSTCMP4, 1 << 8   @ bitWidth 1 (Master compare 4)  
        .equ HRTIM_TIMB_RSTBR_MSTCMP3, 1 << 7   @ bitWidth 1 (Master compare 3)  
        .equ HRTIM_TIMB_RSTBR_MSTCMP2, 1 << 6   @ bitWidth 1 (Master compare 2)  
        .equ HRTIM_TIMB_RSTBR_MSTCMP1, 1 << 5   @ bitWidth 1 (Master compare 1)  
        .equ HRTIM_TIMB_RSTBR_MSTPER, 1 << 4   @ bitWidth 1 (Master timer Period)  
        .equ HRTIM_TIMB_RSTBR_CMP4, 1 << 3   @ bitWidth 1 (Timer A compare 4 reset)  
        .equ HRTIM_TIMB_RSTBR_CMP2, 1 << 2   @ bitWidth 1 (Timer A compare 2 reset)  
        .equ HRTIM_TIMB_RSTBR_UPDT, 1 << 1   @ bitWidth 1 (Timer A Update reset)  
 
    .equ HRTIM_TIMB_CHPBR, HRTIM_TIMB_BASE + 0x58 @ (Timerx Chopper Register) 
        .equ HRTIM_TIMB_CHPBR_STRTPW_Shift, 7   @ bitWidth 4 (STRTPW)  
        .equ HRTIM_TIMB_CHPBR_CHPDTY_Shift, 4   @ bitWidth 3 (Timerx chopper duty cycle  value)  
        .equ HRTIM_TIMB_CHPBR_CHPFRQ_Shift, 0   @ bitWidth 4 (Timerx carrier frequency  value)  
 
    .equ HRTIM_TIMB_CPT1BCR, HRTIM_TIMB_BASE + 0x5C @ (Timerx Capture 2 Control  Register) 
        .equ HRTIM_TIMB_CPT1BCR_TECMP2, 1 << 31   @ bitWidth 1 (Timer E Compare 2)  
        .equ HRTIM_TIMB_CPT1BCR_TECMP1, 1 << 30   @ bitWidth 1 (Timer E Compare 1)  
        .equ HRTIM_TIMB_CPT1BCR_TE1RST, 1 << 29   @ bitWidth 1 (Timer E output 1 Reset)  
        .equ HRTIM_TIMB_CPT1BCR_TE1SET, 1 << 28   @ bitWidth 1 (Timer E output 1 Set)  
        .equ HRTIM_TIMB_CPT1BCR_TDCMP2, 1 << 27   @ bitWidth 1 (Timer D Compare 2)  
        .equ HRTIM_TIMB_CPT1BCR_TDCMP1, 1 << 26   @ bitWidth 1 (Timer D Compare 1)  
        .equ HRTIM_TIMB_CPT1BCR_TD1RST, 1 << 25   @ bitWidth 1 (Timer D output 1 Reset)  
        .equ HRTIM_TIMB_CPT1BCR_TD1SET, 1 << 24   @ bitWidth 1 (Timer D output 1 Set)  
        .equ HRTIM_TIMB_CPT1BCR_TCCMP2, 1 << 23   @ bitWidth 1 (Timer C Compare 2)  
        .equ HRTIM_TIMB_CPT1BCR_TCCMP1, 1 << 22   @ bitWidth 1 (Timer C Compare 1)  
        .equ HRTIM_TIMB_CPT1BCR_TC1RST, 1 << 21   @ bitWidth 1 (Timer C output 1 Reset)  
        .equ HRTIM_TIMB_CPT1BCR_TC1SET, 1 << 20   @ bitWidth 1 (Timer C output 1 Set)  
        .equ HRTIM_TIMB_CPT1BCR_TACMP2, 1 << 15   @ bitWidth 1 (Timer A Compare 2)  
        .equ HRTIM_TIMB_CPT1BCR_TACMP1, 1 << 14   @ bitWidth 1 (Timer A Compare 1)  
        .equ HRTIM_TIMB_CPT1BCR_TA1RST, 1 << 13   @ bitWidth 1 (Timer A output 1 Reset)  
        .equ HRTIM_TIMB_CPT1BCR_TA1SET, 1 << 12   @ bitWidth 1 (Timer A output 1 Set)  
        .equ HRTIM_TIMB_CPT1BCR_EXEV10CPT, 1 << 11   @ bitWidth 1 (External Event 10 Capture)  
        .equ HRTIM_TIMB_CPT1BCR_EXEV9CPT, 1 << 10   @ bitWidth 1 (External Event 9 Capture)  
        .equ HRTIM_TIMB_CPT1BCR_EXEV8CPT, 1 << 9   @ bitWidth 1 (External Event 8 Capture)  
        .equ HRTIM_TIMB_CPT1BCR_EXEV7CPT, 1 << 8   @ bitWidth 1 (External Event 7 Capture)  
        .equ HRTIM_TIMB_CPT1BCR_EXEV6CPT, 1 << 7   @ bitWidth 1 (External Event 6 Capture)  
        .equ HRTIM_TIMB_CPT1BCR_EXEV5CPT, 1 << 6   @ bitWidth 1 (External Event 5 Capture)  
        .equ HRTIM_TIMB_CPT1BCR_EXEV4CPT, 1 << 5   @ bitWidth 1 (External Event 4 Capture)  
        .equ HRTIM_TIMB_CPT1BCR_EXEV3CPT, 1 << 4   @ bitWidth 1 (External Event 3 Capture)  
        .equ HRTIM_TIMB_CPT1BCR_EXEV2CPT, 1 << 3   @ bitWidth 1 (External Event 2 Capture)  
        .equ HRTIM_TIMB_CPT1BCR_EXEV1CPT, 1 << 2   @ bitWidth 1 (External Event 1 Capture)  
        .equ HRTIM_TIMB_CPT1BCR_UDPCPT, 1 << 1   @ bitWidth 1 (Update Capture)  
        .equ HRTIM_TIMB_CPT1BCR_SWCPT, 1 << 0   @ bitWidth 1 (Software Capture)  
 
    .equ HRTIM_TIMB_CPT2BCR, HRTIM_TIMB_BASE + 0x60 @ (CPT2xCR) 
        .equ HRTIM_TIMB_CPT2BCR_TECMP2, 1 << 31   @ bitWidth 1 (Timer E Compare 2)  
        .equ HRTIM_TIMB_CPT2BCR_TECMP1, 1 << 30   @ bitWidth 1 (Timer E Compare 1)  
        .equ HRTIM_TIMB_CPT2BCR_TE1RST, 1 << 29   @ bitWidth 1 (Timer E output 1 Reset)  
        .equ HRTIM_TIMB_CPT2BCR_TE1SET, 1 << 28   @ bitWidth 1 (Timer E output 1 Set)  
        .equ HRTIM_TIMB_CPT2BCR_TDCMP2, 1 << 27   @ bitWidth 1 (Timer D Compare 2)  
        .equ HRTIM_TIMB_CPT2BCR_TDCMP1, 1 << 26   @ bitWidth 1 (Timer D Compare 1)  
        .equ HRTIM_TIMB_CPT2BCR_TD1RST, 1 << 25   @ bitWidth 1 (Timer D output 1 Reset)  
        .equ HRTIM_TIMB_CPT2BCR_TD1SET, 1 << 24   @ bitWidth 1 (Timer D output 1 Set)  
        .equ HRTIM_TIMB_CPT2BCR_TCCMP2, 1 << 23   @ bitWidth 1 (Timer C Compare 2)  
        .equ HRTIM_TIMB_CPT2BCR_TCCMP1, 1 << 22   @ bitWidth 1 (Timer C Compare 1)  
        .equ HRTIM_TIMB_CPT2BCR_TC1RST, 1 << 21   @ bitWidth 1 (Timer C output 1 Reset)  
        .equ HRTIM_TIMB_CPT2BCR_TC1SET, 1 << 20   @ bitWidth 1 (Timer C output 1 Set)  
        .equ HRTIM_TIMB_CPT2BCR_TACMP2, 1 << 15   @ bitWidth 1 (Timer A Compare 2)  
        .equ HRTIM_TIMB_CPT2BCR_TACMP1, 1 << 14   @ bitWidth 1 (Timer A Compare 1)  
        .equ HRTIM_TIMB_CPT2BCR_TA1RST, 1 << 13   @ bitWidth 1 (Timer A output 1 Reset)  
        .equ HRTIM_TIMB_CPT2BCR_TA1SET, 1 << 12   @ bitWidth 1 (Timer A output 1 Set)  
        .equ HRTIM_TIMB_CPT2BCR_EXEV10CPT, 1 << 11   @ bitWidth 1 (External Event 10 Capture)  
        .equ HRTIM_TIMB_CPT2BCR_EXEV9CPT, 1 << 10   @ bitWidth 1 (External Event 9 Capture)  
        .equ HRTIM_TIMB_CPT2BCR_EXEV8CPT, 1 << 9   @ bitWidth 1 (External Event 8 Capture)  
        .equ HRTIM_TIMB_CPT2BCR_EXEV7CPT, 1 << 8   @ bitWidth 1 (External Event 7 Capture)  
        .equ HRTIM_TIMB_CPT2BCR_EXEV6CPT, 1 << 7   @ bitWidth 1 (External Event 6 Capture)  
        .equ HRTIM_TIMB_CPT2BCR_EXEV5CPT, 1 << 6   @ bitWidth 1 (External Event 5 Capture)  
        .equ HRTIM_TIMB_CPT2BCR_EXEV4CPT, 1 << 5   @ bitWidth 1 (External Event 4 Capture)  
        .equ HRTIM_TIMB_CPT2BCR_EXEV3CPT, 1 << 4   @ bitWidth 1 (External Event 3 Capture)  
        .equ HRTIM_TIMB_CPT2BCR_EXEV2CPT, 1 << 3   @ bitWidth 1 (External Event 2 Capture)  
        .equ HRTIM_TIMB_CPT2BCR_EXEV1CPT, 1 << 2   @ bitWidth 1 (External Event 1 Capture)  
        .equ HRTIM_TIMB_CPT2BCR_UDPCPT, 1 << 1   @ bitWidth 1 (Update Capture)  
        .equ HRTIM_TIMB_CPT2BCR_SWCPT, 1 << 0   @ bitWidth 1 (Software Capture)  
 
    .equ HRTIM_TIMB_OUTBR, HRTIM_TIMB_BASE + 0x64 @ (Timerx Output Register) 
        .equ HRTIM_TIMB_OUTBR_DIDL2, 1 << 23   @ bitWidth 1 (Output 2 Deadtime upon burst mode Idle  entry)  
        .equ HRTIM_TIMB_OUTBR_CHP2, 1 << 22   @ bitWidth 1 (Output 2 Chopper enable)  
        .equ HRTIM_TIMB_OUTBR_FAULT2_Shift, 20   @ bitWidth 2 (Output 2 Fault state)  
        .equ HRTIM_TIMB_OUTBR_IDLES2, 1 << 19   @ bitWidth 1 (Output 2 Idle State)  
        .equ HRTIM_TIMB_OUTBR_IDLEM2, 1 << 18   @ bitWidth 1 (Output 2 Idle mode)  
        .equ HRTIM_TIMB_OUTBR_POL2, 1 << 17   @ bitWidth 1 (Output 2 polarity)  
        .equ HRTIM_TIMB_OUTBR_DLYPRT_Shift, 10   @ bitWidth 3 (Delayed Protection)  
        .equ HRTIM_TIMB_OUTBR_DLYPRTEN, 1 << 9   @ bitWidth 1 (Delayed Protection Enable)  
        .equ HRTIM_TIMB_OUTBR_DTEN, 1 << 8   @ bitWidth 1 (Deadtime enable)  
        .equ HRTIM_TIMB_OUTBR_DIDL1, 1 << 7   @ bitWidth 1 (Output 1 Deadtime upon burst mode Idle  entry)  
        .equ HRTIM_TIMB_OUTBR_CHP1, 1 << 6   @ bitWidth 1 (Output 1 Chopper enable)  
        .equ HRTIM_TIMB_OUTBR_FAULT1_Shift, 4   @ bitWidth 2 (Output 1 Fault state)  
        .equ HRTIM_TIMB_OUTBR_IDLES1, 1 << 3   @ bitWidth 1 (Output 1 Idle State)  
        .equ HRTIM_TIMB_OUTBR_IDLEM1, 1 << 2   @ bitWidth 1 (Output 1 Idle mode)  
        .equ HRTIM_TIMB_OUTBR_POL1, 1 << 1   @ bitWidth 1 (Output 1 polarity)  
 
    .equ HRTIM_TIMB_FLTBR, HRTIM_TIMB_BASE + 0x68 @ (Timerx Fault Register) 
        .equ HRTIM_TIMB_FLTBR_FLTLCK, 1 << 31   @ bitWidth 1 (Fault sources Lock)  
        .equ HRTIM_TIMB_FLTBR_FLT5EN, 1 << 4   @ bitWidth 1 (Fault 5 enable)  
        .equ HRTIM_TIMB_FLTBR_FLT4EN, 1 << 3   @ bitWidth 1 (Fault 4 enable)  
        .equ HRTIM_TIMB_FLTBR_FLT3EN, 1 << 2   @ bitWidth 1 (Fault 3 enable)  
        .equ HRTIM_TIMB_FLTBR_FLT2EN, 1 << 1   @ bitWidth 1 (Fault 2 enable)  
        .equ HRTIM_TIMB_FLTBR_FLT1EN, 1 << 0   @ bitWidth 1 (Fault 1 enable)  
 

@=========================== HRTIM_TIMC ===========================@
.equ HRTIM_TIMC_BASE, 0x40017580 @ (High Resolution Timer: TIMC) 
    .equ HRTIM_TIMC_TIMCCR, HRTIM_TIMC_BASE + 0x0 @ (Timerx Control Register) 
        .equ HRTIM_TIMC_TIMCCR_UPDGAT_Shift, 28   @ bitWidth 4 (Update Gating)  
        .equ HRTIM_TIMC_TIMCCR_PREEN, 1 << 27   @ bitWidth 1 (Preload enable)  
        .equ HRTIM_TIMC_TIMCCR_DACSYNC_Shift, 25   @ bitWidth 2 (AC Synchronization)  
        .equ HRTIM_TIMC_TIMCCR_MSTU, 1 << 24   @ bitWidth 1 (Master Timer update)  
        .equ HRTIM_TIMC_TIMCCR_TEU, 1 << 23   @ bitWidth 1 (TEU)  
        .equ HRTIM_TIMC_TIMCCR_TDU, 1 << 22   @ bitWidth 1 (TDU)  
        .equ HRTIM_TIMC_TIMCCR_TCU, 1 << 21   @ bitWidth 1 (TCU)  
        .equ HRTIM_TIMC_TIMCCR_TBU, 1 << 20   @ bitWidth 1 (TBU)  
        .equ HRTIM_TIMC_TIMCCR_TxRSTU, 1 << 18   @ bitWidth 1 (Timerx reset update)  
        .equ HRTIM_TIMC_TIMCCR_TxREPU, 1 << 17   @ bitWidth 1 (Timer x Repetition update)  
        .equ HRTIM_TIMC_TIMCCR_DELCMP4_Shift, 14   @ bitWidth 2 (Delayed CMP4 mode)  
        .equ HRTIM_TIMC_TIMCCR_DELCMP2_Shift, 12   @ bitWidth 2 (Delayed CMP2 mode)  
        .equ HRTIM_TIMC_TIMCCR_SYNCSTRTx, 1 << 11   @ bitWidth 1 (Synchronization Starts Timer  x)  
        .equ HRTIM_TIMC_TIMCCR_SYNCRSTx, 1 << 10   @ bitWidth 1 (Synchronization Resets Timer  x)  
        .equ HRTIM_TIMC_TIMCCR_PSHPLL, 1 << 6   @ bitWidth 1 (Push-Pull mode enable)  
        .equ HRTIM_TIMC_TIMCCR_HALF, 1 << 5   @ bitWidth 1 (Half mode enable)  
        .equ HRTIM_TIMC_TIMCCR_RETRIG, 1 << 4   @ bitWidth 1 (Re-triggerable mode)  
        .equ HRTIM_TIMC_TIMCCR_CONT, 1 << 3   @ bitWidth 1 (Continuous mode)  
        .equ HRTIM_TIMC_TIMCCR_CK_PSCx_Shift, 0   @ bitWidth 3 (HRTIM Timer x Clock  prescaler)  
 
    .equ HRTIM_TIMC_TIMCISR, HRTIM_TIMC_BASE + 0x4 @ (Timerx Interrupt Status  Register) 
        .equ HRTIM_TIMC_TIMCISR_O2STAT, 1 << 19   @ bitWidth 1 (Output 2 State)  
        .equ HRTIM_TIMC_TIMCISR_O1STAT, 1 << 18   @ bitWidth 1 (Output 1 State)  
        .equ HRTIM_TIMC_TIMCISR_IPPSTAT, 1 << 17   @ bitWidth 1 (Idle Push Pull Status)  
        .equ HRTIM_TIMC_TIMCISR_CPPSTAT, 1 << 16   @ bitWidth 1 (Current Push Pull Status)  
        .equ HRTIM_TIMC_TIMCISR_DLYPRT, 1 << 14   @ bitWidth 1 (Delayed Protection Flag)  
        .equ HRTIM_TIMC_TIMCISR_RST, 1 << 13   @ bitWidth 1 (Reset Interrupt Flag)  
        .equ HRTIM_TIMC_TIMCISR_RSTx2, 1 << 12   @ bitWidth 1 (Output 2 Reset Interrupt  Flag)  
        .equ HRTIM_TIMC_TIMCISR_SETx2, 1 << 11   @ bitWidth 1 (Output 2 Set Interrupt  Flag)  
        .equ HRTIM_TIMC_TIMCISR_RSTx1, 1 << 10   @ bitWidth 1 (Output 1 Reset Interrupt  Flag)  
        .equ HRTIM_TIMC_TIMCISR_SETx1, 1 << 9   @ bitWidth 1 (Output 1 Set Interrupt  Flag)  
        .equ HRTIM_TIMC_TIMCISR_CPT2, 1 << 8   @ bitWidth 1 (Capture2 Interrupt Flag)  
        .equ HRTIM_TIMC_TIMCISR_CPT1, 1 << 7   @ bitWidth 1 (Capture1 Interrupt Flag)  
        .equ HRTIM_TIMC_TIMCISR_UPD, 1 << 6   @ bitWidth 1 (Update Interrupt Flag)  
        .equ HRTIM_TIMC_TIMCISR_REP, 1 << 4   @ bitWidth 1 (Repetition Interrupt Flag)  
        .equ HRTIM_TIMC_TIMCISR_CMP4, 1 << 3   @ bitWidth 1 (Compare 4 Interrupt Flag)  
        .equ HRTIM_TIMC_TIMCISR_CMP3, 1 << 2   @ bitWidth 1 (Compare 3 Interrupt Flag)  
        .equ HRTIM_TIMC_TIMCISR_CMP2, 1 << 1   @ bitWidth 1 (Compare 2 Interrupt Flag)  
        .equ HRTIM_TIMC_TIMCISR_CMP1, 1 << 0   @ bitWidth 1 (Compare 1 Interrupt Flag)  
 
    .equ HRTIM_TIMC_TIMCICR, HRTIM_TIMC_BASE + 0x8 @ (Timerx Interrupt Clear  Register) 
        .equ HRTIM_TIMC_TIMCICR_DLYPRTC, 1 << 14   @ bitWidth 1 (Delayed Protection Flag  Clear)  
        .equ HRTIM_TIMC_TIMCICR_RSTC, 1 << 13   @ bitWidth 1 (Reset Interrupt flag Clear)  
        .equ HRTIM_TIMC_TIMCICR_RSTx2C, 1 << 12   @ bitWidth 1 (Output 2 Reset flag Clear)  
        .equ HRTIM_TIMC_TIMCICR_SET2xC, 1 << 11   @ bitWidth 1 (Output 2 Set flag Clear)  
        .equ HRTIM_TIMC_TIMCICR_RSTx1C, 1 << 10   @ bitWidth 1 (Output 1 Reset flag Clear)  
        .equ HRTIM_TIMC_TIMCICR_SET1xC, 1 << 9   @ bitWidth 1 (Output 1 Set flag Clear)  
        .equ HRTIM_TIMC_TIMCICR_CPT2C, 1 << 8   @ bitWidth 1 (Capture2 Interrupt flag  Clear)  
        .equ HRTIM_TIMC_TIMCICR_CPT1C, 1 << 7   @ bitWidth 1 (Capture1 Interrupt flag  Clear)  
        .equ HRTIM_TIMC_TIMCICR_UPDC, 1 << 6   @ bitWidth 1 (Update Interrupt flag  Clear)  
        .equ HRTIM_TIMC_TIMCICR_REPC, 1 << 4   @ bitWidth 1 (Repetition Interrupt flag  Clear)  
        .equ HRTIM_TIMC_TIMCICR_CMP4C, 1 << 3   @ bitWidth 1 (Compare 4 Interrupt flag  Clear)  
        .equ HRTIM_TIMC_TIMCICR_CMP3C, 1 << 2   @ bitWidth 1 (Compare 3 Interrupt flag  Clear)  
        .equ HRTIM_TIMC_TIMCICR_CMP2C, 1 << 1   @ bitWidth 1 (Compare 2 Interrupt flag  Clear)  
        .equ HRTIM_TIMC_TIMCICR_CMP1C, 1 << 0   @ bitWidth 1 (Compare 1 Interrupt flag  Clear)  
 
    .equ HRTIM_TIMC_TIMCDIER5, HRTIM_TIMC_BASE + 0xC @ (TIMxDIER5) 
        .equ HRTIM_TIMC_TIMCDIER5_DLYPRTDE, 1 << 30   @ bitWidth 1 (DLYPRTDE)  
        .equ HRTIM_TIMC_TIMCDIER5_RSTDE, 1 << 29   @ bitWidth 1 (RSTDE)  
        .equ HRTIM_TIMC_TIMCDIER5_RSTx2DE, 1 << 28   @ bitWidth 1 (RSTx2DE)  
        .equ HRTIM_TIMC_TIMCDIER5_SETx2DE, 1 << 27   @ bitWidth 1 (SETx2DE)  
        .equ HRTIM_TIMC_TIMCDIER5_RSTx1DE, 1 << 26   @ bitWidth 1 (RSTx1DE)  
        .equ HRTIM_TIMC_TIMCDIER5_SET1xDE, 1 << 25   @ bitWidth 1 (SET1xDE)  
        .equ HRTIM_TIMC_TIMCDIER5_CPT2DE, 1 << 24   @ bitWidth 1 (CPT2DE)  
        .equ HRTIM_TIMC_TIMCDIER5_CPT1DE, 1 << 23   @ bitWidth 1 (CPT1DE)  
        .equ HRTIM_TIMC_TIMCDIER5_UPDDE, 1 << 22   @ bitWidth 1 (UPDDE)  
        .equ HRTIM_TIMC_TIMCDIER5_REPDE, 1 << 20   @ bitWidth 1 (REPDE)  
        .equ HRTIM_TIMC_TIMCDIER5_CMP4DE, 1 << 19   @ bitWidth 1 (CMP4DE)  
        .equ HRTIM_TIMC_TIMCDIER5_CMP3DE, 1 << 18   @ bitWidth 1 (CMP3DE)  
        .equ HRTIM_TIMC_TIMCDIER5_CMP2DE, 1 << 17   @ bitWidth 1 (CMP2DE)  
        .equ HRTIM_TIMC_TIMCDIER5_CMP1DE, 1 << 16   @ bitWidth 1 (CMP1DE)  
        .equ HRTIM_TIMC_TIMCDIER5_DLYPRTIE, 1 << 14   @ bitWidth 1 (DLYPRTIE)  
        .equ HRTIM_TIMC_TIMCDIER5_RSTIE, 1 << 13   @ bitWidth 1 (RSTIE)  
        .equ HRTIM_TIMC_TIMCDIER5_RSTx2IE, 1 << 12   @ bitWidth 1 (RSTx2IE)  
        .equ HRTIM_TIMC_TIMCDIER5_SETx2IE, 1 << 11   @ bitWidth 1 (SETx2IE)  
        .equ HRTIM_TIMC_TIMCDIER5_RSTx1IE, 1 << 10   @ bitWidth 1 (RSTx1IE)  
        .equ HRTIM_TIMC_TIMCDIER5_SET1xIE, 1 << 9   @ bitWidth 1 (SET1xIE)  
        .equ HRTIM_TIMC_TIMCDIER5_CPT2IE, 1 << 8   @ bitWidth 1 (CPT2IE)  
        .equ HRTIM_TIMC_TIMCDIER5_CPT1IE, 1 << 7   @ bitWidth 1 (CPT1IE)  
        .equ HRTIM_TIMC_TIMCDIER5_UPDIE, 1 << 6   @ bitWidth 1 (UPDIE)  
        .equ HRTIM_TIMC_TIMCDIER5_REPIE, 1 << 4   @ bitWidth 1 (REPIE)  
        .equ HRTIM_TIMC_TIMCDIER5_CMP4IE, 1 << 3   @ bitWidth 1 (CMP4IE)  
        .equ HRTIM_TIMC_TIMCDIER5_CMP3IE, 1 << 2   @ bitWidth 1 (CMP3IE)  
        .equ HRTIM_TIMC_TIMCDIER5_CMP2IE, 1 << 1   @ bitWidth 1 (CMP2IE)  
        .equ HRTIM_TIMC_TIMCDIER5_CMP1IE, 1 << 0   @ bitWidth 1 (CMP1IE)  
 
    .equ HRTIM_TIMC_CNTCR, HRTIM_TIMC_BASE + 0x10 @ (Timerx Counter Register) 
        .equ HRTIM_TIMC_CNTCR_CNTx_Shift, 0   @ bitWidth 16 (Timerx Counter value)  
 
    .equ HRTIM_TIMC_PERCR, HRTIM_TIMC_BASE + 0x14 @ (Timerx Period Register) 
        .equ HRTIM_TIMC_PERCR_PERx_Shift, 0   @ bitWidth 16 (Timerx Period value)  
 
    .equ HRTIM_TIMC_REPCR, HRTIM_TIMC_BASE + 0x18 @ (Timerx Repetition Register) 
        .equ HRTIM_TIMC_REPCR_REPx_Shift, 0   @ bitWidth 8 (Timerx Repetition counter  value)  
 
    .equ HRTIM_TIMC_CMP1CR, HRTIM_TIMC_BASE + 0x1C @ (Timerx Compare 1 Register) 
        .equ HRTIM_TIMC_CMP1CR_CMP1x_Shift, 0   @ bitWidth 16 (Timerx Compare 1 value)  
 
    .equ HRTIM_TIMC_CMP1CCR, HRTIM_TIMC_BASE + 0x20 @ (Timerx Compare 1 Compound  Register) 
        .equ HRTIM_TIMC_CMP1CCR_REPx_Shift, 16   @ bitWidth 8 (Timerx Repetition value aliased from  HRTIM_REPx register)  
        .equ HRTIM_TIMC_CMP1CCR_CMP1x_Shift, 0   @ bitWidth 16 (Timerx Compare 1 value)  
 
    .equ HRTIM_TIMC_CMP2CR, HRTIM_TIMC_BASE + 0x24 @ (Timerx Compare 2 Register) 
        .equ HRTIM_TIMC_CMP2CR_CMP2x_Shift, 0   @ bitWidth 16 (Timerx Compare 2 value)  
 
    .equ HRTIM_TIMC_CMP3CR, HRTIM_TIMC_BASE + 0x28 @ (Timerx Compare 3 Register) 
        .equ HRTIM_TIMC_CMP3CR_CMP3x_Shift, 0   @ bitWidth 16 (Timerx Compare 3 value)  
 
    .equ HRTIM_TIMC_CMP4CR, HRTIM_TIMC_BASE + 0x2C @ (Timerx Compare 4 Register) 
        .equ HRTIM_TIMC_CMP4CR_CMP4x_Shift, 0   @ bitWidth 16 (Timerx Compare 4 value)  
 
    .equ HRTIM_TIMC_CPT1CR, HRTIM_TIMC_BASE + 0x30 @ (Timerx Capture 1 Register) 
        .equ HRTIM_TIMC_CPT1CR_CPT1x_Shift, 0   @ bitWidth 16 (Timerx Capture 1 value)  
 
    .equ HRTIM_TIMC_CPT2CR, HRTIM_TIMC_BASE + 0x34 @ (Timerx Capture 2 Register) 
        .equ HRTIM_TIMC_CPT2CR_CPT2x_Shift, 0   @ bitWidth 16 (Timerx Capture 2 value)  
 
    .equ HRTIM_TIMC_DTCR, HRTIM_TIMC_BASE + 0x38 @ (Timerx Deadtime Register) 
        .equ HRTIM_TIMC_DTCR_DTFLKx, 1 << 31   @ bitWidth 1 (Deadtime Falling Lock)  
        .equ HRTIM_TIMC_DTCR_DTFSLKx, 1 << 30   @ bitWidth 1 (Deadtime Falling Sign Lock)  
        .equ HRTIM_TIMC_DTCR_SDTFx, 1 << 25   @ bitWidth 1 (Sign Deadtime Falling  value)  
        .equ HRTIM_TIMC_DTCR_DTFx_Shift, 16   @ bitWidth 9 (Deadtime Falling value)  
        .equ HRTIM_TIMC_DTCR_DTRLKx, 1 << 15   @ bitWidth 1 (Deadtime Rising Lock)  
        .equ HRTIM_TIMC_DTCR_DTRSLKx, 1 << 14   @ bitWidth 1 (Deadtime Rising Sign Lock)  
        .equ HRTIM_TIMC_DTCR_DTPRSC_Shift, 10   @ bitWidth 3 (Deadtime Prescaler)  
        .equ HRTIM_TIMC_DTCR_SDTRx, 1 << 9   @ bitWidth 1 (Sign Deadtime Rising value)  
        .equ HRTIM_TIMC_DTCR_DTRx_Shift, 0   @ bitWidth 9 (Deadtime Rising value)  
 
    .equ HRTIM_TIMC_SETC1R, HRTIM_TIMC_BASE + 0x3C @ (Timerx Output1 Set Register) 
        .equ HRTIM_TIMC_SETC1R_UPDATE, 1 << 31   @ bitWidth 1 (Registers update transfer preload to  active)  
        .equ HRTIM_TIMC_SETC1R_EXTEVNT10, 1 << 30   @ bitWidth 1 (External Event 10)  
        .equ HRTIM_TIMC_SETC1R_EXTEVNT9, 1 << 29   @ bitWidth 1 (External Event 9)  
        .equ HRTIM_TIMC_SETC1R_EXTEVNT8, 1 << 28   @ bitWidth 1 (External Event 8)  
        .equ HRTIM_TIMC_SETC1R_EXTEVNT7, 1 << 27   @ bitWidth 1 (External Event 7)  
        .equ HRTIM_TIMC_SETC1R_EXTEVNT6, 1 << 26   @ bitWidth 1 (External Event 6)  
        .equ HRTIM_TIMC_SETC1R_EXTEVNT5, 1 << 25   @ bitWidth 1 (External Event 5)  
        .equ HRTIM_TIMC_SETC1R_EXTEVNT4, 1 << 24   @ bitWidth 1 (External Event 4)  
        .equ HRTIM_TIMC_SETC1R_EXTEVNT3, 1 << 23   @ bitWidth 1 (External Event 3)  
        .equ HRTIM_TIMC_SETC1R_EXTEVNT2, 1 << 22   @ bitWidth 1 (External Event 2)  
        .equ HRTIM_TIMC_SETC1R_EXTEVNT1, 1 << 21   @ bitWidth 1 (External Event 1)  
        .equ HRTIM_TIMC_SETC1R_TIMEVNT9, 1 << 20   @ bitWidth 1 (Timer Event 9)  
        .equ HRTIM_TIMC_SETC1R_TIMEVNT8, 1 << 19   @ bitWidth 1 (Timer Event 8)  
        .equ HRTIM_TIMC_SETC1R_TIMEVNT7, 1 << 18   @ bitWidth 1 (Timer Event 7)  
        .equ HRTIM_TIMC_SETC1R_TIMEVNT6, 1 << 17   @ bitWidth 1 (Timer Event 6)  
        .equ HRTIM_TIMC_SETC1R_TIMEVNT5, 1 << 16   @ bitWidth 1 (Timer Event 5)  
        .equ HRTIM_TIMC_SETC1R_TIMEVNT4, 1 << 15   @ bitWidth 1 (Timer Event 4)  
        .equ HRTIM_TIMC_SETC1R_TIMEVNT3, 1 << 14   @ bitWidth 1 (Timer Event 3)  
        .equ HRTIM_TIMC_SETC1R_TIMEVNT2, 1 << 13   @ bitWidth 1 (Timer Event 2)  
        .equ HRTIM_TIMC_SETC1R_TIMEVNT1, 1 << 12   @ bitWidth 1 (Timer Event 1)  
        .equ HRTIM_TIMC_SETC1R_MSTCMP4, 1 << 11   @ bitWidth 1 (Master Compare 4)  
        .equ HRTIM_TIMC_SETC1R_MSTCMP3, 1 << 10   @ bitWidth 1 (Master Compare 3)  
        .equ HRTIM_TIMC_SETC1R_MSTCMP2, 1 << 9   @ bitWidth 1 (Master Compare 2)  
        .equ HRTIM_TIMC_SETC1R_MSTCMP1, 1 << 8   @ bitWidth 1 (Master Compare 1)  
        .equ HRTIM_TIMC_SETC1R_MSTPER, 1 << 7   @ bitWidth 1 (Master Period)  
        .equ HRTIM_TIMC_SETC1R_CMP4, 1 << 6   @ bitWidth 1 (Timer A compare 4)  
        .equ HRTIM_TIMC_SETC1R_CMP3, 1 << 5   @ bitWidth 1 (Timer A compare 3)  
        .equ HRTIM_TIMC_SETC1R_CMP2, 1 << 4   @ bitWidth 1 (Timer A compare 2)  
        .equ HRTIM_TIMC_SETC1R_CMP1, 1 << 3   @ bitWidth 1 (Timer A compare 1)  
        .equ HRTIM_TIMC_SETC1R_PER, 1 << 2   @ bitWidth 1 (Timer A Period)  
        .equ HRTIM_TIMC_SETC1R_RESYNC, 1 << 1   @ bitWidth 1 (Timer A resynchronizaton)  
        .equ HRTIM_TIMC_SETC1R_SST, 1 << 0   @ bitWidth 1 (Software Set trigger)  
 
    .equ HRTIM_TIMC_RSTC1R, HRTIM_TIMC_BASE + 0x40 @ (Timerx Output1 Reset Register) 
        .equ HRTIM_TIMC_RSTC1R_UPDATE, 1 << 31   @ bitWidth 1 (UPDATE)  
        .equ HRTIM_TIMC_RSTC1R_EXTEVNT10, 1 << 30   @ bitWidth 1 (EXTEVNT10)  
        .equ HRTIM_TIMC_RSTC1R_EXTEVNT9, 1 << 29   @ bitWidth 1 (EXTEVNT9)  
        .equ HRTIM_TIMC_RSTC1R_EXTEVNT8, 1 << 28   @ bitWidth 1 (EXTEVNT8)  
        .equ HRTIM_TIMC_RSTC1R_EXTEVNT7, 1 << 27   @ bitWidth 1 (EXTEVNT7)  
        .equ HRTIM_TIMC_RSTC1R_EXTEVNT6, 1 << 26   @ bitWidth 1 (EXTEVNT6)  
        .equ HRTIM_TIMC_RSTC1R_EXTEVNT5, 1 << 25   @ bitWidth 1 (EXTEVNT5)  
        .equ HRTIM_TIMC_RSTC1R_EXTEVNT4, 1 << 24   @ bitWidth 1 (EXTEVNT4)  
        .equ HRTIM_TIMC_RSTC1R_EXTEVNT3, 1 << 23   @ bitWidth 1 (EXTEVNT3)  
        .equ HRTIM_TIMC_RSTC1R_EXTEVNT2, 1 << 22   @ bitWidth 1 (EXTEVNT2)  
        .equ HRTIM_TIMC_RSTC1R_EXTEVNT1, 1 << 21   @ bitWidth 1 (EXTEVNT1)  
        .equ HRTIM_TIMC_RSTC1R_TIMEVNT9, 1 << 20   @ bitWidth 1 (TIMEVNT9)  
        .equ HRTIM_TIMC_RSTC1R_TIMEVNT8, 1 << 19   @ bitWidth 1 (TIMEVNT8)  
        .equ HRTIM_TIMC_RSTC1R_TIMEVNT7, 1 << 18   @ bitWidth 1 (TIMEVNT7)  
        .equ HRTIM_TIMC_RSTC1R_TIMEVNT6, 1 << 17   @ bitWidth 1 (TIMEVNT6)  
        .equ HRTIM_TIMC_RSTC1R_TIMEVNT5, 1 << 16   @ bitWidth 1 (TIMEVNT5)  
        .equ HRTIM_TIMC_RSTC1R_TIMEVNT4, 1 << 15   @ bitWidth 1 (TIMEVNT4)  
        .equ HRTIM_TIMC_RSTC1R_TIMEVNT3, 1 << 14   @ bitWidth 1 (TIMEVNT3)  
        .equ HRTIM_TIMC_RSTC1R_TIMEVNT2, 1 << 13   @ bitWidth 1 (TIMEVNT2)  
        .equ HRTIM_TIMC_RSTC1R_TIMEVNT1, 1 << 12   @ bitWidth 1 (TIMEVNT1)  
        .equ HRTIM_TIMC_RSTC1R_MSTCMP4, 1 << 11   @ bitWidth 1 (MSTCMP4)  
        .equ HRTIM_TIMC_RSTC1R_MSTCMP3, 1 << 10   @ bitWidth 1 (MSTCMP3)  
        .equ HRTIM_TIMC_RSTC1R_MSTCMP2, 1 << 9   @ bitWidth 1 (MSTCMP2)  
        .equ HRTIM_TIMC_RSTC1R_MSTCMP1, 1 << 8   @ bitWidth 1 (MSTCMP1)  
        .equ HRTIM_TIMC_RSTC1R_MSTPER, 1 << 7   @ bitWidth 1 (MSTPER)  
        .equ HRTIM_TIMC_RSTC1R_CMP4, 1 << 6   @ bitWidth 1 (CMP4)  
        .equ HRTIM_TIMC_RSTC1R_CMP3, 1 << 5   @ bitWidth 1 (CMP3)  
        .equ HRTIM_TIMC_RSTC1R_CMP2, 1 << 4   @ bitWidth 1 (CMP2)  
        .equ HRTIM_TIMC_RSTC1R_CMP1, 1 << 3   @ bitWidth 1 (CMP1)  
        .equ HRTIM_TIMC_RSTC1R_PER, 1 << 2   @ bitWidth 1 (PER)  
        .equ HRTIM_TIMC_RSTC1R_RESYNC, 1 << 1   @ bitWidth 1 (RESYNC)  
        .equ HRTIM_TIMC_RSTC1R_SRT, 1 << 0   @ bitWidth 1 (SRT)  
 
    .equ HRTIM_TIMC_SETC2R, HRTIM_TIMC_BASE + 0x44 @ (Timerx Output2 Set Register) 
        .equ HRTIM_TIMC_SETC2R_UPDATE, 1 << 31   @ bitWidth 1 (UPDATE)  
        .equ HRTIM_TIMC_SETC2R_EXTEVNT10, 1 << 30   @ bitWidth 1 (EXTEVNT10)  
        .equ HRTIM_TIMC_SETC2R_EXTEVNT9, 1 << 29   @ bitWidth 1 (EXTEVNT9)  
        .equ HRTIM_TIMC_SETC2R_EXTEVNT8, 1 << 28   @ bitWidth 1 (EXTEVNT8)  
        .equ HRTIM_TIMC_SETC2R_EXTEVNT7, 1 << 27   @ bitWidth 1 (EXTEVNT7)  
        .equ HRTIM_TIMC_SETC2R_EXTEVNT6, 1 << 26   @ bitWidth 1 (EXTEVNT6)  
        .equ HRTIM_TIMC_SETC2R_EXTEVNT5, 1 << 25   @ bitWidth 1 (EXTEVNT5)  
        .equ HRTIM_TIMC_SETC2R_EXTEVNT4, 1 << 24   @ bitWidth 1 (EXTEVNT4)  
        .equ HRTIM_TIMC_SETC2R_EXTEVNT3, 1 << 23   @ bitWidth 1 (EXTEVNT3)  
        .equ HRTIM_TIMC_SETC2R_EXTEVNT2, 1 << 22   @ bitWidth 1 (EXTEVNT2)  
        .equ HRTIM_TIMC_SETC2R_EXTEVNT1, 1 << 21   @ bitWidth 1 (EXTEVNT1)  
        .equ HRTIM_TIMC_SETC2R_TIMEVNT9, 1 << 20   @ bitWidth 1 (TIMEVNT9)  
        .equ HRTIM_TIMC_SETC2R_TIMEVNT8, 1 << 19   @ bitWidth 1 (TIMEVNT8)  
        .equ HRTIM_TIMC_SETC2R_TIMEVNT7, 1 << 18   @ bitWidth 1 (TIMEVNT7)  
        .equ HRTIM_TIMC_SETC2R_TIMEVNT6, 1 << 17   @ bitWidth 1 (TIMEVNT6)  
        .equ HRTIM_TIMC_SETC2R_TIMEVNT5, 1 << 16   @ bitWidth 1 (TIMEVNT5)  
        .equ HRTIM_TIMC_SETC2R_TIMEVNT4, 1 << 15   @ bitWidth 1 (TIMEVNT4)  
        .equ HRTIM_TIMC_SETC2R_TIMEVNT3, 1 << 14   @ bitWidth 1 (TIMEVNT3)  
        .equ HRTIM_TIMC_SETC2R_TIMEVNT2, 1 << 13   @ bitWidth 1 (TIMEVNT2)  
        .equ HRTIM_TIMC_SETC2R_TIMEVNT1, 1 << 12   @ bitWidth 1 (TIMEVNT1)  
        .equ HRTIM_TIMC_SETC2R_MSTCMP4, 1 << 11   @ bitWidth 1 (MSTCMP4)  
        .equ HRTIM_TIMC_SETC2R_MSTCMP3, 1 << 10   @ bitWidth 1 (MSTCMP3)  
        .equ HRTIM_TIMC_SETC2R_MSTCMP2, 1 << 9   @ bitWidth 1 (MSTCMP2)  
        .equ HRTIM_TIMC_SETC2R_MSTCMP1, 1 << 8   @ bitWidth 1 (MSTCMP1)  
        .equ HRTIM_TIMC_SETC2R_MSTPER, 1 << 7   @ bitWidth 1 (MSTPER)  
        .equ HRTIM_TIMC_SETC2R_CMP4, 1 << 6   @ bitWidth 1 (CMP4)  
        .equ HRTIM_TIMC_SETC2R_CMP3, 1 << 5   @ bitWidth 1 (CMP3)  
        .equ HRTIM_TIMC_SETC2R_CMP2, 1 << 4   @ bitWidth 1 (CMP2)  
        .equ HRTIM_TIMC_SETC2R_CMP1, 1 << 3   @ bitWidth 1 (CMP1)  
        .equ HRTIM_TIMC_SETC2R_PER, 1 << 2   @ bitWidth 1 (PER)  
        .equ HRTIM_TIMC_SETC2R_RESYNC, 1 << 1   @ bitWidth 1 (RESYNC)  
        .equ HRTIM_TIMC_SETC2R_SST, 1 << 0   @ bitWidth 1 (SST)  
 
    .equ HRTIM_TIMC_RSTC2R, HRTIM_TIMC_BASE + 0x48 @ (Timerx Output2 Reset Register) 
        .equ HRTIM_TIMC_RSTC2R_UPDATE, 1 << 31   @ bitWidth 1 (UPDATE)  
        .equ HRTIM_TIMC_RSTC2R_EXTEVNT10, 1 << 30   @ bitWidth 1 (EXTEVNT10)  
        .equ HRTIM_TIMC_RSTC2R_EXTEVNT9, 1 << 29   @ bitWidth 1 (EXTEVNT9)  
        .equ HRTIM_TIMC_RSTC2R_EXTEVNT8, 1 << 28   @ bitWidth 1 (EXTEVNT8)  
        .equ HRTIM_TIMC_RSTC2R_EXTEVNT7, 1 << 27   @ bitWidth 1 (EXTEVNT7)  
        .equ HRTIM_TIMC_RSTC2R_EXTEVNT6, 1 << 26   @ bitWidth 1 (EXTEVNT6)  
        .equ HRTIM_TIMC_RSTC2R_EXTEVNT5, 1 << 25   @ bitWidth 1 (EXTEVNT5)  
        .equ HRTIM_TIMC_RSTC2R_EXTEVNT4, 1 << 24   @ bitWidth 1 (EXTEVNT4)  
        .equ HRTIM_TIMC_RSTC2R_EXTEVNT3, 1 << 23   @ bitWidth 1 (EXTEVNT3)  
        .equ HRTIM_TIMC_RSTC2R_EXTEVNT2, 1 << 22   @ bitWidth 1 (EXTEVNT2)  
        .equ HRTIM_TIMC_RSTC2R_EXTEVNT1, 1 << 21   @ bitWidth 1 (EXTEVNT1)  
        .equ HRTIM_TIMC_RSTC2R_TIMEVNT9, 1 << 20   @ bitWidth 1 (TIMEVNT9)  
        .equ HRTIM_TIMC_RSTC2R_TIMEVNT8, 1 << 19   @ bitWidth 1 (TIMEVNT8)  
        .equ HRTIM_TIMC_RSTC2R_TIMEVNT7, 1 << 18   @ bitWidth 1 (TIMEVNT7)  
        .equ HRTIM_TIMC_RSTC2R_TIMEVNT6, 1 << 17   @ bitWidth 1 (TIMEVNT6)  
        .equ HRTIM_TIMC_RSTC2R_TIMEVNT5, 1 << 16   @ bitWidth 1 (TIMEVNT5)  
        .equ HRTIM_TIMC_RSTC2R_TIMEVNT4, 1 << 15   @ bitWidth 1 (TIMEVNT4)  
        .equ HRTIM_TIMC_RSTC2R_TIMEVNT3, 1 << 14   @ bitWidth 1 (TIMEVNT3)  
        .equ HRTIM_TIMC_RSTC2R_TIMEVNT2, 1 << 13   @ bitWidth 1 (TIMEVNT2)  
        .equ HRTIM_TIMC_RSTC2R_TIMEVNT1, 1 << 12   @ bitWidth 1 (TIMEVNT1)  
        .equ HRTIM_TIMC_RSTC2R_MSTCMP4, 1 << 11   @ bitWidth 1 (MSTCMP4)  
        .equ HRTIM_TIMC_RSTC2R_MSTCMP3, 1 << 10   @ bitWidth 1 (MSTCMP3)  
        .equ HRTIM_TIMC_RSTC2R_MSTCMP2, 1 << 9   @ bitWidth 1 (MSTCMP2)  
        .equ HRTIM_TIMC_RSTC2R_MSTCMP1, 1 << 8   @ bitWidth 1 (MSTCMP1)  
        .equ HRTIM_TIMC_RSTC2R_MSTPER, 1 << 7   @ bitWidth 1 (MSTPER)  
        .equ HRTIM_TIMC_RSTC2R_CMP4, 1 << 6   @ bitWidth 1 (CMP4)  
        .equ HRTIM_TIMC_RSTC2R_CMP3, 1 << 5   @ bitWidth 1 (CMP3)  
        .equ HRTIM_TIMC_RSTC2R_CMP2, 1 << 4   @ bitWidth 1 (CMP2)  
        .equ HRTIM_TIMC_RSTC2R_CMP1, 1 << 3   @ bitWidth 1 (CMP1)  
        .equ HRTIM_TIMC_RSTC2R_PER, 1 << 2   @ bitWidth 1 (PER)  
        .equ HRTIM_TIMC_RSTC2R_RESYNC, 1 << 1   @ bitWidth 1 (RESYNC)  
        .equ HRTIM_TIMC_RSTC2R_SRT, 1 << 0   @ bitWidth 1 (SRT)  
 
    .equ HRTIM_TIMC_EEFCR1, HRTIM_TIMC_BASE + 0x4C @ (Timerx External Event Filtering Register  1) 
        .equ HRTIM_TIMC_EEFCR1_EE5FLTR_Shift, 25   @ bitWidth 4 (External Event 5 filter)  
        .equ HRTIM_TIMC_EEFCR1_EE5LTCH, 1 << 24   @ bitWidth 1 (External Event 5 latch)  
        .equ HRTIM_TIMC_EEFCR1_EE4FLTR_Shift, 19   @ bitWidth 4 (External Event 4 filter)  
        .equ HRTIM_TIMC_EEFCR1_EE4LTCH, 1 << 18   @ bitWidth 1 (External Event 4 latch)  
        .equ HRTIM_TIMC_EEFCR1_EE3FLTR_Shift, 13   @ bitWidth 4 (External Event 3 filter)  
        .equ HRTIM_TIMC_EEFCR1_EE3LTCH, 1 << 12   @ bitWidth 1 (External Event 3 latch)  
        .equ HRTIM_TIMC_EEFCR1_EE2FLTR_Shift, 7   @ bitWidth 4 (External Event 2 filter)  
        .equ HRTIM_TIMC_EEFCR1_EE2LTCH, 1 << 6   @ bitWidth 1 (External Event 2 latch)  
        .equ HRTIM_TIMC_EEFCR1_EE1FLTR_Shift, 1   @ bitWidth 4 (External Event 1 filter)  
        .equ HRTIM_TIMC_EEFCR1_EE1LTCH, 1 << 0   @ bitWidth 1 (External Event 1 latch)  
 
    .equ HRTIM_TIMC_EEFCR2, HRTIM_TIMC_BASE + 0x50 @ (Timerx External Event Filtering Register  2) 
        .equ HRTIM_TIMC_EEFCR2_EE10FLTR_Shift, 25   @ bitWidth 4 (External Event 10 filter)  
        .equ HRTIM_TIMC_EEFCR2_EE10LTCH, 1 << 24   @ bitWidth 1 (External Event 10 latch)  
        .equ HRTIM_TIMC_EEFCR2_EE9FLTR_Shift, 19   @ bitWidth 4 (External Event 9 filter)  
        .equ HRTIM_TIMC_EEFCR2_EE9LTCH, 1 << 18   @ bitWidth 1 (External Event 9 latch)  
        .equ HRTIM_TIMC_EEFCR2_EE8FLTR_Shift, 13   @ bitWidth 4 (External Event 8 filter)  
        .equ HRTIM_TIMC_EEFCR2_EE8LTCH, 1 << 12   @ bitWidth 1 (External Event 8 latch)  
        .equ HRTIM_TIMC_EEFCR2_EE7FLTR_Shift, 7   @ bitWidth 4 (External Event 7 filter)  
        .equ HRTIM_TIMC_EEFCR2_EE7LTCH, 1 << 6   @ bitWidth 1 (External Event 7 latch)  
        .equ HRTIM_TIMC_EEFCR2_EE6FLTR_Shift, 1   @ bitWidth 4 (External Event 6 filter)  
        .equ HRTIM_TIMC_EEFCR2_EE6LTCH, 1 << 0   @ bitWidth 1 (External Event 6 latch)  
 
    .equ HRTIM_TIMC_RSTCR, HRTIM_TIMC_BASE + 0x54 @ (TimerA Reset Register) 
        .equ HRTIM_TIMC_RSTCR_TIMECMP4, 1 << 30   @ bitWidth 1 (Timer E Compare 4)  
        .equ HRTIM_TIMC_RSTCR_TIMECMP2, 1 << 29   @ bitWidth 1 (Timer E Compare 2)  
        .equ HRTIM_TIMC_RSTCR_TIMECMP1, 1 << 28   @ bitWidth 1 (Timer E Compare 1)  
        .equ HRTIM_TIMC_RSTCR_TIMDCMP4, 1 << 27   @ bitWidth 1 (Timer D Compare 4)  
        .equ HRTIM_TIMC_RSTCR_TIMDCMP2, 1 << 26   @ bitWidth 1 (Timer D Compare 2)  
        .equ HRTIM_TIMC_RSTCR_TIMDCMP1, 1 << 25   @ bitWidth 1 (Timer D Compare 1)  
        .equ HRTIM_TIMC_RSTCR_TIMBCMP4, 1 << 24   @ bitWidth 1 (Timer B Compare 4)  
        .equ HRTIM_TIMC_RSTCR_TIMBCMP2, 1 << 23   @ bitWidth 1 (Timer B Compare 2)  
        .equ HRTIM_TIMC_RSTCR_TIMBCMP1, 1 << 22   @ bitWidth 1 (Timer B Compare 1)  
        .equ HRTIM_TIMC_RSTCR_TIMACMP4, 1 << 21   @ bitWidth 1 (Timer A Compare 4)  
        .equ HRTIM_TIMC_RSTCR_TIMACMP2, 1 << 20   @ bitWidth 1 (Timer A Compare 2)  
        .equ HRTIM_TIMC_RSTCR_TIMACMP1, 1 << 19   @ bitWidth 1 (Timer A Compare 1)  
        .equ HRTIM_TIMC_RSTCR_EXTEVNT10, 1 << 18   @ bitWidth 1 (External Event 10)  
        .equ HRTIM_TIMC_RSTCR_EXTEVNT9, 1 << 17   @ bitWidth 1 (External Event 9)  
        .equ HRTIM_TIMC_RSTCR_EXTEVNT8, 1 << 16   @ bitWidth 1 (External Event 8)  
        .equ HRTIM_TIMC_RSTCR_EXTEVNT7, 1 << 15   @ bitWidth 1 (External Event 7)  
        .equ HRTIM_TIMC_RSTCR_EXTEVNT6, 1 << 14   @ bitWidth 1 (External Event 6)  
        .equ HRTIM_TIMC_RSTCR_EXTEVNT5, 1 << 13   @ bitWidth 1 (External Event 5)  
        .equ HRTIM_TIMC_RSTCR_EXTEVNT4, 1 << 12   @ bitWidth 1 (External Event 4)  
        .equ HRTIM_TIMC_RSTCR_EXTEVNT3, 1 << 11   @ bitWidth 1 (External Event 3)  
        .equ HRTIM_TIMC_RSTCR_EXTEVNT2, 1 << 10   @ bitWidth 1 (External Event 2)  
        .equ HRTIM_TIMC_RSTCR_EXTEVNT1, 1 << 9   @ bitWidth 1 (External Event 1)  
        .equ HRTIM_TIMC_RSTCR_MSTCMP4, 1 << 8   @ bitWidth 1 (Master compare 4)  
        .equ HRTIM_TIMC_RSTCR_MSTCMP3, 1 << 7   @ bitWidth 1 (Master compare 3)  
        .equ HRTIM_TIMC_RSTCR_MSTCMP2, 1 << 6   @ bitWidth 1 (Master compare 2)  
        .equ HRTIM_TIMC_RSTCR_MSTCMP1, 1 << 5   @ bitWidth 1 (Master compare 1)  
        .equ HRTIM_TIMC_RSTCR_MSTPER, 1 << 4   @ bitWidth 1 (Master timer Period)  
        .equ HRTIM_TIMC_RSTCR_CMP4, 1 << 3   @ bitWidth 1 (Timer A compare 4 reset)  
        .equ HRTIM_TIMC_RSTCR_CMP2, 1 << 2   @ bitWidth 1 (Timer A compare 2 reset)  
        .equ HRTIM_TIMC_RSTCR_UPDT, 1 << 1   @ bitWidth 1 (Timer A Update reset)  
 
    .equ HRTIM_TIMC_CHPCR, HRTIM_TIMC_BASE + 0x58 @ (Timerx Chopper Register) 
        .equ HRTIM_TIMC_CHPCR_STRTPW_Shift, 7   @ bitWidth 4 (STRTPW)  
        .equ HRTIM_TIMC_CHPCR_CHPDTY_Shift, 4   @ bitWidth 3 (Timerx chopper duty cycle  value)  
        .equ HRTIM_TIMC_CHPCR_CHPFRQ_Shift, 0   @ bitWidth 4 (Timerx carrier frequency  value)  
 
    .equ HRTIM_TIMC_CPT1CCR, HRTIM_TIMC_BASE + 0x5C @ (Timerx Capture 2 Control  Register) 
        .equ HRTIM_TIMC_CPT1CCR_TECMP2, 1 << 31   @ bitWidth 1 (Timer E Compare 2)  
        .equ HRTIM_TIMC_CPT1CCR_TECMP1, 1 << 30   @ bitWidth 1 (Timer E Compare 1)  
        .equ HRTIM_TIMC_CPT1CCR_TE1RST, 1 << 29   @ bitWidth 1 (Timer E output 1 Reset)  
        .equ HRTIM_TIMC_CPT1CCR_TE1SET, 1 << 28   @ bitWidth 1 (Timer E output 1 Set)  
        .equ HRTIM_TIMC_CPT1CCR_TDCMP2, 1 << 27   @ bitWidth 1 (Timer D Compare 2)  
        .equ HRTIM_TIMC_CPT1CCR_TDCMP1, 1 << 26   @ bitWidth 1 (Timer D Compare 1)  
        .equ HRTIM_TIMC_CPT1CCR_TD1RST, 1 << 25   @ bitWidth 1 (Timer D output 1 Reset)  
        .equ HRTIM_TIMC_CPT1CCR_TD1SET, 1 << 24   @ bitWidth 1 (Timer D output 1 Set)  
        .equ HRTIM_TIMC_CPT1CCR_TBCMP2, 1 << 19   @ bitWidth 1 (Timer B Compare 2)  
        .equ HRTIM_TIMC_CPT1CCR_TBCMP1, 1 << 18   @ bitWidth 1 (Timer B Compare 1)  
        .equ HRTIM_TIMC_CPT1CCR_TB1RST, 1 << 17   @ bitWidth 1 (Timer B output 1 Reset)  
        .equ HRTIM_TIMC_CPT1CCR_TB1SET, 1 << 16   @ bitWidth 1 (Timer B output 1 Set)  
        .equ HRTIM_TIMC_CPT1CCR_TACMP2, 1 << 15   @ bitWidth 1 (Timer A Compare 2)  
        .equ HRTIM_TIMC_CPT1CCR_TACMP1, 1 << 14   @ bitWidth 1 (Timer A Compare 1)  
        .equ HRTIM_TIMC_CPT1CCR_TA1RST, 1 << 13   @ bitWidth 1 (Timer A output 1 Reset)  
        .equ HRTIM_TIMC_CPT1CCR_TA1SET, 1 << 12   @ bitWidth 1 (Timer A output 1 Set)  
        .equ HRTIM_TIMC_CPT1CCR_EXEV10CPT, 1 << 11   @ bitWidth 1 (External Event 10 Capture)  
        .equ HRTIM_TIMC_CPT1CCR_EXEV9CPT, 1 << 10   @ bitWidth 1 (External Event 9 Capture)  
        .equ HRTIM_TIMC_CPT1CCR_EXEV8CPT, 1 << 9   @ bitWidth 1 (External Event 8 Capture)  
        .equ HRTIM_TIMC_CPT1CCR_EXEV7CPT, 1 << 8   @ bitWidth 1 (External Event 7 Capture)  
        .equ HRTIM_TIMC_CPT1CCR_EXEV6CPT, 1 << 7   @ bitWidth 1 (External Event 6 Capture)  
        .equ HRTIM_TIMC_CPT1CCR_EXEV5CPT, 1 << 6   @ bitWidth 1 (External Event 5 Capture)  
        .equ HRTIM_TIMC_CPT1CCR_EXEV4CPT, 1 << 5   @ bitWidth 1 (External Event 4 Capture)  
        .equ HRTIM_TIMC_CPT1CCR_EXEV3CPT, 1 << 4   @ bitWidth 1 (External Event 3 Capture)  
        .equ HRTIM_TIMC_CPT1CCR_EXEV2CPT, 1 << 3   @ bitWidth 1 (External Event 2 Capture)  
        .equ HRTIM_TIMC_CPT1CCR_EXEV1CPT, 1 << 2   @ bitWidth 1 (External Event 1 Capture)  
        .equ HRTIM_TIMC_CPT1CCR_UDPCPT, 1 << 1   @ bitWidth 1 (Update Capture)  
        .equ HRTIM_TIMC_CPT1CCR_SWCPT, 1 << 0   @ bitWidth 1 (Software Capture)  
 
    .equ HRTIM_TIMC_CPT2CCR, HRTIM_TIMC_BASE + 0x60 @ (CPT2xCR) 
        .equ HRTIM_TIMC_CPT2CCR_TECMP2, 1 << 31   @ bitWidth 1 (Timer E Compare 2)  
        .equ HRTIM_TIMC_CPT2CCR_TECMP1, 1 << 30   @ bitWidth 1 (Timer E Compare 1)  
        .equ HRTIM_TIMC_CPT2CCR_TE1RST, 1 << 29   @ bitWidth 1 (Timer E output 1 Reset)  
        .equ HRTIM_TIMC_CPT2CCR_TE1SET, 1 << 28   @ bitWidth 1 (Timer E output 1 Set)  
        .equ HRTIM_TIMC_CPT2CCR_TDCMP2, 1 << 27   @ bitWidth 1 (Timer D Compare 2)  
        .equ HRTIM_TIMC_CPT2CCR_TDCMP1, 1 << 26   @ bitWidth 1 (Timer D Compare 1)  
        .equ HRTIM_TIMC_CPT2CCR_TD1RST, 1 << 25   @ bitWidth 1 (Timer D output 1 Reset)  
        .equ HRTIM_TIMC_CPT2CCR_TD1SET, 1 << 24   @ bitWidth 1 (Timer D output 1 Set)  
        .equ HRTIM_TIMC_CPT2CCR_TBCMP2, 1 << 19   @ bitWidth 1 (Timer B Compare 2)  
        .equ HRTIM_TIMC_CPT2CCR_TBCMP1, 1 << 18   @ bitWidth 1 (Timer B Compare 1)  
        .equ HRTIM_TIMC_CPT2CCR_TB1RST, 1 << 17   @ bitWidth 1 (Timer B output 1 Reset)  
        .equ HRTIM_TIMC_CPT2CCR_TB1SET, 1 << 16   @ bitWidth 1 (Timer B output 1 Set)  
        .equ HRTIM_TIMC_CPT2CCR_TACMP2, 1 << 15   @ bitWidth 1 (Timer A Compare 2)  
        .equ HRTIM_TIMC_CPT2CCR_TACMP1, 1 << 14   @ bitWidth 1 (Timer A Compare 1)  
        .equ HRTIM_TIMC_CPT2CCR_TA1RST, 1 << 13   @ bitWidth 1 (Timer A output 1 Reset)  
        .equ HRTIM_TIMC_CPT2CCR_TA1SET, 1 << 12   @ bitWidth 1 (Timer A output 1 Set)  
        .equ HRTIM_TIMC_CPT2CCR_EXEV10CPT, 1 << 11   @ bitWidth 1 (External Event 10 Capture)  
        .equ HRTIM_TIMC_CPT2CCR_EXEV9CPT, 1 << 10   @ bitWidth 1 (External Event 9 Capture)  
        .equ HRTIM_TIMC_CPT2CCR_EXEV8CPT, 1 << 9   @ bitWidth 1 (External Event 8 Capture)  
        .equ HRTIM_TIMC_CPT2CCR_EXEV7CPT, 1 << 8   @ bitWidth 1 (External Event 7 Capture)  
        .equ HRTIM_TIMC_CPT2CCR_EXEV6CPT, 1 << 7   @ bitWidth 1 (External Event 6 Capture)  
        .equ HRTIM_TIMC_CPT2CCR_EXEV5CPT, 1 << 6   @ bitWidth 1 (External Event 5 Capture)  
        .equ HRTIM_TIMC_CPT2CCR_EXEV4CPT, 1 << 5   @ bitWidth 1 (External Event 4 Capture)  
        .equ HRTIM_TIMC_CPT2CCR_EXEV3CPT, 1 << 4   @ bitWidth 1 (External Event 3 Capture)  
        .equ HRTIM_TIMC_CPT2CCR_EXEV2CPT, 1 << 3   @ bitWidth 1 (External Event 2 Capture)  
        .equ HRTIM_TIMC_CPT2CCR_EXEV1CPT, 1 << 2   @ bitWidth 1 (External Event 1 Capture)  
        .equ HRTIM_TIMC_CPT2CCR_UDPCPT, 1 << 1   @ bitWidth 1 (Update Capture)  
        .equ HRTIM_TIMC_CPT2CCR_SWCPT, 1 << 0   @ bitWidth 1 (Software Capture)  
 
    .equ HRTIM_TIMC_OUTCR, HRTIM_TIMC_BASE + 0x64 @ (Timerx Output Register) 
        .equ HRTIM_TIMC_OUTCR_DIDL2, 1 << 23   @ bitWidth 1 (Output 2 Deadtime upon burst mode Idle  entry)  
        .equ HRTIM_TIMC_OUTCR_CHP2, 1 << 22   @ bitWidth 1 (Output 2 Chopper enable)  
        .equ HRTIM_TIMC_OUTCR_FAULT2_Shift, 20   @ bitWidth 2 (Output 2 Fault state)  
        .equ HRTIM_TIMC_OUTCR_IDLES2, 1 << 19   @ bitWidth 1 (Output 2 Idle State)  
        .equ HRTIM_TIMC_OUTCR_IDLEM2, 1 << 18   @ bitWidth 1 (Output 2 Idle mode)  
        .equ HRTIM_TIMC_OUTCR_POL2, 1 << 17   @ bitWidth 1 (Output 2 polarity)  
        .equ HRTIM_TIMC_OUTCR_DLYPRT_Shift, 10   @ bitWidth 3 (Delayed Protection)  
        .equ HRTIM_TIMC_OUTCR_DLYPRTEN, 1 << 9   @ bitWidth 1 (Delayed Protection Enable)  
        .equ HRTIM_TIMC_OUTCR_DTEN, 1 << 8   @ bitWidth 1 (Deadtime enable)  
        .equ HRTIM_TIMC_OUTCR_DIDL1, 1 << 7   @ bitWidth 1 (Output 1 Deadtime upon burst mode Idle  entry)  
        .equ HRTIM_TIMC_OUTCR_CHP1, 1 << 6   @ bitWidth 1 (Output 1 Chopper enable)  
        .equ HRTIM_TIMC_OUTCR_FAULT1_Shift, 4   @ bitWidth 2 (Output 1 Fault state)  
        .equ HRTIM_TIMC_OUTCR_IDLES1, 1 << 3   @ bitWidth 1 (Output 1 Idle State)  
        .equ HRTIM_TIMC_OUTCR_IDLEM1, 1 << 2   @ bitWidth 1 (Output 1 Idle mode)  
        .equ HRTIM_TIMC_OUTCR_POL1, 1 << 1   @ bitWidth 1 (Output 1 polarity)  
 
    .equ HRTIM_TIMC_FLTCR, HRTIM_TIMC_BASE + 0x68 @ (Timerx Fault Register) 
        .equ HRTIM_TIMC_FLTCR_FLTLCK, 1 << 31   @ bitWidth 1 (Fault sources Lock)  
        .equ HRTIM_TIMC_FLTCR_FLT5EN, 1 << 4   @ bitWidth 1 (Fault 5 enable)  
        .equ HRTIM_TIMC_FLTCR_FLT4EN, 1 << 3   @ bitWidth 1 (Fault 4 enable)  
        .equ HRTIM_TIMC_FLTCR_FLT3EN, 1 << 2   @ bitWidth 1 (Fault 3 enable)  
        .equ HRTIM_TIMC_FLTCR_FLT2EN, 1 << 1   @ bitWidth 1 (Fault 2 enable)  
        .equ HRTIM_TIMC_FLTCR_FLT1EN, 1 << 0   @ bitWidth 1 (Fault 1 enable)  
 

@=========================== HRTIM_TIMD ===========================@
.equ HRTIM_TIMD_BASE, 0x40017600 @ (High Resolution Timer: TIMD) 
    .equ HRTIM_TIMD_TIMDCR, HRTIM_TIMD_BASE + 0x0 @ (Timerx Control Register) 
        .equ HRTIM_TIMD_TIMDCR_UPDGAT_Shift, 28   @ bitWidth 4 (Update Gating)  
        .equ HRTIM_TIMD_TIMDCR_PREEN, 1 << 27   @ bitWidth 1 (Preload enable)  
        .equ HRTIM_TIMD_TIMDCR_DACSYNC_Shift, 25   @ bitWidth 2 (AC Synchronization)  
        .equ HRTIM_TIMD_TIMDCR_MSTU, 1 << 24   @ bitWidth 1 (Master Timer update)  
        .equ HRTIM_TIMD_TIMDCR_TEU, 1 << 23   @ bitWidth 1 (TEU)  
        .equ HRTIM_TIMD_TIMDCR_TDU, 1 << 22   @ bitWidth 1 (TDU)  
        .equ HRTIM_TIMD_TIMDCR_TCU, 1 << 21   @ bitWidth 1 (TCU)  
        .equ HRTIM_TIMD_TIMDCR_TBU, 1 << 20   @ bitWidth 1 (TBU)  
        .equ HRTIM_TIMD_TIMDCR_TxRSTU, 1 << 18   @ bitWidth 1 (Timerx reset update)  
        .equ HRTIM_TIMD_TIMDCR_TxREPU, 1 << 17   @ bitWidth 1 (Timer x Repetition update)  
        .equ HRTIM_TIMD_TIMDCR_DELCMP4_Shift, 14   @ bitWidth 2 (Delayed CMP4 mode)  
        .equ HRTIM_TIMD_TIMDCR_DELCMP2_Shift, 12   @ bitWidth 2 (Delayed CMP2 mode)  
        .equ HRTIM_TIMD_TIMDCR_SYNCSTRTx, 1 << 11   @ bitWidth 1 (Synchronization Starts Timer  x)  
        .equ HRTIM_TIMD_TIMDCR_SYNCRSTx, 1 << 10   @ bitWidth 1 (Synchronization Resets Timer  x)  
        .equ HRTIM_TIMD_TIMDCR_PSHPLL, 1 << 6   @ bitWidth 1 (Push-Pull mode enable)  
        .equ HRTIM_TIMD_TIMDCR_HALF, 1 << 5   @ bitWidth 1 (Half mode enable)  
        .equ HRTIM_TIMD_TIMDCR_RETRIG, 1 << 4   @ bitWidth 1 (Re-triggerable mode)  
        .equ HRTIM_TIMD_TIMDCR_CONT, 1 << 3   @ bitWidth 1 (Continuous mode)  
        .equ HRTIM_TIMD_TIMDCR_CK_PSCx_Shift, 0   @ bitWidth 3 (HRTIM Timer x Clock  prescaler)  
 
    .equ HRTIM_TIMD_TIMDISR, HRTIM_TIMD_BASE + 0x4 @ (Timerx Interrupt Status  Register) 
        .equ HRTIM_TIMD_TIMDISR_O2STAT, 1 << 19   @ bitWidth 1 (Output 2 State)  
        .equ HRTIM_TIMD_TIMDISR_O1STAT, 1 << 18   @ bitWidth 1 (Output 1 State)  
        .equ HRTIM_TIMD_TIMDISR_IPPSTAT, 1 << 17   @ bitWidth 1 (Idle Push Pull Status)  
        .equ HRTIM_TIMD_TIMDISR_CPPSTAT, 1 << 16   @ bitWidth 1 (Current Push Pull Status)  
        .equ HRTIM_TIMD_TIMDISR_DLYPRT, 1 << 14   @ bitWidth 1 (Delayed Protection Flag)  
        .equ HRTIM_TIMD_TIMDISR_RST, 1 << 13   @ bitWidth 1 (Reset Interrupt Flag)  
        .equ HRTIM_TIMD_TIMDISR_RSTx2, 1 << 12   @ bitWidth 1 (Output 2 Reset Interrupt  Flag)  
        .equ HRTIM_TIMD_TIMDISR_SETx2, 1 << 11   @ bitWidth 1 (Output 2 Set Interrupt  Flag)  
        .equ HRTIM_TIMD_TIMDISR_RSTx1, 1 << 10   @ bitWidth 1 (Output 1 Reset Interrupt  Flag)  
        .equ HRTIM_TIMD_TIMDISR_SETx1, 1 << 9   @ bitWidth 1 (Output 1 Set Interrupt  Flag)  
        .equ HRTIM_TIMD_TIMDISR_CPT2, 1 << 8   @ bitWidth 1 (Capture2 Interrupt Flag)  
        .equ HRTIM_TIMD_TIMDISR_CPT1, 1 << 7   @ bitWidth 1 (Capture1 Interrupt Flag)  
        .equ HRTIM_TIMD_TIMDISR_UPD, 1 << 6   @ bitWidth 1 (Update Interrupt Flag)  
        .equ HRTIM_TIMD_TIMDISR_REP, 1 << 4   @ bitWidth 1 (Repetition Interrupt Flag)  
        .equ HRTIM_TIMD_TIMDISR_CMP4, 1 << 3   @ bitWidth 1 (Compare 4 Interrupt Flag)  
        .equ HRTIM_TIMD_TIMDISR_CMP3, 1 << 2   @ bitWidth 1 (Compare 3 Interrupt Flag)  
        .equ HRTIM_TIMD_TIMDISR_CMP2, 1 << 1   @ bitWidth 1 (Compare 2 Interrupt Flag)  
        .equ HRTIM_TIMD_TIMDISR_CMP1, 1 << 0   @ bitWidth 1 (Compare 1 Interrupt Flag)  
 
    .equ HRTIM_TIMD_TIMDICR, HRTIM_TIMD_BASE + 0x8 @ (Timerx Interrupt Clear  Register) 
        .equ HRTIM_TIMD_TIMDICR_DLYPRTC, 1 << 14   @ bitWidth 1 (Delayed Protection Flag  Clear)  
        .equ HRTIM_TIMD_TIMDICR_RSTC, 1 << 13   @ bitWidth 1 (Reset Interrupt flag Clear)  
        .equ HRTIM_TIMD_TIMDICR_RSTx2C, 1 << 12   @ bitWidth 1 (Output 2 Reset flag Clear)  
        .equ HRTIM_TIMD_TIMDICR_SET2xC, 1 << 11   @ bitWidth 1 (Output 2 Set flag Clear)  
        .equ HRTIM_TIMD_TIMDICR_RSTx1C, 1 << 10   @ bitWidth 1 (Output 1 Reset flag Clear)  
        .equ HRTIM_TIMD_TIMDICR_SET1xC, 1 << 9   @ bitWidth 1 (Output 1 Set flag Clear)  
        .equ HRTIM_TIMD_TIMDICR_CPT2C, 1 << 8   @ bitWidth 1 (Capture2 Interrupt flag  Clear)  
        .equ HRTIM_TIMD_TIMDICR_CPT1C, 1 << 7   @ bitWidth 1 (Capture1 Interrupt flag  Clear)  
        .equ HRTIM_TIMD_TIMDICR_UPDC, 1 << 6   @ bitWidth 1 (Update Interrupt flag  Clear)  
        .equ HRTIM_TIMD_TIMDICR_REPC, 1 << 4   @ bitWidth 1 (Repetition Interrupt flag  Clear)  
        .equ HRTIM_TIMD_TIMDICR_CMP4C, 1 << 3   @ bitWidth 1 (Compare 4 Interrupt flag  Clear)  
        .equ HRTIM_TIMD_TIMDICR_CMP3C, 1 << 2   @ bitWidth 1 (Compare 3 Interrupt flag  Clear)  
        .equ HRTIM_TIMD_TIMDICR_CMP2C, 1 << 1   @ bitWidth 1 (Compare 2 Interrupt flag  Clear)  
        .equ HRTIM_TIMD_TIMDICR_CMP1C, 1 << 0   @ bitWidth 1 (Compare 1 Interrupt flag  Clear)  
 
    .equ HRTIM_TIMD_TIMDDIER5, HRTIM_TIMD_BASE + 0xC @ (TIMxDIER5) 
        .equ HRTIM_TIMD_TIMDDIER5_DLYPRTDE, 1 << 30   @ bitWidth 1 (DLYPRTDE)  
        .equ HRTIM_TIMD_TIMDDIER5_RSTDE, 1 << 29   @ bitWidth 1 (RSTDE)  
        .equ HRTIM_TIMD_TIMDDIER5_RSTx2DE, 1 << 28   @ bitWidth 1 (RSTx2DE)  
        .equ HRTIM_TIMD_TIMDDIER5_SETx2DE, 1 << 27   @ bitWidth 1 (SETx2DE)  
        .equ HRTIM_TIMD_TIMDDIER5_RSTx1DE, 1 << 26   @ bitWidth 1 (RSTx1DE)  
        .equ HRTIM_TIMD_TIMDDIER5_SET1xDE, 1 << 25   @ bitWidth 1 (SET1xDE)  
        .equ HRTIM_TIMD_TIMDDIER5_CPT2DE, 1 << 24   @ bitWidth 1 (CPT2DE)  
        .equ HRTIM_TIMD_TIMDDIER5_CPT1DE, 1 << 23   @ bitWidth 1 (CPT1DE)  
        .equ HRTIM_TIMD_TIMDDIER5_UPDDE, 1 << 22   @ bitWidth 1 (UPDDE)  
        .equ HRTIM_TIMD_TIMDDIER5_REPDE, 1 << 20   @ bitWidth 1 (REPDE)  
        .equ HRTIM_TIMD_TIMDDIER5_CMP4DE, 1 << 19   @ bitWidth 1 (CMP4DE)  
        .equ HRTIM_TIMD_TIMDDIER5_CMP3DE, 1 << 18   @ bitWidth 1 (CMP3DE)  
        .equ HRTIM_TIMD_TIMDDIER5_CMP2DE, 1 << 17   @ bitWidth 1 (CMP2DE)  
        .equ HRTIM_TIMD_TIMDDIER5_CMP1DE, 1 << 16   @ bitWidth 1 (CMP1DE)  
        .equ HRTIM_TIMD_TIMDDIER5_DLYPRTIE, 1 << 14   @ bitWidth 1 (DLYPRTIE)  
        .equ HRTIM_TIMD_TIMDDIER5_RSTIE, 1 << 13   @ bitWidth 1 (RSTIE)  
        .equ HRTIM_TIMD_TIMDDIER5_RSTx2IE, 1 << 12   @ bitWidth 1 (RSTx2IE)  
        .equ HRTIM_TIMD_TIMDDIER5_SETx2IE, 1 << 11   @ bitWidth 1 (SETx2IE)  
        .equ HRTIM_TIMD_TIMDDIER5_RSTx1IE, 1 << 10   @ bitWidth 1 (RSTx1IE)  
        .equ HRTIM_TIMD_TIMDDIER5_SET1xIE, 1 << 9   @ bitWidth 1 (SET1xIE)  
        .equ HRTIM_TIMD_TIMDDIER5_CPT2IE, 1 << 8   @ bitWidth 1 (CPT2IE)  
        .equ HRTIM_TIMD_TIMDDIER5_CPT1IE, 1 << 7   @ bitWidth 1 (CPT1IE)  
        .equ HRTIM_TIMD_TIMDDIER5_UPDIE, 1 << 6   @ bitWidth 1 (UPDIE)  
        .equ HRTIM_TIMD_TIMDDIER5_REPIE, 1 << 4   @ bitWidth 1 (REPIE)  
        .equ HRTIM_TIMD_TIMDDIER5_CMP4IE, 1 << 3   @ bitWidth 1 (CMP4IE)  
        .equ HRTIM_TIMD_TIMDDIER5_CMP3IE, 1 << 2   @ bitWidth 1 (CMP3IE)  
        .equ HRTIM_TIMD_TIMDDIER5_CMP2IE, 1 << 1   @ bitWidth 1 (CMP2IE)  
        .equ HRTIM_TIMD_TIMDDIER5_CMP1IE, 1 << 0   @ bitWidth 1 (CMP1IE)  
 
    .equ HRTIM_TIMD_CNTDR, HRTIM_TIMD_BASE + 0x10 @ (Timerx Counter Register) 
        .equ HRTIM_TIMD_CNTDR_CNTx_Shift, 0   @ bitWidth 16 (Timerx Counter value)  
 
    .equ HRTIM_TIMD_PERDR, HRTIM_TIMD_BASE + 0x14 @ (Timerx Period Register) 
        .equ HRTIM_TIMD_PERDR_PERx_Shift, 0   @ bitWidth 16 (Timerx Period value)  
 
    .equ HRTIM_TIMD_REPDR, HRTIM_TIMD_BASE + 0x18 @ (Timerx Repetition Register) 
        .equ HRTIM_TIMD_REPDR_REPx_Shift, 0   @ bitWidth 8 (Timerx Repetition counter  value)  
 
    .equ HRTIM_TIMD_CMP1DR, HRTIM_TIMD_BASE + 0x1C @ (Timerx Compare 1 Register) 
        .equ HRTIM_TIMD_CMP1DR_CMP1x_Shift, 0   @ bitWidth 16 (Timerx Compare 1 value)  
 
    .equ HRTIM_TIMD_CMP1CDR, HRTIM_TIMD_BASE + 0x20 @ (Timerx Compare 1 Compound  Register) 
        .equ HRTIM_TIMD_CMP1CDR_REPx_Shift, 16   @ bitWidth 8 (Timerx Repetition value aliased from  HRTIM_REPx register)  
        .equ HRTIM_TIMD_CMP1CDR_CMP1x_Shift, 0   @ bitWidth 16 (Timerx Compare 1 value)  
 
    .equ HRTIM_TIMD_CMP2DR, HRTIM_TIMD_BASE + 0x24 @ (Timerx Compare 2 Register) 
        .equ HRTIM_TIMD_CMP2DR_CMP2x_Shift, 0   @ bitWidth 16 (Timerx Compare 2 value)  
 
    .equ HRTIM_TIMD_CMP3DR, HRTIM_TIMD_BASE + 0x28 @ (Timerx Compare 3 Register) 
        .equ HRTIM_TIMD_CMP3DR_CMP3x_Shift, 0   @ bitWidth 16 (Timerx Compare 3 value)  
 
    .equ HRTIM_TIMD_CMP4DR, HRTIM_TIMD_BASE + 0x2C @ (Timerx Compare 4 Register) 
        .equ HRTIM_TIMD_CMP4DR_CMP4x_Shift, 0   @ bitWidth 16 (Timerx Compare 4 value)  
 
    .equ HRTIM_TIMD_CPT1DR, HRTIM_TIMD_BASE + 0x30 @ (Timerx Capture 1 Register) 
        .equ HRTIM_TIMD_CPT1DR_CPT1x_Shift, 0   @ bitWidth 16 (Timerx Capture 1 value)  
 
    .equ HRTIM_TIMD_CPT2DR, HRTIM_TIMD_BASE + 0x34 @ (Timerx Capture 2 Register) 
        .equ HRTIM_TIMD_CPT2DR_CPT2x_Shift, 0   @ bitWidth 16 (Timerx Capture 2 value)  
 
    .equ HRTIM_TIMD_DTDR, HRTIM_TIMD_BASE + 0x38 @ (Timerx Deadtime Register) 
        .equ HRTIM_TIMD_DTDR_DTFLKx, 1 << 31   @ bitWidth 1 (Deadtime Falling Lock)  
        .equ HRTIM_TIMD_DTDR_DTFSLKx, 1 << 30   @ bitWidth 1 (Deadtime Falling Sign Lock)  
        .equ HRTIM_TIMD_DTDR_SDTFx, 1 << 25   @ bitWidth 1 (Sign Deadtime Falling  value)  
        .equ HRTIM_TIMD_DTDR_DTFx_Shift, 16   @ bitWidth 9 (Deadtime Falling value)  
        .equ HRTIM_TIMD_DTDR_DTRLKx, 1 << 15   @ bitWidth 1 (Deadtime Rising Lock)  
        .equ HRTIM_TIMD_DTDR_DTRSLKx, 1 << 14   @ bitWidth 1 (Deadtime Rising Sign Lock)  
        .equ HRTIM_TIMD_DTDR_DTPRSC_Shift, 10   @ bitWidth 3 (Deadtime Prescaler)  
        .equ HRTIM_TIMD_DTDR_SDTRx, 1 << 9   @ bitWidth 1 (Sign Deadtime Rising value)  
        .equ HRTIM_TIMD_DTDR_DTRx_Shift, 0   @ bitWidth 9 (Deadtime Rising value)  
 
    .equ HRTIM_TIMD_SETD1R, HRTIM_TIMD_BASE + 0x3C @ (Timerx Output1 Set Register) 
        .equ HRTIM_TIMD_SETD1R_UPDATE, 1 << 31   @ bitWidth 1 (Registers update transfer preload to  active)  
        .equ HRTIM_TIMD_SETD1R_EXTEVNT10, 1 << 30   @ bitWidth 1 (External Event 10)  
        .equ HRTIM_TIMD_SETD1R_EXTEVNT9, 1 << 29   @ bitWidth 1 (External Event 9)  
        .equ HRTIM_TIMD_SETD1R_EXTEVNT8, 1 << 28   @ bitWidth 1 (External Event 8)  
        .equ HRTIM_TIMD_SETD1R_EXTEVNT7, 1 << 27   @ bitWidth 1 (External Event 7)  
        .equ HRTIM_TIMD_SETD1R_EXTEVNT6, 1 << 26   @ bitWidth 1 (External Event 6)  
        .equ HRTIM_TIMD_SETD1R_EXTEVNT5, 1 << 25   @ bitWidth 1 (External Event 5)  
        .equ HRTIM_TIMD_SETD1R_EXTEVNT4, 1 << 24   @ bitWidth 1 (External Event 4)  
        .equ HRTIM_TIMD_SETD1R_EXTEVNT3, 1 << 23   @ bitWidth 1 (External Event 3)  
        .equ HRTIM_TIMD_SETD1R_EXTEVNT2, 1 << 22   @ bitWidth 1 (External Event 2)  
        .equ HRTIM_TIMD_SETD1R_EXTEVNT1, 1 << 21   @ bitWidth 1 (External Event 1)  
        .equ HRTIM_TIMD_SETD1R_TIMEVNT9, 1 << 20   @ bitWidth 1 (Timer Event 9)  
        .equ HRTIM_TIMD_SETD1R_TIMEVNT8, 1 << 19   @ bitWidth 1 (Timer Event 8)  
        .equ HRTIM_TIMD_SETD1R_TIMEVNT7, 1 << 18   @ bitWidth 1 (Timer Event 7)  
        .equ HRTIM_TIMD_SETD1R_TIMEVNT6, 1 << 17   @ bitWidth 1 (Timer Event 6)  
        .equ HRTIM_TIMD_SETD1R_TIMEVNT5, 1 << 16   @ bitWidth 1 (Timer Event 5)  
        .equ HRTIM_TIMD_SETD1R_TIMEVNT4, 1 << 15   @ bitWidth 1 (Timer Event 4)  
        .equ HRTIM_TIMD_SETD1R_TIMEVNT3, 1 << 14   @ bitWidth 1 (Timer Event 3)  
        .equ HRTIM_TIMD_SETD1R_TIMEVNT2, 1 << 13   @ bitWidth 1 (Timer Event 2)  
        .equ HRTIM_TIMD_SETD1R_TIMEVNT1, 1 << 12   @ bitWidth 1 (Timer Event 1)  
        .equ HRTIM_TIMD_SETD1R_MSTCMP4, 1 << 11   @ bitWidth 1 (Master Compare 4)  
        .equ HRTIM_TIMD_SETD1R_MSTCMP3, 1 << 10   @ bitWidth 1 (Master Compare 3)  
        .equ HRTIM_TIMD_SETD1R_MSTCMP2, 1 << 9   @ bitWidth 1 (Master Compare 2)  
        .equ HRTIM_TIMD_SETD1R_MSTCMP1, 1 << 8   @ bitWidth 1 (Master Compare 1)  
        .equ HRTIM_TIMD_SETD1R_MSTPER, 1 << 7   @ bitWidth 1 (Master Period)  
        .equ HRTIM_TIMD_SETD1R_CMP4, 1 << 6   @ bitWidth 1 (Timer A compare 4)  
        .equ HRTIM_TIMD_SETD1R_CMP3, 1 << 5   @ bitWidth 1 (Timer A compare 3)  
        .equ HRTIM_TIMD_SETD1R_CMP2, 1 << 4   @ bitWidth 1 (Timer A compare 2)  
        .equ HRTIM_TIMD_SETD1R_CMP1, 1 << 3   @ bitWidth 1 (Timer A compare 1)  
        .equ HRTIM_TIMD_SETD1R_PER, 1 << 2   @ bitWidth 1 (Timer A Period)  
        .equ HRTIM_TIMD_SETD1R_RESYNC, 1 << 1   @ bitWidth 1 (Timer A resynchronizaton)  
        .equ HRTIM_TIMD_SETD1R_SST, 1 << 0   @ bitWidth 1 (Software Set trigger)  
 
    .equ HRTIM_TIMD_RSTD1R, HRTIM_TIMD_BASE + 0x40 @ (Timerx Output1 Reset Register) 
        .equ HRTIM_TIMD_RSTD1R_UPDATE, 1 << 31   @ bitWidth 1 (UPDATE)  
        .equ HRTIM_TIMD_RSTD1R_EXTEVNT10, 1 << 30   @ bitWidth 1 (EXTEVNT10)  
        .equ HRTIM_TIMD_RSTD1R_EXTEVNT9, 1 << 29   @ bitWidth 1 (EXTEVNT9)  
        .equ HRTIM_TIMD_RSTD1R_EXTEVNT8, 1 << 28   @ bitWidth 1 (EXTEVNT8)  
        .equ HRTIM_TIMD_RSTD1R_EXTEVNT7, 1 << 27   @ bitWidth 1 (EXTEVNT7)  
        .equ HRTIM_TIMD_RSTD1R_EXTEVNT6, 1 << 26   @ bitWidth 1 (EXTEVNT6)  
        .equ HRTIM_TIMD_RSTD1R_EXTEVNT5, 1 << 25   @ bitWidth 1 (EXTEVNT5)  
        .equ HRTIM_TIMD_RSTD1R_EXTEVNT4, 1 << 24   @ bitWidth 1 (EXTEVNT4)  
        .equ HRTIM_TIMD_RSTD1R_EXTEVNT3, 1 << 23   @ bitWidth 1 (EXTEVNT3)  
        .equ HRTIM_TIMD_RSTD1R_EXTEVNT2, 1 << 22   @ bitWidth 1 (EXTEVNT2)  
        .equ HRTIM_TIMD_RSTD1R_EXTEVNT1, 1 << 21   @ bitWidth 1 (EXTEVNT1)  
        .equ HRTIM_TIMD_RSTD1R_TIMEVNT9, 1 << 20   @ bitWidth 1 (TIMEVNT9)  
        .equ HRTIM_TIMD_RSTD1R_TIMEVNT8, 1 << 19   @ bitWidth 1 (TIMEVNT8)  
        .equ HRTIM_TIMD_RSTD1R_TIMEVNT7, 1 << 18   @ bitWidth 1 (TIMEVNT7)  
        .equ HRTIM_TIMD_RSTD1R_TIMEVNT6, 1 << 17   @ bitWidth 1 (TIMEVNT6)  
        .equ HRTIM_TIMD_RSTD1R_TIMEVNT5, 1 << 16   @ bitWidth 1 (TIMEVNT5)  
        .equ HRTIM_TIMD_RSTD1R_TIMEVNT4, 1 << 15   @ bitWidth 1 (TIMEVNT4)  
        .equ HRTIM_TIMD_RSTD1R_TIMEVNT3, 1 << 14   @ bitWidth 1 (TIMEVNT3)  
        .equ HRTIM_TIMD_RSTD1R_TIMEVNT2, 1 << 13   @ bitWidth 1 (TIMEVNT2)  
        .equ HRTIM_TIMD_RSTD1R_TIMEVNT1, 1 << 12   @ bitWidth 1 (TIMEVNT1)  
        .equ HRTIM_TIMD_RSTD1R_MSTCMP4, 1 << 11   @ bitWidth 1 (MSTCMP4)  
        .equ HRTIM_TIMD_RSTD1R_MSTCMP3, 1 << 10   @ bitWidth 1 (MSTCMP3)  
        .equ HRTIM_TIMD_RSTD1R_MSTCMP2, 1 << 9   @ bitWidth 1 (MSTCMP2)  
        .equ HRTIM_TIMD_RSTD1R_MSTCMP1, 1 << 8   @ bitWidth 1 (MSTCMP1)  
        .equ HRTIM_TIMD_RSTD1R_MSTPER, 1 << 7   @ bitWidth 1 (MSTPER)  
        .equ HRTIM_TIMD_RSTD1R_CMP4, 1 << 6   @ bitWidth 1 (CMP4)  
        .equ HRTIM_TIMD_RSTD1R_CMP3, 1 << 5   @ bitWidth 1 (CMP3)  
        .equ HRTIM_TIMD_RSTD1R_CMP2, 1 << 4   @ bitWidth 1 (CMP2)  
        .equ HRTIM_TIMD_RSTD1R_CMP1, 1 << 3   @ bitWidth 1 (CMP1)  
        .equ HRTIM_TIMD_RSTD1R_PER, 1 << 2   @ bitWidth 1 (PER)  
        .equ HRTIM_TIMD_RSTD1R_RESYNC, 1 << 1   @ bitWidth 1 (RESYNC)  
        .equ HRTIM_TIMD_RSTD1R_SRT, 1 << 0   @ bitWidth 1 (SRT)  
 
    .equ HRTIM_TIMD_SETD2R, HRTIM_TIMD_BASE + 0x44 @ (Timerx Output2 Set Register) 
        .equ HRTIM_TIMD_SETD2R_UPDATE, 1 << 31   @ bitWidth 1 (UPDATE)  
        .equ HRTIM_TIMD_SETD2R_EXTEVNT10, 1 << 30   @ bitWidth 1 (EXTEVNT10)  
        .equ HRTIM_TIMD_SETD2R_EXTEVNT9, 1 << 29   @ bitWidth 1 (EXTEVNT9)  
        .equ HRTIM_TIMD_SETD2R_EXTEVNT8, 1 << 28   @ bitWidth 1 (EXTEVNT8)  
        .equ HRTIM_TIMD_SETD2R_EXTEVNT7, 1 << 27   @ bitWidth 1 (EXTEVNT7)  
        .equ HRTIM_TIMD_SETD2R_EXTEVNT6, 1 << 26   @ bitWidth 1 (EXTEVNT6)  
        .equ HRTIM_TIMD_SETD2R_EXTEVNT5, 1 << 25   @ bitWidth 1 (EXTEVNT5)  
        .equ HRTIM_TIMD_SETD2R_EXTEVNT4, 1 << 24   @ bitWidth 1 (EXTEVNT4)  
        .equ HRTIM_TIMD_SETD2R_EXTEVNT3, 1 << 23   @ bitWidth 1 (EXTEVNT3)  
        .equ HRTIM_TIMD_SETD2R_EXTEVNT2, 1 << 22   @ bitWidth 1 (EXTEVNT2)  
        .equ HRTIM_TIMD_SETD2R_EXTEVNT1, 1 << 21   @ bitWidth 1 (EXTEVNT1)  
        .equ HRTIM_TIMD_SETD2R_TIMEVNT9, 1 << 20   @ bitWidth 1 (TIMEVNT9)  
        .equ HRTIM_TIMD_SETD2R_TIMEVNT8, 1 << 19   @ bitWidth 1 (TIMEVNT8)  
        .equ HRTIM_TIMD_SETD2R_TIMEVNT7, 1 << 18   @ bitWidth 1 (TIMEVNT7)  
        .equ HRTIM_TIMD_SETD2R_TIMEVNT6, 1 << 17   @ bitWidth 1 (TIMEVNT6)  
        .equ HRTIM_TIMD_SETD2R_TIMEVNT5, 1 << 16   @ bitWidth 1 (TIMEVNT5)  
        .equ HRTIM_TIMD_SETD2R_TIMEVNT4, 1 << 15   @ bitWidth 1 (TIMEVNT4)  
        .equ HRTIM_TIMD_SETD2R_TIMEVNT3, 1 << 14   @ bitWidth 1 (TIMEVNT3)  
        .equ HRTIM_TIMD_SETD2R_TIMEVNT2, 1 << 13   @ bitWidth 1 (TIMEVNT2)  
        .equ HRTIM_TIMD_SETD2R_TIMEVNT1, 1 << 12   @ bitWidth 1 (TIMEVNT1)  
        .equ HRTIM_TIMD_SETD2R_MSTCMP4, 1 << 11   @ bitWidth 1 (MSTCMP4)  
        .equ HRTIM_TIMD_SETD2R_MSTCMP3, 1 << 10   @ bitWidth 1 (MSTCMP3)  
        .equ HRTIM_TIMD_SETD2R_MSTCMP2, 1 << 9   @ bitWidth 1 (MSTCMP2)  
        .equ HRTIM_TIMD_SETD2R_MSTCMP1, 1 << 8   @ bitWidth 1 (MSTCMP1)  
        .equ HRTIM_TIMD_SETD2R_MSTPER, 1 << 7   @ bitWidth 1 (MSTPER)  
        .equ HRTIM_TIMD_SETD2R_CMP4, 1 << 6   @ bitWidth 1 (CMP4)  
        .equ HRTIM_TIMD_SETD2R_CMP3, 1 << 5   @ bitWidth 1 (CMP3)  
        .equ HRTIM_TIMD_SETD2R_CMP2, 1 << 4   @ bitWidth 1 (CMP2)  
        .equ HRTIM_TIMD_SETD2R_CMP1, 1 << 3   @ bitWidth 1 (CMP1)  
        .equ HRTIM_TIMD_SETD2R_PER, 1 << 2   @ bitWidth 1 (PER)  
        .equ HRTIM_TIMD_SETD2R_RESYNC, 1 << 1   @ bitWidth 1 (RESYNC)  
        .equ HRTIM_TIMD_SETD2R_SST, 1 << 0   @ bitWidth 1 (SST)  
 
    .equ HRTIM_TIMD_RSTD2R, HRTIM_TIMD_BASE + 0x48 @ (Timerx Output2 Reset Register) 
        .equ HRTIM_TIMD_RSTD2R_UPDATE, 1 << 31   @ bitWidth 1 (UPDATE)  
        .equ HRTIM_TIMD_RSTD2R_EXTEVNT10, 1 << 30   @ bitWidth 1 (EXTEVNT10)  
        .equ HRTIM_TIMD_RSTD2R_EXTEVNT9, 1 << 29   @ bitWidth 1 (EXTEVNT9)  
        .equ HRTIM_TIMD_RSTD2R_EXTEVNT8, 1 << 28   @ bitWidth 1 (EXTEVNT8)  
        .equ HRTIM_TIMD_RSTD2R_EXTEVNT7, 1 << 27   @ bitWidth 1 (EXTEVNT7)  
        .equ HRTIM_TIMD_RSTD2R_EXTEVNT6, 1 << 26   @ bitWidth 1 (EXTEVNT6)  
        .equ HRTIM_TIMD_RSTD2R_EXTEVNT5, 1 << 25   @ bitWidth 1 (EXTEVNT5)  
        .equ HRTIM_TIMD_RSTD2R_EXTEVNT4, 1 << 24   @ bitWidth 1 (EXTEVNT4)  
        .equ HRTIM_TIMD_RSTD2R_EXTEVNT3, 1 << 23   @ bitWidth 1 (EXTEVNT3)  
        .equ HRTIM_TIMD_RSTD2R_EXTEVNT2, 1 << 22   @ bitWidth 1 (EXTEVNT2)  
        .equ HRTIM_TIMD_RSTD2R_EXTEVNT1, 1 << 21   @ bitWidth 1 (EXTEVNT1)  
        .equ HRTIM_TIMD_RSTD2R_TIMEVNT9, 1 << 20   @ bitWidth 1 (TIMEVNT9)  
        .equ HRTIM_TIMD_RSTD2R_TIMEVNT8, 1 << 19   @ bitWidth 1 (TIMEVNT8)  
        .equ HRTIM_TIMD_RSTD2R_TIMEVNT7, 1 << 18   @ bitWidth 1 (TIMEVNT7)  
        .equ HRTIM_TIMD_RSTD2R_TIMEVNT6, 1 << 17   @ bitWidth 1 (TIMEVNT6)  
        .equ HRTIM_TIMD_RSTD2R_TIMEVNT5, 1 << 16   @ bitWidth 1 (TIMEVNT5)  
        .equ HRTIM_TIMD_RSTD2R_TIMEVNT4, 1 << 15   @ bitWidth 1 (TIMEVNT4)  
        .equ HRTIM_TIMD_RSTD2R_TIMEVNT3, 1 << 14   @ bitWidth 1 (TIMEVNT3)  
        .equ HRTIM_TIMD_RSTD2R_TIMEVNT2, 1 << 13   @ bitWidth 1 (TIMEVNT2)  
        .equ HRTIM_TIMD_RSTD2R_TIMEVNT1, 1 << 12   @ bitWidth 1 (TIMEVNT1)  
        .equ HRTIM_TIMD_RSTD2R_MSTCMP4, 1 << 11   @ bitWidth 1 (MSTCMP4)  
        .equ HRTIM_TIMD_RSTD2R_MSTCMP3, 1 << 10   @ bitWidth 1 (MSTCMP3)  
        .equ HRTIM_TIMD_RSTD2R_MSTCMP2, 1 << 9   @ bitWidth 1 (MSTCMP2)  
        .equ HRTIM_TIMD_RSTD2R_MSTCMP1, 1 << 8   @ bitWidth 1 (MSTCMP1)  
        .equ HRTIM_TIMD_RSTD2R_MSTPER, 1 << 7   @ bitWidth 1 (MSTPER)  
        .equ HRTIM_TIMD_RSTD2R_CMP4, 1 << 6   @ bitWidth 1 (CMP4)  
        .equ HRTIM_TIMD_RSTD2R_CMP3, 1 << 5   @ bitWidth 1 (CMP3)  
        .equ HRTIM_TIMD_RSTD2R_CMP2, 1 << 4   @ bitWidth 1 (CMP2)  
        .equ HRTIM_TIMD_RSTD2R_CMP1, 1 << 3   @ bitWidth 1 (CMP1)  
        .equ HRTIM_TIMD_RSTD2R_PER, 1 << 2   @ bitWidth 1 (PER)  
        .equ HRTIM_TIMD_RSTD2R_RESYNC, 1 << 1   @ bitWidth 1 (RESYNC)  
        .equ HRTIM_TIMD_RSTD2R_SRT, 1 << 0   @ bitWidth 1 (SRT)  
 
    .equ HRTIM_TIMD_EEFDR1, HRTIM_TIMD_BASE + 0x4C @ (Timerx External Event Filtering Register  1) 
        .equ HRTIM_TIMD_EEFDR1_EE5FLTR_Shift, 25   @ bitWidth 4 (External Event 5 filter)  
        .equ HRTIM_TIMD_EEFDR1_EE5LTCH, 1 << 24   @ bitWidth 1 (External Event 5 latch)  
        .equ HRTIM_TIMD_EEFDR1_EE4FLTR_Shift, 19   @ bitWidth 4 (External Event 4 filter)  
        .equ HRTIM_TIMD_EEFDR1_EE4LTCH, 1 << 18   @ bitWidth 1 (External Event 4 latch)  
        .equ HRTIM_TIMD_EEFDR1_EE3FLTR_Shift, 13   @ bitWidth 4 (External Event 3 filter)  
        .equ HRTIM_TIMD_EEFDR1_EE3LTCH, 1 << 12   @ bitWidth 1 (External Event 3 latch)  
        .equ HRTIM_TIMD_EEFDR1_EE2FLTR_Shift, 7   @ bitWidth 4 (External Event 2 filter)  
        .equ HRTIM_TIMD_EEFDR1_EE2LTCH, 1 << 6   @ bitWidth 1 (External Event 2 latch)  
        .equ HRTIM_TIMD_EEFDR1_EE1FLTR_Shift, 1   @ bitWidth 4 (External Event 1 filter)  
        .equ HRTIM_TIMD_EEFDR1_EE1LTCH, 1 << 0   @ bitWidth 1 (External Event 1 latch)  
 
    .equ HRTIM_TIMD_EEFDR2, HRTIM_TIMD_BASE + 0x50 @ (Timerx External Event Filtering Register  2) 
        .equ HRTIM_TIMD_EEFDR2_EE10FLTR_Shift, 25   @ bitWidth 4 (External Event 10 filter)  
        .equ HRTIM_TIMD_EEFDR2_EE10LTCH, 1 << 24   @ bitWidth 1 (External Event 10 latch)  
        .equ HRTIM_TIMD_EEFDR2_EE9FLTR_Shift, 19   @ bitWidth 4 (External Event 9 filter)  
        .equ HRTIM_TIMD_EEFDR2_EE9LTCH, 1 << 18   @ bitWidth 1 (External Event 9 latch)  
        .equ HRTIM_TIMD_EEFDR2_EE8FLTR_Shift, 13   @ bitWidth 4 (External Event 8 filter)  
        .equ HRTIM_TIMD_EEFDR2_EE8LTCH, 1 << 12   @ bitWidth 1 (External Event 8 latch)  
        .equ HRTIM_TIMD_EEFDR2_EE7FLTR_Shift, 7   @ bitWidth 4 (External Event 7 filter)  
        .equ HRTIM_TIMD_EEFDR2_EE7LTCH, 1 << 6   @ bitWidth 1 (External Event 7 latch)  
        .equ HRTIM_TIMD_EEFDR2_EE6FLTR_Shift, 1   @ bitWidth 4 (External Event 6 filter)  
        .equ HRTIM_TIMD_EEFDR2_EE6LTCH, 1 << 0   @ bitWidth 1 (External Event 6 latch)  
 
    .equ HRTIM_TIMD_RSTDR, HRTIM_TIMD_BASE + 0x54 @ (TimerA Reset Register) 
        .equ HRTIM_TIMD_RSTDR_TIMECMP4, 1 << 30   @ bitWidth 1 (Timer E Compare 4)  
        .equ HRTIM_TIMD_RSTDR_TIMECMP2, 1 << 29   @ bitWidth 1 (Timer E Compare 2)  
        .equ HRTIM_TIMD_RSTDR_TIMECMP1, 1 << 28   @ bitWidth 1 (Timer E Compare 1)  
        .equ HRTIM_TIMD_RSTDR_TIMCCMP4, 1 << 27   @ bitWidth 1 (Timer C Compare 4)  
        .equ HRTIM_TIMD_RSTDR_TIMCCMP2, 1 << 26   @ bitWidth 1 (Timer C Compare 2)  
        .equ HRTIM_TIMD_RSTDR_TIMCCMP1, 1 << 25   @ bitWidth 1 (Timer C Compare 1)  
        .equ HRTIM_TIMD_RSTDR_TIMBCMP4, 1 << 24   @ bitWidth 1 (Timer B Compare 4)  
        .equ HRTIM_TIMD_RSTDR_TIMBCMP2, 1 << 23   @ bitWidth 1 (Timer B Compare 2)  
        .equ HRTIM_TIMD_RSTDR_TIMBCMP1, 1 << 22   @ bitWidth 1 (Timer B Compare 1)  
        .equ HRTIM_TIMD_RSTDR_TIMACMP4, 1 << 21   @ bitWidth 1 (Timer A Compare 4)  
        .equ HRTIM_TIMD_RSTDR_TIMACMP2, 1 << 20   @ bitWidth 1 (Timer A Compare 2)  
        .equ HRTIM_TIMD_RSTDR_TIMACMP1, 1 << 19   @ bitWidth 1 (Timer A Compare 1)  
        .equ HRTIM_TIMD_RSTDR_EXTEVNT10, 1 << 18   @ bitWidth 1 (External Event 10)  
        .equ HRTIM_TIMD_RSTDR_EXTEVNT9, 1 << 17   @ bitWidth 1 (External Event 9)  
        .equ HRTIM_TIMD_RSTDR_EXTEVNT8, 1 << 16   @ bitWidth 1 (External Event 8)  
        .equ HRTIM_TIMD_RSTDR_EXTEVNT7, 1 << 15   @ bitWidth 1 (External Event 7)  
        .equ HRTIM_TIMD_RSTDR_EXTEVNT6, 1 << 14   @ bitWidth 1 (External Event 6)  
        .equ HRTIM_TIMD_RSTDR_EXTEVNT5, 1 << 13   @ bitWidth 1 (External Event 5)  
        .equ HRTIM_TIMD_RSTDR_EXTEVNT4, 1 << 12   @ bitWidth 1 (External Event 4)  
        .equ HRTIM_TIMD_RSTDR_EXTEVNT3, 1 << 11   @ bitWidth 1 (External Event 3)  
        .equ HRTIM_TIMD_RSTDR_EXTEVNT2, 1 << 10   @ bitWidth 1 (External Event 2)  
        .equ HRTIM_TIMD_RSTDR_EXTEVNT1, 1 << 9   @ bitWidth 1 (External Event 1)  
        .equ HRTIM_TIMD_RSTDR_MSTCMP4, 1 << 8   @ bitWidth 1 (Master compare 4)  
        .equ HRTIM_TIMD_RSTDR_MSTCMP3, 1 << 7   @ bitWidth 1 (Master compare 3)  
        .equ HRTIM_TIMD_RSTDR_MSTCMP2, 1 << 6   @ bitWidth 1 (Master compare 2)  
        .equ HRTIM_TIMD_RSTDR_MSTCMP1, 1 << 5   @ bitWidth 1 (Master compare 1)  
        .equ HRTIM_TIMD_RSTDR_MSTPER, 1 << 4   @ bitWidth 1 (Master timer Period)  
        .equ HRTIM_TIMD_RSTDR_CMP4, 1 << 3   @ bitWidth 1 (Timer A compare 4 reset)  
        .equ HRTIM_TIMD_RSTDR_CMP2, 1 << 2   @ bitWidth 1 (Timer A compare 2 reset)  
        .equ HRTIM_TIMD_RSTDR_UPDT, 1 << 1   @ bitWidth 1 (Timer A Update reset)  
 
    .equ HRTIM_TIMD_CHPDR, HRTIM_TIMD_BASE + 0x58 @ (Timerx Chopper Register) 
        .equ HRTIM_TIMD_CHPDR_STRTPW_Shift, 7   @ bitWidth 4 (STRTPW)  
        .equ HRTIM_TIMD_CHPDR_CHPDTY_Shift, 4   @ bitWidth 3 (Timerx chopper duty cycle  value)  
        .equ HRTIM_TIMD_CHPDR_CHPFRQ_Shift, 0   @ bitWidth 4 (Timerx carrier frequency  value)  
 
    .equ HRTIM_TIMD_CPT1DCR, HRTIM_TIMD_BASE + 0x5C @ (Timerx Capture 2 Control  Register) 
        .equ HRTIM_TIMD_CPT1DCR_TECMP2, 1 << 31   @ bitWidth 1 (Timer E Compare 2)  
        .equ HRTIM_TIMD_CPT1DCR_TECMP1, 1 << 30   @ bitWidth 1 (Timer E Compare 1)  
        .equ HRTIM_TIMD_CPT1DCR_TE1RST, 1 << 29   @ bitWidth 1 (Timer E output 1 Reset)  
        .equ HRTIM_TIMD_CPT1DCR_TE1SET, 1 << 28   @ bitWidth 1 (Timer E output 1 Set)  
        .equ HRTIM_TIMD_CPT1DCR_TCCMP2, 1 << 23   @ bitWidth 1 (Timer C Compare 2)  
        .equ HRTIM_TIMD_CPT1DCR_TCCMP1, 1 << 22   @ bitWidth 1 (Timer C Compare 1)  
        .equ HRTIM_TIMD_CPT1DCR_TC1RST, 1 << 21   @ bitWidth 1 (Timer C output 1 Reset)  
        .equ HRTIM_TIMD_CPT1DCR_TC1SET, 1 << 20   @ bitWidth 1 (Timer C output 1 Set)  
        .equ HRTIM_TIMD_CPT1DCR_TBCMP2, 1 << 19   @ bitWidth 1 (Timer B Compare 2)  
        .equ HRTIM_TIMD_CPT1DCR_TBCMP1, 1 << 18   @ bitWidth 1 (Timer B Compare 1)  
        .equ HRTIM_TIMD_CPT1DCR_TB1RST, 1 << 17   @ bitWidth 1 (Timer B output 1 Reset)  
        .equ HRTIM_TIMD_CPT1DCR_TB1SET, 1 << 16   @ bitWidth 1 (Timer B output 1 Set)  
        .equ HRTIM_TIMD_CPT1DCR_TACMP2, 1 << 15   @ bitWidth 1 (Timer A Compare 2)  
        .equ HRTIM_TIMD_CPT1DCR_TACMP1, 1 << 14   @ bitWidth 1 (Timer A Compare 1)  
        .equ HRTIM_TIMD_CPT1DCR_TA1RST, 1 << 13   @ bitWidth 1 (Timer A output 1 Reset)  
        .equ HRTIM_TIMD_CPT1DCR_TA1SET, 1 << 12   @ bitWidth 1 (Timer A output 1 Set)  
        .equ HRTIM_TIMD_CPT1DCR_EXEV10CPT, 1 << 11   @ bitWidth 1 (External Event 10 Capture)  
        .equ HRTIM_TIMD_CPT1DCR_EXEV9CPT, 1 << 10   @ bitWidth 1 (External Event 9 Capture)  
        .equ HRTIM_TIMD_CPT1DCR_EXEV8CPT, 1 << 9   @ bitWidth 1 (External Event 8 Capture)  
        .equ HRTIM_TIMD_CPT1DCR_EXEV7CPT, 1 << 8   @ bitWidth 1 (External Event 7 Capture)  
        .equ HRTIM_TIMD_CPT1DCR_EXEV6CPT, 1 << 7   @ bitWidth 1 (External Event 6 Capture)  
        .equ HRTIM_TIMD_CPT1DCR_EXEV5CPT, 1 << 6   @ bitWidth 1 (External Event 5 Capture)  
        .equ HRTIM_TIMD_CPT1DCR_EXEV4CPT, 1 << 5   @ bitWidth 1 (External Event 4 Capture)  
        .equ HRTIM_TIMD_CPT1DCR_EXEV3CPT, 1 << 4   @ bitWidth 1 (External Event 3 Capture)  
        .equ HRTIM_TIMD_CPT1DCR_EXEV2CPT, 1 << 3   @ bitWidth 1 (External Event 2 Capture)  
        .equ HRTIM_TIMD_CPT1DCR_EXEV1CPT, 1 << 2   @ bitWidth 1 (External Event 1 Capture)  
        .equ HRTIM_TIMD_CPT1DCR_UDPCPT, 1 << 1   @ bitWidth 1 (Update Capture)  
        .equ HRTIM_TIMD_CPT1DCR_SWCPT, 1 << 0   @ bitWidth 1 (Software Capture)  
 
    .equ HRTIM_TIMD_CPT2DCR, HRTIM_TIMD_BASE + 0x60 @ (CPT2xCR) 
        .equ HRTIM_TIMD_CPT2DCR_TECMP2, 1 << 31   @ bitWidth 1 (Timer E Compare 2)  
        .equ HRTIM_TIMD_CPT2DCR_TECMP1, 1 << 30   @ bitWidth 1 (Timer E Compare 1)  
        .equ HRTIM_TIMD_CPT2DCR_TE1RST, 1 << 29   @ bitWidth 1 (Timer E output 1 Reset)  
        .equ HRTIM_TIMD_CPT2DCR_TE1SET, 1 << 28   @ bitWidth 1 (Timer E output 1 Set)  
        .equ HRTIM_TIMD_CPT2DCR_TCCMP2, 1 << 23   @ bitWidth 1 (Timer C Compare 2)  
        .equ HRTIM_TIMD_CPT2DCR_TCCMP1, 1 << 22   @ bitWidth 1 (Timer C Compare 1)  
        .equ HRTIM_TIMD_CPT2DCR_TC1RST, 1 << 21   @ bitWidth 1 (Timer C output 1 Reset)  
        .equ HRTIM_TIMD_CPT2DCR_TC1SET, 1 << 20   @ bitWidth 1 (Timer C output 1 Set)  
        .equ HRTIM_TIMD_CPT2DCR_TBCMP2, 1 << 19   @ bitWidth 1 (Timer B Compare 2)  
        .equ HRTIM_TIMD_CPT2DCR_TBCMP1, 1 << 18   @ bitWidth 1 (Timer B Compare 1)  
        .equ HRTIM_TIMD_CPT2DCR_TB1RST, 1 << 17   @ bitWidth 1 (Timer B output 1 Reset)  
        .equ HRTIM_TIMD_CPT2DCR_TB1SET, 1 << 16   @ bitWidth 1 (Timer B output 1 Set)  
        .equ HRTIM_TIMD_CPT2DCR_TACMP2, 1 << 15   @ bitWidth 1 (Timer A Compare 2)  
        .equ HRTIM_TIMD_CPT2DCR_TACMP1, 1 << 14   @ bitWidth 1 (Timer A Compare 1)  
        .equ HRTIM_TIMD_CPT2DCR_TA1RST, 1 << 13   @ bitWidth 1 (Timer A output 1 Reset)  
        .equ HRTIM_TIMD_CPT2DCR_TA1SET, 1 << 12   @ bitWidth 1 (Timer A output 1 Set)  
        .equ HRTIM_TIMD_CPT2DCR_EXEV10CPT, 1 << 11   @ bitWidth 1 (External Event 10 Capture)  
        .equ HRTIM_TIMD_CPT2DCR_EXEV9CPT, 1 << 10   @ bitWidth 1 (External Event 9 Capture)  
        .equ HRTIM_TIMD_CPT2DCR_EXEV8CPT, 1 << 9   @ bitWidth 1 (External Event 8 Capture)  
        .equ HRTIM_TIMD_CPT2DCR_EXEV7CPT, 1 << 8   @ bitWidth 1 (External Event 7 Capture)  
        .equ HRTIM_TIMD_CPT2DCR_EXEV6CPT, 1 << 7   @ bitWidth 1 (External Event 6 Capture)  
        .equ HRTIM_TIMD_CPT2DCR_EXEV5CPT, 1 << 6   @ bitWidth 1 (External Event 5 Capture)  
        .equ HRTIM_TIMD_CPT2DCR_EXEV4CPT, 1 << 5   @ bitWidth 1 (External Event 4 Capture)  
        .equ HRTIM_TIMD_CPT2DCR_EXEV3CPT, 1 << 4   @ bitWidth 1 (External Event 3 Capture)  
        .equ HRTIM_TIMD_CPT2DCR_EXEV2CPT, 1 << 3   @ bitWidth 1 (External Event 2 Capture)  
        .equ HRTIM_TIMD_CPT2DCR_EXEV1CPT, 1 << 2   @ bitWidth 1 (External Event 1 Capture)  
        .equ HRTIM_TIMD_CPT2DCR_UDPCPT, 1 << 1   @ bitWidth 1 (Update Capture)  
        .equ HRTIM_TIMD_CPT2DCR_SWCPT, 1 << 0   @ bitWidth 1 (Software Capture)  
 
    .equ HRTIM_TIMD_OUTDR, HRTIM_TIMD_BASE + 0x64 @ (Timerx Output Register) 
        .equ HRTIM_TIMD_OUTDR_DIDL2, 1 << 23   @ bitWidth 1 (Output 2 Deadtime upon burst mode Idle  entry)  
        .equ HRTIM_TIMD_OUTDR_CHP2, 1 << 22   @ bitWidth 1 (Output 2 Chopper enable)  
        .equ HRTIM_TIMD_OUTDR_FAULT2_Shift, 20   @ bitWidth 2 (Output 2 Fault state)  
        .equ HRTIM_TIMD_OUTDR_IDLES2, 1 << 19   @ bitWidth 1 (Output 2 Idle State)  
        .equ HRTIM_TIMD_OUTDR_IDLEM2, 1 << 18   @ bitWidth 1 (Output 2 Idle mode)  
        .equ HRTIM_TIMD_OUTDR_POL2, 1 << 17   @ bitWidth 1 (Output 2 polarity)  
        .equ HRTIM_TIMD_OUTDR_DLYPRT_Shift, 10   @ bitWidth 3 (Delayed Protection)  
        .equ HRTIM_TIMD_OUTDR_DLYPRTEN, 1 << 9   @ bitWidth 1 (Delayed Protection Enable)  
        .equ HRTIM_TIMD_OUTDR_DTEN, 1 << 8   @ bitWidth 1 (Deadtime enable)  
        .equ HRTIM_TIMD_OUTDR_DIDL1, 1 << 7   @ bitWidth 1 (Output 1 Deadtime upon burst mode Idle  entry)  
        .equ HRTIM_TIMD_OUTDR_CHP1, 1 << 6   @ bitWidth 1 (Output 1 Chopper enable)  
        .equ HRTIM_TIMD_OUTDR_FAULT1_Shift, 4   @ bitWidth 2 (Output 1 Fault state)  
        .equ HRTIM_TIMD_OUTDR_IDLES1, 1 << 3   @ bitWidth 1 (Output 1 Idle State)  
        .equ HRTIM_TIMD_OUTDR_IDLEM1, 1 << 2   @ bitWidth 1 (Output 1 Idle mode)  
        .equ HRTIM_TIMD_OUTDR_POL1, 1 << 1   @ bitWidth 1 (Output 1 polarity)  
 
    .equ HRTIM_TIMD_FLTDR, HRTIM_TIMD_BASE + 0x68 @ (Timerx Fault Register) 
        .equ HRTIM_TIMD_FLTDR_FLTLCK, 1 << 31   @ bitWidth 1 (Fault sources Lock)  
        .equ HRTIM_TIMD_FLTDR_FLT5EN, 1 << 4   @ bitWidth 1 (Fault 5 enable)  
        .equ HRTIM_TIMD_FLTDR_FLT4EN, 1 << 3   @ bitWidth 1 (Fault 4 enable)  
        .equ HRTIM_TIMD_FLTDR_FLT3EN, 1 << 2   @ bitWidth 1 (Fault 3 enable)  
        .equ HRTIM_TIMD_FLTDR_FLT2EN, 1 << 1   @ bitWidth 1 (Fault 2 enable)  
        .equ HRTIM_TIMD_FLTDR_FLT1EN, 1 << 0   @ bitWidth 1 (Fault 1 enable)  
 

@=========================== HRTIM_TIME ===========================@
.equ HRTIM_TIME_BASE, 0x40017680 @ (High Resolution Timer: TIME) 
    .equ HRTIM_TIME_TIMECR, HRTIM_TIME_BASE + 0x0 @ (Timerx Control Register) 
        .equ HRTIM_TIME_TIMECR_UPDGAT_Shift, 28   @ bitWidth 4 (Update Gating)  
        .equ HRTIM_TIME_TIMECR_PREEN, 1 << 27   @ bitWidth 1 (Preload enable)  
        .equ HRTIM_TIME_TIMECR_DACSYNC_Shift, 25   @ bitWidth 2 (AC Synchronization)  
        .equ HRTIM_TIME_TIMECR_MSTU, 1 << 24   @ bitWidth 1 (Master Timer update)  
        .equ HRTIM_TIME_TIMECR_TEU, 1 << 23   @ bitWidth 1 (TEU)  
        .equ HRTIM_TIME_TIMECR_TDU, 1 << 22   @ bitWidth 1 (TDU)  
        .equ HRTIM_TIME_TIMECR_TCU, 1 << 21   @ bitWidth 1 (TCU)  
        .equ HRTIM_TIME_TIMECR_TBU, 1 << 20   @ bitWidth 1 (TBU)  
        .equ HRTIM_TIME_TIMECR_TxRSTU, 1 << 18   @ bitWidth 1 (Timerx reset update)  
        .equ HRTIM_TIME_TIMECR_TxREPU, 1 << 17   @ bitWidth 1 (Timer x Repetition update)  
        .equ HRTIM_TIME_TIMECR_DELCMP4_Shift, 14   @ bitWidth 2 (Delayed CMP4 mode)  
        .equ HRTIM_TIME_TIMECR_DELCMP2_Shift, 12   @ bitWidth 2 (Delayed CMP2 mode)  
        .equ HRTIM_TIME_TIMECR_SYNCSTRTx, 1 << 11   @ bitWidth 1 (Synchronization Starts Timer  x)  
        .equ HRTIM_TIME_TIMECR_SYNCRSTx, 1 << 10   @ bitWidth 1 (Synchronization Resets Timer  x)  
        .equ HRTIM_TIME_TIMECR_PSHPLL, 1 << 6   @ bitWidth 1 (Push-Pull mode enable)  
        .equ HRTIM_TIME_TIMECR_HALF, 1 << 5   @ bitWidth 1 (Half mode enable)  
        .equ HRTIM_TIME_TIMECR_RETRIG, 1 << 4   @ bitWidth 1 (Re-triggerable mode)  
        .equ HRTIM_TIME_TIMECR_CONT, 1 << 3   @ bitWidth 1 (Continuous mode)  
        .equ HRTIM_TIME_TIMECR_CK_PSCx_Shift, 0   @ bitWidth 3 (HRTIM Timer x Clock  prescaler)  
 
    .equ HRTIM_TIME_TIMEISR, HRTIM_TIME_BASE + 0x4 @ (Timerx Interrupt Status  Register) 
        .equ HRTIM_TIME_TIMEISR_O2STAT, 1 << 19   @ bitWidth 1 (Output 2 State)  
        .equ HRTIM_TIME_TIMEISR_O1STAT, 1 << 18   @ bitWidth 1 (Output 1 State)  
        .equ HRTIM_TIME_TIMEISR_IPPSTAT, 1 << 17   @ bitWidth 1 (Idle Push Pull Status)  
        .equ HRTIM_TIME_TIMEISR_CPPSTAT, 1 << 16   @ bitWidth 1 (Current Push Pull Status)  
        .equ HRTIM_TIME_TIMEISR_DLYPRT, 1 << 14   @ bitWidth 1 (Delayed Protection Flag)  
        .equ HRTIM_TIME_TIMEISR_RST, 1 << 13   @ bitWidth 1 (Reset Interrupt Flag)  
        .equ HRTIM_TIME_TIMEISR_RSTx2, 1 << 12   @ bitWidth 1 (Output 2 Reset Interrupt  Flag)  
        .equ HRTIM_TIME_TIMEISR_SETx2, 1 << 11   @ bitWidth 1 (Output 2 Set Interrupt  Flag)  
        .equ HRTIM_TIME_TIMEISR_RSTx1, 1 << 10   @ bitWidth 1 (Output 1 Reset Interrupt  Flag)  
        .equ HRTIM_TIME_TIMEISR_SETx1, 1 << 9   @ bitWidth 1 (Output 1 Set Interrupt  Flag)  
        .equ HRTIM_TIME_TIMEISR_CPT2, 1 << 8   @ bitWidth 1 (Capture2 Interrupt Flag)  
        .equ HRTIM_TIME_TIMEISR_CPT1, 1 << 7   @ bitWidth 1 (Capture1 Interrupt Flag)  
        .equ HRTIM_TIME_TIMEISR_UPD, 1 << 6   @ bitWidth 1 (Update Interrupt Flag)  
        .equ HRTIM_TIME_TIMEISR_REP, 1 << 4   @ bitWidth 1 (Repetition Interrupt Flag)  
        .equ HRTIM_TIME_TIMEISR_CMP4, 1 << 3   @ bitWidth 1 (Compare 4 Interrupt Flag)  
        .equ HRTIM_TIME_TIMEISR_CMP3, 1 << 2   @ bitWidth 1 (Compare 3 Interrupt Flag)  
        .equ HRTIM_TIME_TIMEISR_CMP2, 1 << 1   @ bitWidth 1 (Compare 2 Interrupt Flag)  
        .equ HRTIM_TIME_TIMEISR_CMP1, 1 << 0   @ bitWidth 1 (Compare 1 Interrupt Flag)  
 
    .equ HRTIM_TIME_TIMEICR, HRTIM_TIME_BASE + 0x8 @ (Timerx Interrupt Clear  Register) 
        .equ HRTIM_TIME_TIMEICR_DLYPRTC, 1 << 14   @ bitWidth 1 (Delayed Protection Flag  Clear)  
        .equ HRTIM_TIME_TIMEICR_RSTC, 1 << 13   @ bitWidth 1 (Reset Interrupt flag Clear)  
        .equ HRTIM_TIME_TIMEICR_RSTx2C, 1 << 12   @ bitWidth 1 (Output 2 Reset flag Clear)  
        .equ HRTIM_TIME_TIMEICR_SET2xC, 1 << 11   @ bitWidth 1 (Output 2 Set flag Clear)  
        .equ HRTIM_TIME_TIMEICR_RSTx1C, 1 << 10   @ bitWidth 1 (Output 1 Reset flag Clear)  
        .equ HRTIM_TIME_TIMEICR_SET1xC, 1 << 9   @ bitWidth 1 (Output 1 Set flag Clear)  
        .equ HRTIM_TIME_TIMEICR_CPT2C, 1 << 8   @ bitWidth 1 (Capture2 Interrupt flag  Clear)  
        .equ HRTIM_TIME_TIMEICR_CPT1C, 1 << 7   @ bitWidth 1 (Capture1 Interrupt flag  Clear)  
        .equ HRTIM_TIME_TIMEICR_UPDC, 1 << 6   @ bitWidth 1 (Update Interrupt flag  Clear)  
        .equ HRTIM_TIME_TIMEICR_REPC, 1 << 4   @ bitWidth 1 (Repetition Interrupt flag  Clear)  
        .equ HRTIM_TIME_TIMEICR_CMP4C, 1 << 3   @ bitWidth 1 (Compare 4 Interrupt flag  Clear)  
        .equ HRTIM_TIME_TIMEICR_CMP3C, 1 << 2   @ bitWidth 1 (Compare 3 Interrupt flag  Clear)  
        .equ HRTIM_TIME_TIMEICR_CMP2C, 1 << 1   @ bitWidth 1 (Compare 2 Interrupt flag  Clear)  
        .equ HRTIM_TIME_TIMEICR_CMP1C, 1 << 0   @ bitWidth 1 (Compare 1 Interrupt flag  Clear)  
 
    .equ HRTIM_TIME_TIMEDIER5, HRTIM_TIME_BASE + 0xC @ (TIMxDIER5) 
        .equ HRTIM_TIME_TIMEDIER5_DLYPRTDE, 1 << 30   @ bitWidth 1 (DLYPRTDE)  
        .equ HRTIM_TIME_TIMEDIER5_RSTDE, 1 << 29   @ bitWidth 1 (RSTDE)  
        .equ HRTIM_TIME_TIMEDIER5_RSTx2DE, 1 << 28   @ bitWidth 1 (RSTx2DE)  
        .equ HRTIM_TIME_TIMEDIER5_SETx2DE, 1 << 27   @ bitWidth 1 (SETx2DE)  
        .equ HRTIM_TIME_TIMEDIER5_RSTx1DE, 1 << 26   @ bitWidth 1 (RSTx1DE)  
        .equ HRTIM_TIME_TIMEDIER5_SET1xDE, 1 << 25   @ bitWidth 1 (SET1xDE)  
        .equ HRTIM_TIME_TIMEDIER5_CPT2DE, 1 << 24   @ bitWidth 1 (CPT2DE)  
        .equ HRTIM_TIME_TIMEDIER5_CPT1DE, 1 << 23   @ bitWidth 1 (CPT1DE)  
        .equ HRTIM_TIME_TIMEDIER5_UPDDE, 1 << 22   @ bitWidth 1 (UPDDE)  
        .equ HRTIM_TIME_TIMEDIER5_REPDE, 1 << 20   @ bitWidth 1 (REPDE)  
        .equ HRTIM_TIME_TIMEDIER5_CMP4DE, 1 << 19   @ bitWidth 1 (CMP4DE)  
        .equ HRTIM_TIME_TIMEDIER5_CMP3DE, 1 << 18   @ bitWidth 1 (CMP3DE)  
        .equ HRTIM_TIME_TIMEDIER5_CMP2DE, 1 << 17   @ bitWidth 1 (CMP2DE)  
        .equ HRTIM_TIME_TIMEDIER5_CMP1DE, 1 << 16   @ bitWidth 1 (CMP1DE)  
        .equ HRTIM_TIME_TIMEDIER5_DLYPRTIE, 1 << 14   @ bitWidth 1 (DLYPRTIE)  
        .equ HRTIM_TIME_TIMEDIER5_RSTIE, 1 << 13   @ bitWidth 1 (RSTIE)  
        .equ HRTIM_TIME_TIMEDIER5_RSTx2IE, 1 << 12   @ bitWidth 1 (RSTx2IE)  
        .equ HRTIM_TIME_TIMEDIER5_SETx2IE, 1 << 11   @ bitWidth 1 (SETx2IE)  
        .equ HRTIM_TIME_TIMEDIER5_RSTx1IE, 1 << 10   @ bitWidth 1 (RSTx1IE)  
        .equ HRTIM_TIME_TIMEDIER5_SET1xIE, 1 << 9   @ bitWidth 1 (SET1xIE)  
        .equ HRTIM_TIME_TIMEDIER5_CPT2IE, 1 << 8   @ bitWidth 1 (CPT2IE)  
        .equ HRTIM_TIME_TIMEDIER5_CPT1IE, 1 << 7   @ bitWidth 1 (CPT1IE)  
        .equ HRTIM_TIME_TIMEDIER5_UPDIE, 1 << 6   @ bitWidth 1 (UPDIE)  
        .equ HRTIM_TIME_TIMEDIER5_REPIE, 1 << 4   @ bitWidth 1 (REPIE)  
        .equ HRTIM_TIME_TIMEDIER5_CMP4IE, 1 << 3   @ bitWidth 1 (CMP4IE)  
        .equ HRTIM_TIME_TIMEDIER5_CMP3IE, 1 << 2   @ bitWidth 1 (CMP3IE)  
        .equ HRTIM_TIME_TIMEDIER5_CMP2IE, 1 << 1   @ bitWidth 1 (CMP2IE)  
        .equ HRTIM_TIME_TIMEDIER5_CMP1IE, 1 << 0   @ bitWidth 1 (CMP1IE)  
 
    .equ HRTIM_TIME_CNTER, HRTIM_TIME_BASE + 0x10 @ (Timerx Counter Register) 
        .equ HRTIM_TIME_CNTER_CNTx_Shift, 0   @ bitWidth 16 (Timerx Counter value)  
 
    .equ HRTIM_TIME_PERER, HRTIM_TIME_BASE + 0x14 @ (Timerx Period Register) 
        .equ HRTIM_TIME_PERER_PERx_Shift, 0   @ bitWidth 16 (Timerx Period value)  
 
    .equ HRTIM_TIME_REPER, HRTIM_TIME_BASE + 0x18 @ (Timerx Repetition Register) 
        .equ HRTIM_TIME_REPER_REPx_Shift, 0   @ bitWidth 8 (Timerx Repetition counter  value)  
 
    .equ HRTIM_TIME_CMP1ER, HRTIM_TIME_BASE + 0x1C @ (Timerx Compare 1 Register) 
        .equ HRTIM_TIME_CMP1ER_CMP1x_Shift, 0   @ bitWidth 16 (Timerx Compare 1 value)  
 
    .equ HRTIM_TIME_CMP1CER, HRTIM_TIME_BASE + 0x20 @ (Timerx Compare 1 Compound  Register) 
        .equ HRTIM_TIME_CMP1CER_REPx_Shift, 16   @ bitWidth 8 (Timerx Repetition value aliased from  HRTIM_REPx register)  
        .equ HRTIM_TIME_CMP1CER_CMP1x_Shift, 0   @ bitWidth 16 (Timerx Compare 1 value)  
 
    .equ HRTIM_TIME_CMP2ER, HRTIM_TIME_BASE + 0x24 @ (Timerx Compare 2 Register) 
        .equ HRTIM_TIME_CMP2ER_CMP2x_Shift, 0   @ bitWidth 16 (Timerx Compare 2 value)  
 
    .equ HRTIM_TIME_CMP3ER, HRTIM_TIME_BASE + 0x28 @ (Timerx Compare 3 Register) 
        .equ HRTIM_TIME_CMP3ER_CMP3x_Shift, 0   @ bitWidth 16 (Timerx Compare 3 value)  
 
    .equ HRTIM_TIME_CMP4ER, HRTIM_TIME_BASE + 0x2C @ (Timerx Compare 4 Register) 
        .equ HRTIM_TIME_CMP4ER_CMP4x_Shift, 0   @ bitWidth 16 (Timerx Compare 4 value)  
 
    .equ HRTIM_TIME_CPT1ER, HRTIM_TIME_BASE + 0x30 @ (Timerx Capture 1 Register) 
        .equ HRTIM_TIME_CPT1ER_CPT1x_Shift, 0   @ bitWidth 16 (Timerx Capture 1 value)  
 
    .equ HRTIM_TIME_CPT2ER, HRTIM_TIME_BASE + 0x34 @ (Timerx Capture 2 Register) 
        .equ HRTIM_TIME_CPT2ER_CPT2x_Shift, 0   @ bitWidth 16 (Timerx Capture 2 value)  
 
    .equ HRTIM_TIME_DTER, HRTIM_TIME_BASE + 0x38 @ (Timerx Deadtime Register) 
        .equ HRTIM_TIME_DTER_DTFLKx, 1 << 31   @ bitWidth 1 (Deadtime Falling Lock)  
        .equ HRTIM_TIME_DTER_DTFSLKx, 1 << 30   @ bitWidth 1 (Deadtime Falling Sign Lock)  
        .equ HRTIM_TIME_DTER_SDTFx, 1 << 25   @ bitWidth 1 (Sign Deadtime Falling  value)  
        .equ HRTIM_TIME_DTER_DTFx_Shift, 16   @ bitWidth 9 (Deadtime Falling value)  
        .equ HRTIM_TIME_DTER_DTRLKx, 1 << 15   @ bitWidth 1 (Deadtime Rising Lock)  
        .equ HRTIM_TIME_DTER_DTRSLKx, 1 << 14   @ bitWidth 1 (Deadtime Rising Sign Lock)  
        .equ HRTIM_TIME_DTER_DTPRSC_Shift, 10   @ bitWidth 3 (Deadtime Prescaler)  
        .equ HRTIM_TIME_DTER_SDTRx, 1 << 9   @ bitWidth 1 (Sign Deadtime Rising value)  
        .equ HRTIM_TIME_DTER_DTRx_Shift, 0   @ bitWidth 9 (Deadtime Rising value)  
 
    .equ HRTIM_TIME_SETE1R, HRTIM_TIME_BASE + 0x3C @ (Timerx Output1 Set Register) 
        .equ HRTIM_TIME_SETE1R_UPDATE, 1 << 31   @ bitWidth 1 (Registers update transfer preload to  active)  
        .equ HRTIM_TIME_SETE1R_EXTEVNT10, 1 << 30   @ bitWidth 1 (External Event 10)  
        .equ HRTIM_TIME_SETE1R_EXTEVNT9, 1 << 29   @ bitWidth 1 (External Event 9)  
        .equ HRTIM_TIME_SETE1R_EXTEVNT8, 1 << 28   @ bitWidth 1 (External Event 8)  
        .equ HRTIM_TIME_SETE1R_EXTEVNT7, 1 << 27   @ bitWidth 1 (External Event 7)  
        .equ HRTIM_TIME_SETE1R_EXTEVNT6, 1 << 26   @ bitWidth 1 (External Event 6)  
        .equ HRTIM_TIME_SETE1R_EXTEVNT5, 1 << 25   @ bitWidth 1 (External Event 5)  
        .equ HRTIM_TIME_SETE1R_EXTEVNT4, 1 << 24   @ bitWidth 1 (External Event 4)  
        .equ HRTIM_TIME_SETE1R_EXTEVNT3, 1 << 23   @ bitWidth 1 (External Event 3)  
        .equ HRTIM_TIME_SETE1R_EXTEVNT2, 1 << 22   @ bitWidth 1 (External Event 2)  
        .equ HRTIM_TIME_SETE1R_EXTEVNT1, 1 << 21   @ bitWidth 1 (External Event 1)  
        .equ HRTIM_TIME_SETE1R_TIMEVNT9, 1 << 20   @ bitWidth 1 (Timer Event 9)  
        .equ HRTIM_TIME_SETE1R_TIMEVNT8, 1 << 19   @ bitWidth 1 (Timer Event 8)  
        .equ HRTIM_TIME_SETE1R_TIMEVNT7, 1 << 18   @ bitWidth 1 (Timer Event 7)  
        .equ HRTIM_TIME_SETE1R_TIMEVNT6, 1 << 17   @ bitWidth 1 (Timer Event 6)  
        .equ HRTIM_TIME_SETE1R_TIMEVNT5, 1 << 16   @ bitWidth 1 (Timer Event 5)  
        .equ HRTIM_TIME_SETE1R_TIMEVNT4, 1 << 15   @ bitWidth 1 (Timer Event 4)  
        .equ HRTIM_TIME_SETE1R_TIMEVNT3, 1 << 14   @ bitWidth 1 (Timer Event 3)  
        .equ HRTIM_TIME_SETE1R_TIMEVNT2, 1 << 13   @ bitWidth 1 (Timer Event 2)  
        .equ HRTIM_TIME_SETE1R_TIMEVNT1, 1 << 12   @ bitWidth 1 (Timer Event 1)  
        .equ HRTIM_TIME_SETE1R_MSTCMP4, 1 << 11   @ bitWidth 1 (Master Compare 4)  
        .equ HRTIM_TIME_SETE1R_MSTCMP3, 1 << 10   @ bitWidth 1 (Master Compare 3)  
        .equ HRTIM_TIME_SETE1R_MSTCMP2, 1 << 9   @ bitWidth 1 (Master Compare 2)  
        .equ HRTIM_TIME_SETE1R_MSTCMP1, 1 << 8   @ bitWidth 1 (Master Compare 1)  
        .equ HRTIM_TIME_SETE1R_MSTPER, 1 << 7   @ bitWidth 1 (Master Period)  
        .equ HRTIM_TIME_SETE1R_CMP4, 1 << 6   @ bitWidth 1 (Timer A compare 4)  
        .equ HRTIM_TIME_SETE1R_CMP3, 1 << 5   @ bitWidth 1 (Timer A compare 3)  
        .equ HRTIM_TIME_SETE1R_CMP2, 1 << 4   @ bitWidth 1 (Timer A compare 2)  
        .equ HRTIM_TIME_SETE1R_CMP1, 1 << 3   @ bitWidth 1 (Timer A compare 1)  
        .equ HRTIM_TIME_SETE1R_PER, 1 << 2   @ bitWidth 1 (Timer A Period)  
        .equ HRTIM_TIME_SETE1R_RESYNC, 1 << 1   @ bitWidth 1 (Timer A resynchronizaton)  
        .equ HRTIM_TIME_SETE1R_SST, 1 << 0   @ bitWidth 1 (Software Set trigger)  
 
    .equ HRTIM_TIME_RSTE1R, HRTIM_TIME_BASE + 0x40 @ (Timerx Output1 Reset Register) 
        .equ HRTIM_TIME_RSTE1R_UPDATE, 1 << 31   @ bitWidth 1 (UPDATE)  
        .equ HRTIM_TIME_RSTE1R_EXTEVNT10, 1 << 30   @ bitWidth 1 (EXTEVNT10)  
        .equ HRTIM_TIME_RSTE1R_EXTEVNT9, 1 << 29   @ bitWidth 1 (EXTEVNT9)  
        .equ HRTIM_TIME_RSTE1R_EXTEVNT8, 1 << 28   @ bitWidth 1 (EXTEVNT8)  
        .equ HRTIM_TIME_RSTE1R_EXTEVNT7, 1 << 27   @ bitWidth 1 (EXTEVNT7)  
        .equ HRTIM_TIME_RSTE1R_EXTEVNT6, 1 << 26   @ bitWidth 1 (EXTEVNT6)  
        .equ HRTIM_TIME_RSTE1R_EXTEVNT5, 1 << 25   @ bitWidth 1 (EXTEVNT5)  
        .equ HRTIM_TIME_RSTE1R_EXTEVNT4, 1 << 24   @ bitWidth 1 (EXTEVNT4)  
        .equ HRTIM_TIME_RSTE1R_EXTEVNT3, 1 << 23   @ bitWidth 1 (EXTEVNT3)  
        .equ HRTIM_TIME_RSTE1R_EXTEVNT2, 1 << 22   @ bitWidth 1 (EXTEVNT2)  
        .equ HRTIM_TIME_RSTE1R_EXTEVNT1, 1 << 21   @ bitWidth 1 (EXTEVNT1)  
        .equ HRTIM_TIME_RSTE1R_TIMEVNT9, 1 << 20   @ bitWidth 1 (TIMEVNT9)  
        .equ HRTIM_TIME_RSTE1R_TIMEVNT8, 1 << 19   @ bitWidth 1 (TIMEVNT8)  
        .equ HRTIM_TIME_RSTE1R_TIMEVNT7, 1 << 18   @ bitWidth 1 (TIMEVNT7)  
        .equ HRTIM_TIME_RSTE1R_TIMEVNT6, 1 << 17   @ bitWidth 1 (TIMEVNT6)  
        .equ HRTIM_TIME_RSTE1R_TIMEVNT5, 1 << 16   @ bitWidth 1 (TIMEVNT5)  
        .equ HRTIM_TIME_RSTE1R_TIMEVNT4, 1 << 15   @ bitWidth 1 (TIMEVNT4)  
        .equ HRTIM_TIME_RSTE1R_TIMEVNT3, 1 << 14   @ bitWidth 1 (TIMEVNT3)  
        .equ HRTIM_TIME_RSTE1R_TIMEVNT2, 1 << 13   @ bitWidth 1 (TIMEVNT2)  
        .equ HRTIM_TIME_RSTE1R_TIMEVNT1, 1 << 12   @ bitWidth 1 (TIMEVNT1)  
        .equ HRTIM_TIME_RSTE1R_MSTCMP4, 1 << 11   @ bitWidth 1 (MSTCMP4)  
        .equ HRTIM_TIME_RSTE1R_MSTCMP3, 1 << 10   @ bitWidth 1 (MSTCMP3)  
        .equ HRTIM_TIME_RSTE1R_MSTCMP2, 1 << 9   @ bitWidth 1 (MSTCMP2)  
        .equ HRTIM_TIME_RSTE1R_MSTCMP1, 1 << 8   @ bitWidth 1 (MSTCMP1)  
        .equ HRTIM_TIME_RSTE1R_MSTPER, 1 << 7   @ bitWidth 1 (MSTPER)  
        .equ HRTIM_TIME_RSTE1R_CMP4, 1 << 6   @ bitWidth 1 (CMP4)  
        .equ HRTIM_TIME_RSTE1R_CMP3, 1 << 5   @ bitWidth 1 (CMP3)  
        .equ HRTIM_TIME_RSTE1R_CMP2, 1 << 4   @ bitWidth 1 (CMP2)  
        .equ HRTIM_TIME_RSTE1R_CMP1, 1 << 3   @ bitWidth 1 (CMP1)  
        .equ HRTIM_TIME_RSTE1R_PER, 1 << 2   @ bitWidth 1 (PER)  
        .equ HRTIM_TIME_RSTE1R_RESYNC, 1 << 1   @ bitWidth 1 (RESYNC)  
        .equ HRTIM_TIME_RSTE1R_SRT, 1 << 0   @ bitWidth 1 (SRT)  
 
    .equ HRTIM_TIME_SETE2R, HRTIM_TIME_BASE + 0x44 @ (Timerx Output2 Set Register) 
        .equ HRTIM_TIME_SETE2R_UPDATE, 1 << 31   @ bitWidth 1 (UPDATE)  
        .equ HRTIM_TIME_SETE2R_EXTEVNT10, 1 << 30   @ bitWidth 1 (EXTEVNT10)  
        .equ HRTIM_TIME_SETE2R_EXTEVNT9, 1 << 29   @ bitWidth 1 (EXTEVNT9)  
        .equ HRTIM_TIME_SETE2R_EXTEVNT8, 1 << 28   @ bitWidth 1 (EXTEVNT8)  
        .equ HRTIM_TIME_SETE2R_EXTEVNT7, 1 << 27   @ bitWidth 1 (EXTEVNT7)  
        .equ HRTIM_TIME_SETE2R_EXTEVNT6, 1 << 26   @ bitWidth 1 (EXTEVNT6)  
        .equ HRTIM_TIME_SETE2R_EXTEVNT5, 1 << 25   @ bitWidth 1 (EXTEVNT5)  
        .equ HRTIM_TIME_SETE2R_EXTEVNT4, 1 << 24   @ bitWidth 1 (EXTEVNT4)  
        .equ HRTIM_TIME_SETE2R_EXTEVNT3, 1 << 23   @ bitWidth 1 (EXTEVNT3)  
        .equ HRTIM_TIME_SETE2R_EXTEVNT2, 1 << 22   @ bitWidth 1 (EXTEVNT2)  
        .equ HRTIM_TIME_SETE2R_EXTEVNT1, 1 << 21   @ bitWidth 1 (EXTEVNT1)  
        .equ HRTIM_TIME_SETE2R_TIMEVNT9, 1 << 20   @ bitWidth 1 (TIMEVNT9)  
        .equ HRTIM_TIME_SETE2R_TIMEVNT8, 1 << 19   @ bitWidth 1 (TIMEVNT8)  
        .equ HRTIM_TIME_SETE2R_TIMEVNT7, 1 << 18   @ bitWidth 1 (TIMEVNT7)  
        .equ HRTIM_TIME_SETE2R_TIMEVNT6, 1 << 17   @ bitWidth 1 (TIMEVNT6)  
        .equ HRTIM_TIME_SETE2R_TIMEVNT5, 1 << 16   @ bitWidth 1 (TIMEVNT5)  
        .equ HRTIM_TIME_SETE2R_TIMEVNT4, 1 << 15   @ bitWidth 1 (TIMEVNT4)  
        .equ HRTIM_TIME_SETE2R_TIMEVNT3, 1 << 14   @ bitWidth 1 (TIMEVNT3)  
        .equ HRTIM_TIME_SETE2R_TIMEVNT2, 1 << 13   @ bitWidth 1 (TIMEVNT2)  
        .equ HRTIM_TIME_SETE2R_TIMEVNT1, 1 << 12   @ bitWidth 1 (TIMEVNT1)  
        .equ HRTIM_TIME_SETE2R_MSTCMP4, 1 << 11   @ bitWidth 1 (MSTCMP4)  
        .equ HRTIM_TIME_SETE2R_MSTCMP3, 1 << 10   @ bitWidth 1 (MSTCMP3)  
        .equ HRTIM_TIME_SETE2R_MSTCMP2, 1 << 9   @ bitWidth 1 (MSTCMP2)  
        .equ HRTIM_TIME_SETE2R_MSTCMP1, 1 << 8   @ bitWidth 1 (MSTCMP1)  
        .equ HRTIM_TIME_SETE2R_MSTPER, 1 << 7   @ bitWidth 1 (MSTPER)  
        .equ HRTIM_TIME_SETE2R_CMP4, 1 << 6   @ bitWidth 1 (CMP4)  
        .equ HRTIM_TIME_SETE2R_CMP3, 1 << 5   @ bitWidth 1 (CMP3)  
        .equ HRTIM_TIME_SETE2R_CMP2, 1 << 4   @ bitWidth 1 (CMP2)  
        .equ HRTIM_TIME_SETE2R_CMP1, 1 << 3   @ bitWidth 1 (CMP1)  
        .equ HRTIM_TIME_SETE2R_PER, 1 << 2   @ bitWidth 1 (PER)  
        .equ HRTIM_TIME_SETE2R_RESYNC, 1 << 1   @ bitWidth 1 (RESYNC)  
        .equ HRTIM_TIME_SETE2R_SST, 1 << 0   @ bitWidth 1 (SST)  
 
    .equ HRTIM_TIME_RSTE2R, HRTIM_TIME_BASE + 0x48 @ (Timerx Output2 Reset Register) 
        .equ HRTIM_TIME_RSTE2R_UPDATE, 1 << 31   @ bitWidth 1 (UPDATE)  
        .equ HRTIM_TIME_RSTE2R_EXTEVNT10, 1 << 30   @ bitWidth 1 (EXTEVNT10)  
        .equ HRTIM_TIME_RSTE2R_EXTEVNT9, 1 << 29   @ bitWidth 1 (EXTEVNT9)  
        .equ HRTIM_TIME_RSTE2R_EXTEVNT8, 1 << 28   @ bitWidth 1 (EXTEVNT8)  
        .equ HRTIM_TIME_RSTE2R_EXTEVNT7, 1 << 27   @ bitWidth 1 (EXTEVNT7)  
        .equ HRTIM_TIME_RSTE2R_EXTEVNT6, 1 << 26   @ bitWidth 1 (EXTEVNT6)  
        .equ HRTIM_TIME_RSTE2R_EXTEVNT5, 1 << 25   @ bitWidth 1 (EXTEVNT5)  
        .equ HRTIM_TIME_RSTE2R_EXTEVNT4, 1 << 24   @ bitWidth 1 (EXTEVNT4)  
        .equ HRTIM_TIME_RSTE2R_EXTEVNT3, 1 << 23   @ bitWidth 1 (EXTEVNT3)  
        .equ HRTIM_TIME_RSTE2R_EXTEVNT2, 1 << 22   @ bitWidth 1 (EXTEVNT2)  
        .equ HRTIM_TIME_RSTE2R_EXTEVNT1, 1 << 21   @ bitWidth 1 (EXTEVNT1)  
        .equ HRTIM_TIME_RSTE2R_TIMEVNT9, 1 << 20   @ bitWidth 1 (TIMEVNT9)  
        .equ HRTIM_TIME_RSTE2R_TIMEVNT8, 1 << 19   @ bitWidth 1 (TIMEVNT8)  
        .equ HRTIM_TIME_RSTE2R_TIMEVNT7, 1 << 18   @ bitWidth 1 (TIMEVNT7)  
        .equ HRTIM_TIME_RSTE2R_TIMEVNT6, 1 << 17   @ bitWidth 1 (TIMEVNT6)  
        .equ HRTIM_TIME_RSTE2R_TIMEVNT5, 1 << 16   @ bitWidth 1 (TIMEVNT5)  
        .equ HRTIM_TIME_RSTE2R_TIMEVNT4, 1 << 15   @ bitWidth 1 (TIMEVNT4)  
        .equ HRTIM_TIME_RSTE2R_TIMEVNT3, 1 << 14   @ bitWidth 1 (TIMEVNT3)  
        .equ HRTIM_TIME_RSTE2R_TIMEVNT2, 1 << 13   @ bitWidth 1 (TIMEVNT2)  
        .equ HRTIM_TIME_RSTE2R_TIMEVNT1, 1 << 12   @ bitWidth 1 (TIMEVNT1)  
        .equ HRTIM_TIME_RSTE2R_MSTCMP4, 1 << 11   @ bitWidth 1 (MSTCMP4)  
        .equ HRTIM_TIME_RSTE2R_MSTCMP3, 1 << 10   @ bitWidth 1 (MSTCMP3)  
        .equ HRTIM_TIME_RSTE2R_MSTCMP2, 1 << 9   @ bitWidth 1 (MSTCMP2)  
        .equ HRTIM_TIME_RSTE2R_MSTCMP1, 1 << 8   @ bitWidth 1 (MSTCMP1)  
        .equ HRTIM_TIME_RSTE2R_MSTPER, 1 << 7   @ bitWidth 1 (MSTPER)  
        .equ HRTIM_TIME_RSTE2R_CMP4, 1 << 6   @ bitWidth 1 (CMP4)  
        .equ HRTIM_TIME_RSTE2R_CMP3, 1 << 5   @ bitWidth 1 (CMP3)  
        .equ HRTIM_TIME_RSTE2R_CMP2, 1 << 4   @ bitWidth 1 (CMP2)  
        .equ HRTIM_TIME_RSTE2R_CMP1, 1 << 3   @ bitWidth 1 (CMP1)  
        .equ HRTIM_TIME_RSTE2R_PER, 1 << 2   @ bitWidth 1 (PER)  
        .equ HRTIM_TIME_RSTE2R_RESYNC, 1 << 1   @ bitWidth 1 (RESYNC)  
        .equ HRTIM_TIME_RSTE2R_SRT, 1 << 0   @ bitWidth 1 (SRT)  
 
    .equ HRTIM_TIME_EEFER1, HRTIM_TIME_BASE + 0x4C @ (Timerx External Event Filtering Register  1) 
        .equ HRTIM_TIME_EEFER1_EE5FLTR_Shift, 25   @ bitWidth 4 (External Event 5 filter)  
        .equ HRTIM_TIME_EEFER1_EE5LTCH, 1 << 24   @ bitWidth 1 (External Event 5 latch)  
        .equ HRTIM_TIME_EEFER1_EE4FLTR_Shift, 19   @ bitWidth 4 (External Event 4 filter)  
        .equ HRTIM_TIME_EEFER1_EE4LTCH, 1 << 18   @ bitWidth 1 (External Event 4 latch)  
        .equ HRTIM_TIME_EEFER1_EE3FLTR_Shift, 13   @ bitWidth 4 (External Event 3 filter)  
        .equ HRTIM_TIME_EEFER1_EE3LTCH, 1 << 12   @ bitWidth 1 (External Event 3 latch)  
        .equ HRTIM_TIME_EEFER1_EE2FLTR_Shift, 7   @ bitWidth 4 (External Event 2 filter)  
        .equ HRTIM_TIME_EEFER1_EE2LTCH, 1 << 6   @ bitWidth 1 (External Event 2 latch)  
        .equ HRTIM_TIME_EEFER1_EE1FLTR_Shift, 1   @ bitWidth 4 (External Event 1 filter)  
        .equ HRTIM_TIME_EEFER1_EE1LTCH, 1 << 0   @ bitWidth 1 (External Event 1 latch)  
 
    .equ HRTIM_TIME_EEFER2, HRTIM_TIME_BASE + 0x50 @ (Timerx External Event Filtering Register  2) 
        .equ HRTIM_TIME_EEFER2_EE10FLTR_Shift, 25   @ bitWidth 4 (External Event 10 filter)  
        .equ HRTIM_TIME_EEFER2_EE10LTCH, 1 << 24   @ bitWidth 1 (External Event 10 latch)  
        .equ HRTIM_TIME_EEFER2_EE9FLTR_Shift, 19   @ bitWidth 4 (External Event 9 filter)  
        .equ HRTIM_TIME_EEFER2_EE9LTCH, 1 << 18   @ bitWidth 1 (External Event 9 latch)  
        .equ HRTIM_TIME_EEFER2_EE8FLTR_Shift, 13   @ bitWidth 4 (External Event 8 filter)  
        .equ HRTIM_TIME_EEFER2_EE8LTCH, 1 << 12   @ bitWidth 1 (External Event 8 latch)  
        .equ HRTIM_TIME_EEFER2_EE7FLTR_Shift, 7   @ bitWidth 4 (External Event 7 filter)  
        .equ HRTIM_TIME_EEFER2_EE7LTCH, 1 << 6   @ bitWidth 1 (External Event 7 latch)  
        .equ HRTIM_TIME_EEFER2_EE6FLTR_Shift, 1   @ bitWidth 4 (External Event 6 filter)  
        .equ HRTIM_TIME_EEFER2_EE6LTCH, 1 << 0   @ bitWidth 1 (External Event 6 latch)  
 
    .equ HRTIM_TIME_RSTER, HRTIM_TIME_BASE + 0x54 @ (TimerA Reset Register) 
        .equ HRTIM_TIME_RSTER_TIMDCMP4, 1 << 30   @ bitWidth 1 (Timer D Compare 4)  
        .equ HRTIM_TIME_RSTER_TIMDCMP2, 1 << 29   @ bitWidth 1 (Timer D Compare 2)  
        .equ HRTIM_TIME_RSTER_TIMDCMP1, 1 << 28   @ bitWidth 1 (Timer D Compare 1)  
        .equ HRTIM_TIME_RSTER_TIMCCMP4, 1 << 27   @ bitWidth 1 (Timer C Compare 4)  
        .equ HRTIM_TIME_RSTER_TIMCCMP2, 1 << 26   @ bitWidth 1 (Timer C Compare 2)  
        .equ HRTIM_TIME_RSTER_TIMCCMP1, 1 << 25   @ bitWidth 1 (Timer C Compare 1)  
        .equ HRTIM_TIME_RSTER_TIMBCMP4, 1 << 24   @ bitWidth 1 (Timer B Compare 4)  
        .equ HRTIM_TIME_RSTER_TIMBCMP2, 1 << 23   @ bitWidth 1 (Timer B Compare 2)  
        .equ HRTIM_TIME_RSTER_TIMBCMP1, 1 << 22   @ bitWidth 1 (Timer B Compare 1)  
        .equ HRTIM_TIME_RSTER_TIMACMP4, 1 << 21   @ bitWidth 1 (Timer A Compare 4)  
        .equ HRTIM_TIME_RSTER_TIMACMP2, 1 << 20   @ bitWidth 1 (Timer A Compare 2)  
        .equ HRTIM_TIME_RSTER_TIMACMP1, 1 << 19   @ bitWidth 1 (Timer A Compare 1)  
        .equ HRTIM_TIME_RSTER_EXTEVNT10, 1 << 18   @ bitWidth 1 (External Event 10)  
        .equ HRTIM_TIME_RSTER_EXTEVNT9, 1 << 17   @ bitWidth 1 (External Event 9)  
        .equ HRTIM_TIME_RSTER_EXTEVNT8, 1 << 16   @ bitWidth 1 (External Event 8)  
        .equ HRTIM_TIME_RSTER_EXTEVNT7, 1 << 15   @ bitWidth 1 (External Event 7)  
        .equ HRTIM_TIME_RSTER_EXTEVNT6, 1 << 14   @ bitWidth 1 (External Event 6)  
        .equ HRTIM_TIME_RSTER_EXTEVNT5, 1 << 13   @ bitWidth 1 (External Event 5)  
        .equ HRTIM_TIME_RSTER_EXTEVNT4, 1 << 12   @ bitWidth 1 (External Event 4)  
        .equ HRTIM_TIME_RSTER_EXTEVNT3, 1 << 11   @ bitWidth 1 (External Event 3)  
        .equ HRTIM_TIME_RSTER_EXTEVNT2, 1 << 10   @ bitWidth 1 (External Event 2)  
        .equ HRTIM_TIME_RSTER_EXTEVNT1, 1 << 9   @ bitWidth 1 (External Event 1)  
        .equ HRTIM_TIME_RSTER_MSTCMP4, 1 << 8   @ bitWidth 1 (Master compare 4)  
        .equ HRTIM_TIME_RSTER_MSTCMP3, 1 << 7   @ bitWidth 1 (Master compare 3)  
        .equ HRTIM_TIME_RSTER_MSTCMP2, 1 << 6   @ bitWidth 1 (Master compare 2)  
        .equ HRTIM_TIME_RSTER_MSTCMP1, 1 << 5   @ bitWidth 1 (Master compare 1)  
        .equ HRTIM_TIME_RSTER_MSTPER, 1 << 4   @ bitWidth 1 (Master timer Period)  
        .equ HRTIM_TIME_RSTER_CMP4, 1 << 3   @ bitWidth 1 (Timer A compare 4 reset)  
        .equ HRTIM_TIME_RSTER_CMP2, 1 << 2   @ bitWidth 1 (Timer A compare 2 reset)  
        .equ HRTIM_TIME_RSTER_UPDT, 1 << 1   @ bitWidth 1 (Timer A Update reset)  
 
    .equ HRTIM_TIME_CHPER, HRTIM_TIME_BASE + 0x58 @ (Timerx Chopper Register) 
        .equ HRTIM_TIME_CHPER_STRTPW_Shift, 7   @ bitWidth 4 (STRTPW)  
        .equ HRTIM_TIME_CHPER_CHPDTY_Shift, 4   @ bitWidth 3 (Timerx chopper duty cycle  value)  
        .equ HRTIM_TIME_CHPER_CHPFRQ_Shift, 0   @ bitWidth 4 (Timerx carrier frequency  value)  
 
    .equ HRTIM_TIME_CPT1ECR, HRTIM_TIME_BASE + 0x5C @ (Timerx Capture 2 Control  Register) 
        .equ HRTIM_TIME_CPT1ECR_TDCMP2, 1 << 27   @ bitWidth 1 (Timer D Compare 2)  
        .equ HRTIM_TIME_CPT1ECR_TDCMP1, 1 << 26   @ bitWidth 1 (Timer D Compare 1)  
        .equ HRTIM_TIME_CPT1ECR_TD1RST, 1 << 25   @ bitWidth 1 (Timer D output 1 Reset)  
        .equ HRTIM_TIME_CPT1ECR_TD1SET, 1 << 24   @ bitWidth 1 (Timer D output 1 Set)  
        .equ HRTIM_TIME_CPT1ECR_TCCMP2, 1 << 23   @ bitWidth 1 (Timer C Compare 2)  
        .equ HRTIM_TIME_CPT1ECR_TCCMP1, 1 << 22   @ bitWidth 1 (Timer C Compare 1)  
        .equ HRTIM_TIME_CPT1ECR_TC1RST, 1 << 21   @ bitWidth 1 (Timer C output 1 Reset)  
        .equ HRTIM_TIME_CPT1ECR_TC1SET, 1 << 20   @ bitWidth 1 (Timer C output 1 Set)  
        .equ HRTIM_TIME_CPT1ECR_TBCMP2, 1 << 19   @ bitWidth 1 (Timer B Compare 2)  
        .equ HRTIM_TIME_CPT1ECR_TBCMP1, 1 << 18   @ bitWidth 1 (Timer B Compare 1)  
        .equ HRTIM_TIME_CPT1ECR_TB1RST, 1 << 17   @ bitWidth 1 (Timer B output 1 Reset)  
        .equ HRTIM_TIME_CPT1ECR_TB1SET, 1 << 16   @ bitWidth 1 (Timer B output 1 Set)  
        .equ HRTIM_TIME_CPT1ECR_TACMP2, 1 << 15   @ bitWidth 1 (Timer A Compare 2)  
        .equ HRTIM_TIME_CPT1ECR_TACMP1, 1 << 14   @ bitWidth 1 (Timer A Compare 1)  
        .equ HRTIM_TIME_CPT1ECR_TA1RST, 1 << 13   @ bitWidth 1 (Timer A output 1 Reset)  
        .equ HRTIM_TIME_CPT1ECR_TA1SET, 1 << 12   @ bitWidth 1 (Timer A output 1 Set)  
        .equ HRTIM_TIME_CPT1ECR_EXEV10CPT, 1 << 11   @ bitWidth 1 (External Event 10 Capture)  
        .equ HRTIM_TIME_CPT1ECR_EXEV9CPT, 1 << 10   @ bitWidth 1 (External Event 9 Capture)  
        .equ HRTIM_TIME_CPT1ECR_EXEV8CPT, 1 << 9   @ bitWidth 1 (External Event 8 Capture)  
        .equ HRTIM_TIME_CPT1ECR_EXEV7CPT, 1 << 8   @ bitWidth 1 (External Event 7 Capture)  
        .equ HRTIM_TIME_CPT1ECR_EXEV6CPT, 1 << 7   @ bitWidth 1 (External Event 6 Capture)  
        .equ HRTIM_TIME_CPT1ECR_EXEV5CPT, 1 << 6   @ bitWidth 1 (External Event 5 Capture)  
        .equ HRTIM_TIME_CPT1ECR_EXEV4CPT, 1 << 5   @ bitWidth 1 (External Event 4 Capture)  
        .equ HRTIM_TIME_CPT1ECR_EXEV3CPT, 1 << 4   @ bitWidth 1 (External Event 3 Capture)  
        .equ HRTIM_TIME_CPT1ECR_EXEV2CPT, 1 << 3   @ bitWidth 1 (External Event 2 Capture)  
        .equ HRTIM_TIME_CPT1ECR_EXEV1CPT, 1 << 2   @ bitWidth 1 (External Event 1 Capture)  
        .equ HRTIM_TIME_CPT1ECR_UDPCPT, 1 << 1   @ bitWidth 1 (Update Capture)  
        .equ HRTIM_TIME_CPT1ECR_SWCPT, 1 << 0   @ bitWidth 1 (Software Capture)  
 
    .equ HRTIM_TIME_CPT2ECR, HRTIM_TIME_BASE + 0x60 @ (CPT2xCR) 
        .equ HRTIM_TIME_CPT2ECR_TDCMP2, 1 << 27   @ bitWidth 1 (Timer D Compare 2)  
        .equ HRTIM_TIME_CPT2ECR_TDCMP1, 1 << 26   @ bitWidth 1 (Timer D Compare 1)  
        .equ HRTIM_TIME_CPT2ECR_TD1RST, 1 << 25   @ bitWidth 1 (Timer D output 1 Reset)  
        .equ HRTIM_TIME_CPT2ECR_TD1SET, 1 << 24   @ bitWidth 1 (Timer D output 1 Set)  
        .equ HRTIM_TIME_CPT2ECR_TCCMP2, 1 << 23   @ bitWidth 1 (Timer C Compare 2)  
        .equ HRTIM_TIME_CPT2ECR_TCCMP1, 1 << 22   @ bitWidth 1 (Timer C Compare 1)  
        .equ HRTIM_TIME_CPT2ECR_TC1RST, 1 << 21   @ bitWidth 1 (Timer C output 1 Reset)  
        .equ HRTIM_TIME_CPT2ECR_TC1SET, 1 << 20   @ bitWidth 1 (Timer C output 1 Set)  
        .equ HRTIM_TIME_CPT2ECR_TBCMP2, 1 << 19   @ bitWidth 1 (Timer B Compare 2)  
        .equ HRTIM_TIME_CPT2ECR_TBCMP1, 1 << 18   @ bitWidth 1 (Timer B Compare 1)  
        .equ HRTIM_TIME_CPT2ECR_TB1RST, 1 << 17   @ bitWidth 1 (Timer B output 1 Reset)  
        .equ HRTIM_TIME_CPT2ECR_TB1SET, 1 << 16   @ bitWidth 1 (Timer B output 1 Set)  
        .equ HRTIM_TIME_CPT2ECR_TACMP2, 1 << 15   @ bitWidth 1 (Timer A Compare 2)  
        .equ HRTIM_TIME_CPT2ECR_TACMP1, 1 << 14   @ bitWidth 1 (Timer A Compare 1)  
        .equ HRTIM_TIME_CPT2ECR_TA1RST, 1 << 13   @ bitWidth 1 (Timer A output 1 Reset)  
        .equ HRTIM_TIME_CPT2ECR_TA1SET, 1 << 12   @ bitWidth 1 (Timer A output 1 Set)  
        .equ HRTIM_TIME_CPT2ECR_EXEV10CPT, 1 << 11   @ bitWidth 1 (External Event 10 Capture)  
        .equ HRTIM_TIME_CPT2ECR_EXEV9CPT, 1 << 10   @ bitWidth 1 (External Event 9 Capture)  
        .equ HRTIM_TIME_CPT2ECR_EXEV8CPT, 1 << 9   @ bitWidth 1 (External Event 8 Capture)  
        .equ HRTIM_TIME_CPT2ECR_EXEV7CPT, 1 << 8   @ bitWidth 1 (External Event 7 Capture)  
        .equ HRTIM_TIME_CPT2ECR_EXEV6CPT, 1 << 7   @ bitWidth 1 (External Event 6 Capture)  
        .equ HRTIM_TIME_CPT2ECR_EXEV5CPT, 1 << 6   @ bitWidth 1 (External Event 5 Capture)  
        .equ HRTIM_TIME_CPT2ECR_EXEV4CPT, 1 << 5   @ bitWidth 1 (External Event 4 Capture)  
        .equ HRTIM_TIME_CPT2ECR_EXEV3CPT, 1 << 4   @ bitWidth 1 (External Event 3 Capture)  
        .equ HRTIM_TIME_CPT2ECR_EXEV2CPT, 1 << 3   @ bitWidth 1 (External Event 2 Capture)  
        .equ HRTIM_TIME_CPT2ECR_EXEV1CPT, 1 << 2   @ bitWidth 1 (External Event 1 Capture)  
        .equ HRTIM_TIME_CPT2ECR_UDPCPT, 1 << 1   @ bitWidth 1 (Update Capture)  
        .equ HRTIM_TIME_CPT2ECR_SWCPT, 1 << 0   @ bitWidth 1 (Software Capture)  
 
    .equ HRTIM_TIME_OUTER, HRTIM_TIME_BASE + 0x64 @ (Timerx Output Register) 
        .equ HRTIM_TIME_OUTER_DIDL2, 1 << 23   @ bitWidth 1 (Output 2 Deadtime upon burst mode Idle  entry)  
        .equ HRTIM_TIME_OUTER_CHP2, 1 << 22   @ bitWidth 1 (Output 2 Chopper enable)  
        .equ HRTIM_TIME_OUTER_FAULT2_Shift, 20   @ bitWidth 2 (Output 2 Fault state)  
        .equ HRTIM_TIME_OUTER_IDLES2, 1 << 19   @ bitWidth 1 (Output 2 Idle State)  
        .equ HRTIM_TIME_OUTER_IDLEM2, 1 << 18   @ bitWidth 1 (Output 2 Idle mode)  
        .equ HRTIM_TIME_OUTER_POL2, 1 << 17   @ bitWidth 1 (Output 2 polarity)  
        .equ HRTIM_TIME_OUTER_DLYPRT_Shift, 10   @ bitWidth 3 (Delayed Protection)  
        .equ HRTIM_TIME_OUTER_DLYPRTEN, 1 << 9   @ bitWidth 1 (Delayed Protection Enable)  
        .equ HRTIM_TIME_OUTER_DTEN, 1 << 8   @ bitWidth 1 (Deadtime enable)  
        .equ HRTIM_TIME_OUTER_DIDL1, 1 << 7   @ bitWidth 1 (Output 1 Deadtime upon burst mode Idle  entry)  
        .equ HRTIM_TIME_OUTER_CHP1, 1 << 6   @ bitWidth 1 (Output 1 Chopper enable)  
        .equ HRTIM_TIME_OUTER_FAULT1_Shift, 4   @ bitWidth 2 (Output 1 Fault state)  
        .equ HRTIM_TIME_OUTER_IDLES1, 1 << 3   @ bitWidth 1 (Output 1 Idle State)  
        .equ HRTIM_TIME_OUTER_IDLEM1, 1 << 2   @ bitWidth 1 (Output 1 Idle mode)  
        .equ HRTIM_TIME_OUTER_POL1, 1 << 1   @ bitWidth 1 (Output 1 polarity)  
 
    .equ HRTIM_TIME_FLTER, HRTIM_TIME_BASE + 0x68 @ (Timerx Fault Register) 
        .equ HRTIM_TIME_FLTER_FLTLCK, 1 << 31   @ bitWidth 1 (Fault sources Lock)  
        .equ HRTIM_TIME_FLTER_FLT5EN, 1 << 4   @ bitWidth 1 (Fault 5 enable)  
        .equ HRTIM_TIME_FLTER_FLT4EN, 1 << 3   @ bitWidth 1 (Fault 4 enable)  
        .equ HRTIM_TIME_FLTER_FLT3EN, 1 << 2   @ bitWidth 1 (Fault 3 enable)  
        .equ HRTIM_TIME_FLTER_FLT2EN, 1 << 1   @ bitWidth 1 (Fault 2 enable)  
        .equ HRTIM_TIME_FLTER_FLT1EN, 1 << 0   @ bitWidth 1 (Fault 1 enable)  
 

@=========================== HRTIM_Common ===========================@
.equ HRTIM_Common_BASE, 0x40017780 @ (High Resolution Timer: Common  functions) 
    .equ HRTIM_Common_CR1, HRTIM_Common_BASE + 0x0 @ (Control Register 1) 
        .equ HRTIM_Common_CR1_AD4USRC_Shift, 25   @ bitWidth 3 (ADC Trigger 4 Update  Source)  
        .equ HRTIM_Common_CR1_AD3USRC_Shift, 22   @ bitWidth 3 (ADC Trigger 3 Update  Source)  
        .equ HRTIM_Common_CR1_AD2USRC_Shift, 19   @ bitWidth 3 (ADC Trigger 2 Update  Source)  
        .equ HRTIM_Common_CR1_AD1USRC_Shift, 16   @ bitWidth 3 (ADC Trigger 1 Update  Source)  
        .equ HRTIM_Common_CR1_TEUDIS, 1 << 5   @ bitWidth 1 (Timer E Update Disable)  
        .equ HRTIM_Common_CR1_TDUDIS, 1 << 4   @ bitWidth 1 (Timer D Update Disable)  
        .equ HRTIM_Common_CR1_TCUDIS, 1 << 3   @ bitWidth 1 (Timer C Update Disable)  
        .equ HRTIM_Common_CR1_TBUDIS, 1 << 2   @ bitWidth 1 (Timer B Update Disable)  
        .equ HRTIM_Common_CR1_TAUDIS, 1 << 1   @ bitWidth 1 (Timer A Update Disable)  
        .equ HRTIM_Common_CR1_MUDIS, 1 << 0   @ bitWidth 1 (Master Update Disable)  
 
    .equ HRTIM_Common_CR2, HRTIM_Common_BASE + 0x4 @ (Control Register 2) 
        .equ HRTIM_Common_CR2_TERST, 1 << 13   @ bitWidth 1 (Timer E counter software  reset)  
        .equ HRTIM_Common_CR2_TDRST, 1 << 12   @ bitWidth 1 (Timer D counter software  reset)  
        .equ HRTIM_Common_CR2_TCRST, 1 << 11   @ bitWidth 1 (Timer C counter software  reset)  
        .equ HRTIM_Common_CR2_TBRST, 1 << 10   @ bitWidth 1 (Timer B counter software  reset)  
        .equ HRTIM_Common_CR2_TARST, 1 << 9   @ bitWidth 1 (Timer A counter software  reset)  
        .equ HRTIM_Common_CR2_MRST, 1 << 8   @ bitWidth 1 (Master Counter software  reset)  
        .equ HRTIM_Common_CR2_TESWU, 1 << 5   @ bitWidth 1 (Timer E Software Update)  
        .equ HRTIM_Common_CR2_TDSWU, 1 << 4   @ bitWidth 1 (Timer D Software Update)  
        .equ HRTIM_Common_CR2_TCSWU, 1 << 3   @ bitWidth 1 (Timer C Software Update)  
        .equ HRTIM_Common_CR2_TBSWU, 1 << 2   @ bitWidth 1 (Timer B Software Update)  
        .equ HRTIM_Common_CR2_TASWU, 1 << 1   @ bitWidth 1 (Timer A Software update)  
        .equ HRTIM_Common_CR2_MSWU, 1 << 0   @ bitWidth 1 (Master Timer Software  update)  
 
    .equ HRTIM_Common_ISR, HRTIM_Common_BASE + 0x8 @ (Interrupt Status Register) 
        .equ HRTIM_Common_ISR_BMPER, 1 << 17   @ bitWidth 1 (Burst mode Period Interrupt  Flag)  
        .equ HRTIM_Common_ISR_DLLRDY, 1 << 16   @ bitWidth 1 (DLL Ready Interrupt Flag)  
        .equ HRTIM_Common_ISR_SYSFLT, 1 << 5   @ bitWidth 1 (System Fault Interrupt  Flag)  
        .equ HRTIM_Common_ISR_FLT5, 1 << 4   @ bitWidth 1 (Fault 5 Interrupt Flag)  
        .equ HRTIM_Common_ISR_FLT4, 1 << 3   @ bitWidth 1 (Fault 4 Interrupt Flag)  
        .equ HRTIM_Common_ISR_FLT3, 1 << 2   @ bitWidth 1 (Fault 3 Interrupt Flag)  
        .equ HRTIM_Common_ISR_FLT2, 1 << 1   @ bitWidth 1 (Fault 2 Interrupt Flag)  
        .equ HRTIM_Common_ISR_FLT1, 1 << 0   @ bitWidth 1 (Fault 1 Interrupt Flag)  
 
    .equ HRTIM_Common_ICR, HRTIM_Common_BASE + 0xC @ (Interrupt Clear Register) 
        .equ HRTIM_Common_ICR_BMPERC, 1 << 17   @ bitWidth 1 (Burst mode period flag  Clear)  
        .equ HRTIM_Common_ICR_DLLRDYC, 1 << 16   @ bitWidth 1 (DLL Ready Interrupt flag  Clear)  
        .equ HRTIM_Common_ICR_SYSFLTC, 1 << 5   @ bitWidth 1 (System Fault Interrupt Flag  Clear)  
        .equ HRTIM_Common_ICR_FLT5C, 1 << 4   @ bitWidth 1 (Fault 5 Interrupt Flag  Clear)  
        .equ HRTIM_Common_ICR_FLT4C, 1 << 3   @ bitWidth 1 (Fault 4 Interrupt Flag  Clear)  
        .equ HRTIM_Common_ICR_FLT3C, 1 << 2   @ bitWidth 1 (Fault 3 Interrupt Flag  Clear)  
        .equ HRTIM_Common_ICR_FLT2C, 1 << 1   @ bitWidth 1 (Fault 2 Interrupt Flag  Clear)  
        .equ HRTIM_Common_ICR_FLT1C, 1 << 0   @ bitWidth 1 (Fault 1 Interrupt Flag  Clear)  
 
    .equ HRTIM_Common_IER, HRTIM_Common_BASE + 0x10 @ (Interrupt Enable Register) 
        .equ HRTIM_Common_IER_BMPERIE, 1 << 17   @ bitWidth 1 (Burst mode period Interrupt  Enable)  
        .equ HRTIM_Common_IER_DLLRDYIE, 1 << 16   @ bitWidth 1 (DLL Ready Interrupt Enable)  
        .equ HRTIM_Common_IER_SYSFLTE, 1 << 5   @ bitWidth 1 (System Fault Interrupt  Enable)  
        .equ HRTIM_Common_IER_FLT5IE, 1 << 4   @ bitWidth 1 (Fault 5 Interrupt Enable)  
        .equ HRTIM_Common_IER_FLT4IE, 1 << 3   @ bitWidth 1 (Fault 4 Interrupt Enable)  
        .equ HRTIM_Common_IER_FLT3IE, 1 << 2   @ bitWidth 1 (Fault 3 Interrupt Enable)  
        .equ HRTIM_Common_IER_FLT2IE, 1 << 1   @ bitWidth 1 (Fault 2 Interrupt Enable)  
        .equ HRTIM_Common_IER_FLT1IE, 1 << 0   @ bitWidth 1 (Fault 1 Interrupt Enable)  
 
    .equ HRTIM_Common_OENR, HRTIM_Common_BASE + 0x14 @ (Output Enable Register) 
        .equ HRTIM_Common_OENR_TE2OEN, 1 << 9   @ bitWidth 1 (Timer E Output 2 Enable)  
        .equ HRTIM_Common_OENR_TE1OEN, 1 << 8   @ bitWidth 1 (Timer E Output 1 Enable)  
        .equ HRTIM_Common_OENR_TD2OEN, 1 << 7   @ bitWidth 1 (Timer D Output 2 Enable)  
        .equ HRTIM_Common_OENR_TD1OEN, 1 << 6   @ bitWidth 1 (Timer D Output 1 Enable)  
        .equ HRTIM_Common_OENR_TC2OEN, 1 << 5   @ bitWidth 1 (Timer C Output 2 Enable)  
        .equ HRTIM_Common_OENR_TC1OEN, 1 << 4   @ bitWidth 1 (Timer C Output 1 Enable)  
        .equ HRTIM_Common_OENR_TB2OEN, 1 << 3   @ bitWidth 1 (Timer B Output 2 Enable)  
        .equ HRTIM_Common_OENR_TB1OEN, 1 << 2   @ bitWidth 1 (Timer B Output 1 Enable)  
        .equ HRTIM_Common_OENR_TA2OEN, 1 << 1   @ bitWidth 1 (Timer A Output 2 Enable)  
        .equ HRTIM_Common_OENR_TA1OEN, 1 << 0   @ bitWidth 1 (Timer A Output 1 Enable)  
 
    .equ HRTIM_Common_DISR, HRTIM_Common_BASE + 0x18 @ (DISR) 
        .equ HRTIM_Common_DISR_TE2ODIS, 1 << 9   @ bitWidth 1 (TE2ODIS)  
        .equ HRTIM_Common_DISR_TE1ODIS, 1 << 8   @ bitWidth 1 (TE1ODIS)  
        .equ HRTIM_Common_DISR_TD2ODIS, 1 << 7   @ bitWidth 1 (TD2ODIS)  
        .equ HRTIM_Common_DISR_TD1ODIS, 1 << 6   @ bitWidth 1 (TD1ODIS)  
        .equ HRTIM_Common_DISR_TC2ODIS, 1 << 5   @ bitWidth 1 (TC2ODIS)  
        .equ HRTIM_Common_DISR_TC1ODIS, 1 << 4   @ bitWidth 1 (TC1ODIS)  
        .equ HRTIM_Common_DISR_TB2ODIS, 1 << 3   @ bitWidth 1 (TB2ODIS)  
        .equ HRTIM_Common_DISR_TB1ODIS, 1 << 2   @ bitWidth 1 (TB1ODIS)  
        .equ HRTIM_Common_DISR_TA2ODIS, 1 << 1   @ bitWidth 1 (TA2ODIS)  
        .equ HRTIM_Common_DISR_TA1ODIS, 1 << 0   @ bitWidth 1 (TA1ODIS)  
 
    .equ HRTIM_Common_ODSR, HRTIM_Common_BASE + 0x1C @ (Output Disable Status Register) 
        .equ HRTIM_Common_ODSR_TE2ODS, 1 << 9   @ bitWidth 1 (Timer E Output 2 disable  status)  
        .equ HRTIM_Common_ODSR_TE1ODS, 1 << 8   @ bitWidth 1 (Timer E Output 1 disable  status)  
        .equ HRTIM_Common_ODSR_TD2ODS, 1 << 7   @ bitWidth 1 (Timer D Output 2 disable  status)  
        .equ HRTIM_Common_ODSR_TD1ODS, 1 << 6   @ bitWidth 1 (Timer D Output 1 disable  status)  
        .equ HRTIM_Common_ODSR_TC2ODS, 1 << 5   @ bitWidth 1 (Timer C Output 2 disable  status)  
        .equ HRTIM_Common_ODSR_TC1ODS, 1 << 4   @ bitWidth 1 (Timer C Output 1 disable  status)  
        .equ HRTIM_Common_ODSR_TB2ODS, 1 << 3   @ bitWidth 1 (Timer B Output 2 disable  status)  
        .equ HRTIM_Common_ODSR_TB1ODS, 1 << 2   @ bitWidth 1 (Timer B Output 1 disable  status)  
        .equ HRTIM_Common_ODSR_TA2ODS, 1 << 1   @ bitWidth 1 (Timer A Output 2 disable  status)  
        .equ HRTIM_Common_ODSR_TA1ODS, 1 << 0   @ bitWidth 1 (Timer A Output 1 disable  status)  
 
    .equ HRTIM_Common_BMCR, HRTIM_Common_BASE + 0x20 @ (Burst Mode Control Register) 
        .equ HRTIM_Common_BMCR_BMSTAT, 1 << 31   @ bitWidth 1 (Burst Mode Status)  
        .equ HRTIM_Common_BMCR_TEBM, 1 << 21   @ bitWidth 1 (Timer E Burst Mode)  
        .equ HRTIM_Common_BMCR_TDBM, 1 << 20   @ bitWidth 1 (Timer D Burst Mode)  
        .equ HRTIM_Common_BMCR_TCBM, 1 << 19   @ bitWidth 1 (Timer C Burst Mode)  
        .equ HRTIM_Common_BMCR_TBBM, 1 << 18   @ bitWidth 1 (Timer B Burst Mode)  
        .equ HRTIM_Common_BMCR_TABM, 1 << 17   @ bitWidth 1 (Timer A Burst Mode)  
        .equ HRTIM_Common_BMCR_MTBM, 1 << 16   @ bitWidth 1 (Master Timer Burst Mode)  
        .equ HRTIM_Common_BMCR_BMPREN, 1 << 10   @ bitWidth 1 (Burst Mode Preload Enable)  
        .equ HRTIM_Common_BMCR_BMPRSC_Shift, 6   @ bitWidth 4 (Burst Mode Prescaler)  
        .equ HRTIM_Common_BMCR_BMCLK_Shift, 2   @ bitWidth 4 (Burst Mode Clock source)  
        .equ HRTIM_Common_BMCR_BMOM, 1 << 1   @ bitWidth 1 (Burst Mode operating mode)  
        .equ HRTIM_Common_BMCR_BME, 1 << 0   @ bitWidth 1 (Burst Mode enable)  
 
    .equ HRTIM_Common_BMTRG, HRTIM_Common_BASE + 0x24 @ (BMTRG) 
        .equ HRTIM_Common_BMTRG_OCHPEV, 1 << 31   @ bitWidth 1 (OCHPEV)  
        .equ HRTIM_Common_BMTRG_TECMP2, 1 << 26   @ bitWidth 1 (TECMP2)  
        .equ HRTIM_Common_BMTRG_TECMP1, 1 << 25   @ bitWidth 1 (TECMP1)  
        .equ HRTIM_Common_BMTRG_TEREP, 1 << 24   @ bitWidth 1 (TEREP)  
        .equ HRTIM_Common_BMTRG_TERST, 1 << 23   @ bitWidth 1 (TERST)  
        .equ HRTIM_Common_BMTRG_TDCMP2, 1 << 22   @ bitWidth 1 (TDCMP2)  
        .equ HRTIM_Common_BMTRG_TDCMP1, 1 << 21   @ bitWidth 1 (TDCMP1)  
        .equ HRTIM_Common_BMTRG_TDREP, 1 << 20   @ bitWidth 1 (TDREP)  
        .equ HRTIM_Common_BMTRG_TDRST, 1 << 19   @ bitWidth 1 (TDRST)  
        .equ HRTIM_Common_BMTRG_TCCMP2, 1 << 18   @ bitWidth 1 (TCCMP2)  
        .equ HRTIM_Common_BMTRG_TCCMP1, 1 << 17   @ bitWidth 1 (TCCMP1)  
        .equ HRTIM_Common_BMTRG_TCREP, 1 << 16   @ bitWidth 1 (TCREP)  
        .equ HRTIM_Common_BMTRG_TCRST, 1 << 15   @ bitWidth 1 (TCRST)  
        .equ HRTIM_Common_BMTRG_TBCMP2, 1 << 14   @ bitWidth 1 (TBCMP2)  
        .equ HRTIM_Common_BMTRG_TBCMP1, 1 << 13   @ bitWidth 1 (TBCMP1)  
        .equ HRTIM_Common_BMTRG_TBREP, 1 << 12   @ bitWidth 1 (TBREP)  
        .equ HRTIM_Common_BMTRG_TBRST, 1 << 11   @ bitWidth 1 (TBRST)  
        .equ HRTIM_Common_BMTRG_TACMP2, 1 << 10   @ bitWidth 1 (TACMP2)  
        .equ HRTIM_Common_BMTRG_TACMP1, 1 << 9   @ bitWidth 1 (TACMP1)  
        .equ HRTIM_Common_BMTRG_TAREP, 1 << 8   @ bitWidth 1 (TAREP)  
        .equ HRTIM_Common_BMTRG_TARST, 1 << 7   @ bitWidth 1 (TARST)  
        .equ HRTIM_Common_BMTRG_MSTCMP4, 1 << 6   @ bitWidth 1 (MSTCMP4)  
        .equ HRTIM_Common_BMTRG_MSTCMP3, 1 << 5   @ bitWidth 1 (MSTCMP3)  
        .equ HRTIM_Common_BMTRG_MSTCMP2, 1 << 4   @ bitWidth 1 (MSTCMP2)  
        .equ HRTIM_Common_BMTRG_MSTCMP1, 1 << 3   @ bitWidth 1 (MSTCMP1)  
        .equ HRTIM_Common_BMTRG_MSTREP, 1 << 2   @ bitWidth 1 (MSTREP)  
        .equ HRTIM_Common_BMTRG_MSTRST, 1 << 1   @ bitWidth 1 (MSTRST)  
        .equ HRTIM_Common_BMTRG_SW, 1 << 0   @ bitWidth 1 (SW)  
 
    .equ HRTIM_Common_BMCMPR6, HRTIM_Common_BASE + 0x28 @ (BMCMPR6) 
        .equ HRTIM_Common_BMCMPR6_BMCMP_Shift, 0   @ bitWidth 16 (BMCMP)  
 
    .equ HRTIM_Common_BMPER, HRTIM_Common_BASE + 0x2C @ (Burst Mode Period Register) 
        .equ HRTIM_Common_BMPER_BMPER_Shift, 0   @ bitWidth 16 (Burst mode Period)  
 
    .equ HRTIM_Common_EECR1, HRTIM_Common_BASE + 0x30 @ (Timer External Event Control Register  1) 
        .equ HRTIM_Common_EECR1_EE5FAST, 1 << 29   @ bitWidth 1 (External Event 5 Fast mode)  
        .equ HRTIM_Common_EECR1_EE5SNS_Shift, 27   @ bitWidth 2 (External Event 5  Sensitivity)  
        .equ HRTIM_Common_EECR1_EE5POL, 1 << 26   @ bitWidth 1 (External Event 5 Polarity)  
        .equ HRTIM_Common_EECR1_EE5SRC_Shift, 24   @ bitWidth 2 (External Event 5 Source)  
        .equ HRTIM_Common_EECR1_EE4FAST, 1 << 23   @ bitWidth 1 (External Event 4 Fast mode)  
        .equ HRTIM_Common_EECR1_EE4SNS_Shift, 21   @ bitWidth 2 (External Event 4  Sensitivity)  
        .equ HRTIM_Common_EECR1_EE4POL, 1 << 20   @ bitWidth 1 (External Event 4 Polarity)  
        .equ HRTIM_Common_EECR1_EE4SRC_Shift, 18   @ bitWidth 2 (External Event 4 Source)  
        .equ HRTIM_Common_EECR1_EE3FAST, 1 << 17   @ bitWidth 1 (External Event 3 Fast mode)  
        .equ HRTIM_Common_EECR1_EE3SNS_Shift, 15   @ bitWidth 2 (External Event 3  Sensitivity)  
        .equ HRTIM_Common_EECR1_EE3POL, 1 << 14   @ bitWidth 1 (External Event 3 Polarity)  
        .equ HRTIM_Common_EECR1_EE3SRC_Shift, 12   @ bitWidth 2 (External Event 3 Source)  
        .equ HRTIM_Common_EECR1_EE2FAST, 1 << 11   @ bitWidth 1 (External Event 2 Fast mode)  
        .equ HRTIM_Common_EECR1_EE2SNS_Shift, 9   @ bitWidth 2 (External Event 2  Sensitivity)  
        .equ HRTIM_Common_EECR1_EE2POL, 1 << 8   @ bitWidth 1 (External Event 2 Polarity)  
        .equ HRTIM_Common_EECR1_EE2SRC_Shift, 6   @ bitWidth 2 (External Event 2 Source)  
        .equ HRTIM_Common_EECR1_EE1FAST, 1 << 5   @ bitWidth 1 (External Event 1 Fast mode)  
        .equ HRTIM_Common_EECR1_EE1SNS_Shift, 3   @ bitWidth 2 (External Event 1  Sensitivity)  
        .equ HRTIM_Common_EECR1_EE1POL, 1 << 2   @ bitWidth 1 (External Event 1 Polarity)  
        .equ HRTIM_Common_EECR1_EE1SRC_Shift, 0   @ bitWidth 2 (External Event 1 Source)  
 
    .equ HRTIM_Common_EECR2, HRTIM_Common_BASE + 0x34 @ (Timer External Event Control Register  2) 
        .equ HRTIM_Common_EECR2_EE10SNS_Shift, 27   @ bitWidth 2 (External Event 10  Sensitivity)  
        .equ HRTIM_Common_EECR2_EE10POL, 1 << 26   @ bitWidth 1 (External Event 10 Polarity)  
        .equ HRTIM_Common_EECR2_EE10SRC_Shift, 24   @ bitWidth 2 (External Event 10 Source)  
        .equ HRTIM_Common_EECR2_EE9SNS_Shift, 21   @ bitWidth 2 (External Event 9  Sensitivity)  
        .equ HRTIM_Common_EECR2_EE9POL, 1 << 20   @ bitWidth 1 (External Event 9 Polarity)  
        .equ HRTIM_Common_EECR2_EE9SRC_Shift, 18   @ bitWidth 2 (External Event 9 Source)  
        .equ HRTIM_Common_EECR2_EE8SNS_Shift, 15   @ bitWidth 2 (External Event 8  Sensitivity)  
        .equ HRTIM_Common_EECR2_EE8POL, 1 << 14   @ bitWidth 1 (External Event 8 Polarity)  
        .equ HRTIM_Common_EECR2_EE8SRC_Shift, 12   @ bitWidth 2 (External Event 8 Source)  
        .equ HRTIM_Common_EECR2_EE7SNS_Shift, 9   @ bitWidth 2 (External Event 7  Sensitivity)  
        .equ HRTIM_Common_EECR2_EE7POL, 1 << 8   @ bitWidth 1 (External Event 7 Polarity)  
        .equ HRTIM_Common_EECR2_EE7SRC_Shift, 6   @ bitWidth 2 (External Event 7 Source)  
        .equ HRTIM_Common_EECR2_EE6SNS_Shift, 3   @ bitWidth 2 (External Event 6  Sensitivity)  
        .equ HRTIM_Common_EECR2_EE6POL, 1 << 2   @ bitWidth 1 (External Event 6 Polarity)  
        .equ HRTIM_Common_EECR2_EE6SRC_Shift, 0   @ bitWidth 2 (External Event 6 Source)  
 
    .equ HRTIM_Common_EECR3, HRTIM_Common_BASE + 0x38 @ (Timer External Event Control Register  3) 
        .equ HRTIM_Common_EECR3_EE10SNS_Shift, 27   @ bitWidth 2 (EE10SNS)  
        .equ HRTIM_Common_EECR3_EE10POL, 1 << 26   @ bitWidth 1 (EE10POL)  
        .equ HRTIM_Common_EECR3_EE10SRC_Shift, 24   @ bitWidth 2 (EE10SRC)  
        .equ HRTIM_Common_EECR3_EE9SNS_Shift, 21   @ bitWidth 2 (EE9SNS)  
        .equ HRTIM_Common_EECR3_EE9POL, 1 << 20   @ bitWidth 1 (EE9POL)  
        .equ HRTIM_Common_EECR3_EE9SRC_Shift, 18   @ bitWidth 2 (EE9SRC)  
        .equ HRTIM_Common_EECR3_EE8SNS_Shift, 15   @ bitWidth 2 (EE8SNS)  
        .equ HRTIM_Common_EECR3_EE8POL, 1 << 14   @ bitWidth 1 (EE8POL)  
        .equ HRTIM_Common_EECR3_EE8SRC_Shift, 12   @ bitWidth 2 (EE8SRC)  
        .equ HRTIM_Common_EECR3_EE7SNS_Shift, 9   @ bitWidth 2 (EE7SNS)  
        .equ HRTIM_Common_EECR3_EE7POL, 1 << 8   @ bitWidth 1 (EE7POL)  
        .equ HRTIM_Common_EECR3_EE7SRC_Shift, 6   @ bitWidth 2 (EE7SRC)  
        .equ HRTIM_Common_EECR3_EE6SNS_Shift, 3   @ bitWidth 2 (EE6SNS)  
        .equ HRTIM_Common_EECR3_EE6POL, 1 << 2   @ bitWidth 1 (EE6POL)  
        .equ HRTIM_Common_EECR3_EE6SRC_Shift, 0   @ bitWidth 2 (EE6SRC)  
 
    .equ HRTIM_Common_ADC1R, HRTIM_Common_BASE + 0x3C @ (ADC Trigger 1 Register) 
        .equ HRTIM_Common_ADC1R_AD1TEPER, 1 << 31   @ bitWidth 1 (ADC trigger 1 on Timer E  Period)  
        .equ HRTIM_Common_ADC1R_AD1TEC4, 1 << 30   @ bitWidth 1 (ADC trigger 1 on Timer E compare  4)  
        .equ HRTIM_Common_ADC1R_AD1TEC3, 1 << 29   @ bitWidth 1 (ADC trigger 1 on Timer E compare  3)  
        .equ HRTIM_Common_ADC1R_AD1TEC2, 1 << 28   @ bitWidth 1 (ADC trigger 1 on Timer E compare  2)  
        .equ HRTIM_Common_ADC1R_AD1TDPER, 1 << 27   @ bitWidth 1 (ADC trigger 1 on Timer D  Period)  
        .equ HRTIM_Common_ADC1R_AD1TDC4, 1 << 26   @ bitWidth 1 (ADC trigger 1 on Timer D compare  4)  
        .equ HRTIM_Common_ADC1R_AD1TDC3, 1 << 25   @ bitWidth 1 (ADC trigger 1 on Timer D compare  3)  
        .equ HRTIM_Common_ADC1R_AD1TDC2, 1 << 24   @ bitWidth 1 (ADC trigger 1 on Timer D compare  2)  
        .equ HRTIM_Common_ADC1R_AD1TCPER, 1 << 23   @ bitWidth 1 (ADC trigger 1 on Timer C  Period)  
        .equ HRTIM_Common_ADC1R_AD1TCC4, 1 << 22   @ bitWidth 1 (ADC trigger 1 on Timer C compare  4)  
        .equ HRTIM_Common_ADC1R_AD1TCC3, 1 << 21   @ bitWidth 1 (ADC trigger 1 on Timer C compare  3)  
        .equ HRTIM_Common_ADC1R_AD1TCC2, 1 << 20   @ bitWidth 1 (ADC trigger 1 on Timer C compare  2)  
        .equ HRTIM_Common_ADC1R_AD1TBRST, 1 << 19   @ bitWidth 1 (ADC trigger 1 on Timer B  Reset)  
        .equ HRTIM_Common_ADC1R_AD1TBPER, 1 << 18   @ bitWidth 1 (ADC trigger 1 on Timer B  Period)  
        .equ HRTIM_Common_ADC1R_AD1TBC4, 1 << 17   @ bitWidth 1 (ADC trigger 1 on Timer B compare  4)  
        .equ HRTIM_Common_ADC1R_AD1TBC3, 1 << 16   @ bitWidth 1 (ADC trigger 1 on Timer B compare  3)  
        .equ HRTIM_Common_ADC1R_AD1TBC2, 1 << 15   @ bitWidth 1 (ADC trigger 1 on Timer B compare  2)  
        .equ HRTIM_Common_ADC1R_AD1TARST, 1 << 14   @ bitWidth 1 (ADC trigger 1 on Timer A  Reset)  
        .equ HRTIM_Common_ADC1R_AD1TAPER, 1 << 13   @ bitWidth 1 (ADC trigger 1 on Timer A  Period)  
        .equ HRTIM_Common_ADC1R_AD1TAC4, 1 << 12   @ bitWidth 1 (ADC trigger 1 on Timer A compare  4)  
        .equ HRTIM_Common_ADC1R_AD1TAC3, 1 << 11   @ bitWidth 1 (ADC trigger 1 on Timer A compare  3)  
        .equ HRTIM_Common_ADC1R_AD1TAC2, 1 << 10   @ bitWidth 1 (ADC trigger 1 on Timer A compare  2)  
        .equ HRTIM_Common_ADC1R_AD1EEV5, 1 << 9   @ bitWidth 1 (ADC trigger 1 on External Event  5)  
        .equ HRTIM_Common_ADC1R_AD1EEV4, 1 << 8   @ bitWidth 1 (ADC trigger 1 on External Event  4)  
        .equ HRTIM_Common_ADC1R_AD1EEV3, 1 << 7   @ bitWidth 1 (ADC trigger 1 on External Event  3)  
        .equ HRTIM_Common_ADC1R_AD1EEV2, 1 << 6   @ bitWidth 1 (ADC trigger 1 on External Event  2)  
        .equ HRTIM_Common_ADC1R_AD1EEV1, 1 << 5   @ bitWidth 1 (ADC trigger 1 on External Event  1)  
        .equ HRTIM_Common_ADC1R_AD1MPER, 1 << 4   @ bitWidth 1 (ADC trigger 1 on Master  Period)  
        .equ HRTIM_Common_ADC1R_AD1MC4, 1 << 3   @ bitWidth 1 (ADC trigger 1 on Master Compare  4)  
        .equ HRTIM_Common_ADC1R_AD1MC3, 1 << 2   @ bitWidth 1 (ADC trigger 1 on Master Compare  3)  
        .equ HRTIM_Common_ADC1R_AD1MC2, 1 << 1   @ bitWidth 1 (ADC trigger 1 on Master Compare  2)  
        .equ HRTIM_Common_ADC1R_AD1MC1, 1 << 0   @ bitWidth 1 (ADC trigger 1 on Master Compare  1)  
 
    .equ HRTIM_Common_ADC2R, HRTIM_Common_BASE + 0x40 @ (ADC Trigger 2 Register) 
        .equ HRTIM_Common_ADC2R_AD2TERST, 1 << 31   @ bitWidth 1 (ADC trigger 2 on Timer E  Reset)  
        .equ HRTIM_Common_ADC2R_AD2TEC4, 1 << 30   @ bitWidth 1 (ADC trigger 2 on Timer E compare  4)  
        .equ HRTIM_Common_ADC2R_AD2TEC3, 1 << 29   @ bitWidth 1 (ADC trigger 2 on Timer E compare  3)  
        .equ HRTIM_Common_ADC2R_AD2TEC2, 1 << 28   @ bitWidth 1 (ADC trigger 2 on Timer E compare  2)  
        .equ HRTIM_Common_ADC2R_AD2TDRST, 1 << 27   @ bitWidth 1 (ADC trigger 2 on Timer D  Reset)  
        .equ HRTIM_Common_ADC2R_AD2TDPER, 1 << 26   @ bitWidth 1 (ADC trigger 2 on Timer D  Period)  
        .equ HRTIM_Common_ADC2R_AD2TDC4, 1 << 25   @ bitWidth 1 (ADC trigger 2 on Timer D compare  4)  
        .equ HRTIM_Common_ADC2R_AD2TDC3, 1 << 24   @ bitWidth 1 (ADC trigger 2 on Timer D compare  3)  
        .equ HRTIM_Common_ADC2R_AD2TDC2, 1 << 23   @ bitWidth 1 (ADC trigger 2 on Timer D compare  2)  
        .equ HRTIM_Common_ADC2R_AD2TCRST, 1 << 22   @ bitWidth 1 (ADC trigger 2 on Timer C  Reset)  
        .equ HRTIM_Common_ADC2R_AD2TCPER, 1 << 21   @ bitWidth 1 (ADC trigger 2 on Timer C  Period)  
        .equ HRTIM_Common_ADC2R_AD2TCC4, 1 << 20   @ bitWidth 1 (ADC trigger 2 on Timer C compare  4)  
        .equ HRTIM_Common_ADC2R_AD2TCC3, 1 << 19   @ bitWidth 1 (ADC trigger 2 on Timer C compare  3)  
        .equ HRTIM_Common_ADC2R_AD2TCC2, 1 << 18   @ bitWidth 1 (ADC trigger 2 on Timer C compare  2)  
        .equ HRTIM_Common_ADC2R_AD2TBPER, 1 << 17   @ bitWidth 1 (ADC trigger 2 on Timer B  Period)  
        .equ HRTIM_Common_ADC2R_AD2TBC4, 1 << 16   @ bitWidth 1 (ADC trigger 2 on Timer B compare  4)  
        .equ HRTIM_Common_ADC2R_AD2TBC3, 1 << 15   @ bitWidth 1 (ADC trigger 2 on Timer B compare  3)  
        .equ HRTIM_Common_ADC2R_AD2TBC2, 1 << 14   @ bitWidth 1 (ADC trigger 2 on Timer B compare  2)  
        .equ HRTIM_Common_ADC2R_AD2TAPER, 1 << 13   @ bitWidth 1 (ADC trigger 2 on Timer A  Period)  
        .equ HRTIM_Common_ADC2R_AD2TAC4, 1 << 12   @ bitWidth 1 (ADC trigger 2 on Timer A compare  4)  
        .equ HRTIM_Common_ADC2R_AD2TAC3, 1 << 11   @ bitWidth 1 (ADC trigger 2 on Timer A compare  3)  
        .equ HRTIM_Common_ADC2R_AD2TAC2, 1 << 10   @ bitWidth 1 (ADC trigger 2 on Timer A compare  2)  
        .equ HRTIM_Common_ADC2R_AD2EEV10, 1 << 9   @ bitWidth 1 (ADC trigger 2 on External Event  10)  
        .equ HRTIM_Common_ADC2R_AD2EEV9, 1 << 8   @ bitWidth 1 (ADC trigger 2 on External Event  9)  
        .equ HRTIM_Common_ADC2R_AD2EEV8, 1 << 7   @ bitWidth 1 (ADC trigger 2 on External Event  8)  
        .equ HRTIM_Common_ADC2R_AD2EEV7, 1 << 6   @ bitWidth 1 (ADC trigger 2 on External Event  7)  
        .equ HRTIM_Common_ADC2R_AD2EEV6, 1 << 5   @ bitWidth 1 (ADC trigger 2 on External Event  6)  
        .equ HRTIM_Common_ADC2R_AD2MPER, 1 << 4   @ bitWidth 1 (ADC trigger 2 on Master  Period)  
        .equ HRTIM_Common_ADC2R_AD2MC4, 1 << 3   @ bitWidth 1 (ADC trigger 2 on Master Compare  4)  
        .equ HRTIM_Common_ADC2R_AD2MC3, 1 << 2   @ bitWidth 1 (ADC trigger 2 on Master Compare  3)  
        .equ HRTIM_Common_ADC2R_AD2MC2, 1 << 1   @ bitWidth 1 (ADC trigger 2 on Master Compare  2)  
        .equ HRTIM_Common_ADC2R_AD2MC1, 1 << 0   @ bitWidth 1 (ADC trigger 2 on Master Compare  1)  
 
    .equ HRTIM_Common_ADC3R, HRTIM_Common_BASE + 0x44 @ (ADC Trigger 3 Register) 
        .equ HRTIM_Common_ADC3R_AD1TEPER, 1 << 31   @ bitWidth 1 (AD1TEPER)  
        .equ HRTIM_Common_ADC3R_AD1TEC4, 1 << 30   @ bitWidth 1 (AD1TEC4)  
        .equ HRTIM_Common_ADC3R_AD1TEC3, 1 << 29   @ bitWidth 1 (AD1TEC3)  
        .equ HRTIM_Common_ADC3R_AD1TEC2, 1 << 28   @ bitWidth 1 (AD1TEC2)  
        .equ HRTIM_Common_ADC3R_AD1TDPER, 1 << 27   @ bitWidth 1 (AD1TDPER)  
        .equ HRTIM_Common_ADC3R_AD1TDC4, 1 << 26   @ bitWidth 1 (AD1TDC4)  
        .equ HRTIM_Common_ADC3R_AD1TDC3, 1 << 25   @ bitWidth 1 (AD1TDC3)  
        .equ HRTIM_Common_ADC3R_AD1TDC2, 1 << 24   @ bitWidth 1 (AD1TDC2)  
        .equ HRTIM_Common_ADC3R_AD1TCPER, 1 << 23   @ bitWidth 1 (AD1TCPER)  
        .equ HRTIM_Common_ADC3R_AD1TCC4, 1 << 22   @ bitWidth 1 (AD1TCC4)  
        .equ HRTIM_Common_ADC3R_AD1TCC3, 1 << 21   @ bitWidth 1 (AD1TCC3)  
        .equ HRTIM_Common_ADC3R_AD1TCC2, 1 << 20   @ bitWidth 1 (AD1TCC2)  
        .equ HRTIM_Common_ADC3R_AD1TBRST, 1 << 19   @ bitWidth 1 (AD1TBRST)  
        .equ HRTIM_Common_ADC3R_AD1TBPER, 1 << 18   @ bitWidth 1 (AD1TBPER)  
        .equ HRTIM_Common_ADC3R_AD1TBC4, 1 << 17   @ bitWidth 1 (AD1TBC4)  
        .equ HRTIM_Common_ADC3R_AD1TBC3, 1 << 16   @ bitWidth 1 (AD1TBC3)  
        .equ HRTIM_Common_ADC3R_AD1TBC2, 1 << 15   @ bitWidth 1 (AD1TBC2)  
        .equ HRTIM_Common_ADC3R_AD1TARST, 1 << 14   @ bitWidth 1 (AD1TARST)  
        .equ HRTIM_Common_ADC3R_AD1TAPER, 1 << 13   @ bitWidth 1 (AD1TAPER)  
        .equ HRTIM_Common_ADC3R_AD1TAC4, 1 << 12   @ bitWidth 1 (AD1TAC4)  
        .equ HRTIM_Common_ADC3R_AD1TAC3, 1 << 11   @ bitWidth 1 (AD1TAC3)  
        .equ HRTIM_Common_ADC3R_AD1TAC2, 1 << 10   @ bitWidth 1 (AD1TAC2)  
        .equ HRTIM_Common_ADC3R_AD1EEV5, 1 << 9   @ bitWidth 1 (AD1EEV5)  
        .equ HRTIM_Common_ADC3R_AD1EEV4, 1 << 8   @ bitWidth 1 (AD1EEV4)  
        .equ HRTIM_Common_ADC3R_AD1EEV3, 1 << 7   @ bitWidth 1 (AD1EEV3)  
        .equ HRTIM_Common_ADC3R_AD1EEV2, 1 << 6   @ bitWidth 1 (AD1EEV2)  
        .equ HRTIM_Common_ADC3R_AD1EEV1, 1 << 5   @ bitWidth 1 (AD1EEV1)  
        .equ HRTIM_Common_ADC3R_AD1MPER, 1 << 4   @ bitWidth 1 (AD1MPER)  
        .equ HRTIM_Common_ADC3R_AD1MC4, 1 << 3   @ bitWidth 1 (AD1MC4)  
        .equ HRTIM_Common_ADC3R_AD1MC3, 1 << 2   @ bitWidth 1 (AD1MC3)  
        .equ HRTIM_Common_ADC3R_AD1MC2, 1 << 1   @ bitWidth 1 (AD1MC2)  
        .equ HRTIM_Common_ADC3R_AD1MC1, 1 << 0   @ bitWidth 1 (AD1MC1)  
 
    .equ HRTIM_Common_ADC4R, HRTIM_Common_BASE + 0x48 @ (ADC Trigger 4 Register) 
        .equ HRTIM_Common_ADC4R_AD2TERST, 1 << 31   @ bitWidth 1 (AD2TERST)  
        .equ HRTIM_Common_ADC4R_AD2TEC4, 1 << 30   @ bitWidth 1 (AD2TEC4)  
        .equ HRTIM_Common_ADC4R_AD2TEC3, 1 << 29   @ bitWidth 1 (AD2TEC3)  
        .equ HRTIM_Common_ADC4R_AD2TEC2, 1 << 28   @ bitWidth 1 (AD2TEC2)  
        .equ HRTIM_Common_ADC4R_AD2TDRST, 1 << 27   @ bitWidth 1 (AD2TDRST)  
        .equ HRTIM_Common_ADC4R_AD2TDPER, 1 << 26   @ bitWidth 1 (AD2TDPER)  
        .equ HRTIM_Common_ADC4R_AD2TDC4, 1 << 25   @ bitWidth 1 (AD2TDC4)  
        .equ HRTIM_Common_ADC4R_AD2TDC3, 1 << 24   @ bitWidth 1 (AD2TDC3)  
        .equ HRTIM_Common_ADC4R_AD2TDC2, 1 << 23   @ bitWidth 1 (AD2TDC2)  
        .equ HRTIM_Common_ADC4R_AD2TCRST, 1 << 22   @ bitWidth 1 (AD2TCRST)  
        .equ HRTIM_Common_ADC4R_AD2TCPER, 1 << 21   @ bitWidth 1 (AD2TCPER)  
        .equ HRTIM_Common_ADC4R_AD2TCC4, 1 << 20   @ bitWidth 1 (AD2TCC4)  
        .equ HRTIM_Common_ADC4R_AD2TCC3, 1 << 19   @ bitWidth 1 (AD2TCC3)  
        .equ HRTIM_Common_ADC4R_AD2TCC2, 1 << 18   @ bitWidth 1 (AD2TCC2)  
        .equ HRTIM_Common_ADC4R_AD2TBPER, 1 << 17   @ bitWidth 1 (AD2TBPER)  
        .equ HRTIM_Common_ADC4R_AD2TBC4, 1 << 16   @ bitWidth 1 (AD2TBC4)  
        .equ HRTIM_Common_ADC4R_AD2TBC3, 1 << 15   @ bitWidth 1 (AD2TBC3)  
        .equ HRTIM_Common_ADC4R_AD2TBC2, 1 << 14   @ bitWidth 1 (AD2TBC2)  
        .equ HRTIM_Common_ADC4R_AD2TAPER, 1 << 13   @ bitWidth 1 (AD2TAPER)  
        .equ HRTIM_Common_ADC4R_AD2TAC4, 1 << 12   @ bitWidth 1 (AD2TAC4)  
        .equ HRTIM_Common_ADC4R_AD2TAC3, 1 << 11   @ bitWidth 1 (AD2TAC3)  
        .equ HRTIM_Common_ADC4R_AD2TAC2, 1 << 10   @ bitWidth 1 (AD2TAC2)  
        .equ HRTIM_Common_ADC4R_AD2EEV10, 1 << 9   @ bitWidth 1 (AD2EEV10)  
        .equ HRTIM_Common_ADC4R_AD2EEV9, 1 << 8   @ bitWidth 1 (AD2EEV9)  
        .equ HRTIM_Common_ADC4R_AD2EEV8, 1 << 7   @ bitWidth 1 (AD2EEV8)  
        .equ HRTIM_Common_ADC4R_AD2EEV7, 1 << 6   @ bitWidth 1 (AD2EEV7)  
        .equ HRTIM_Common_ADC4R_AD2EEV6, 1 << 5   @ bitWidth 1 (AD2EEV6)  
        .equ HRTIM_Common_ADC4R_AD2MPER, 1 << 4   @ bitWidth 1 (AD2MPER)  
        .equ HRTIM_Common_ADC4R_AD2MC4, 1 << 3   @ bitWidth 1 (AD2MC4)  
        .equ HRTIM_Common_ADC4R_AD2MC3, 1 << 2   @ bitWidth 1 (AD2MC3)  
        .equ HRTIM_Common_ADC4R_AD2MC2, 1 << 1   @ bitWidth 1 (AD2MC2)  
        .equ HRTIM_Common_ADC4R_AD2MC1, 1 << 0   @ bitWidth 1 (AD2MC1)  
 
    .equ HRTIM_Common_DLLCR, HRTIM_Common_BASE + 0x4C @ (DLL Control Register) 
        .equ HRTIM_Common_DLLCR_CALRTE_Shift, 2   @ bitWidth 2 (DLL Calibration rate)  
        .equ HRTIM_Common_DLLCR_CALEN, 1 << 1   @ bitWidth 1 (DLL Calibration Enable)  
        .equ HRTIM_Common_DLLCR_CAL, 1 << 0   @ bitWidth 1 (DLL Calibration Start)  
 
    .equ HRTIM_Common_FLTINR1, HRTIM_Common_BASE + 0x50 @ (HRTIM Fault Input Register 1) 
        .equ HRTIM_Common_FLTINR1_FLT4LCK, 1 << 31   @ bitWidth 1 (FLT4LCK)  
        .equ HRTIM_Common_FLTINR1_FLT4F_Shift, 27   @ bitWidth 4 (FLT4F)  
        .equ HRTIM_Common_FLTINR1_FLT4SRC, 1 << 26   @ bitWidth 1 (FLT4SRC)  
        .equ HRTIM_Common_FLTINR1_FLT4P, 1 << 25   @ bitWidth 1 (FLT4P)  
        .equ HRTIM_Common_FLTINR1_FLT4E, 1 << 24   @ bitWidth 1 (FLT4E)  
        .equ HRTIM_Common_FLTINR1_FLT3LCK, 1 << 23   @ bitWidth 1 (FLT3LCK)  
        .equ HRTIM_Common_FLTINR1_FLT3F_Shift, 19   @ bitWidth 4 (FLT3F)  
        .equ HRTIM_Common_FLTINR1_FLT3SRC, 1 << 18   @ bitWidth 1 (FLT3SRC)  
        .equ HRTIM_Common_FLTINR1_FLT3P, 1 << 17   @ bitWidth 1 (FLT3P)  
        .equ HRTIM_Common_FLTINR1_FLT3E, 1 << 16   @ bitWidth 1 (FLT3E)  
        .equ HRTIM_Common_FLTINR1_FLT2LCK, 1 << 15   @ bitWidth 1 (FLT2LCK)  
        .equ HRTIM_Common_FLTINR1_FLT2F_Shift, 11   @ bitWidth 4 (FLT2F)  
        .equ HRTIM_Common_FLTINR1_FLT2SRC, 1 << 10   @ bitWidth 1 (FLT2SRC)  
        .equ HRTIM_Common_FLTINR1_FLT2P, 1 << 9   @ bitWidth 1 (FLT2P)  
        .equ HRTIM_Common_FLTINR1_FLT2E, 1 << 8   @ bitWidth 1 (FLT2E)  
        .equ HRTIM_Common_FLTINR1_FLT1LCK, 1 << 7   @ bitWidth 1 (FLT1LCK)  
        .equ HRTIM_Common_FLTINR1_FLT1F_Shift, 3   @ bitWidth 4 (FLT1F)  
        .equ HRTIM_Common_FLTINR1_FLT1SRC, 1 << 2   @ bitWidth 1 (FLT1SRC)  
        .equ HRTIM_Common_FLTINR1_FLT1P, 1 << 1   @ bitWidth 1 (FLT1P)  
        .equ HRTIM_Common_FLTINR1_FLT1E, 1 << 0   @ bitWidth 1 (FLT1E)  
 
    .equ HRTIM_Common_FLTINR2, HRTIM_Common_BASE + 0x54 @ (HRTIM Fault Input Register 2) 
        .equ HRTIM_Common_FLTINR2_FLTSD_Shift, 24   @ bitWidth 2 (FLTSD)  
        .equ HRTIM_Common_FLTINR2_FLT5LCK, 1 << 7   @ bitWidth 1 (FLT5LCK)  
        .equ HRTIM_Common_FLTINR2_FLT5F_Shift, 3   @ bitWidth 4 (FLT5F)  
        .equ HRTIM_Common_FLTINR2_FLT5SRC, 1 << 2   @ bitWidth 1 (FLT5SRC)  
        .equ HRTIM_Common_FLTINR2_FLT5P, 1 << 1   @ bitWidth 1 (FLT5P)  
        .equ HRTIM_Common_FLTINR2_FLT5E, 1 << 0   @ bitWidth 1 (FLT5E)  
 
    .equ HRTIM_Common_BDMUPDR, HRTIM_Common_BASE + 0x58 @ (BDMUPDR) 
        .equ HRTIM_Common_BDMUPDR_MCMP4, 1 << 9   @ bitWidth 1 (MCMP4)  
        .equ HRTIM_Common_BDMUPDR_MCMP3, 1 << 8   @ bitWidth 1 (MCMP3)  
        .equ HRTIM_Common_BDMUPDR_MCMP2, 1 << 7   @ bitWidth 1 (MCMP2)  
        .equ HRTIM_Common_BDMUPDR_MCMP1, 1 << 6   @ bitWidth 1 (MCMP1)  
        .equ HRTIM_Common_BDMUPDR_MREP, 1 << 5   @ bitWidth 1 (MREP)  
        .equ HRTIM_Common_BDMUPDR_MPER, 1 << 4   @ bitWidth 1 (MPER)  
        .equ HRTIM_Common_BDMUPDR_MCNT, 1 << 3   @ bitWidth 1 (MCNT)  
        .equ HRTIM_Common_BDMUPDR_MDIER, 1 << 2   @ bitWidth 1 (MDIER)  
        .equ HRTIM_Common_BDMUPDR_MICR, 1 << 1   @ bitWidth 1 (MICR)  
        .equ HRTIM_Common_BDMUPDR_MCR, 1 << 0   @ bitWidth 1 (MCR)  
 
    .equ HRTIM_Common_BDTxUPR, HRTIM_Common_BASE + 0x5C @ (Burst DMA Timerx update  Register) 
        .equ HRTIM_Common_BDTxUPR_TIMxFLTR, 1 << 20   @ bitWidth 1 (HRTIM_FLTxR register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxOUTR, 1 << 19   @ bitWidth 1 (HRTIM_OUTxR register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxCHPR, 1 << 18   @ bitWidth 1 (HRTIM_CHPxR register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxRSTR, 1 << 17   @ bitWidth 1 (HRTIM_RSTxR register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxEEFR2, 1 << 16   @ bitWidth 1 (HRTIM_EEFxR2 register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxEEFR1, 1 << 15   @ bitWidth 1 (HRTIM_EEFxR1 register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxRST2R, 1 << 14   @ bitWidth 1 (HRTIM_RST2xR register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxSET2R, 1 << 13   @ bitWidth 1 (HRTIM_SET2xR register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxRST1R, 1 << 12   @ bitWidth 1 (HRTIM_RST1xR register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxSET1R, 1 << 11   @ bitWidth 1 (HRTIM_SET1xR register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMx_DTxR, 1 << 10   @ bitWidth 1 (HRTIM_DTxR register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxCMP4, 1 << 9   @ bitWidth 1 (HRTIM_CMP4xR register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxCMP3, 1 << 8   @ bitWidth 1 (HRTIM_CMP3xR register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxCMP2, 1 << 7   @ bitWidth 1 (HRTIM_CMP2xR register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxCMP1, 1 << 6   @ bitWidth 1 (HRTIM_CMP1xR register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxREP, 1 << 5   @ bitWidth 1 (HRTIM_REPxR register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxPER, 1 << 4   @ bitWidth 1 (HRTIM_PERxR register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxCNT, 1 << 3   @ bitWidth 1 (HRTIM_CNTxR register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxDIER, 1 << 2   @ bitWidth 1 (HRTIM_TIMxDIER register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxICR, 1 << 1   @ bitWidth 1 (HRTIM_TIMxICR register update  enable)  
        .equ HRTIM_Common_BDTxUPR_TIMxCR, 1 << 0   @ bitWidth 1 (HRTIM_TIMxCR register update  enable)  
 
    .equ HRTIM_Common_BDMADR, HRTIM_Common_BASE + 0x60 @ (Burst DMA Data Register) 
        .equ HRTIM_Common_BDMADR_BDMADR_Shift, 0   @ bitWidth 32 (Burst DMA Data register)  
 

@=========================== DFSDM ===========================@
.equ DFSDM_BASE, 0x40017000 @ (Digital filter for sigma delta  modulators) 
    .equ DFSDM_DFSDM_CHCFG0R1, DFSDM_BASE + 0x0 @ (DFSDM channel configuration 0 register  1) 
        .equ DFSDM_DFSDM_CHCFG0R1_SITP_Shift, 0   @ bitWidth 2 (Serial interface type for channel  0)  
        .equ DFSDM_DFSDM_CHCFG0R1_SPICKSEL_Shift, 2   @ bitWidth 2 (SPI clock select for channel  0)  
        .equ DFSDM_DFSDM_CHCFG0R1_SCDEN, 1 << 5   @ bitWidth 1 (Short-circuit detector enable on channel  0)  
        .equ DFSDM_DFSDM_CHCFG0R1_CKABEN, 1 << 6   @ bitWidth 1 (Clock absence detector enable on channel  0)  
        .equ DFSDM_DFSDM_CHCFG0R1_CHEN, 1 << 7   @ bitWidth 1 (Channel 0 enable)  
        .equ DFSDM_DFSDM_CHCFG0R1_CHINSEL, 1 << 8   @ bitWidth 1 (Channel inputs selection)  
        .equ DFSDM_DFSDM_CHCFG0R1_DATMPX_Shift, 12   @ bitWidth 2 (Input data multiplexer for channel  0)  
        .equ DFSDM_DFSDM_CHCFG0R1_DATPACK_Shift, 14   @ bitWidth 2 (Data packing mode in DFSDM_CHDATINyR  register)  
        .equ DFSDM_DFSDM_CHCFG0R1_CKOUTDIV_Shift, 16   @ bitWidth 8 (Output serial clock  divider)  
        .equ DFSDM_DFSDM_CHCFG0R1_CKOUTSRC, 1 << 30   @ bitWidth 1 (Output serial clock source  selection)  
        .equ DFSDM_DFSDM_CHCFG0R1_DFSDMEN, 1 << 31   @ bitWidth 1 (Global enable for DFSDM  interface)  
 
    .equ DFSDM_DFSDM_CHCFG1R1, DFSDM_BASE + 0x4 @ (DFSDM channel configuration 1 register  1) 
        .equ DFSDM_DFSDM_CHCFG1R1_SITP_Shift, 0   @ bitWidth 2 (Serial interface type for channel  1)  
        .equ DFSDM_DFSDM_CHCFG1R1_SPICKSEL_Shift, 2   @ bitWidth 2 (SPI clock select for channel  1)  
        .equ DFSDM_DFSDM_CHCFG1R1_SCDEN, 1 << 5   @ bitWidth 1 (Short-circuit detector enable on channel  1)  
        .equ DFSDM_DFSDM_CHCFG1R1_CKABEN, 1 << 6   @ bitWidth 1 (Clock absence detector enable on channel  1)  
        .equ DFSDM_DFSDM_CHCFG1R1_CHEN, 1 << 7   @ bitWidth 1 (Channel 1 enable)  
        .equ DFSDM_DFSDM_CHCFG1R1_CHINSEL, 1 << 8   @ bitWidth 1 (Channel inputs selection)  
        .equ DFSDM_DFSDM_CHCFG1R1_DATMPX_Shift, 12   @ bitWidth 2 (Input data multiplexer for channel  1)  
        .equ DFSDM_DFSDM_CHCFG1R1_DATPACK_Shift, 14   @ bitWidth 2 (Data packing mode in DFSDM_CHDATINyR  register)  
        .equ DFSDM_DFSDM_CHCFG1R1_CKOUTDIV_Shift, 16   @ bitWidth 8 (Output serial clock  divider)  
        .equ DFSDM_DFSDM_CHCFG1R1_CKOUTSRC, 1 << 30   @ bitWidth 1 (Output serial clock source  selection)  
        .equ DFSDM_DFSDM_CHCFG1R1_DFSDMEN, 1 << 31   @ bitWidth 1 (Global enable for DFSDM  interface)  
 
    .equ DFSDM_DFSDM_CHCFG2R1, DFSDM_BASE + 0x8 @ (DFSDM channel configuration 2 register  1) 
        .equ DFSDM_DFSDM_CHCFG2R1_SITP_Shift, 0   @ bitWidth 2 (Serial interface type for channel  2)  
        .equ DFSDM_DFSDM_CHCFG2R1_SPICKSEL_Shift, 2   @ bitWidth 2 (SPI clock select for channel  2)  
        .equ DFSDM_DFSDM_CHCFG2R1_SCDEN, 1 << 5   @ bitWidth 1 (Short-circuit detector enable on channel  2)  
        .equ DFSDM_DFSDM_CHCFG2R1_CKABEN, 1 << 6   @ bitWidth 1 (Clock absence detector enable on channel  2)  
        .equ DFSDM_DFSDM_CHCFG2R1_CHEN, 1 << 7   @ bitWidth 1 (Channel 2 enable)  
        .equ DFSDM_DFSDM_CHCFG2R1_CHINSEL, 1 << 8   @ bitWidth 1 (Channel inputs selection)  
        .equ DFSDM_DFSDM_CHCFG2R1_DATMPX_Shift, 12   @ bitWidth 2 (Input data multiplexer for channel  2)  
        .equ DFSDM_DFSDM_CHCFG2R1_DATPACK_Shift, 14   @ bitWidth 2 (Data packing mode in DFSDM_CHDATINyR  register)  
        .equ DFSDM_DFSDM_CHCFG2R1_CKOUTDIV_Shift, 16   @ bitWidth 8 (Output serial clock  divider)  
        .equ DFSDM_DFSDM_CHCFG2R1_CKOUTSRC, 1 << 30   @ bitWidth 1 (Output serial clock source  selection)  
        .equ DFSDM_DFSDM_CHCFG2R1_DFSDMEN, 1 << 31   @ bitWidth 1 (Global enable for DFSDM  interface)  
 
    .equ DFSDM_DFSDM_CHCFG3R1, DFSDM_BASE + 0xC @ (DFSDM channel configuration 3 register  1) 
        .equ DFSDM_DFSDM_CHCFG3R1_SITP_Shift, 0   @ bitWidth 2 (Serial interface type for channel  3)  
        .equ DFSDM_DFSDM_CHCFG3R1_SPICKSEL_Shift, 2   @ bitWidth 2 (SPI clock select for channel  3)  
        .equ DFSDM_DFSDM_CHCFG3R1_SCDEN, 1 << 5   @ bitWidth 1 (Short-circuit detector enable on channel  3)  
        .equ DFSDM_DFSDM_CHCFG3R1_CKABEN, 1 << 6   @ bitWidth 1 (Clock absence detector enable on channel  3)  
        .equ DFSDM_DFSDM_CHCFG3R1_CHEN, 1 << 7   @ bitWidth 1 (Channel 3 enable)  
        .equ DFSDM_DFSDM_CHCFG3R1_CHINSEL, 1 << 8   @ bitWidth 1 (Channel inputs selection)  
        .equ DFSDM_DFSDM_CHCFG3R1_DATMPX_Shift, 12   @ bitWidth 2 (Input data multiplexer for channel  3)  
        .equ DFSDM_DFSDM_CHCFG3R1_DATPACK_Shift, 14   @ bitWidth 2 (Data packing mode in DFSDM_CHDATINyR  register)  
        .equ DFSDM_DFSDM_CHCFG3R1_CKOUTDIV_Shift, 16   @ bitWidth 8 (Output serial clock  divider)  
        .equ DFSDM_DFSDM_CHCFG3R1_CKOUTSRC, 1 << 30   @ bitWidth 1 (Output serial clock source  selection)  
        .equ DFSDM_DFSDM_CHCFG3R1_DFSDMEN, 1 << 31   @ bitWidth 1 (Global enable for DFSDM  interface)  
 
    .equ DFSDM_DFSDM_CHCFG4R1, DFSDM_BASE + 0x10 @ (DFSDM channel configuration 4 register  1) 
        .equ DFSDM_DFSDM_CHCFG4R1_SITP_Shift, 0   @ bitWidth 2 (Serial interface type for channel  4)  
        .equ DFSDM_DFSDM_CHCFG4R1_SPICKSEL_Shift, 2   @ bitWidth 2 (SPI clock select for channel  4)  
        .equ DFSDM_DFSDM_CHCFG4R1_SCDEN, 1 << 5   @ bitWidth 1 (Short-circuit detector enable on channel  4)  
        .equ DFSDM_DFSDM_CHCFG4R1_CKABEN, 1 << 6   @ bitWidth 1 (Clock absence detector enable on channel  4)  
        .equ DFSDM_DFSDM_CHCFG4R1_CHEN, 1 << 7   @ bitWidth 1 (Channel 4 enable)  
        .equ DFSDM_DFSDM_CHCFG4R1_CHINSEL, 1 << 8   @ bitWidth 1 (Channel inputs selection)  
        .equ DFSDM_DFSDM_CHCFG4R1_DATMPX_Shift, 12   @ bitWidth 2 (Input data multiplexer for channel  4)  
        .equ DFSDM_DFSDM_CHCFG4R1_DATPACK_Shift, 14   @ bitWidth 2 (Data packing mode in DFSDM_CHDATINyR  register)  
        .equ DFSDM_DFSDM_CHCFG4R1_CKOUTDIV_Shift, 16   @ bitWidth 8 (Output serial clock  divider)  
        .equ DFSDM_DFSDM_CHCFG4R1_CKOUTSRC, 1 << 30   @ bitWidth 1 (Output serial clock source  selection)  
        .equ DFSDM_DFSDM_CHCFG4R1_DFSDMEN, 1 << 31   @ bitWidth 1 (Global enable for DFSDM  interface)  
 
    .equ DFSDM_DFSDM_CHCFG5R1, DFSDM_BASE + 0x14 @ (DFSDM channel configuration 5 register  1) 
        .equ DFSDM_DFSDM_CHCFG5R1_SITP_Shift, 0   @ bitWidth 2 (Serial interface type for channel  5)  
        .equ DFSDM_DFSDM_CHCFG5R1_SPICKSEL_Shift, 2   @ bitWidth 2 (SPI clock select for channel  5)  
        .equ DFSDM_DFSDM_CHCFG5R1_SCDEN, 1 << 5   @ bitWidth 1 (Short-circuit detector enable on channel  5)  
        .equ DFSDM_DFSDM_CHCFG5R1_CKABEN, 1 << 6   @ bitWidth 1 (Clock absence detector enable on channel  5)  
        .equ DFSDM_DFSDM_CHCFG5R1_CHEN, 1 << 7   @ bitWidth 1 (Channel 5 enable)  
        .equ DFSDM_DFSDM_CHCFG5R1_CHINSEL, 1 << 8   @ bitWidth 1 (Channel inputs selection)  
        .equ DFSDM_DFSDM_CHCFG5R1_DATMPX_Shift, 12   @ bitWidth 2 (Input data multiplexer for channel  5)  
        .equ DFSDM_DFSDM_CHCFG5R1_DATPACK_Shift, 14   @ bitWidth 2 (Data packing mode in DFSDM_CHDATINyR  register)  
        .equ DFSDM_DFSDM_CHCFG5R1_CKOUTDIV_Shift, 16   @ bitWidth 8 (Output serial clock  divider)  
        .equ DFSDM_DFSDM_CHCFG5R1_CKOUTSRC, 1 << 30   @ bitWidth 1 (Output serial clock source  selection)  
        .equ DFSDM_DFSDM_CHCFG5R1_DFSDMEN, 1 << 31   @ bitWidth 1 (Global enable for DFSDM  interface)  
 
    .equ DFSDM_DFSDM_CHCFG6R1, DFSDM_BASE + 0x18 @ (DFSDM channel configuration 6 register  1) 
        .equ DFSDM_DFSDM_CHCFG6R1_SITP_Shift, 0   @ bitWidth 2 (Serial interface type for channel  6)  
        .equ DFSDM_DFSDM_CHCFG6R1_SPICKSEL_Shift, 2   @ bitWidth 2 (SPI clock select for channel  6)  
        .equ DFSDM_DFSDM_CHCFG6R1_SCDEN, 1 << 5   @ bitWidth 1 (Short-circuit detector enable on channel  6)  
        .equ DFSDM_DFSDM_CHCFG6R1_CKABEN, 1 << 6   @ bitWidth 1 (Clock absence detector enable on channel  6)  
        .equ DFSDM_DFSDM_CHCFG6R1_CHEN, 1 << 7   @ bitWidth 1 (Channel 6 enable)  
        .equ DFSDM_DFSDM_CHCFG6R1_CHINSEL, 1 << 8   @ bitWidth 1 (Channel inputs selection)  
        .equ DFSDM_DFSDM_CHCFG6R1_DATMPX_Shift, 12   @ bitWidth 2 (Input data multiplexer for channel  6)  
        .equ DFSDM_DFSDM_CHCFG6R1_DATPACK_Shift, 14   @ bitWidth 2 (Data packing mode in DFSDM_CHDATINyR  register)  
        .equ DFSDM_DFSDM_CHCFG6R1_CKOUTDIV_Shift, 16   @ bitWidth 8 (Output serial clock  divider)  
        .equ DFSDM_DFSDM_CHCFG6R1_CKOUTSRC, 1 << 30   @ bitWidth 1 (Output serial clock source  selection)  
        .equ DFSDM_DFSDM_CHCFG6R1_DFSDMEN, 1 << 31   @ bitWidth 1 (Global enable for DFSDM  interface)  
 
    .equ DFSDM_DFSDM_CHCFG7R1, DFSDM_BASE + 0x1C @ (DFSDM channel configuration 7 register  1) 
        .equ DFSDM_DFSDM_CHCFG7R1_SITP_Shift, 0   @ bitWidth 2 (Serial interface type for channel  7)  
        .equ DFSDM_DFSDM_CHCFG7R1_SPICKSEL_Shift, 2   @ bitWidth 2 (SPI clock select for channel  7)  
        .equ DFSDM_DFSDM_CHCFG7R1_SCDEN, 1 << 5   @ bitWidth 1 (Short-circuit detector enable on channel  7)  
        .equ DFSDM_DFSDM_CHCFG7R1_CKABEN, 1 << 6   @ bitWidth 1 (Clock absence detector enable on channel  7)  
        .equ DFSDM_DFSDM_CHCFG7R1_CHEN, 1 << 7   @ bitWidth 1 (Channel 7 enable)  
        .equ DFSDM_DFSDM_CHCFG7R1_CHINSEL, 1 << 8   @ bitWidth 1 (Channel inputs selection)  
        .equ DFSDM_DFSDM_CHCFG7R1_DATMPX_Shift, 12   @ bitWidth 2 (Input data multiplexer for channel  7)  
        .equ DFSDM_DFSDM_CHCFG7R1_DATPACK_Shift, 14   @ bitWidth 2 (Data packing mode in DFSDM_CHDATINyR  register)  
        .equ DFSDM_DFSDM_CHCFG7R1_CKOUTDIV_Shift, 16   @ bitWidth 8 (Output serial clock  divider)  
        .equ DFSDM_DFSDM_CHCFG7R1_CKOUTSRC, 1 << 30   @ bitWidth 1 (Output serial clock source  selection)  
        .equ DFSDM_DFSDM_CHCFG7R1_DFSDMEN, 1 << 31   @ bitWidth 1 (Global enable for DFSDM  interface)  
 
    .equ DFSDM_DFSDM_CHCFG0R2, DFSDM_BASE + 0x20 @ (DFSDM channel configuration 0 register  2) 
        .equ DFSDM_DFSDM_CHCFG0R2_DTRBS_Shift, 3   @ bitWidth 5 (Data right bit-shift for channel  0)  
        .equ DFSDM_DFSDM_CHCFG0R2_OFFSET_Shift, 8   @ bitWidth 24 (24-bit calibration offset for channel  0)  
 
    .equ DFSDM_DFSDM_CHCFG1R2, DFSDM_BASE + 0x24 @ (DFSDM channel configuration 1 register  2) 
        .equ DFSDM_DFSDM_CHCFG1R2_DTRBS_Shift, 3   @ bitWidth 5 (Data right bit-shift for channel  1)  
        .equ DFSDM_DFSDM_CHCFG1R2_OFFSET_Shift, 8   @ bitWidth 24 (24-bit calibration offset for channel  1)  
 
    .equ DFSDM_DFSDM_CHCFG2R2, DFSDM_BASE + 0x28 @ (DFSDM channel configuration 2 register  2) 
        .equ DFSDM_DFSDM_CHCFG2R2_DTRBS_Shift, 3   @ bitWidth 5 (Data right bit-shift for channel  2)  
        .equ DFSDM_DFSDM_CHCFG2R2_OFFSET_Shift, 8   @ bitWidth 24 (24-bit calibration offset for channel  2)  
 
    .equ DFSDM_DFSDM_CHCFG3R2, DFSDM_BASE + 0x2C @ (DFSDM channel configuration 3 register  2) 
        .equ DFSDM_DFSDM_CHCFG3R2_DTRBS_Shift, 3   @ bitWidth 5 (Data right bit-shift for channel  3)  
        .equ DFSDM_DFSDM_CHCFG3R2_OFFSET_Shift, 8   @ bitWidth 24 (24-bit calibration offset for channel  3)  
 
    .equ DFSDM_DFSDM_CHCFG4R2, DFSDM_BASE + 0x30 @ (DFSDM channel configuration 4 register  2) 
        .equ DFSDM_DFSDM_CHCFG4R2_DTRBS_Shift, 3   @ bitWidth 5 (Data right bit-shift for channel  4)  
        .equ DFSDM_DFSDM_CHCFG4R2_OFFSET_Shift, 8   @ bitWidth 24 (24-bit calibration offset for channel  4)  
 
    .equ DFSDM_DFSDM_CHCFG5R2, DFSDM_BASE + 0x34 @ (DFSDM channel configuration 5 register  2) 
        .equ DFSDM_DFSDM_CHCFG5R2_DTRBS_Shift, 3   @ bitWidth 5 (Data right bit-shift for channel  5)  
        .equ DFSDM_DFSDM_CHCFG5R2_OFFSET_Shift, 8   @ bitWidth 24 (24-bit calibration offset for channel  5)  
 
    .equ DFSDM_DFSDM_CHCFG6R2, DFSDM_BASE + 0x38 @ (DFSDM channel configuration 6 register  2) 
        .equ DFSDM_DFSDM_CHCFG6R2_DTRBS_Shift, 3   @ bitWidth 5 (Data right bit-shift for channel  6)  
        .equ DFSDM_DFSDM_CHCFG6R2_OFFSET_Shift, 8   @ bitWidth 24 (24-bit calibration offset for channel  6)  
 
    .equ DFSDM_DFSDM_CHCFG7R2, DFSDM_BASE + 0x3C @ (DFSDM channel configuration 7 register  2) 
        .equ DFSDM_DFSDM_CHCFG7R2_DTRBS_Shift, 3   @ bitWidth 5 (Data right bit-shift for channel  7)  
        .equ DFSDM_DFSDM_CHCFG7R2_OFFSET_Shift, 8   @ bitWidth 24 (24-bit calibration offset for channel  7)  
 
    .equ DFSDM_DFSDM_AWSCD0R, DFSDM_BASE + 0x40 @ (DFSDM analog watchdog and short-circuit  detector register) 
        .equ DFSDM_DFSDM_AWSCD0R_SCDT_Shift, 0   @ bitWidth 8 (short-circuit detector threshold for  channel 0)  
        .equ DFSDM_DFSDM_AWSCD0R_BKSCD_Shift, 12   @ bitWidth 4 (Break signal assignment for  short-circuit detector on channel 0)  
        .equ DFSDM_DFSDM_AWSCD0R_AWFOSR_Shift, 16   @ bitWidth 5 (Analog watchdog filter oversampling  ratio decimation rate on channel 0)  
        .equ DFSDM_DFSDM_AWSCD0R_AWFORD_Shift, 22   @ bitWidth 2 (Analog watchdog Sinc filter order on  channel 0)  
 
    .equ DFSDM_DFSDM_AWSCD1R, DFSDM_BASE + 0x44 @ (DFSDM analog watchdog and short-circuit  detector register) 
        .equ DFSDM_DFSDM_AWSCD1R_SCDT_Shift, 0   @ bitWidth 8 (short-circuit detector threshold for  channel 1)  
        .equ DFSDM_DFSDM_AWSCD1R_BKSCD_Shift, 12   @ bitWidth 4 (Break signal assignment for  short-circuit detector on channel 1)  
        .equ DFSDM_DFSDM_AWSCD1R_AWFOSR_Shift, 16   @ bitWidth 5 (Analog watchdog filter oversampling  ratio decimation rate on channel 1)  
        .equ DFSDM_DFSDM_AWSCD1R_AWFORD_Shift, 22   @ bitWidth 2 (Analog watchdog Sinc filter order on  channel 1)  
 
    .equ DFSDM_DFSDM_AWSCD2R, DFSDM_BASE + 0x48 @ (DFSDM analog watchdog and short-circuit  detector register) 
        .equ DFSDM_DFSDM_AWSCD2R_SCDT_Shift, 0   @ bitWidth 8 (short-circuit detector threshold for  channel 2)  
        .equ DFSDM_DFSDM_AWSCD2R_BKSCD_Shift, 12   @ bitWidth 4 (Break signal assignment for  short-circuit detector on channel 2)  
        .equ DFSDM_DFSDM_AWSCD2R_AWFOSR_Shift, 16   @ bitWidth 5 (Analog watchdog filter oversampling  ratio decimation rate on channel 2)  
        .equ DFSDM_DFSDM_AWSCD2R_AWFORD_Shift, 22   @ bitWidth 2 (Analog watchdog Sinc filter order on  channel 2)  
 
    .equ DFSDM_DFSDM_AWSCD3R, DFSDM_BASE + 0x4C @ (DFSDM analog watchdog and short-circuit  detector register) 
        .equ DFSDM_DFSDM_AWSCD3R_SCDT_Shift, 0   @ bitWidth 8 (short-circuit detector threshold for  channel 3)  
        .equ DFSDM_DFSDM_AWSCD3R_BKSCD_Shift, 12   @ bitWidth 4 (Break signal assignment for  short-circuit detector on channel 3)  
        .equ DFSDM_DFSDM_AWSCD3R_AWFOSR_Shift, 16   @ bitWidth 5 (Analog watchdog filter oversampling  ratio decimation rate on channel 3)  
        .equ DFSDM_DFSDM_AWSCD3R_AWFORD_Shift, 22   @ bitWidth 2 (Analog watchdog Sinc filter order on  channel 3)  
 
    .equ DFSDM_DFSDM_AWSCD4R, DFSDM_BASE + 0x50 @ (DFSDM analog watchdog and short-circuit  detector register) 
        .equ DFSDM_DFSDM_AWSCD4R_SCDT_Shift, 0   @ bitWidth 8 (short-circuit detector threshold for  channel 4)  
        .equ DFSDM_DFSDM_AWSCD4R_BKSCD_Shift, 12   @ bitWidth 4 (Break signal assignment for  short-circuit detector on channel 4)  
        .equ DFSDM_DFSDM_AWSCD4R_AWFOSR_Shift, 16   @ bitWidth 5 (Analog watchdog filter oversampling  ratio decimation rate on channel 4)  
        .equ DFSDM_DFSDM_AWSCD4R_AWFORD_Shift, 22   @ bitWidth 2 (Analog watchdog Sinc filter order on  channel 4)  
 
    .equ DFSDM_DFSDM_AWSCD5R, DFSDM_BASE + 0x54 @ (DFSDM analog watchdog and short-circuit  detector register) 
        .equ DFSDM_DFSDM_AWSCD5R_SCDT_Shift, 0   @ bitWidth 8 (short-circuit detector threshold for  channel 5)  
        .equ DFSDM_DFSDM_AWSCD5R_BKSCD_Shift, 12   @ bitWidth 4 (Break signal assignment for  short-circuit detector on channel 5)  
        .equ DFSDM_DFSDM_AWSCD5R_AWFOSR_Shift, 16   @ bitWidth 5 (Analog watchdog filter oversampling  ratio decimation rate on channel 5)  
        .equ DFSDM_DFSDM_AWSCD5R_AWFORD_Shift, 22   @ bitWidth 2 (Analog watchdog Sinc filter order on  channel 5)  
 
    .equ DFSDM_DFSDM_AWSCD6R, DFSDM_BASE + 0x58 @ (DFSDM analog watchdog and short-circuit  detector register) 
        .equ DFSDM_DFSDM_AWSCD6R_SCDT_Shift, 0   @ bitWidth 8 (short-circuit detector threshold for  channel 6)  
        .equ DFSDM_DFSDM_AWSCD6R_BKSCD_Shift, 12   @ bitWidth 4 (Break signal assignment for  short-circuit detector on channel 6)  
        .equ DFSDM_DFSDM_AWSCD6R_AWFOSR_Shift, 16   @ bitWidth 5 (Analog watchdog filter oversampling  ratio decimation rate on channel 6)  
        .equ DFSDM_DFSDM_AWSCD6R_AWFORD_Shift, 22   @ bitWidth 2 (Analog watchdog Sinc filter order on  channel 6)  
 
    .equ DFSDM_DFSDM_AWSCD7R, DFSDM_BASE + 0x5C @ (DFSDM analog watchdog and short-circuit  detector register) 
        .equ DFSDM_DFSDM_AWSCD7R_SCDT_Shift, 0   @ bitWidth 8 (short-circuit detector threshold for  channel 7)  
        .equ DFSDM_DFSDM_AWSCD7R_BKSCD_Shift, 12   @ bitWidth 4 (Break signal assignment for  short-circuit detector on channel 7)  
        .equ DFSDM_DFSDM_AWSCD7R_AWFOSR_Shift, 16   @ bitWidth 5 (Analog watchdog filter oversampling  ratio decimation rate on channel 7)  
        .equ DFSDM_DFSDM_AWSCD7R_AWFORD_Shift, 22   @ bitWidth 2 (Analog watchdog Sinc filter order on  channel 7)  
 
    .equ DFSDM_DFSDM_CHWDAT0R, DFSDM_BASE + 0x60 @ (DFSDM channel watchdog filter data  register) 
        .equ DFSDM_DFSDM_CHWDAT0R_WDATA_Shift, 0   @ bitWidth 16 (Input channel y watchdog  data)  
 
    .equ DFSDM_DFSDM_CHWDAT1R, DFSDM_BASE + 0x64 @ (DFSDM channel watchdog filter data  register) 
        .equ DFSDM_DFSDM_CHWDAT1R_WDATA_Shift, 0   @ bitWidth 16 (Input channel y watchdog  data)  
 
    .equ DFSDM_DFSDM_CHWDAT2R, DFSDM_BASE + 0x68 @ (DFSDM channel watchdog filter data  register) 
        .equ DFSDM_DFSDM_CHWDAT2R_WDATA_Shift, 0   @ bitWidth 16 (Input channel y watchdog  data)  
 
    .equ DFSDM_DFSDM_CHWDAT3R, DFSDM_BASE + 0x6C @ (DFSDM channel watchdog filter data  register) 
        .equ DFSDM_DFSDM_CHWDAT3R_WDATA_Shift, 0   @ bitWidth 16 (Input channel y watchdog  data)  
 
    .equ DFSDM_DFSDM_CHWDAT4R, DFSDM_BASE + 0x70 @ (DFSDM channel watchdog filter data  register) 
        .equ DFSDM_DFSDM_CHWDAT4R_WDATA_Shift, 0   @ bitWidth 16 (Input channel y watchdog  data)  
 
    .equ DFSDM_DFSDM_CHWDAT5R, DFSDM_BASE + 0x74 @ (DFSDM channel watchdog filter data  register) 
        .equ DFSDM_DFSDM_CHWDAT5R_WDATA_Shift, 0   @ bitWidth 16 (Input channel y watchdog  data)  
 
    .equ DFSDM_DFSDM_CHWDAT6R, DFSDM_BASE + 0x78 @ (DFSDM channel watchdog filter data  register) 
        .equ DFSDM_DFSDM_CHWDAT6R_WDATA_Shift, 0   @ bitWidth 16 (Input channel y watchdog  data)  
 
    .equ DFSDM_DFSDM_CHWDAT7R, DFSDM_BASE + 0x7C @ (DFSDM channel watchdog filter data  register) 
        .equ DFSDM_DFSDM_CHWDAT7R_WDATA_Shift, 0   @ bitWidth 16 (Input channel y watchdog  data)  
 
    .equ DFSDM_DFSDM_CHDATIN0R, DFSDM_BASE + 0x80 @ (DFSDM channel data input  register) 
        .equ DFSDM_DFSDM_CHDATIN0R_INDAT0_Shift, 0   @ bitWidth 16 (Input data for channel 0)  
        .equ DFSDM_DFSDM_CHDATIN0R_INDAT1_Shift, 16   @ bitWidth 16 (Input data for channel 1)  
 
    .equ DFSDM_DFSDM_CHDATIN1R, DFSDM_BASE + 0x84 @ (DFSDM channel data input  register) 
        .equ DFSDM_DFSDM_CHDATIN1R_INDAT0_Shift, 0   @ bitWidth 16 (Input data for channel 1)  
        .equ DFSDM_DFSDM_CHDATIN1R_INDAT1_Shift, 16   @ bitWidth 16 (Input data for channel 2)  
 
    .equ DFSDM_DFSDM_CHDATIN2R, DFSDM_BASE + 0x88 @ (DFSDM channel data input  register) 
        .equ DFSDM_DFSDM_CHDATIN2R_INDAT0_Shift, 0   @ bitWidth 16 (Input data for channel 2)  
        .equ DFSDM_DFSDM_CHDATIN2R_INDAT1_Shift, 16   @ bitWidth 16 (Input data for channel 3)  
 
    .equ DFSDM_DFSDM_CHDATIN3R, DFSDM_BASE + 0x8C @ (DFSDM channel data input  register) 
        .equ DFSDM_DFSDM_CHDATIN3R_INDAT0_Shift, 0   @ bitWidth 16 (Input data for channel 3)  
        .equ DFSDM_DFSDM_CHDATIN3R_INDAT1_Shift, 16   @ bitWidth 16 (Input data for channel 4)  
 
    .equ DFSDM_DFSDM_CHDATIN4R, DFSDM_BASE + 0x90 @ (DFSDM channel data input  register) 
        .equ DFSDM_DFSDM_CHDATIN4R_INDAT0_Shift, 0   @ bitWidth 16 (Input data for channel 4)  
        .equ DFSDM_DFSDM_CHDATIN4R_INDAT1_Shift, 16   @ bitWidth 16 (Input data for channel 5)  
 
    .equ DFSDM_DFSDM_CHDATIN5R, DFSDM_BASE + 0x94 @ (DFSDM channel data input  register) 
        .equ DFSDM_DFSDM_CHDATIN5R_INDAT0_Shift, 0   @ bitWidth 16 (Input data for channel 5)  
        .equ DFSDM_DFSDM_CHDATIN5R_INDAT1_Shift, 16   @ bitWidth 16 (Input data for channel 6)  
 
    .equ DFSDM_DFSDM_CHDATIN6R, DFSDM_BASE + 0x98 @ (DFSDM channel data input  register) 
        .equ DFSDM_DFSDM_CHDATIN6R_INDAT0_Shift, 0   @ bitWidth 16 (Input data for channel 6)  
        .equ DFSDM_DFSDM_CHDATIN6R_INDAT1_Shift, 16   @ bitWidth 16 (Input data for channel 7)  
 
    .equ DFSDM_DFSDM_CHDATIN7R, DFSDM_BASE + 0x9C @ (DFSDM channel data input  register) 
        .equ DFSDM_DFSDM_CHDATIN7R_INDAT0_Shift, 0   @ bitWidth 16 (Input data for channel 7)  
        .equ DFSDM_DFSDM_CHDATIN7R_INDAT1_Shift, 16   @ bitWidth 16 (Input data for channel 8)  
 
    .equ DFSDM_DFSDM0_CR1, DFSDM_BASE + 0xA0 @ (DFSDM control register 1) 
        .equ DFSDM_DFSDM0_CR1_DFEN, 1 << 0   @ bitWidth 1 (DFSDM enable)  
        .equ DFSDM_DFSDM0_CR1_JSWSTART, 1 << 1   @ bitWidth 1 (Start a conversion of the injected group  of channels)  
        .equ DFSDM_DFSDM0_CR1_JSYNC, 1 << 3   @ bitWidth 1 (Launch an injected conversion  synchronously with the DFSDM0 JSWSTART  trigger)  
        .equ DFSDM_DFSDM0_CR1_JSCAN, 1 << 4   @ bitWidth 1 (Scanning conversion mode for injected  conversions)  
        .equ DFSDM_DFSDM0_CR1_JDMAEN, 1 << 5   @ bitWidth 1 (DMA channel enabled to read data for the  injected channel group)  
        .equ DFSDM_DFSDM0_CR1_JEXTSEL_Shift, 8   @ bitWidth 5 (Trigger signal selection for launching  injected conversions)  
        .equ DFSDM_DFSDM0_CR1_JEXTEN_Shift, 13   @ bitWidth 2 (Trigger enable and trigger edge  selection for injected conversions)  
        .equ DFSDM_DFSDM0_CR1_RSWSTART, 1 << 17   @ bitWidth 1 (Software start of a conversion on the  regular channel)  
        .equ DFSDM_DFSDM0_CR1_RCONT, 1 << 18   @ bitWidth 1 (Continuous mode selection for regular  conversions)  
        .equ DFSDM_DFSDM0_CR1_RSYNC, 1 << 19   @ bitWidth 1 (Launch regular conversion synchronously  with DFSDM0)  
        .equ DFSDM_DFSDM0_CR1_RDMAEN, 1 << 21   @ bitWidth 1 (DMA channel enabled to read data for the  regular conversion)  
        .equ DFSDM_DFSDM0_CR1_RCH_Shift, 24   @ bitWidth 3 (Regular channel selection)  
        .equ DFSDM_DFSDM0_CR1_FAST, 1 << 29   @ bitWidth 1 (Fast conversion mode selection for  regular conversions)  
        .equ DFSDM_DFSDM0_CR1_AWFSEL, 1 << 30   @ bitWidth 1 (Analog watchdog fast mode  select)  
 
    .equ DFSDM_DFSDM1_CR1, DFSDM_BASE + 0xA4 @ (DFSDM control register 1) 
        .equ DFSDM_DFSDM1_CR1_DFEN, 1 << 0   @ bitWidth 1 (DFSDM enable)  
        .equ DFSDM_DFSDM1_CR1_JSWSTART, 1 << 1   @ bitWidth 1 (Start a conversion of the injected group  of channels)  
        .equ DFSDM_DFSDM1_CR1_JSYNC, 1 << 3   @ bitWidth 1 (Launch an injected conversion  synchronously with the DFSDM0 JSWSTART  trigger)  
        .equ DFSDM_DFSDM1_CR1_JSCAN, 1 << 4   @ bitWidth 1 (Scanning conversion mode for injected  conversions)  
        .equ DFSDM_DFSDM1_CR1_JDMAEN, 1 << 5   @ bitWidth 1 (DMA channel enabled to read data for the  injected channel group)  
        .equ DFSDM_DFSDM1_CR1_JEXTSEL_Shift, 8   @ bitWidth 5 (Trigger signal selection for launching  injected conversions)  
        .equ DFSDM_DFSDM1_CR1_JEXTEN_Shift, 13   @ bitWidth 2 (Trigger enable and trigger edge  selection for injected conversions)  
        .equ DFSDM_DFSDM1_CR1_RSWSTART, 1 << 17   @ bitWidth 1 (Software start of a conversion on the  regular channel)  
        .equ DFSDM_DFSDM1_CR1_RCONT, 1 << 18   @ bitWidth 1 (Continuous mode selection for regular  conversions)  
        .equ DFSDM_DFSDM1_CR1_RSYNC, 1 << 19   @ bitWidth 1 (Launch regular conversion synchronously  with DFSDM0)  
        .equ DFSDM_DFSDM1_CR1_RDMAEN, 1 << 21   @ bitWidth 1 (DMA channel enabled to read data for the  regular conversion)  
        .equ DFSDM_DFSDM1_CR1_RCH_Shift, 24   @ bitWidth 3 (Regular channel selection)  
        .equ DFSDM_DFSDM1_CR1_FAST, 1 << 29   @ bitWidth 1 (Fast conversion mode selection for  regular conversions)  
        .equ DFSDM_DFSDM1_CR1_AWFSEL, 1 << 30   @ bitWidth 1 (Analog watchdog fast mode  select)  
 
    .equ DFSDM_DFSDM2_CR1, DFSDM_BASE + 0xA8 @ (DFSDM control register 1) 
        .equ DFSDM_DFSDM2_CR1_DFEN, 1 << 0   @ bitWidth 1 (DFSDM enable)  
        .equ DFSDM_DFSDM2_CR1_JSWSTART, 1 << 1   @ bitWidth 1 (Start a conversion of the injected group  of channels)  
        .equ DFSDM_DFSDM2_CR1_JSYNC, 1 << 3   @ bitWidth 1 (Launch an injected conversion  synchronously with the DFSDM0 JSWSTART  trigger)  
        .equ DFSDM_DFSDM2_CR1_JSCAN, 1 << 4   @ bitWidth 1 (Scanning conversion mode for injected  conversions)  
        .equ DFSDM_DFSDM2_CR1_JDMAEN, 1 << 5   @ bitWidth 1 (DMA channel enabled to read data for the  injected channel group)  
        .equ DFSDM_DFSDM2_CR1_JEXTSEL_Shift, 8   @ bitWidth 5 (Trigger signal selection for launching  injected conversions)  
        .equ DFSDM_DFSDM2_CR1_JEXTEN_Shift, 13   @ bitWidth 2 (Trigger enable and trigger edge  selection for injected conversions)  
        .equ DFSDM_DFSDM2_CR1_RSWSTART, 1 << 17   @ bitWidth 1 (Software start of a conversion on the  regular channel)  
        .equ DFSDM_DFSDM2_CR1_RCONT, 1 << 18   @ bitWidth 1 (Continuous mode selection for regular  conversions)  
        .equ DFSDM_DFSDM2_CR1_RSYNC, 1 << 19   @ bitWidth 1 (Launch regular conversion synchronously  with DFSDM0)  
        .equ DFSDM_DFSDM2_CR1_RDMAEN, 1 << 21   @ bitWidth 1 (DMA channel enabled to read data for the  regular conversion)  
        .equ DFSDM_DFSDM2_CR1_RCH_Shift, 24   @ bitWidth 3 (Regular channel selection)  
        .equ DFSDM_DFSDM2_CR1_FAST, 1 << 29   @ bitWidth 1 (Fast conversion mode selection for  regular conversions)  
        .equ DFSDM_DFSDM2_CR1_AWFSEL, 1 << 30   @ bitWidth 1 (Analog watchdog fast mode  select)  
 
    .equ DFSDM_DFSDM3_CR1, DFSDM_BASE + 0xAC @ (DFSDM control register 1) 
        .equ DFSDM_DFSDM3_CR1_DFEN, 1 << 0   @ bitWidth 1 (DFSDM enable)  
        .equ DFSDM_DFSDM3_CR1_JSWSTART, 1 << 1   @ bitWidth 1 (Start a conversion of the injected group  of channels)  
        .equ DFSDM_DFSDM3_CR1_JSYNC, 1 << 3   @ bitWidth 1 (Launch an injected conversion  synchronously with the DFSDM0 JSWSTART  trigger)  
        .equ DFSDM_DFSDM3_CR1_JSCAN, 1 << 4   @ bitWidth 1 (Scanning conversion mode for injected  conversions)  
        .equ DFSDM_DFSDM3_CR1_JDMAEN, 1 << 5   @ bitWidth 1 (DMA channel enabled to read data for the  injected channel group)  
        .equ DFSDM_DFSDM3_CR1_JEXTSEL_Shift, 8   @ bitWidth 5 (Trigger signal selection for launching  injected conversions)  
        .equ DFSDM_DFSDM3_CR1_JEXTEN_Shift, 13   @ bitWidth 2 (Trigger enable and trigger edge  selection for injected conversions)  
        .equ DFSDM_DFSDM3_CR1_RSWSTART, 1 << 17   @ bitWidth 1 (Software start of a conversion on the  regular channel)  
        .equ DFSDM_DFSDM3_CR1_RCONT, 1 << 18   @ bitWidth 1 (Continuous mode selection for regular  conversions)  
        .equ DFSDM_DFSDM3_CR1_RSYNC, 1 << 19   @ bitWidth 1 (Launch regular conversion synchronously  with DFSDM0)  
        .equ DFSDM_DFSDM3_CR1_RDMAEN, 1 << 21   @ bitWidth 1 (DMA channel enabled to read data for the  regular conversion)  
        .equ DFSDM_DFSDM3_CR1_RCH_Shift, 24   @ bitWidth 3 (Regular channel selection)  
        .equ DFSDM_DFSDM3_CR1_FAST, 1 << 29   @ bitWidth 1 (Fast conversion mode selection for  regular conversions)  
        .equ DFSDM_DFSDM3_CR1_AWFSEL, 1 << 30   @ bitWidth 1 (Analog watchdog fast mode  select)  
 
    .equ DFSDM_DFSDM0_CR2, DFSDM_BASE + 0xB0 @ (DFSDM control register 2) 
        .equ DFSDM_DFSDM0_CR2_JEOCIE, 1 << 0   @ bitWidth 1 (Injected end of conversion interrupt  enable)  
        .equ DFSDM_DFSDM0_CR2_REOCIE, 1 << 1   @ bitWidth 1 (Regular end of conversion interrupt  enable)  
        .equ DFSDM_DFSDM0_CR2_JOVRIE, 1 << 2   @ bitWidth 1 (Injected data overrun interrupt  enable)  
        .equ DFSDM_DFSDM0_CR2_ROVRIE, 1 << 3   @ bitWidth 1 (Regular data overrun interrupt  enable)  
        .equ DFSDM_DFSDM0_CR2_AWDIE, 1 << 4   @ bitWidth 1 (Analog watchdog interrupt  enable)  
        .equ DFSDM_DFSDM0_CR2_SCDIE, 1 << 5   @ bitWidth 1 (Short-circuit detector interrupt  enable)  
        .equ DFSDM_DFSDM0_CR2_CKABIE, 1 << 6   @ bitWidth 1 (Clock absence interrupt  enable)  
        .equ DFSDM_DFSDM0_CR2_EXCH_Shift, 8   @ bitWidth 8 (Extremes detector channel  selection)  
        .equ DFSDM_DFSDM0_CR2_AWDCH_Shift, 16   @ bitWidth 8 (Analog watchdog channel  selection)  
 
    .equ DFSDM_DFSDM1_CR2, DFSDM_BASE + 0xB4 @ (DFSDM control register 2) 
        .equ DFSDM_DFSDM1_CR2_JEOCIE, 1 << 0   @ bitWidth 1 (Injected end of conversion interrupt  enable)  
        .equ DFSDM_DFSDM1_CR2_REOCIE, 1 << 1   @ bitWidth 1 (Regular end of conversion interrupt  enable)  
        .equ DFSDM_DFSDM1_CR2_JOVRIE, 1 << 2   @ bitWidth 1 (Injected data overrun interrupt  enable)  
        .equ DFSDM_DFSDM1_CR2_ROVRIE, 1 << 3   @ bitWidth 1 (Regular data overrun interrupt  enable)  
        .equ DFSDM_DFSDM1_CR2_AWDIE, 1 << 4   @ bitWidth 1 (Analog watchdog interrupt  enable)  
        .equ DFSDM_DFSDM1_CR2_SCDIE, 1 << 5   @ bitWidth 1 (Short-circuit detector interrupt  enable)  
        .equ DFSDM_DFSDM1_CR2_CKABIE, 1 << 6   @ bitWidth 1 (Clock absence interrupt  enable)  
        .equ DFSDM_DFSDM1_CR2_EXCH_Shift, 8   @ bitWidth 8 (Extremes detector channel  selection)  
        .equ DFSDM_DFSDM1_CR2_AWDCH_Shift, 16   @ bitWidth 8 (Analog watchdog channel  selection)  
 
    .equ DFSDM_DFSDM2_CR2, DFSDM_BASE + 0xB8 @ (DFSDM control register 2) 
        .equ DFSDM_DFSDM2_CR2_JEOCIE, 1 << 0   @ bitWidth 1 (Injected end of conversion interrupt  enable)  
        .equ DFSDM_DFSDM2_CR2_REOCIE, 1 << 1   @ bitWidth 1 (Regular end of conversion interrupt  enable)  
        .equ DFSDM_DFSDM2_CR2_JOVRIE, 1 << 2   @ bitWidth 1 (Injected data overrun interrupt  enable)  
        .equ DFSDM_DFSDM2_CR2_ROVRIE, 1 << 3   @ bitWidth 1 (Regular data overrun interrupt  enable)  
        .equ DFSDM_DFSDM2_CR2_AWDIE, 1 << 4   @ bitWidth 1 (Analog watchdog interrupt  enable)  
        .equ DFSDM_DFSDM2_CR2_SCDIE, 1 << 5   @ bitWidth 1 (Short-circuit detector interrupt  enable)  
        .equ DFSDM_DFSDM2_CR2_CKABIE, 1 << 6   @ bitWidth 1 (Clock absence interrupt  enable)  
        .equ DFSDM_DFSDM2_CR2_EXCH_Shift, 8   @ bitWidth 8 (Extremes detector channel  selection)  
        .equ DFSDM_DFSDM2_CR2_AWDCH_Shift, 16   @ bitWidth 8 (Analog watchdog channel  selection)  
 
    .equ DFSDM_DFSDM3_CR2, DFSDM_BASE + 0xBC @ (DFSDM control register 2) 
        .equ DFSDM_DFSDM3_CR2_JEOCIE, 1 << 0   @ bitWidth 1 (Injected end of conversion interrupt  enable)  
        .equ DFSDM_DFSDM3_CR2_REOCIE, 1 << 1   @ bitWidth 1 (Regular end of conversion interrupt  enable)  
        .equ DFSDM_DFSDM3_CR2_JOVRIE, 1 << 2   @ bitWidth 1 (Injected data overrun interrupt  enable)  
        .equ DFSDM_DFSDM3_CR2_ROVRIE, 1 << 3   @ bitWidth 1 (Regular data overrun interrupt  enable)  
        .equ DFSDM_DFSDM3_CR2_AWDIE, 1 << 4   @ bitWidth 1 (Analog watchdog interrupt  enable)  
        .equ DFSDM_DFSDM3_CR2_SCDIE, 1 << 5   @ bitWidth 1 (Short-circuit detector interrupt  enable)  
        .equ DFSDM_DFSDM3_CR2_CKABIE, 1 << 6   @ bitWidth 1 (Clock absence interrupt  enable)  
        .equ DFSDM_DFSDM3_CR2_EXCH_Shift, 8   @ bitWidth 8 (Extremes detector channel  selection)  
        .equ DFSDM_DFSDM3_CR2_AWDCH_Shift, 16   @ bitWidth 8 (Analog watchdog channel  selection)  
 
    .equ DFSDM_DFSDM0_ISR, DFSDM_BASE + 0xC0 @ (DFSDM interrupt and status  register) 
        .equ DFSDM_DFSDM0_ISR_JEOCF, 1 << 0   @ bitWidth 1 (End of injected conversion  flag)  
        .equ DFSDM_DFSDM0_ISR_REOCF, 1 << 1   @ bitWidth 1 (End of regular conversion  flag)  
        .equ DFSDM_DFSDM0_ISR_JOVRF, 1 << 2   @ bitWidth 1 (Injected conversion overrun  flag)  
        .equ DFSDM_DFSDM0_ISR_ROVRF, 1 << 3   @ bitWidth 1 (Regular conversion overrun  flag)  
        .equ DFSDM_DFSDM0_ISR_AWDF, 1 << 4   @ bitWidth 1 (Analog watchdog)  
        .equ DFSDM_DFSDM0_ISR_JCIP, 1 << 13   @ bitWidth 1 (Injected conversion in progress  status)  
        .equ DFSDM_DFSDM0_ISR_RCIP, 1 << 14   @ bitWidth 1 (Regular conversion in progress  status)  
        .equ DFSDM_DFSDM0_ISR_CKABF_Shift, 16   @ bitWidth 8 (Clock absence flag)  
        .equ DFSDM_DFSDM0_ISR_SCDF_Shift, 24   @ bitWidth 8 (short-circuit detector  flag)  
 
    .equ DFSDM_DFSDM1_ISR, DFSDM_BASE + 0xC4 @ (DFSDM interrupt and status  register) 
        .equ DFSDM_DFSDM1_ISR_JEOCF, 1 << 0   @ bitWidth 1 (End of injected conversion  flag)  
        .equ DFSDM_DFSDM1_ISR_REOCF, 1 << 1   @ bitWidth 1 (End of regular conversion  flag)  
        .equ DFSDM_DFSDM1_ISR_JOVRF, 1 << 2   @ bitWidth 1 (Injected conversion overrun  flag)  
        .equ DFSDM_DFSDM1_ISR_ROVRF, 1 << 3   @ bitWidth 1 (Regular conversion overrun  flag)  
        .equ DFSDM_DFSDM1_ISR_AWDF, 1 << 4   @ bitWidth 1 (Analog watchdog)  
        .equ DFSDM_DFSDM1_ISR_JCIP, 1 << 13   @ bitWidth 1 (Injected conversion in progress  status)  
        .equ DFSDM_DFSDM1_ISR_RCIP, 1 << 14   @ bitWidth 1 (Regular conversion in progress  status)  
        .equ DFSDM_DFSDM1_ISR_CKABF_Shift, 16   @ bitWidth 8 (Clock absence flag)  
        .equ DFSDM_DFSDM1_ISR_SCDF_Shift, 24   @ bitWidth 8 (short-circuit detector  flag)  
 
    .equ DFSDM_DFSDM2_ISR, DFSDM_BASE + 0xC8 @ (DFSDM interrupt and status  register) 
        .equ DFSDM_DFSDM2_ISR_JEOCF, 1 << 0   @ bitWidth 1 (End of injected conversion  flag)  
        .equ DFSDM_DFSDM2_ISR_REOCF, 1 << 1   @ bitWidth 1 (End of regular conversion  flag)  
        .equ DFSDM_DFSDM2_ISR_JOVRF, 1 << 2   @ bitWidth 1 (Injected conversion overrun  flag)  
        .equ DFSDM_DFSDM2_ISR_ROVRF, 1 << 3   @ bitWidth 1 (Regular conversion overrun  flag)  
        .equ DFSDM_DFSDM2_ISR_AWDF, 1 << 4   @ bitWidth 1 (Analog watchdog)  
        .equ DFSDM_DFSDM2_ISR_JCIP, 1 << 13   @ bitWidth 1 (Injected conversion in progress  status)  
        .equ DFSDM_DFSDM2_ISR_RCIP, 1 << 14   @ bitWidth 1 (Regular conversion in progress  status)  
        .equ DFSDM_DFSDM2_ISR_CKABF_Shift, 16   @ bitWidth 8 (Clock absence flag)  
        .equ DFSDM_DFSDM2_ISR_SCDF_Shift, 24   @ bitWidth 8 (short-circuit detector  flag)  
 
    .equ DFSDM_DFSDM3_ISR, DFSDM_BASE + 0xCC @ (DFSDM interrupt and status  register) 
        .equ DFSDM_DFSDM3_ISR_JEOCF, 1 << 0   @ bitWidth 1 (End of injected conversion  flag)  
        .equ DFSDM_DFSDM3_ISR_REOCF, 1 << 1   @ bitWidth 1 (End of regular conversion  flag)  
        .equ DFSDM_DFSDM3_ISR_JOVRF, 1 << 2   @ bitWidth 1 (Injected conversion overrun  flag)  
        .equ DFSDM_DFSDM3_ISR_ROVRF, 1 << 3   @ bitWidth 1 (Regular conversion overrun  flag)  
        .equ DFSDM_DFSDM3_ISR_AWDF, 1 << 4   @ bitWidth 1 (Analog watchdog)  
        .equ DFSDM_DFSDM3_ISR_JCIP, 1 << 13   @ bitWidth 1 (Injected conversion in progress  status)  
        .equ DFSDM_DFSDM3_ISR_RCIP, 1 << 14   @ bitWidth 1 (Regular conversion in progress  status)  
        .equ DFSDM_DFSDM3_ISR_CKABF_Shift, 16   @ bitWidth 8 (Clock absence flag)  
        .equ DFSDM_DFSDM3_ISR_SCDF_Shift, 24   @ bitWidth 8 (short-circuit detector  flag)  
 
    .equ DFSDM_DFSDM0_ICR, DFSDM_BASE + 0xD0 @ (DFSDM interrupt flag clear  register) 
        .equ DFSDM_DFSDM0_ICR_CLRJOVRF, 1 << 2   @ bitWidth 1 (Clear the injected conversion overrun  flag)  
        .equ DFSDM_DFSDM0_ICR_CLRROVRF, 1 << 3   @ bitWidth 1 (Clear the regular conversion overrun  flag)  
        .equ DFSDM_DFSDM0_ICR_CLRCKABF_Shift, 16   @ bitWidth 8 (Clear the clock absence  flag)  
        .equ DFSDM_DFSDM0_ICR_CLRSCDF_Shift, 24   @ bitWidth 8 (Clear the short-circuit detector  flag)  
 
    .equ DFSDM_DFSDM1_ICR, DFSDM_BASE + 0xD4 @ (DFSDM interrupt flag clear  register) 
        .equ DFSDM_DFSDM1_ICR_CLRJOVRF, 1 << 2   @ bitWidth 1 (Clear the injected conversion overrun  flag)  
        .equ DFSDM_DFSDM1_ICR_CLRROVRF, 1 << 3   @ bitWidth 1 (Clear the regular conversion overrun  flag)  
        .equ DFSDM_DFSDM1_ICR_CLRCKABF_Shift, 16   @ bitWidth 8 (Clear the clock absence  flag)  
        .equ DFSDM_DFSDM1_ICR_CLRSCDF_Shift, 24   @ bitWidth 8 (Clear the short-circuit detector  flag)  
 
    .equ DFSDM_DFSDM2_ICR, DFSDM_BASE + 0xD8 @ (DFSDM interrupt flag clear  register) 
        .equ DFSDM_DFSDM2_ICR_CLRJOVRF, 1 << 2   @ bitWidth 1 (Clear the injected conversion overrun  flag)  
        .equ DFSDM_DFSDM2_ICR_CLRROVRF, 1 << 3   @ bitWidth 1 (Clear the regular conversion overrun  flag)  
        .equ DFSDM_DFSDM2_ICR_CLRCKABF_Shift, 16   @ bitWidth 8 (Clear the clock absence  flag)  
        .equ DFSDM_DFSDM2_ICR_CLRSCDF_Shift, 24   @ bitWidth 8 (Clear the short-circuit detector  flag)  
 
    .equ DFSDM_DFSDM3_ICR, DFSDM_BASE + 0xDC @ (DFSDM interrupt flag clear  register) 
        .equ DFSDM_DFSDM3_ICR_CLRJOVRF, 1 << 2   @ bitWidth 1 (Clear the injected conversion overrun  flag)  
        .equ DFSDM_DFSDM3_ICR_CLRROVRF, 1 << 3   @ bitWidth 1 (Clear the regular conversion overrun  flag)  
        .equ DFSDM_DFSDM3_ICR_CLRCKABF_Shift, 16   @ bitWidth 8 (Clear the clock absence  flag)  
        .equ DFSDM_DFSDM3_ICR_CLRSCDF_Shift, 24   @ bitWidth 8 (Clear the short-circuit detector  flag)  
 
    .equ DFSDM_DFSDM0_JCHGR, DFSDM_BASE + 0xE0 @ (DFSDM injected channel group selection  register) 
        .equ DFSDM_DFSDM0_JCHGR_JCHG_Shift, 0   @ bitWidth 8 (Injected channel group  selection)  
 
    .equ DFSDM_DFSDM1_JCHGR, DFSDM_BASE + 0xE4 @ (DFSDM injected channel group selection  register) 
        .equ DFSDM_DFSDM1_JCHGR_JCHG_Shift, 0   @ bitWidth 8 (Injected channel group  selection)  
 
    .equ DFSDM_DFSDM2_JCHGR, DFSDM_BASE + 0xE8 @ (DFSDM injected channel group selection  register) 
        .equ DFSDM_DFSDM2_JCHGR_JCHG_Shift, 0   @ bitWidth 8 (Injected channel group  selection)  
 
    .equ DFSDM_DFSDM3_JCHGR, DFSDM_BASE + 0xEC @ (DFSDM injected channel group selection  register) 
        .equ DFSDM_DFSDM3_JCHGR_JCHG_Shift, 0   @ bitWidth 8 (Injected channel group  selection)  
 
    .equ DFSDM_DFSDM0_FCR, DFSDM_BASE + 0xF0 @ (DFSDM filter control register) 
        .equ DFSDM_DFSDM0_FCR_IOSR_Shift, 0   @ bitWidth 8 (Integrator oversampling ratio averaging  length)  
        .equ DFSDM_DFSDM0_FCR_FOSR_Shift, 16   @ bitWidth 10 (Sinc filter oversampling ratio  decimation rate)  
        .equ DFSDM_DFSDM0_FCR_FORD_Shift, 29   @ bitWidth 3 (Sinc filter order)  
 
    .equ DFSDM_DFSDM1_FCR, DFSDM_BASE + 0xF4 @ (DFSDM filter control register) 
        .equ DFSDM_DFSDM1_FCR_IOSR_Shift, 0   @ bitWidth 8 (Integrator oversampling ratio averaging  length)  
        .equ DFSDM_DFSDM1_FCR_FOSR_Shift, 16   @ bitWidth 10 (Sinc filter oversampling ratio  decimation rate)  
        .equ DFSDM_DFSDM1_FCR_FORD_Shift, 29   @ bitWidth 3 (Sinc filter order)  
 
    .equ DFSDM_DFSDM2_FCR, DFSDM_BASE + 0xF8 @ (DFSDM filter control register) 
        .equ DFSDM_DFSDM2_FCR_IOSR_Shift, 0   @ bitWidth 8 (Integrator oversampling ratio averaging  length)  
        .equ DFSDM_DFSDM2_FCR_FOSR_Shift, 16   @ bitWidth 10 (Sinc filter oversampling ratio  decimation rate)  
        .equ DFSDM_DFSDM2_FCR_FORD_Shift, 29   @ bitWidth 3 (Sinc filter order)  
 
    .equ DFSDM_DFSDM3_FCR, DFSDM_BASE + 0xFC @ (DFSDM filter control register) 
        .equ DFSDM_DFSDM3_FCR_IOSR_Shift, 0   @ bitWidth 8 (Integrator oversampling ratio averaging  length)  
        .equ DFSDM_DFSDM3_FCR_FOSR_Shift, 16   @ bitWidth 10 (Sinc filter oversampling ratio  decimation rate)  
        .equ DFSDM_DFSDM3_FCR_FORD_Shift, 29   @ bitWidth 3 (Sinc filter order)  
 
    .equ DFSDM_DFSDM0_JDATAR, DFSDM_BASE + 0x100 @ (DFSDM data register for injected  group) 
        .equ DFSDM_DFSDM0_JDATAR_JDATACH_Shift, 0   @ bitWidth 3 (Injected channel most recently  converted)  
        .equ DFSDM_DFSDM0_JDATAR_JDATA_Shift, 8   @ bitWidth 24 (Injected group conversion  data)  
 
    .equ DFSDM_DFSDM1_JDATAR, DFSDM_BASE + 0x104 @ (DFSDM data register for injected  group) 
        .equ DFSDM_DFSDM1_JDATAR_JDATACH_Shift, 0   @ bitWidth 3 (Injected channel most recently  converted)  
        .equ DFSDM_DFSDM1_JDATAR_JDATA_Shift, 8   @ bitWidth 24 (Injected group conversion  data)  
 
    .equ DFSDM_DFSDM2_JDATAR, DFSDM_BASE + 0x108 @ (DFSDM data register for injected  group) 
        .equ DFSDM_DFSDM2_JDATAR_JDATACH_Shift, 0   @ bitWidth 3 (Injected channel most recently  converted)  
        .equ DFSDM_DFSDM2_JDATAR_JDATA_Shift, 8   @ bitWidth 24 (Injected group conversion  data)  
 
    .equ DFSDM_DFSDM3_JDATAR, DFSDM_BASE + 0x10C @ (DFSDM data register for injected  group) 
        .equ DFSDM_DFSDM3_JDATAR_JDATACH_Shift, 0   @ bitWidth 3 (Injected channel most recently  converted)  
        .equ DFSDM_DFSDM3_JDATAR_JDATA_Shift, 8   @ bitWidth 24 (Injected group conversion  data)  
 
    .equ DFSDM_DFSDM0_RDATAR, DFSDM_BASE + 0x110 @ (DFSDM data register for the regular  channel) 
        .equ DFSDM_DFSDM0_RDATAR_RDATACH_Shift, 0   @ bitWidth 3 (Regular channel most recently  converted)  
        .equ DFSDM_DFSDM0_RDATAR_RPEND, 1 << 4   @ bitWidth 1 (Regular channel pending  data)  
        .equ DFSDM_DFSDM0_RDATAR_RDATA_Shift, 8   @ bitWidth 24 (Regular channel conversion  data)  
 
    .equ DFSDM_DFSDM1_RDATAR, DFSDM_BASE + 0x114 @ (DFSDM data register for the regular  channel) 
        .equ DFSDM_DFSDM1_RDATAR_RDATACH_Shift, 0   @ bitWidth 3 (Regular channel most recently  converted)  
        .equ DFSDM_DFSDM1_RDATAR_RPEND, 1 << 4   @ bitWidth 1 (Regular channel pending  data)  
        .equ DFSDM_DFSDM1_RDATAR_RDATA_Shift, 8   @ bitWidth 24 (Regular channel conversion  data)  
 
    .equ DFSDM_DFSDM2_RDATAR, DFSDM_BASE + 0x118 @ (DFSDM data register for the regular  channel) 
        .equ DFSDM_DFSDM2_RDATAR_RDATACH_Shift, 0   @ bitWidth 3 (Regular channel most recently  converted)  
        .equ DFSDM_DFSDM2_RDATAR_RPEND, 1 << 4   @ bitWidth 1 (Regular channel pending  data)  
        .equ DFSDM_DFSDM2_RDATAR_RDATA_Shift, 8   @ bitWidth 24 (Regular channel conversion  data)  
 
    .equ DFSDM_DFSDM3_RDATAR, DFSDM_BASE + 0x11C @ (DFSDM data register for the regular  channel) 
        .equ DFSDM_DFSDM3_RDATAR_RDATACH_Shift, 0   @ bitWidth 3 (Regular channel most recently  converted)  
        .equ DFSDM_DFSDM3_RDATAR_RPEND, 1 << 4   @ bitWidth 1 (Regular channel pending  data)  
        .equ DFSDM_DFSDM3_RDATAR_RDATA_Shift, 8   @ bitWidth 24 (Regular channel conversion  data)  
 
    .equ DFSDM_DFSDM0_AWHTR, DFSDM_BASE + 0x120 @ (DFSDM analog watchdog high threshold  register) 
        .equ DFSDM_DFSDM0_AWHTR_BKAWH_Shift, 0   @ bitWidth 4 (Break signal assignment to analog  watchdog high threshold event)  
        .equ DFSDM_DFSDM0_AWHTR_AWHT_Shift, 8   @ bitWidth 24 (Analog watchdog high  threshold)  
 
    .equ DFSDM_DFSDM1_AWHTR, DFSDM_BASE + 0x124 @ (DFSDM analog watchdog high threshold  register) 
        .equ DFSDM_DFSDM1_AWHTR_BKAWH_Shift, 0   @ bitWidth 4 (Break signal assignment to analog  watchdog high threshold event)  
        .equ DFSDM_DFSDM1_AWHTR_AWHT_Shift, 8   @ bitWidth 24 (Analog watchdog high  threshold)  
 
    .equ DFSDM_DFSDM2_AWHTR, DFSDM_BASE + 0x128 @ (DFSDM analog watchdog high threshold  register) 
        .equ DFSDM_DFSDM2_AWHTR_BKAWH_Shift, 0   @ bitWidth 4 (Break signal assignment to analog  watchdog high threshold event)  
        .equ DFSDM_DFSDM2_AWHTR_AWHT_Shift, 8   @ bitWidth 24 (Analog watchdog high  threshold)  
 
    .equ DFSDM_DFSDM3_AWHTR, DFSDM_BASE + 0x12C @ (DFSDM analog watchdog high threshold  register) 
        .equ DFSDM_DFSDM3_AWHTR_BKAWH_Shift, 0   @ bitWidth 4 (Break signal assignment to analog  watchdog high threshold event)  
        .equ DFSDM_DFSDM3_AWHTR_AWHT_Shift, 8   @ bitWidth 24 (Analog watchdog high  threshold)  
 
    .equ DFSDM_DFSDM0_AWLTR, DFSDM_BASE + 0x130 @ (DFSDM analog watchdog low threshold  register) 
        .equ DFSDM_DFSDM0_AWLTR_BKAWL_Shift, 0   @ bitWidth 4 (Break signal assignment to analog  watchdog low threshold event)  
        .equ DFSDM_DFSDM0_AWLTR_AWLT_Shift, 8   @ bitWidth 24 (Analog watchdog low  threshold)  
 
    .equ DFSDM_DFSDM1_AWLTR, DFSDM_BASE + 0x134 @ (DFSDM analog watchdog low threshold  register) 
        .equ DFSDM_DFSDM1_AWLTR_BKAWL_Shift, 0   @ bitWidth 4 (Break signal assignment to analog  watchdog low threshold event)  
        .equ DFSDM_DFSDM1_AWLTR_AWLT_Shift, 8   @ bitWidth 24 (Analog watchdog low  threshold)  
 
    .equ DFSDM_DFSDM2_AWLTR, DFSDM_BASE + 0x138 @ (DFSDM analog watchdog low threshold  register) 
        .equ DFSDM_DFSDM2_AWLTR_BKAWL_Shift, 0   @ bitWidth 4 (Break signal assignment to analog  watchdog low threshold event)  
        .equ DFSDM_DFSDM2_AWLTR_AWLT_Shift, 8   @ bitWidth 24 (Analog watchdog low  threshold)  
 
    .equ DFSDM_DFSDM3_AWLTR, DFSDM_BASE + 0x13C @ (DFSDM analog watchdog low threshold  register) 
        .equ DFSDM_DFSDM3_AWLTR_BKAWL_Shift, 0   @ bitWidth 4 (Break signal assignment to analog  watchdog low threshold event)  
        .equ DFSDM_DFSDM3_AWLTR_AWLT_Shift, 8   @ bitWidth 24 (Analog watchdog low  threshold)  
 
    .equ DFSDM_DFSDM0_AWSR, DFSDM_BASE + 0x140 @ (DFSDM analog watchdog status  register) 
        .equ DFSDM_DFSDM0_AWSR_AWLTF_Shift, 0   @ bitWidth 8 (Analog watchdog low threshold  flag)  
        .equ DFSDM_DFSDM0_AWSR_AWHTF_Shift, 8   @ bitWidth 8 (Analog watchdog high threshold  flag)  
 
    .equ DFSDM_DFSDM1_AWSR, DFSDM_BASE + 0x144 @ (DFSDM analog watchdog status  register) 
        .equ DFSDM_DFSDM1_AWSR_AWLTF_Shift, 0   @ bitWidth 8 (Analog watchdog low threshold  flag)  
        .equ DFSDM_DFSDM1_AWSR_AWHTF_Shift, 8   @ bitWidth 8 (Analog watchdog high threshold  flag)  
 
    .equ DFSDM_DFSDM2_AWSR, DFSDM_BASE + 0x148 @ (DFSDM analog watchdog status  register) 
        .equ DFSDM_DFSDM2_AWSR_AWLTF_Shift, 0   @ bitWidth 8 (Analog watchdog low threshold  flag)  
        .equ DFSDM_DFSDM2_AWSR_AWHTF_Shift, 8   @ bitWidth 8 (Analog watchdog high threshold  flag)  
 
    .equ DFSDM_DFSDM3_AWSR, DFSDM_BASE + 0x14C @ (DFSDM analog watchdog status  register) 
        .equ DFSDM_DFSDM3_AWSR_AWLTF_Shift, 0   @ bitWidth 8 (Analog watchdog low threshold  flag)  
        .equ DFSDM_DFSDM3_AWSR_AWHTF_Shift, 8   @ bitWidth 8 (Analog watchdog high threshold  flag)  
 
    .equ DFSDM_DFSDM0_AWCFR, DFSDM_BASE + 0x150 @ (DFSDM analog watchdog clear flag  register) 
        .equ DFSDM_DFSDM0_AWCFR_CLRAWLTF_Shift, 0   @ bitWidth 8 (Clear the analog watchdog low threshold  flag)  
        .equ DFSDM_DFSDM0_AWCFR_CLRAWHTF_Shift, 8   @ bitWidth 8 (Clear the analog watchdog high threshold  flag)  
 
    .equ DFSDM_DFSDM1_AWCFR, DFSDM_BASE + 0x154 @ (DFSDM analog watchdog clear flag  register) 
        .equ DFSDM_DFSDM1_AWCFR_CLRAWLTF_Shift, 0   @ bitWidth 8 (Clear the analog watchdog low threshold  flag)  
        .equ DFSDM_DFSDM1_AWCFR_CLRAWHTF_Shift, 8   @ bitWidth 8 (Clear the analog watchdog high threshold  flag)  
 
    .equ DFSDM_DFSDM2_AWCFR, DFSDM_BASE + 0x158 @ (DFSDM analog watchdog clear flag  register) 
        .equ DFSDM_DFSDM2_AWCFR_CLRAWLTF_Shift, 0   @ bitWidth 8 (Clear the analog watchdog low threshold  flag)  
        .equ DFSDM_DFSDM2_AWCFR_CLRAWHTF_Shift, 8   @ bitWidth 8 (Clear the analog watchdog high threshold  flag)  
 
    .equ DFSDM_DFSDM3_AWCFR, DFSDM_BASE + 0x15C @ (DFSDM analog watchdog clear flag  register) 
        .equ DFSDM_DFSDM3_AWCFR_CLRAWLTF_Shift, 0   @ bitWidth 8 (Clear the analog watchdog low threshold  flag)  
        .equ DFSDM_DFSDM3_AWCFR_CLRAWHTF_Shift, 8   @ bitWidth 8 (Clear the analog watchdog high threshold  flag)  
 
    .equ DFSDM_DFSDM0_EXMAX, DFSDM_BASE + 0x160 @ (DFSDM Extremes detector maximum  register) 
        .equ DFSDM_DFSDM0_EXMAX_EXMAXCH_Shift, 0   @ bitWidth 3 (Extremes detector maximum data  channel)  
        .equ DFSDM_DFSDM0_EXMAX_EXMAX_Shift, 8   @ bitWidth 24 (Extremes detector maximum  value)  
 
    .equ DFSDM_DFSDM1_EXMAX, DFSDM_BASE + 0x164 @ (DFSDM Extremes detector maximum  register) 
        .equ DFSDM_DFSDM1_EXMAX_EXMAXCH_Shift, 0   @ bitWidth 3 (Extremes detector maximum data  channel)  
        .equ DFSDM_DFSDM1_EXMAX_EXMAX_Shift, 8   @ bitWidth 24 (Extremes detector maximum  value)  
 
    .equ DFSDM_DFSDM2_EXMAX, DFSDM_BASE + 0x168 @ (DFSDM Extremes detector maximum  register) 
        .equ DFSDM_DFSDM2_EXMAX_EXMAXCH_Shift, 0   @ bitWidth 3 (Extremes detector maximum data  channel)  
        .equ DFSDM_DFSDM2_EXMAX_EXMAX_Shift, 8   @ bitWidth 24 (Extremes detector maximum  value)  
 
    .equ DFSDM_DFSDM3_EXMAX, DFSDM_BASE + 0x16C @ (DFSDM Extremes detector maximum  register) 
        .equ DFSDM_DFSDM3_EXMAX_EXMAXCH_Shift, 0   @ bitWidth 3 (Extremes detector maximum data  channel)  
        .equ DFSDM_DFSDM3_EXMAX_EXMAX_Shift, 8   @ bitWidth 24 (Extremes detector maximum  value)  
 
    .equ DFSDM_DFSDM0_EXMIN, DFSDM_BASE + 0x170 @ (DFSDM Extremes detector minimum  register) 
        .equ DFSDM_DFSDM0_EXMIN_EXMINCH_Shift, 0   @ bitWidth 3 (Extremes detector minimum data  channel)  
        .equ DFSDM_DFSDM0_EXMIN_EXMIN_Shift, 8   @ bitWidth 24 (Extremes detector minimum  value)  
 
    .equ DFSDM_DFSDM1_EXMIN, DFSDM_BASE + 0x174 @ (DFSDM Extremes detector minimum  register) 
        .equ DFSDM_DFSDM1_EXMIN_EXMINCH_Shift, 0   @ bitWidth 3 (Extremes detector minimum data  channel)  
        .equ DFSDM_DFSDM1_EXMIN_EXMIN_Shift, 8   @ bitWidth 24 (Extremes detector minimum  value)  
 
    .equ DFSDM_DFSDM2_EXMIN, DFSDM_BASE + 0x178 @ (DFSDM Extremes detector minimum  register) 
        .equ DFSDM_DFSDM2_EXMIN_EXMINCH_Shift, 0   @ bitWidth 3 (Extremes detector minimum data  channel)  
        .equ DFSDM_DFSDM2_EXMIN_EXMIN_Shift, 8   @ bitWidth 24 (Extremes detector minimum  value)  
 
    .equ DFSDM_DFSDM3_EXMIN, DFSDM_BASE + 0x17C @ (DFSDM Extremes detector minimum  register) 
        .equ DFSDM_DFSDM3_EXMIN_EXMINCH_Shift, 0   @ bitWidth 3 (Extremes detector minimum data  channel)  
        .equ DFSDM_DFSDM3_EXMIN_EXMIN_Shift, 8   @ bitWidth 24 (Extremes detector minimum  value)  
 
    .equ DFSDM_DFSDM0_CNVTIMR, DFSDM_BASE + 0x180 @ (DFSDM conversion timer  register) 
        .equ DFSDM_DFSDM0_CNVTIMR_CNVCNT_Shift, 4   @ bitWidth 28 (28-bit timer counting conversion  time)  
 
    .equ DFSDM_DFSDM1_CNVTIMR, DFSDM_BASE + 0x184 @ (DFSDM conversion timer  register) 
        .equ DFSDM_DFSDM1_CNVTIMR_CNVCNT_Shift, 4   @ bitWidth 28 (28-bit timer counting conversion  time)  
 
    .equ DFSDM_DFSDM2_CNVTIMR, DFSDM_BASE + 0x188 @ (DFSDM conversion timer  register) 
        .equ DFSDM_DFSDM2_CNVTIMR_CNVCNT_Shift, 4   @ bitWidth 28 (28-bit timer counting conversion  time)  
 
    .equ DFSDM_DFSDM3_CNVTIMR, DFSDM_BASE + 0x18C @ (DFSDM conversion timer  register) 
        .equ DFSDM_DFSDM3_CNVTIMR_CNVCNT_Shift, 4   @ bitWidth 28 (28-bit timer counting conversion  time)  
 

@=========================== TIM16 ===========================@
.equ TIM16_BASE, 0x40014400 @ (General-purpose-timers) 
    .equ TIM16_CR1, TIM16_BASE + 0x0 @ (control register 1) 
        .equ TIM16_CR1_CEN, 1 << 0   @ bitWidth 1 (Counter enable)  
        .equ TIM16_CR1_UDIS, 1 << 1   @ bitWidth 1 (Update disable)  
        .equ TIM16_CR1_URS, 1 << 2   @ bitWidth 1 (Update request source)  
        .equ TIM16_CR1_OPM, 1 << 3   @ bitWidth 1 (One-pulse mode)  
        .equ TIM16_CR1_ARPE, 1 << 7   @ bitWidth 1 (Auto-reload preload enable)  
        .equ TIM16_CR1_CKD_Shift, 8   @ bitWidth 2 (Clock division)  
        .equ TIM16_CR1_UIFREMAP, 1 << 11   @ bitWidth 1 (UIF status bit remapping)  
 
    .equ TIM16_CR2, TIM16_BASE + 0x4 @ (control register 2) 
        .equ TIM16_CR2_OIS1N, 1 << 9   @ bitWidth 1 (Output Idle state 1)  
        .equ TIM16_CR2_OIS1, 1 << 8   @ bitWidth 1 (Output Idle state 1)  
        .equ TIM16_CR2_CCDS, 1 << 3   @ bitWidth 1 (Capture/compare DMA  selection)  
        .equ TIM16_CR2_CCUS, 1 << 2   @ bitWidth 1 (Capture/compare control update  selection)  
        .equ TIM16_CR2_CCPC, 1 << 0   @ bitWidth 1 (Capture/compare preloaded  control)  
 
    .equ TIM16_DIER, TIM16_BASE + 0xC @ (DMA/Interrupt enable register) 
        .equ TIM16_DIER_UIE, 1 << 0   @ bitWidth 1 (Update interrupt enable)  
        .equ TIM16_DIER_CC1IE, 1 << 1   @ bitWidth 1 (Capture/Compare 1 interrupt  enable)  
        .equ TIM16_DIER_COMIE, 1 << 5   @ bitWidth 1 (COM interrupt enable)  
        .equ TIM16_DIER_BIE, 1 << 7   @ bitWidth 1 (Break interrupt enable)  
        .equ TIM16_DIER_UDE, 1 << 8   @ bitWidth 1 (Update DMA request enable)  
        .equ TIM16_DIER_CC1DE, 1 << 9   @ bitWidth 1 (Capture/Compare 1 DMA request  enable)  
        .equ TIM16_DIER_COMDE, 1 << 13   @ bitWidth 1 (COM DMA request enable)  
 
    .equ TIM16_SR, TIM16_BASE + 0x10 @ (status register) 
        .equ TIM16_SR_CC1OF, 1 << 9   @ bitWidth 1 (Capture/Compare 1 overcapture  flag)  
        .equ TIM16_SR_BIF, 1 << 7   @ bitWidth 1 (Break interrupt flag)  
        .equ TIM16_SR_COMIF, 1 << 5   @ bitWidth 1 (COM interrupt flag)  
        .equ TIM16_SR_CC1IF, 1 << 1   @ bitWidth 1 (Capture/compare 1 interrupt  flag)  
        .equ TIM16_SR_UIF, 1 << 0   @ bitWidth 1 (Update interrupt flag)  
 
    .equ TIM16_EGR, TIM16_BASE + 0x14 @ (event generation register) 
        .equ TIM16_EGR_BG, 1 << 7   @ bitWidth 1 (Break generation)  
        .equ TIM16_EGR_COMG, 1 << 5   @ bitWidth 1 (Capture/Compare control update  generation)  
        .equ TIM16_EGR_CC1G, 1 << 1   @ bitWidth 1 (Capture/compare 1  generation)  
        .equ TIM16_EGR_UG, 1 << 0   @ bitWidth 1 (Update generation)  
 
    .equ TIM16_CCMR1_Output, TIM16_BASE + 0x18 @ (capture/compare mode register output  mode) 
        .equ TIM16_CCMR1_Output_CC1S_Shift, 0   @ bitWidth 2 (Capture/Compare 1  selection)  
        .equ TIM16_CCMR1_Output_OC1FE, 1 << 2   @ bitWidth 1 (Output Compare 1 fast  enable)  
        .equ TIM16_CCMR1_Output_OC1PE, 1 << 3   @ bitWidth 1 (Output Compare 1 preload  enable)  
        .equ TIM16_CCMR1_Output_OC1M_Shift, 4   @ bitWidth 3 (Output Compare 1 mode)  
        .equ TIM16_CCMR1_Output_OC1M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode)  
 
    .equ TIM16_CCMR1_Input, TIM16_BASE + 0x18 @ (capture/compare mode register 1 input  mode) 
        .equ TIM16_CCMR1_Input_IC1F_Shift, 4   @ bitWidth 4 (Input capture 1 filter)  
        .equ TIM16_CCMR1_Input_IC1PSC_Shift, 2   @ bitWidth 2 (Input capture 1 prescaler)  
        .equ TIM16_CCMR1_Input_CC1S_Shift, 0   @ bitWidth 2 (Capture/Compare 1  selection)  
 
    .equ TIM16_CCER, TIM16_BASE + 0x20 @ (capture/compare enable  register) 
        .equ TIM16_CCER_CC1NP, 1 << 3   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM16_CCER_CC1NE, 1 << 2   @ bitWidth 1 (Capture/Compare 1 complementary output  enable)  
        .equ TIM16_CCER_CC1P, 1 << 1   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM16_CCER_CC1E, 1 << 0   @ bitWidth 1 (Capture/Compare 1 output  enable)  
 
    .equ TIM16_CNT, TIM16_BASE + 0x24 @ (counter) 
        .equ TIM16_CNT_CNT_Shift, 0   @ bitWidth 16 (counter value)  
        .equ TIM16_CNT_UIFCPY, 1 << 31   @ bitWidth 1 (UIF Copy)  
 
    .equ TIM16_PSC, TIM16_BASE + 0x28 @ (prescaler) 
        .equ TIM16_PSC_PSC_Shift, 0   @ bitWidth 16 (Prescaler value)  
 
    .equ TIM16_ARR, TIM16_BASE + 0x2C @ (auto-reload register) 
        .equ TIM16_ARR_ARR_Shift, 0   @ bitWidth 16 (Auto-reload value)  
 
    .equ TIM16_RCR, TIM16_BASE + 0x30 @ (repetition counter register) 
        .equ TIM16_RCR_REP_Shift, 0   @ bitWidth 8 (Repetition counter value)  
 
    .equ TIM16_CCR1, TIM16_BASE + 0x34 @ (capture/compare register 1) 
        .equ TIM16_CCR1_CCR1_Shift, 0   @ bitWidth 16 (Capture/Compare 1 value)  
 
    .equ TIM16_BDTR, TIM16_BASE + 0x44 @ (break and dead-time register) 
        .equ TIM16_BDTR_DTG_Shift, 0   @ bitWidth 8 (Dead-time generator setup)  
        .equ TIM16_BDTR_LOCK_Shift, 8   @ bitWidth 2 (Lock configuration)  
        .equ TIM16_BDTR_OSSI, 1 << 10   @ bitWidth 1 (Off-state selection for Idle  mode)  
        .equ TIM16_BDTR_OSSR, 1 << 11   @ bitWidth 1 (Off-state selection for Run  mode)  
        .equ TIM16_BDTR_BKE, 1 << 12   @ bitWidth 1 (Break enable)  
        .equ TIM16_BDTR_BKP, 1 << 13   @ bitWidth 1 (Break polarity)  
        .equ TIM16_BDTR_AOE, 1 << 14   @ bitWidth 1 (Automatic output enable)  
        .equ TIM16_BDTR_MOE, 1 << 15   @ bitWidth 1 (Main output enable)  
        .equ TIM16_BDTR_BKF_Shift, 16   @ bitWidth 4 (Break filter)  
 
    .equ TIM16_DCR, TIM16_BASE + 0x48 @ (DMA control register) 
        .equ TIM16_DCR_DBL_Shift, 8   @ bitWidth 5 (DMA burst length)  
        .equ TIM16_DCR_DBA_Shift, 0   @ bitWidth 5 (DMA base address)  
 
    .equ TIM16_DMAR, TIM16_BASE + 0x4C @ (DMA address for full transfer) 
        .equ TIM16_DMAR_DMAB_Shift, 0   @ bitWidth 16 (DMA register for burst  accesses)  
 
    .equ TIM16_TIM16_AF1, TIM16_BASE + 0x60 @ (TIM16 alternate function register  1) 
        .equ TIM16_TIM16_AF1_BKINE, 1 << 0   @ bitWidth 1 (BRK BKIN input enable)  
        .equ TIM16_TIM16_AF1_BKCMP1E, 1 << 1   @ bitWidth 1 (BRK COMP1 enable)  
        .equ TIM16_TIM16_AF1_BKCMP2E, 1 << 2   @ bitWidth 1 (BRK COMP2 enable)  
        .equ TIM16_TIM16_AF1_BKDFBK1E, 1 << 8   @ bitWidth 1 (BRK dfsdm1_break[1] enable)  
        .equ TIM16_TIM16_AF1_BKINP, 1 << 9   @ bitWidth 1 (BRK BKIN input polarity)  
        .equ TIM16_TIM16_AF1_BKCMP1P, 1 << 10   @ bitWidth 1 (BRK COMP1 input polarity)  
        .equ TIM16_TIM16_AF1_BKCMP2P, 1 << 11   @ bitWidth 1 (BRK COMP2 input polarity)  
 
    .equ TIM16_TIM16_TISEL, TIM16_BASE + 0x68 @ (TIM16 input selection register) 
        .equ TIM16_TIM16_TISEL_TI1SEL_Shift, 0   @ bitWidth 4 (selects TI1[0] to TI1[15]  input)  
 

@=========================== TIM17 ===========================@
.equ TIM17_BASE, 0x40014800 @ (General-purpose-timers) 
    .equ TIM17_CR1, TIM17_BASE + 0x0 @ (control register 1) 
        .equ TIM17_CR1_CEN, 1 << 0   @ bitWidth 1 (Counter enable)  
        .equ TIM17_CR1_UDIS, 1 << 1   @ bitWidth 1 (Update disable)  
        .equ TIM17_CR1_URS, 1 << 2   @ bitWidth 1 (Update request source)  
        .equ TIM17_CR1_OPM, 1 << 3   @ bitWidth 1 (One-pulse mode)  
        .equ TIM17_CR1_ARPE, 1 << 7   @ bitWidth 1 (Auto-reload preload enable)  
        .equ TIM17_CR1_CKD_Shift, 8   @ bitWidth 2 (Clock division)  
        .equ TIM17_CR1_UIFREMAP, 1 << 11   @ bitWidth 1 (UIF status bit remapping)  
 
    .equ TIM17_CR2, TIM17_BASE + 0x4 @ (control register 2) 
        .equ TIM17_CR2_OIS1N, 1 << 9   @ bitWidth 1 (Output Idle state 1)  
        .equ TIM17_CR2_OIS1, 1 << 8   @ bitWidth 1 (Output Idle state 1)  
        .equ TIM17_CR2_CCDS, 1 << 3   @ bitWidth 1 (Capture/compare DMA  selection)  
        .equ TIM17_CR2_CCUS, 1 << 2   @ bitWidth 1 (Capture/compare control update  selection)  
        .equ TIM17_CR2_CCPC, 1 << 0   @ bitWidth 1 (Capture/compare preloaded  control)  
 
    .equ TIM17_DIER, TIM17_BASE + 0xC @ (DMA/Interrupt enable register) 
        .equ TIM17_DIER_UIE, 1 << 0   @ bitWidth 1 (Update interrupt enable)  
        .equ TIM17_DIER_CC1IE, 1 << 1   @ bitWidth 1 (Capture/Compare 1 interrupt  enable)  
        .equ TIM17_DIER_COMIE, 1 << 5   @ bitWidth 1 (COM interrupt enable)  
        .equ TIM17_DIER_BIE, 1 << 7   @ bitWidth 1 (Break interrupt enable)  
        .equ TIM17_DIER_UDE, 1 << 8   @ bitWidth 1 (Update DMA request enable)  
        .equ TIM17_DIER_CC1DE, 1 << 9   @ bitWidth 1 (Capture/Compare 1 DMA request  enable)  
        .equ TIM17_DIER_COMDE, 1 << 13   @ bitWidth 1 (COM DMA request enable)  
 
    .equ TIM17_SR, TIM17_BASE + 0x10 @ (status register) 
        .equ TIM17_SR_CC1OF, 1 << 9   @ bitWidth 1 (Capture/Compare 1 overcapture  flag)  
        .equ TIM17_SR_BIF, 1 << 7   @ bitWidth 1 (Break interrupt flag)  
        .equ TIM17_SR_COMIF, 1 << 5   @ bitWidth 1 (COM interrupt flag)  
        .equ TIM17_SR_CC1IF, 1 << 1   @ bitWidth 1 (Capture/compare 1 interrupt  flag)  
        .equ TIM17_SR_UIF, 1 << 0   @ bitWidth 1 (Update interrupt flag)  
 
    .equ TIM17_EGR, TIM17_BASE + 0x14 @ (event generation register) 
        .equ TIM17_EGR_BG, 1 << 7   @ bitWidth 1 (Break generation)  
        .equ TIM17_EGR_COMG, 1 << 5   @ bitWidth 1 (Capture/Compare control update  generation)  
        .equ TIM17_EGR_CC1G, 1 << 1   @ bitWidth 1 (Capture/compare 1  generation)  
        .equ TIM17_EGR_UG, 1 << 0   @ bitWidth 1 (Update generation)  
 
    .equ TIM17_CCMR1_Output, TIM17_BASE + 0x18 @ (capture/compare mode register output  mode) 
        .equ TIM17_CCMR1_Output_CC1S_Shift, 0   @ bitWidth 2 (Capture/Compare 1  selection)  
        .equ TIM17_CCMR1_Output_OC1FE, 1 << 2   @ bitWidth 1 (Output Compare 1 fast  enable)  
        .equ TIM17_CCMR1_Output_OC1PE, 1 << 3   @ bitWidth 1 (Output Compare 1 preload  enable)  
        .equ TIM17_CCMR1_Output_OC1M_Shift, 4   @ bitWidth 3 (Output Compare 1 mode)  
        .equ TIM17_CCMR1_Output_OC1M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode)  
 
    .equ TIM17_CCMR1_Input, TIM17_BASE + 0x18 @ (capture/compare mode register 1 input  mode) 
        .equ TIM17_CCMR1_Input_IC1F_Shift, 4   @ bitWidth 4 (Input capture 1 filter)  
        .equ TIM17_CCMR1_Input_IC1PSC_Shift, 2   @ bitWidth 2 (Input capture 1 prescaler)  
        .equ TIM17_CCMR1_Input_CC1S_Shift, 0   @ bitWidth 2 (Capture/Compare 1  selection)  
 
    .equ TIM17_CCER, TIM17_BASE + 0x20 @ (capture/compare enable  register) 
        .equ TIM17_CCER_CC1NP, 1 << 3   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM17_CCER_CC1NE, 1 << 2   @ bitWidth 1 (Capture/Compare 1 complementary output  enable)  
        .equ TIM17_CCER_CC1P, 1 << 1   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM17_CCER_CC1E, 1 << 0   @ bitWidth 1 (Capture/Compare 1 output  enable)  
 
    .equ TIM17_CNT, TIM17_BASE + 0x24 @ (counter) 
        .equ TIM17_CNT_CNT_Shift, 0   @ bitWidth 16 (counter value)  
        .equ TIM17_CNT_UIFCPY, 1 << 31   @ bitWidth 1 (UIF Copy)  
 
    .equ TIM17_PSC, TIM17_BASE + 0x28 @ (prescaler) 
        .equ TIM17_PSC_PSC_Shift, 0   @ bitWidth 16 (Prescaler value)  
 
    .equ TIM17_ARR, TIM17_BASE + 0x2C @ (auto-reload register) 
        .equ TIM17_ARR_ARR_Shift, 0   @ bitWidth 16 (Auto-reload value)  
 
    .equ TIM17_RCR, TIM17_BASE + 0x30 @ (repetition counter register) 
        .equ TIM17_RCR_REP_Shift, 0   @ bitWidth 8 (Repetition counter value)  
 
    .equ TIM17_CCR1, TIM17_BASE + 0x34 @ (capture/compare register 1) 
        .equ TIM17_CCR1_CCR1_Shift, 0   @ bitWidth 16 (Capture/Compare 1 value)  
 
    .equ TIM17_BDTR, TIM17_BASE + 0x44 @ (break and dead-time register) 
        .equ TIM17_BDTR_DTG_Shift, 0   @ bitWidth 8 (Dead-time generator setup)  
        .equ TIM17_BDTR_LOCK_Shift, 8   @ bitWidth 2 (Lock configuration)  
        .equ TIM17_BDTR_OSSI, 1 << 10   @ bitWidth 1 (Off-state selection for Idle  mode)  
        .equ TIM17_BDTR_OSSR, 1 << 11   @ bitWidth 1 (Off-state selection for Run  mode)  
        .equ TIM17_BDTR_BKE, 1 << 12   @ bitWidth 1 (Break enable)  
        .equ TIM17_BDTR_BKP, 1 << 13   @ bitWidth 1 (Break polarity)  
        .equ TIM17_BDTR_AOE, 1 << 14   @ bitWidth 1 (Automatic output enable)  
        .equ TIM17_BDTR_MOE, 1 << 15   @ bitWidth 1 (Main output enable)  
        .equ TIM17_BDTR_BKF_Shift, 16   @ bitWidth 4 (Break filter)  
 
    .equ TIM17_DCR, TIM17_BASE + 0x48 @ (DMA control register) 
        .equ TIM17_DCR_DBL_Shift, 8   @ bitWidth 5 (DMA burst length)  
        .equ TIM17_DCR_DBA_Shift, 0   @ bitWidth 5 (DMA base address)  
 
    .equ TIM17_DMAR, TIM17_BASE + 0x4C @ (DMA address for full transfer) 
        .equ TIM17_DMAR_DMAB_Shift, 0   @ bitWidth 16 (DMA register for burst  accesses)  
 
    .equ TIM17_TIM17_AF1, TIM17_BASE + 0x60 @ (TIM17 alternate function register  1) 
        .equ TIM17_TIM17_AF1_BKINE, 1 << 0   @ bitWidth 1 (BRK BKIN input enable)  
        .equ TIM17_TIM17_AF1_BKCMP1E, 1 << 1   @ bitWidth 1 (BRK COMP1 enable)  
        .equ TIM17_TIM17_AF1_BKCMP2E, 1 << 2   @ bitWidth 1 (BRK COMP2 enable)  
        .equ TIM17_TIM17_AF1_BKDFBK1E, 1 << 8   @ bitWidth 1 (BRK dfsdm1_break[1] enable)  
        .equ TIM17_TIM17_AF1_BKINP, 1 << 9   @ bitWidth 1 (BRK BKIN input polarity)  
        .equ TIM17_TIM17_AF1_BKCMP1P, 1 << 10   @ bitWidth 1 (BRK COMP1 input polarity)  
        .equ TIM17_TIM17_AF1_BKCMP2P, 1 << 11   @ bitWidth 1 (BRK COMP2 input polarity)  
 
    .equ TIM17_TIM17_TISEL, TIM17_BASE + 0x68 @ (TIM17 input selection register) 
        .equ TIM17_TIM17_TISEL_TI1SEL_Shift, 0   @ bitWidth 4 (selects TI1[0] to TI1[15]  input)  
 

@=========================== TIM15 ===========================@
.equ TIM15_BASE, 0x40014000 @ (General purpose timers) 
    .equ TIM15_CR1, TIM15_BASE + 0x0 @ (control register 1) 
        .equ TIM15_CR1_CEN, 1 << 0   @ bitWidth 1 (Counter enable)  
        .equ TIM15_CR1_UDIS, 1 << 1   @ bitWidth 1 (Update disable)  
        .equ TIM15_CR1_URS, 1 << 2   @ bitWidth 1 (Update request source)  
        .equ TIM15_CR1_OPM, 1 << 3   @ bitWidth 1 (One-pulse mode)  
        .equ TIM15_CR1_ARPE, 1 << 7   @ bitWidth 1 (Auto-reload preload enable)  
        .equ TIM15_CR1_CKD_Shift, 8   @ bitWidth 2 (Clock division)  
        .equ TIM15_CR1_UIFREMAP, 1 << 11   @ bitWidth 1 (UIF status bit remapping)  
 
    .equ TIM15_CR2, TIM15_BASE + 0x4 @ (control register 2) 
        .equ TIM15_CR2_CCPC, 1 << 0   @ bitWidth 1 (Capture/compare preloaded  control)  
        .equ TIM15_CR2_CCUS, 1 << 2   @ bitWidth 1 (Capture/compare control update  selection)  
        .equ TIM15_CR2_CCDS, 1 << 3   @ bitWidth 1 (Capture/compare DMA  selection)  
        .equ TIM15_CR2_MMS_Shift, 4   @ bitWidth 3 (Master mode selection)  
        .equ TIM15_CR2_TI1S, 1 << 7   @ bitWidth 1 (TI1 selection)  
        .equ TIM15_CR2_OIS1, 1 << 8   @ bitWidth 1 (Output Idle state 1)  
        .equ TIM15_CR2_OIS1N, 1 << 9   @ bitWidth 1 (Output Idle state 1)  
        .equ TIM15_CR2_OIS2, 1 << 10   @ bitWidth 1 (Output Idle state 2)  
 
    .equ TIM15_SMCR, TIM15_BASE + 0x8 @ (slave mode control register) 
        .equ TIM15_SMCR_SMS_Shift, 0   @ bitWidth 3 (Slave mode selection)  
        .equ TIM15_SMCR_TS_2_0_Shift, 4   @ bitWidth 3 (Trigger selection)  
        .equ TIM15_SMCR_MSM, 1 << 7   @ bitWidth 1 (Master/Slave mode)  
        .equ TIM15_SMCR_SMS_3, 1 << 16   @ bitWidth 1 (Slave mode selection bit 3)  
        .equ TIM15_SMCR_TS_4_3_Shift, 20   @ bitWidth 2 (Trigger selection - bit  4:3)  
 
    .equ TIM15_DIER, TIM15_BASE + 0xC @ (DMA/Interrupt enable register) 
        .equ TIM15_DIER_UIE, 1 << 0   @ bitWidth 1 (Update interrupt enable)  
        .equ TIM15_DIER_CC1IE, 1 << 1   @ bitWidth 1 (Capture/Compare 1 interrupt  enable)  
        .equ TIM15_DIER_CC2IE, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  enable)  
        .equ TIM15_DIER_COMIE, 1 << 5   @ bitWidth 1 (COM interrupt enable)  
        .equ TIM15_DIER_TIE, 1 << 6   @ bitWidth 1 (Trigger interrupt enable)  
        .equ TIM15_DIER_BIE, 1 << 7   @ bitWidth 1 (Break interrupt enable)  
        .equ TIM15_DIER_UDE, 1 << 8   @ bitWidth 1 (Update DMA request enable)  
        .equ TIM15_DIER_CC1DE, 1 << 9   @ bitWidth 1 (Capture/Compare 1 DMA request  enable)  
        .equ TIM15_DIER_CC2DE, 1 << 10   @ bitWidth 1 (Capture/Compare 2 DMA request  enable)  
        .equ TIM15_DIER_COMDE, 1 << 13   @ bitWidth 1 (COM DMA request enable)  
        .equ TIM15_DIER_TDE, 1 << 14   @ bitWidth 1 (Trigger DMA request enable)  
 
    .equ TIM15_SR, TIM15_BASE + 0x10 @ (status register) 
        .equ TIM15_SR_CC2OF, 1 << 10   @ bitWidth 1 (Capture/compare 2 overcapture  flag)  
        .equ TIM15_SR_CC1OF, 1 << 9   @ bitWidth 1 (Capture/Compare 1 overcapture  flag)  
        .equ TIM15_SR_BIF, 1 << 7   @ bitWidth 1 (Break interrupt flag)  
        .equ TIM15_SR_TIF, 1 << 6   @ bitWidth 1 (Trigger interrupt flag)  
        .equ TIM15_SR_COMIF, 1 << 5   @ bitWidth 1 (COM interrupt flag)  
        .equ TIM15_SR_CC2IF, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  flag)  
        .equ TIM15_SR_CC1IF, 1 << 1   @ bitWidth 1 (Capture/compare 1 interrupt  flag)  
        .equ TIM15_SR_UIF, 1 << 0   @ bitWidth 1 (Update interrupt flag)  
 
    .equ TIM15_EGR, TIM15_BASE + 0x14 @ (event generation register) 
        .equ TIM15_EGR_BG, 1 << 7   @ bitWidth 1 (Break generation)  
        .equ TIM15_EGR_TG, 1 << 6   @ bitWidth 1 (Trigger generation)  
        .equ TIM15_EGR_COMG, 1 << 5   @ bitWidth 1 (Capture/Compare control update  generation)  
        .equ TIM15_EGR_CC2G, 1 << 2   @ bitWidth 1 (Capture/compare 2  generation)  
        .equ TIM15_EGR_CC1G, 1 << 1   @ bitWidth 1 (Capture/compare 1  generation)  
        .equ TIM15_EGR_UG, 1 << 0   @ bitWidth 1 (Update generation)  
 
    .equ TIM15_CCMR1_Output, TIM15_BASE + 0x18 @ (capture/compare mode register output  mode) 
        .equ TIM15_CCMR1_Output_CC1S_Shift, 0   @ bitWidth 2 (Capture/Compare 1  selection)  
        .equ TIM15_CCMR1_Output_OC1FE, 1 << 2   @ bitWidth 1 (Output Compare 1 fast  enable)  
        .equ TIM15_CCMR1_Output_OC1PE, 1 << 3   @ bitWidth 1 (Output Compare 1 preload  enable)  
        .equ TIM15_CCMR1_Output_OC1M_Shift, 4   @ bitWidth 3 (Output Compare 1 mode)  
        .equ TIM15_CCMR1_Output_CC2S_Shift, 8   @ bitWidth 2 (Capture/Compare 2  selection)  
        .equ TIM15_CCMR1_Output_OC2FE, 1 << 10   @ bitWidth 1 (Output Compare 2 fast  enable)  
        .equ TIM15_CCMR1_Output_OC2PE, 1 << 11   @ bitWidth 1 (Output Compare 2 preload  enable)  
        .equ TIM15_CCMR1_Output_OC2M_Shift, 12   @ bitWidth 3 (Output Compare 2 mode)  
        .equ TIM15_CCMR1_Output_OC1M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode bit  3)  
        .equ TIM15_CCMR1_Output_OC2M_3, 1 << 24   @ bitWidth 1 (Output Compare 2 mode bit  3)  
 
    .equ TIM15_CCMR1_Input, TIM15_BASE + 0x18 @ (capture/compare mode register 1 input  mode) 
        .equ TIM15_CCMR1_Input_IC2F_Shift, 12   @ bitWidth 4 (Input capture 2 filter)  
        .equ TIM15_CCMR1_Input_IC2PSC_Shift, 10   @ bitWidth 2 (Input capture 2 prescaler)  
        .equ TIM15_CCMR1_Input_CC2S_Shift, 8   @ bitWidth 2 (Capture/Compare 2  selection)  
        .equ TIM15_CCMR1_Input_IC1F_Shift, 4   @ bitWidth 4 (Input capture 1 filter)  
        .equ TIM15_CCMR1_Input_IC1PSC_Shift, 2   @ bitWidth 2 (Input capture 1 prescaler)  
        .equ TIM15_CCMR1_Input_CC1S_Shift, 0   @ bitWidth 2 (Capture/Compare 1  selection)  
 
    .equ TIM15_CCER, TIM15_BASE + 0x20 @ (capture/compare enable  register) 
        .equ TIM15_CCER_CC2NP, 1 << 7   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM15_CCER_CC2P, 1 << 5   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM15_CCER_CC2E, 1 << 4   @ bitWidth 1 (Capture/Compare 2 output  enable)  
        .equ TIM15_CCER_CC1NP, 1 << 3   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM15_CCER_CC1NE, 1 << 2   @ bitWidth 1 (Capture/Compare 1 complementary output  enable)  
        .equ TIM15_CCER_CC1P, 1 << 1   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM15_CCER_CC1E, 1 << 0   @ bitWidth 1 (Capture/Compare 1 output  enable)  
 
    .equ TIM15_CNT, TIM15_BASE + 0x24 @ (counter) 
        .equ TIM15_CNT_CNT_Shift, 0   @ bitWidth 16 (counter value)  
        .equ TIM15_CNT_UIFCPY, 1 << 31   @ bitWidth 1 (UIF copy)  
 
    .equ TIM15_PSC, TIM15_BASE + 0x28 @ (prescaler) 
        .equ TIM15_PSC_PSC_Shift, 0   @ bitWidth 16 (Prescaler value)  
 
    .equ TIM15_ARR, TIM15_BASE + 0x2C @ (auto-reload register) 
        .equ TIM15_ARR_ARR_Shift, 0   @ bitWidth 16 (Auto-reload value)  
 
    .equ TIM15_RCR, TIM15_BASE + 0x30 @ (repetition counter register) 
        .equ TIM15_RCR_REP_Shift, 0   @ bitWidth 8 (Repetition counter value)  
 
    .equ TIM15_CCR1, TIM15_BASE + 0x34 @ (capture/compare register 1) 
        .equ TIM15_CCR1_CCR1_Shift, 0   @ bitWidth 16 (Capture/Compare 1 value)  
 
    .equ TIM15_CCR2, TIM15_BASE + 0x38 @ (capture/compare register 2) 
        .equ TIM15_CCR2_CCR2_Shift, 0   @ bitWidth 16 (Capture/Compare 2 value)  
 
    .equ TIM15_BDTR, TIM15_BASE + 0x44 @ (break and dead-time register) 
        .equ TIM15_BDTR_MOE, 1 << 15   @ bitWidth 1 (Main output enable)  
        .equ TIM15_BDTR_AOE, 1 << 14   @ bitWidth 1 (Automatic output enable)  
        .equ TIM15_BDTR_BKP, 1 << 13   @ bitWidth 1 (Break polarity)  
        .equ TIM15_BDTR_BKE, 1 << 12   @ bitWidth 1 (Break enable)  
        .equ TIM15_BDTR_OSSR, 1 << 11   @ bitWidth 1 (Off-state selection for Run  mode)  
        .equ TIM15_BDTR_OSSI, 1 << 10   @ bitWidth 1 (Off-state selection for Idle  mode)  
        .equ TIM15_BDTR_LOCK_Shift, 8   @ bitWidth 2 (Lock configuration)  
        .equ TIM15_BDTR_DTG_Shift, 0   @ bitWidth 8 (Dead-time generator setup)  
        .equ TIM15_BDTR_BKF_Shift, 16   @ bitWidth 4 (Break filter)  
 
    .equ TIM15_DCR, TIM15_BASE + 0x48 @ (DMA control register) 
        .equ TIM15_DCR_DBL_Shift, 8   @ bitWidth 5 (DMA burst length)  
        .equ TIM15_DCR_DBA_Shift, 0   @ bitWidth 5 (DMA base address)  
 
    .equ TIM15_DMAR, TIM15_BASE + 0x4C @ (DMA address for full transfer) 
        .equ TIM15_DMAR_DMAB_Shift, 0   @ bitWidth 16 (DMA register for burst  accesses)  
 
    .equ TIM15_AF1, TIM15_BASE + 0x60 @ (TIM15 alternate fdfsdm1_breakon register  1) 
        .equ TIM15_AF1_BKINE, 1 << 0   @ bitWidth 1 (BRK BKIN input enable)  
        .equ TIM15_AF1_BKCMP1E, 1 << 1   @ bitWidth 1 (BRK COMP1 enable)  
        .equ TIM15_AF1_BKCMP2E, 1 << 2   @ bitWidth 1 (BRK COMP2 enable)  
        .equ TIM15_AF1_BKDF1BK0E, 1 << 8   @ bitWidth 1 (BRK dfsdm1_break[0] enable)  
        .equ TIM15_AF1_BKINP, 1 << 9   @ bitWidth 1 (BRK BKIN input polarity)  
        .equ TIM15_AF1_BKCMP1P, 1 << 10   @ bitWidth 1 (BRK COMP1 input polarity)  
        .equ TIM15_AF1_BKCMP2P, 1 << 11   @ bitWidth 1 (BRK COMP2 input polarity)  
 
    .equ TIM15_TISEL, TIM15_BASE + 0x68 @ (TIM15 input selection register) 
        .equ TIM15_TISEL_TI1SEL_Shift, 0   @ bitWidth 4 (selects TI1[0] to TI1[15]  input)  
        .equ TIM15_TISEL_TI2SEL_Shift, 8   @ bitWidth 4 (selects TI2[0] to TI2[15]  input)  
 

@=========================== USART1 ===========================@
.equ USART1_BASE, 0x40011000 @ (Universal synchronous asynchronous receiver  transmitter) 
    .equ USART1_CR1, USART1_BASE + 0x0 @ (Control register 1) 
        .equ USART1_CR1_RXFFIE, 1 << 31   @ bitWidth 1 (RXFIFO Full interrupt  enable)  
        .equ USART1_CR1_TXFEIE, 1 << 30   @ bitWidth 1 (TXFIFO empty interrupt  enable)  
        .equ USART1_CR1_FIFOEN, 1 << 29   @ bitWidth 1 (FIFO mode enable)  
        .equ USART1_CR1_M1, 1 << 28   @ bitWidth 1 (Word length)  
        .equ USART1_CR1_EOBIE, 1 << 27   @ bitWidth 1 (End of Block interrupt  enable)  
        .equ USART1_CR1_RTOIE, 1 << 26   @ bitWidth 1 (Receiver timeout interrupt  enable)  
        .equ USART1_CR1_DEAT4, 1 << 25   @ bitWidth 1 (Driver Enable assertion  time)  
        .equ USART1_CR1_DEAT3, 1 << 24   @ bitWidth 1 (DEAT3)  
        .equ USART1_CR1_DEAT2, 1 << 23   @ bitWidth 1 (DEAT2)  
        .equ USART1_CR1_DEAT1, 1 << 22   @ bitWidth 1 (DEAT1)  
        .equ USART1_CR1_DEAT0, 1 << 21   @ bitWidth 1 (DEAT0)  
        .equ USART1_CR1_DEDT4, 1 << 20   @ bitWidth 1 (Driver Enable de-assertion  time)  
        .equ USART1_CR1_DEDT3, 1 << 19   @ bitWidth 1 (DEDT3)  
        .equ USART1_CR1_DEDT2, 1 << 18   @ bitWidth 1 (DEDT2)  
        .equ USART1_CR1_DEDT1, 1 << 17   @ bitWidth 1 (DEDT1)  
        .equ USART1_CR1_DEDT0, 1 << 16   @ bitWidth 1 (DEDT0)  
        .equ USART1_CR1_OVER8, 1 << 15   @ bitWidth 1 (Oversampling mode)  
        .equ USART1_CR1_CMIE, 1 << 14   @ bitWidth 1 (Character match interrupt  enable)  
        .equ USART1_CR1_MME, 1 << 13   @ bitWidth 1 (Mute mode enable)  
        .equ USART1_CR1_M0, 1 << 12   @ bitWidth 1 (Word length)  
        .equ USART1_CR1_WAKE, 1 << 11   @ bitWidth 1 (Receiver wakeup method)  
        .equ USART1_CR1_PCE, 1 << 10   @ bitWidth 1 (Parity control enable)  
        .equ USART1_CR1_PS, 1 << 9   @ bitWidth 1 (Parity selection)  
        .equ USART1_CR1_PEIE, 1 << 8   @ bitWidth 1 (PE interrupt enable)  
        .equ USART1_CR1_TXEIE, 1 << 7   @ bitWidth 1 (interrupt enable)  
        .equ USART1_CR1_TCIE, 1 << 6   @ bitWidth 1 (Transmission complete interrupt  enable)  
        .equ USART1_CR1_RXNEIE, 1 << 5   @ bitWidth 1 (RXNE interrupt enable)  
        .equ USART1_CR1_IDLEIE, 1 << 4   @ bitWidth 1 (IDLE interrupt enable)  
        .equ USART1_CR1_TE, 1 << 3   @ bitWidth 1 (Transmitter enable)  
        .equ USART1_CR1_RE, 1 << 2   @ bitWidth 1 (Receiver enable)  
        .equ USART1_CR1_UESM, 1 << 1   @ bitWidth 1 (USART enable in Stop mode)  
        .equ USART1_CR1_UE, 1 << 0   @ bitWidth 1 (USART enable)  
 
    .equ USART1_CR2, USART1_BASE + 0x4 @ (Control register 2) 
        .equ USART1_CR2_ADD4_7_Shift, 28   @ bitWidth 4 (Address of the USART node)  
        .equ USART1_CR2_ADD0_3_Shift, 24   @ bitWidth 4 (Address of the USART node)  
        .equ USART1_CR2_RTOEN, 1 << 23   @ bitWidth 1 (Receiver timeout enable)  
        .equ USART1_CR2_ABRMOD1, 1 << 22   @ bitWidth 1 (Auto baud rate mode)  
        .equ USART1_CR2_ABRMOD0, 1 << 21   @ bitWidth 1 (ABRMOD0)  
        .equ USART1_CR2_ABREN, 1 << 20   @ bitWidth 1 (Auto baud rate enable)  
        .equ USART1_CR2_MSBFIRST, 1 << 19   @ bitWidth 1 (Most significant bit first)  
        .equ USART1_CR2_TAINV, 1 << 18   @ bitWidth 1 (Binary data inversion)  
        .equ USART1_CR2_TXINV, 1 << 17   @ bitWidth 1 (TX pin active level  inversion)  
        .equ USART1_CR2_RXINV, 1 << 16   @ bitWidth 1 (RX pin active level  inversion)  
        .equ USART1_CR2_SWAP, 1 << 15   @ bitWidth 1 (Swap TX/RX pins)  
        .equ USART1_CR2_LINEN, 1 << 14   @ bitWidth 1 (LIN mode enable)  
        .equ USART1_CR2_STOP_Shift, 12   @ bitWidth 2 (STOP bits)  
        .equ USART1_CR2_CLKEN, 1 << 11   @ bitWidth 1 (Clock enable)  
        .equ USART1_CR2_CPOL, 1 << 10   @ bitWidth 1 (Clock polarity)  
        .equ USART1_CR2_CPHA, 1 << 9   @ bitWidth 1 (Clock phase)  
        .equ USART1_CR2_LBCL, 1 << 8   @ bitWidth 1 (Last bit clock pulse)  
        .equ USART1_CR2_LBDIE, 1 << 6   @ bitWidth 1 (LIN break detection interrupt  enable)  
        .equ USART1_CR2_LBDL, 1 << 5   @ bitWidth 1 (LIN break detection length)  
        .equ USART1_CR2_ADDM7, 1 << 4   @ bitWidth 1 (7-bit Address Detection/4-bit Address  Detection)  
        .equ USART1_CR2_DIS_NSS, 1 << 3   @ bitWidth 1 (When the DSI_NSS bit is set, the NSS pin  input is ignored)  
        .equ USART1_CR2_SLVEN, 1 << 0   @ bitWidth 1 (Synchronous Slave mode  enable)  
 
    .equ USART1_CR3, USART1_BASE + 0x8 @ (Control register 3) 
        .equ USART1_CR3_TXFTCFG_Shift, 29   @ bitWidth 3 (TXFIFO threshold  configuration)  
        .equ USART1_CR3_RXFTIE, 1 << 28   @ bitWidth 1 (RXFIFO threshold interrupt  enable)  
        .equ USART1_CR3_RXFTCFG_Shift, 25   @ bitWidth 3 (Receive FIFO threshold  configuration)  
        .equ USART1_CR3_TCBGTIE, 1 << 24   @ bitWidth 1 (Transmission Complete before guard time,  interrupt enable)  
        .equ USART1_CR3_TXFTIE, 1 << 23   @ bitWidth 1 (TXFIFO threshold interrupt  enable)  
        .equ USART1_CR3_WUFIE, 1 << 22   @ bitWidth 1 (Wakeup from Stop mode interrupt  enable)  
        .equ USART1_CR3_WUS_Shift, 20   @ bitWidth 2 (Wakeup from Stop mode interrupt flag  selection)  
        .equ USART1_CR3_SCARCNT_Shift, 17   @ bitWidth 3 (Smartcard auto-retry count)  
        .equ USART1_CR3_DEP, 1 << 15   @ bitWidth 1 (Driver enable polarity  selection)  
        .equ USART1_CR3_DEM, 1 << 14   @ bitWidth 1 (Driver enable mode)  
        .equ USART1_CR3_DDRE, 1 << 13   @ bitWidth 1 (DMA Disable on Reception  Error)  
        .equ USART1_CR3_OVRDIS, 1 << 12   @ bitWidth 1 (Overrun Disable)  
        .equ USART1_CR3_ONEBIT, 1 << 11   @ bitWidth 1 (One sample bit method  enable)  
        .equ USART1_CR3_CTSIE, 1 << 10   @ bitWidth 1 (CTS interrupt enable)  
        .equ USART1_CR3_CTSE, 1 << 9   @ bitWidth 1 (CTS enable)  
        .equ USART1_CR3_RTSE, 1 << 8   @ bitWidth 1 (RTS enable)  
        .equ USART1_CR3_DMAT, 1 << 7   @ bitWidth 1 (DMA enable transmitter)  
        .equ USART1_CR3_DMAR, 1 << 6   @ bitWidth 1 (DMA enable receiver)  
        .equ USART1_CR3_SCEN, 1 << 5   @ bitWidth 1 (Smartcard mode enable)  
        .equ USART1_CR3_NACK, 1 << 4   @ bitWidth 1 (Smartcard NACK enable)  
        .equ USART1_CR3_HDSEL, 1 << 3   @ bitWidth 1 (Half-duplex selection)  
        .equ USART1_CR3_IRLP, 1 << 2   @ bitWidth 1 (Ir low-power)  
        .equ USART1_CR3_IREN, 1 << 1   @ bitWidth 1 (Ir mode enable)  
        .equ USART1_CR3_EIE, 1 << 0   @ bitWidth 1 (Error interrupt enable)  
 
    .equ USART1_BRR, USART1_BASE + 0xC @ (Baud rate register) 
        .equ USART1_BRR_BRR_4_15_Shift, 4   @ bitWidth 12 (DIV_Mantissa)  
        .equ USART1_BRR_BRR_0_3_Shift, 0   @ bitWidth 4 (DIV_Fraction)  
 
    .equ USART1_GTPR, USART1_BASE + 0x10 @ (Guard time and prescaler  register) 
        .equ USART1_GTPR_GT_Shift, 8   @ bitWidth 8 (Guard time value)  
        .equ USART1_GTPR_PSC_Shift, 0   @ bitWidth 8 (Prescaler value)  
 
    .equ USART1_RTOR, USART1_BASE + 0x14 @ (Receiver timeout register) 
        .equ USART1_RTOR_BLEN_Shift, 24   @ bitWidth 8 (Block Length)  
        .equ USART1_RTOR_RTO_Shift, 0   @ bitWidth 24 (Receiver timeout value)  
 
    .equ USART1_RQR, USART1_BASE + 0x18 @ (Request register) 
        .equ USART1_RQR_TXFRQ, 1 << 4   @ bitWidth 1 (Transmit data flush  request)  
        .equ USART1_RQR_RXFRQ, 1 << 3   @ bitWidth 1 (Receive data flush request)  
        .equ USART1_RQR_MMRQ, 1 << 2   @ bitWidth 1 (Mute mode request)  
        .equ USART1_RQR_SBKRQ, 1 << 1   @ bitWidth 1 (Send break request)  
        .equ USART1_RQR_ABRRQ, 1 << 0   @ bitWidth 1 (Auto baud rate request)  
 
    .equ USART1_ISR, USART1_BASE + 0x1C @ (Interrupt & status  register) 
        .equ USART1_ISR_TXFT, 1 << 27   @ bitWidth 1 (TXFIFO threshold flag)  
        .equ USART1_ISR_RXFT, 1 << 26   @ bitWidth 1 (RXFIFO threshold flag)  
        .equ USART1_ISR_TCBGT, 1 << 25   @ bitWidth 1 (Transmission complete before guard time  flag)  
        .equ USART1_ISR_RXFF, 1 << 24   @ bitWidth 1 (RXFIFO Full)  
        .equ USART1_ISR_TXFE, 1 << 23   @ bitWidth 1 (TXFIFO Empty)  
        .equ USART1_ISR_REACK, 1 << 22   @ bitWidth 1 (REACK)  
        .equ USART1_ISR_TEACK, 1 << 21   @ bitWidth 1 (TEACK)  
        .equ USART1_ISR_WUF, 1 << 20   @ bitWidth 1 (WUF)  
        .equ USART1_ISR_RWU, 1 << 19   @ bitWidth 1 (RWU)  
        .equ USART1_ISR_SBKF, 1 << 18   @ bitWidth 1 (SBKF)  
        .equ USART1_ISR_CMF, 1 << 17   @ bitWidth 1 (CMF)  
        .equ USART1_ISR_BUSY, 1 << 16   @ bitWidth 1 (BUSY)  
        .equ USART1_ISR_ABRF, 1 << 15   @ bitWidth 1 (ABRF)  
        .equ USART1_ISR_ABRE, 1 << 14   @ bitWidth 1 (ABRE)  
        .equ USART1_ISR_UDR, 1 << 13   @ bitWidth 1 (SPI slave underrun error  flag)  
        .equ USART1_ISR_EOBF, 1 << 12   @ bitWidth 1 (EOBF)  
        .equ USART1_ISR_RTOF, 1 << 11   @ bitWidth 1 (RTOF)  
        .equ USART1_ISR_CTS, 1 << 10   @ bitWidth 1 (CTS)  
        .equ USART1_ISR_CTSIF, 1 << 9   @ bitWidth 1 (CTSIF)  
        .equ USART1_ISR_LBDF, 1 << 8   @ bitWidth 1 (LBDF)  
        .equ USART1_ISR_TXE, 1 << 7   @ bitWidth 1 (TXE)  
        .equ USART1_ISR_TC, 1 << 6   @ bitWidth 1 (TC)  
        .equ USART1_ISR_RXNE, 1 << 5   @ bitWidth 1 (RXNE)  
        .equ USART1_ISR_IDLE, 1 << 4   @ bitWidth 1 (IDLE)  
        .equ USART1_ISR_ORE, 1 << 3   @ bitWidth 1 (ORE)  
        .equ USART1_ISR_NF, 1 << 2   @ bitWidth 1 (NF)  
        .equ USART1_ISR_FE, 1 << 1   @ bitWidth 1 (FE)  
        .equ USART1_ISR_PE, 1 << 0   @ bitWidth 1 (PE)  
 
    .equ USART1_ICR, USART1_BASE + 0x20 @ (Interrupt flag clear register) 
        .equ USART1_ICR_WUCF, 1 << 20   @ bitWidth 1 (Wakeup from Stop mode clear  flag)  
        .equ USART1_ICR_CMCF, 1 << 17   @ bitWidth 1 (Character match clear flag)  
        .equ USART1_ICR_UDRCF, 1 << 13   @ bitWidth 1 (SPI slave underrun clear  flag)  
        .equ USART1_ICR_EOBCF, 1 << 12   @ bitWidth 1 (End of block clear flag)  
        .equ USART1_ICR_RTOCF, 1 << 11   @ bitWidth 1 (Receiver timeout clear  flag)  
        .equ USART1_ICR_CTSCF, 1 << 9   @ bitWidth 1 (CTS clear flag)  
        .equ USART1_ICR_LBDCF, 1 << 8   @ bitWidth 1 (LIN break detection clear  flag)  
        .equ USART1_ICR_TCBGTC, 1 << 7   @ bitWidth 1 (Transmission complete before Guard time  clear flag)  
        .equ USART1_ICR_TCCF, 1 << 6   @ bitWidth 1 (Transmission complete clear  flag)  
        .equ USART1_ICR_TXFECF, 1 << 5   @ bitWidth 1 (TXFIFO empty clear flag)  
        .equ USART1_ICR_IDLECF, 1 << 4   @ bitWidth 1 (Idle line detected clear  flag)  
        .equ USART1_ICR_ORECF, 1 << 3   @ bitWidth 1 (Overrun error clear flag)  
        .equ USART1_ICR_NCF, 1 << 2   @ bitWidth 1 (Noise detected clear flag)  
        .equ USART1_ICR_FECF, 1 << 1   @ bitWidth 1 (Framing error clear flag)  
        .equ USART1_ICR_PECF, 1 << 0   @ bitWidth 1 (Parity error clear flag)  
 
    .equ USART1_RDR, USART1_BASE + 0x24 @ (Receive data register) 
        .equ USART1_RDR_RDR_Shift, 0   @ bitWidth 9 (Receive data value)  
 
    .equ USART1_TDR, USART1_BASE + 0x28 @ (Transmit data register) 
        .equ USART1_TDR_TDR_Shift, 0   @ bitWidth 9 (Transmit data value)  
 
    .equ USART1_PRESC, USART1_BASE + 0x2C @ (USART prescaler register) 
        .equ USART1_PRESC_PRESCALER_Shift, 0   @ bitWidth 4 (Clock prescaler)  
 

@=========================== USART2 ===========================@
.equ USART2_BASE, 0x40004400 @ (Universal synchronous asynchronous receiver  transmitter) 
    .equ USART2_CR1, USART2_BASE + 0x0 @ (Control register 1) 
        .equ USART2_CR1_RXFFIE, 1 << 31   @ bitWidth 1 (RXFIFO Full interrupt  enable)  
        .equ USART2_CR1_TXFEIE, 1 << 30   @ bitWidth 1 (TXFIFO empty interrupt  enable)  
        .equ USART2_CR1_FIFOEN, 1 << 29   @ bitWidth 1 (FIFO mode enable)  
        .equ USART2_CR1_M1, 1 << 28   @ bitWidth 1 (Word length)  
        .equ USART2_CR1_EOBIE, 1 << 27   @ bitWidth 1 (End of Block interrupt  enable)  
        .equ USART2_CR1_RTOIE, 1 << 26   @ bitWidth 1 (Receiver timeout interrupt  enable)  
        .equ USART2_CR1_DEAT4, 1 << 25   @ bitWidth 1 (Driver Enable assertion  time)  
        .equ USART2_CR1_DEAT3, 1 << 24   @ bitWidth 1 (DEAT3)  
        .equ USART2_CR1_DEAT2, 1 << 23   @ bitWidth 1 (DEAT2)  
        .equ USART2_CR1_DEAT1, 1 << 22   @ bitWidth 1 (DEAT1)  
        .equ USART2_CR1_DEAT0, 1 << 21   @ bitWidth 1 (DEAT0)  
        .equ USART2_CR1_DEDT4, 1 << 20   @ bitWidth 1 (Driver Enable de-assertion  time)  
        .equ USART2_CR1_DEDT3, 1 << 19   @ bitWidth 1 (DEDT3)  
        .equ USART2_CR1_DEDT2, 1 << 18   @ bitWidth 1 (DEDT2)  
        .equ USART2_CR1_DEDT1, 1 << 17   @ bitWidth 1 (DEDT1)  
        .equ USART2_CR1_DEDT0, 1 << 16   @ bitWidth 1 (DEDT0)  
        .equ USART2_CR1_OVER8, 1 << 15   @ bitWidth 1 (Oversampling mode)  
        .equ USART2_CR1_CMIE, 1 << 14   @ bitWidth 1 (Character match interrupt  enable)  
        .equ USART2_CR1_MME, 1 << 13   @ bitWidth 1 (Mute mode enable)  
        .equ USART2_CR1_M0, 1 << 12   @ bitWidth 1 (Word length)  
        .equ USART2_CR1_WAKE, 1 << 11   @ bitWidth 1 (Receiver wakeup method)  
        .equ USART2_CR1_PCE, 1 << 10   @ bitWidth 1 (Parity control enable)  
        .equ USART2_CR1_PS, 1 << 9   @ bitWidth 1 (Parity selection)  
        .equ USART2_CR1_PEIE, 1 << 8   @ bitWidth 1 (PE interrupt enable)  
        .equ USART2_CR1_TXEIE, 1 << 7   @ bitWidth 1 (interrupt enable)  
        .equ USART2_CR1_TCIE, 1 << 6   @ bitWidth 1 (Transmission complete interrupt  enable)  
        .equ USART2_CR1_RXNEIE, 1 << 5   @ bitWidth 1 (RXNE interrupt enable)  
        .equ USART2_CR1_IDLEIE, 1 << 4   @ bitWidth 1 (IDLE interrupt enable)  
        .equ USART2_CR1_TE, 1 << 3   @ bitWidth 1 (Transmitter enable)  
        .equ USART2_CR1_RE, 1 << 2   @ bitWidth 1 (Receiver enable)  
        .equ USART2_CR1_UESM, 1 << 1   @ bitWidth 1 (USART enable in Stop mode)  
        .equ USART2_CR1_UE, 1 << 0   @ bitWidth 1 (USART enable)  
 
    .equ USART2_CR2, USART2_BASE + 0x4 @ (Control register 2) 
        .equ USART2_CR2_ADD4_7_Shift, 28   @ bitWidth 4 (Address of the USART node)  
        .equ USART2_CR2_ADD0_3_Shift, 24   @ bitWidth 4 (Address of the USART node)  
        .equ USART2_CR2_RTOEN, 1 << 23   @ bitWidth 1 (Receiver timeout enable)  
        .equ USART2_CR2_ABRMOD1, 1 << 22   @ bitWidth 1 (Auto baud rate mode)  
        .equ USART2_CR2_ABRMOD0, 1 << 21   @ bitWidth 1 (ABRMOD0)  
        .equ USART2_CR2_ABREN, 1 << 20   @ bitWidth 1 (Auto baud rate enable)  
        .equ USART2_CR2_MSBFIRST, 1 << 19   @ bitWidth 1 (Most significant bit first)  
        .equ USART2_CR2_TAINV, 1 << 18   @ bitWidth 1 (Binary data inversion)  
        .equ USART2_CR2_TXINV, 1 << 17   @ bitWidth 1 (TX pin active level  inversion)  
        .equ USART2_CR2_RXINV, 1 << 16   @ bitWidth 1 (RX pin active level  inversion)  
        .equ USART2_CR2_SWAP, 1 << 15   @ bitWidth 1 (Swap TX/RX pins)  
        .equ USART2_CR2_LINEN, 1 << 14   @ bitWidth 1 (LIN mode enable)  
        .equ USART2_CR2_STOP_Shift, 12   @ bitWidth 2 (STOP bits)  
        .equ USART2_CR2_CLKEN, 1 << 11   @ bitWidth 1 (Clock enable)  
        .equ USART2_CR2_CPOL, 1 << 10   @ bitWidth 1 (Clock polarity)  
        .equ USART2_CR2_CPHA, 1 << 9   @ bitWidth 1 (Clock phase)  
        .equ USART2_CR2_LBCL, 1 << 8   @ bitWidth 1 (Last bit clock pulse)  
        .equ USART2_CR2_LBDIE, 1 << 6   @ bitWidth 1 (LIN break detection interrupt  enable)  
        .equ USART2_CR2_LBDL, 1 << 5   @ bitWidth 1 (LIN break detection length)  
        .equ USART2_CR2_ADDM7, 1 << 4   @ bitWidth 1 (7-bit Address Detection/4-bit Address  Detection)  
        .equ USART2_CR2_DIS_NSS, 1 << 3   @ bitWidth 1 (When the DSI_NSS bit is set, the NSS pin  input is ignored)  
        .equ USART2_CR2_SLVEN, 1 << 0   @ bitWidth 1 (Synchronous Slave mode  enable)  
 
    .equ USART2_CR3, USART2_BASE + 0x8 @ (Control register 3) 
        .equ USART2_CR3_TXFTCFG_Shift, 29   @ bitWidth 3 (TXFIFO threshold  configuration)  
        .equ USART2_CR3_RXFTIE, 1 << 28   @ bitWidth 1 (RXFIFO threshold interrupt  enable)  
        .equ USART2_CR3_RXFTCFG_Shift, 25   @ bitWidth 3 (Receive FIFO threshold  configuration)  
        .equ USART2_CR3_TCBGTIE, 1 << 24   @ bitWidth 1 (Transmission Complete before guard time,  interrupt enable)  
        .equ USART2_CR3_TXFTIE, 1 << 23   @ bitWidth 1 (TXFIFO threshold interrupt  enable)  
        .equ USART2_CR3_WUFIE, 1 << 22   @ bitWidth 1 (Wakeup from Stop mode interrupt  enable)  
        .equ USART2_CR3_WUS_Shift, 20   @ bitWidth 2 (Wakeup from Stop mode interrupt flag  selection)  
        .equ USART2_CR3_SCARCNT_Shift, 17   @ bitWidth 3 (Smartcard auto-retry count)  
        .equ USART2_CR3_DEP, 1 << 15   @ bitWidth 1 (Driver enable polarity  selection)  
        .equ USART2_CR3_DEM, 1 << 14   @ bitWidth 1 (Driver enable mode)  
        .equ USART2_CR3_DDRE, 1 << 13   @ bitWidth 1 (DMA Disable on Reception  Error)  
        .equ USART2_CR3_OVRDIS, 1 << 12   @ bitWidth 1 (Overrun Disable)  
        .equ USART2_CR3_ONEBIT, 1 << 11   @ bitWidth 1 (One sample bit method  enable)  
        .equ USART2_CR3_CTSIE, 1 << 10   @ bitWidth 1 (CTS interrupt enable)  
        .equ USART2_CR3_CTSE, 1 << 9   @ bitWidth 1 (CTS enable)  
        .equ USART2_CR3_RTSE, 1 << 8   @ bitWidth 1 (RTS enable)  
        .equ USART2_CR3_DMAT, 1 << 7   @ bitWidth 1 (DMA enable transmitter)  
        .equ USART2_CR3_DMAR, 1 << 6   @ bitWidth 1 (DMA enable receiver)  
        .equ USART2_CR3_SCEN, 1 << 5   @ bitWidth 1 (Smartcard mode enable)  
        .equ USART2_CR3_NACK, 1 << 4   @ bitWidth 1 (Smartcard NACK enable)  
        .equ USART2_CR3_HDSEL, 1 << 3   @ bitWidth 1 (Half-duplex selection)  
        .equ USART2_CR3_IRLP, 1 << 2   @ bitWidth 1 (Ir low-power)  
        .equ USART2_CR3_IREN, 1 << 1   @ bitWidth 1 (Ir mode enable)  
        .equ USART2_CR3_EIE, 1 << 0   @ bitWidth 1 (Error interrupt enable)  
 
    .equ USART2_BRR, USART2_BASE + 0xC @ (Baud rate register) 
        .equ USART2_BRR_BRR_4_15_Shift, 4   @ bitWidth 12 (DIV_Mantissa)  
        .equ USART2_BRR_BRR_0_3_Shift, 0   @ bitWidth 4 (DIV_Fraction)  
 
    .equ USART2_GTPR, USART2_BASE + 0x10 @ (Guard time and prescaler  register) 
        .equ USART2_GTPR_GT_Shift, 8   @ bitWidth 8 (Guard time value)  
        .equ USART2_GTPR_PSC_Shift, 0   @ bitWidth 8 (Prescaler value)  
 
    .equ USART2_RTOR, USART2_BASE + 0x14 @ (Receiver timeout register) 
        .equ USART2_RTOR_BLEN_Shift, 24   @ bitWidth 8 (Block Length)  
        .equ USART2_RTOR_RTO_Shift, 0   @ bitWidth 24 (Receiver timeout value)  
 
    .equ USART2_RQR, USART2_BASE + 0x18 @ (Request register) 
        .equ USART2_RQR_TXFRQ, 1 << 4   @ bitWidth 1 (Transmit data flush  request)  
        .equ USART2_RQR_RXFRQ, 1 << 3   @ bitWidth 1 (Receive data flush request)  
        .equ USART2_RQR_MMRQ, 1 << 2   @ bitWidth 1 (Mute mode request)  
        .equ USART2_RQR_SBKRQ, 1 << 1   @ bitWidth 1 (Send break request)  
        .equ USART2_RQR_ABRRQ, 1 << 0   @ bitWidth 1 (Auto baud rate request)  
 
    .equ USART2_ISR, USART2_BASE + 0x1C @ (Interrupt & status  register) 
        .equ USART2_ISR_TXFT, 1 << 27   @ bitWidth 1 (TXFIFO threshold flag)  
        .equ USART2_ISR_RXFT, 1 << 26   @ bitWidth 1 (RXFIFO threshold flag)  
        .equ USART2_ISR_TCBGT, 1 << 25   @ bitWidth 1 (Transmission complete before guard time  flag)  
        .equ USART2_ISR_RXFF, 1 << 24   @ bitWidth 1 (RXFIFO Full)  
        .equ USART2_ISR_TXFE, 1 << 23   @ bitWidth 1 (TXFIFO Empty)  
        .equ USART2_ISR_REACK, 1 << 22   @ bitWidth 1 (REACK)  
        .equ USART2_ISR_TEACK, 1 << 21   @ bitWidth 1 (TEACK)  
        .equ USART2_ISR_WUF, 1 << 20   @ bitWidth 1 (WUF)  
        .equ USART2_ISR_RWU, 1 << 19   @ bitWidth 1 (RWU)  
        .equ USART2_ISR_SBKF, 1 << 18   @ bitWidth 1 (SBKF)  
        .equ USART2_ISR_CMF, 1 << 17   @ bitWidth 1 (CMF)  
        .equ USART2_ISR_BUSY, 1 << 16   @ bitWidth 1 (BUSY)  
        .equ USART2_ISR_ABRF, 1 << 15   @ bitWidth 1 (ABRF)  
        .equ USART2_ISR_ABRE, 1 << 14   @ bitWidth 1 (ABRE)  
        .equ USART2_ISR_UDR, 1 << 13   @ bitWidth 1 (SPI slave underrun error  flag)  
        .equ USART2_ISR_EOBF, 1 << 12   @ bitWidth 1 (EOBF)  
        .equ USART2_ISR_RTOF, 1 << 11   @ bitWidth 1 (RTOF)  
        .equ USART2_ISR_CTS, 1 << 10   @ bitWidth 1 (CTS)  
        .equ USART2_ISR_CTSIF, 1 << 9   @ bitWidth 1 (CTSIF)  
        .equ USART2_ISR_LBDF, 1 << 8   @ bitWidth 1 (LBDF)  
        .equ USART2_ISR_TXE, 1 << 7   @ bitWidth 1 (TXE)  
        .equ USART2_ISR_TC, 1 << 6   @ bitWidth 1 (TC)  
        .equ USART2_ISR_RXNE, 1 << 5   @ bitWidth 1 (RXNE)  
        .equ USART2_ISR_IDLE, 1 << 4   @ bitWidth 1 (IDLE)  
        .equ USART2_ISR_ORE, 1 << 3   @ bitWidth 1 (ORE)  
        .equ USART2_ISR_NF, 1 << 2   @ bitWidth 1 (NF)  
        .equ USART2_ISR_FE, 1 << 1   @ bitWidth 1 (FE)  
        .equ USART2_ISR_PE, 1 << 0   @ bitWidth 1 (PE)  
 
    .equ USART2_ICR, USART2_BASE + 0x20 @ (Interrupt flag clear register) 
        .equ USART2_ICR_WUCF, 1 << 20   @ bitWidth 1 (Wakeup from Stop mode clear  flag)  
        .equ USART2_ICR_CMCF, 1 << 17   @ bitWidth 1 (Character match clear flag)  
        .equ USART2_ICR_UDRCF, 1 << 13   @ bitWidth 1 (SPI slave underrun clear  flag)  
        .equ USART2_ICR_EOBCF, 1 << 12   @ bitWidth 1 (End of block clear flag)  
        .equ USART2_ICR_RTOCF, 1 << 11   @ bitWidth 1 (Receiver timeout clear  flag)  
        .equ USART2_ICR_CTSCF, 1 << 9   @ bitWidth 1 (CTS clear flag)  
        .equ USART2_ICR_LBDCF, 1 << 8   @ bitWidth 1 (LIN break detection clear  flag)  
        .equ USART2_ICR_TCBGTC, 1 << 7   @ bitWidth 1 (Transmission complete before Guard time  clear flag)  
        .equ USART2_ICR_TCCF, 1 << 6   @ bitWidth 1 (Transmission complete clear  flag)  
        .equ USART2_ICR_TXFECF, 1 << 5   @ bitWidth 1 (TXFIFO empty clear flag)  
        .equ USART2_ICR_IDLECF, 1 << 4   @ bitWidth 1 (Idle line detected clear  flag)  
        .equ USART2_ICR_ORECF, 1 << 3   @ bitWidth 1 (Overrun error clear flag)  
        .equ USART2_ICR_NCF, 1 << 2   @ bitWidth 1 (Noise detected clear flag)  
        .equ USART2_ICR_FECF, 1 << 1   @ bitWidth 1 (Framing error clear flag)  
        .equ USART2_ICR_PECF, 1 << 0   @ bitWidth 1 (Parity error clear flag)  
 
    .equ USART2_RDR, USART2_BASE + 0x24 @ (Receive data register) 
        .equ USART2_RDR_RDR_Shift, 0   @ bitWidth 9 (Receive data value)  
 
    .equ USART2_TDR, USART2_BASE + 0x28 @ (Transmit data register) 
        .equ USART2_TDR_TDR_Shift, 0   @ bitWidth 9 (Transmit data value)  
 
    .equ USART2_PRESC, USART2_BASE + 0x2C @ (USART prescaler register) 
        .equ USART2_PRESC_PRESCALER_Shift, 0   @ bitWidth 4 (Clock prescaler)  
 

@=========================== USART3 ===========================@
.equ USART3_BASE, 0x40004800 @ (Universal synchronous asynchronous receiver  transmitter) 
    .equ USART3_CR1, USART3_BASE + 0x0 @ (Control register 1) 
        .equ USART3_CR1_RXFFIE, 1 << 31   @ bitWidth 1 (RXFIFO Full interrupt  enable)  
        .equ USART3_CR1_TXFEIE, 1 << 30   @ bitWidth 1 (TXFIFO empty interrupt  enable)  
        .equ USART3_CR1_FIFOEN, 1 << 29   @ bitWidth 1 (FIFO mode enable)  
        .equ USART3_CR1_M1, 1 << 28   @ bitWidth 1 (Word length)  
        .equ USART3_CR1_EOBIE, 1 << 27   @ bitWidth 1 (End of Block interrupt  enable)  
        .equ USART3_CR1_RTOIE, 1 << 26   @ bitWidth 1 (Receiver timeout interrupt  enable)  
        .equ USART3_CR1_DEAT4, 1 << 25   @ bitWidth 1 (Driver Enable assertion  time)  
        .equ USART3_CR1_DEAT3, 1 << 24   @ bitWidth 1 (DEAT3)  
        .equ USART3_CR1_DEAT2, 1 << 23   @ bitWidth 1 (DEAT2)  
        .equ USART3_CR1_DEAT1, 1 << 22   @ bitWidth 1 (DEAT1)  
        .equ USART3_CR1_DEAT0, 1 << 21   @ bitWidth 1 (DEAT0)  
        .equ USART3_CR1_DEDT4, 1 << 20   @ bitWidth 1 (Driver Enable de-assertion  time)  
        .equ USART3_CR1_DEDT3, 1 << 19   @ bitWidth 1 (DEDT3)  
        .equ USART3_CR1_DEDT2, 1 << 18   @ bitWidth 1 (DEDT2)  
        .equ USART3_CR1_DEDT1, 1 << 17   @ bitWidth 1 (DEDT1)  
        .equ USART3_CR1_DEDT0, 1 << 16   @ bitWidth 1 (DEDT0)  
        .equ USART3_CR1_OVER8, 1 << 15   @ bitWidth 1 (Oversampling mode)  
        .equ USART3_CR1_CMIE, 1 << 14   @ bitWidth 1 (Character match interrupt  enable)  
        .equ USART3_CR1_MME, 1 << 13   @ bitWidth 1 (Mute mode enable)  
        .equ USART3_CR1_M0, 1 << 12   @ bitWidth 1 (Word length)  
        .equ USART3_CR1_WAKE, 1 << 11   @ bitWidth 1 (Receiver wakeup method)  
        .equ USART3_CR1_PCE, 1 << 10   @ bitWidth 1 (Parity control enable)  
        .equ USART3_CR1_PS, 1 << 9   @ bitWidth 1 (Parity selection)  
        .equ USART3_CR1_PEIE, 1 << 8   @ bitWidth 1 (PE interrupt enable)  
        .equ USART3_CR1_TXEIE, 1 << 7   @ bitWidth 1 (interrupt enable)  
        .equ USART3_CR1_TCIE, 1 << 6   @ bitWidth 1 (Transmission complete interrupt  enable)  
        .equ USART3_CR1_RXNEIE, 1 << 5   @ bitWidth 1 (RXNE interrupt enable)  
        .equ USART3_CR1_IDLEIE, 1 << 4   @ bitWidth 1 (IDLE interrupt enable)  
        .equ USART3_CR1_TE, 1 << 3   @ bitWidth 1 (Transmitter enable)  
        .equ USART3_CR1_RE, 1 << 2   @ bitWidth 1 (Receiver enable)  
        .equ USART3_CR1_UESM, 1 << 1   @ bitWidth 1 (USART enable in Stop mode)  
        .equ USART3_CR1_UE, 1 << 0   @ bitWidth 1 (USART enable)  
 
    .equ USART3_CR2, USART3_BASE + 0x4 @ (Control register 2) 
        .equ USART3_CR2_ADD4_7_Shift, 28   @ bitWidth 4 (Address of the USART node)  
        .equ USART3_CR2_ADD0_3_Shift, 24   @ bitWidth 4 (Address of the USART node)  
        .equ USART3_CR2_RTOEN, 1 << 23   @ bitWidth 1 (Receiver timeout enable)  
        .equ USART3_CR2_ABRMOD1, 1 << 22   @ bitWidth 1 (Auto baud rate mode)  
        .equ USART3_CR2_ABRMOD0, 1 << 21   @ bitWidth 1 (ABRMOD0)  
        .equ USART3_CR2_ABREN, 1 << 20   @ bitWidth 1 (Auto baud rate enable)  
        .equ USART3_CR2_MSBFIRST, 1 << 19   @ bitWidth 1 (Most significant bit first)  
        .equ USART3_CR2_TAINV, 1 << 18   @ bitWidth 1 (Binary data inversion)  
        .equ USART3_CR2_TXINV, 1 << 17   @ bitWidth 1 (TX pin active level  inversion)  
        .equ USART3_CR2_RXINV, 1 << 16   @ bitWidth 1 (RX pin active level  inversion)  
        .equ USART3_CR2_SWAP, 1 << 15   @ bitWidth 1 (Swap TX/RX pins)  
        .equ USART3_CR2_LINEN, 1 << 14   @ bitWidth 1 (LIN mode enable)  
        .equ USART3_CR2_STOP_Shift, 12   @ bitWidth 2 (STOP bits)  
        .equ USART3_CR2_CLKEN, 1 << 11   @ bitWidth 1 (Clock enable)  
        .equ USART3_CR2_CPOL, 1 << 10   @ bitWidth 1 (Clock polarity)  
        .equ USART3_CR2_CPHA, 1 << 9   @ bitWidth 1 (Clock phase)  
        .equ USART3_CR2_LBCL, 1 << 8   @ bitWidth 1 (Last bit clock pulse)  
        .equ USART3_CR2_LBDIE, 1 << 6   @ bitWidth 1 (LIN break detection interrupt  enable)  
        .equ USART3_CR2_LBDL, 1 << 5   @ bitWidth 1 (LIN break detection length)  
        .equ USART3_CR2_ADDM7, 1 << 4   @ bitWidth 1 (7-bit Address Detection/4-bit Address  Detection)  
        .equ USART3_CR2_DIS_NSS, 1 << 3   @ bitWidth 1 (When the DSI_NSS bit is set, the NSS pin  input is ignored)  
        .equ USART3_CR2_SLVEN, 1 << 0   @ bitWidth 1 (Synchronous Slave mode  enable)  
 
    .equ USART3_CR3, USART3_BASE + 0x8 @ (Control register 3) 
        .equ USART3_CR3_TXFTCFG_Shift, 29   @ bitWidth 3 (TXFIFO threshold  configuration)  
        .equ USART3_CR3_RXFTIE, 1 << 28   @ bitWidth 1 (RXFIFO threshold interrupt  enable)  
        .equ USART3_CR3_RXFTCFG_Shift, 25   @ bitWidth 3 (Receive FIFO threshold  configuration)  
        .equ USART3_CR3_TCBGTIE, 1 << 24   @ bitWidth 1 (Transmission Complete before guard time,  interrupt enable)  
        .equ USART3_CR3_TXFTIE, 1 << 23   @ bitWidth 1 (TXFIFO threshold interrupt  enable)  
        .equ USART3_CR3_WUFIE, 1 << 22   @ bitWidth 1 (Wakeup from Stop mode interrupt  enable)  
        .equ USART3_CR3_WUS_Shift, 20   @ bitWidth 2 (Wakeup from Stop mode interrupt flag  selection)  
        .equ USART3_CR3_SCARCNT_Shift, 17   @ bitWidth 3 (Smartcard auto-retry count)  
        .equ USART3_CR3_DEP, 1 << 15   @ bitWidth 1 (Driver enable polarity  selection)  
        .equ USART3_CR3_DEM, 1 << 14   @ bitWidth 1 (Driver enable mode)  
        .equ USART3_CR3_DDRE, 1 << 13   @ bitWidth 1 (DMA Disable on Reception  Error)  
        .equ USART3_CR3_OVRDIS, 1 << 12   @ bitWidth 1 (Overrun Disable)  
        .equ USART3_CR3_ONEBIT, 1 << 11   @ bitWidth 1 (One sample bit method  enable)  
        .equ USART3_CR3_CTSIE, 1 << 10   @ bitWidth 1 (CTS interrupt enable)  
        .equ USART3_CR3_CTSE, 1 << 9   @ bitWidth 1 (CTS enable)  
        .equ USART3_CR3_RTSE, 1 << 8   @ bitWidth 1 (RTS enable)  
        .equ USART3_CR3_DMAT, 1 << 7   @ bitWidth 1 (DMA enable transmitter)  
        .equ USART3_CR3_DMAR, 1 << 6   @ bitWidth 1 (DMA enable receiver)  
        .equ USART3_CR3_SCEN, 1 << 5   @ bitWidth 1 (Smartcard mode enable)  
        .equ USART3_CR3_NACK, 1 << 4   @ bitWidth 1 (Smartcard NACK enable)  
        .equ USART3_CR3_HDSEL, 1 << 3   @ bitWidth 1 (Half-duplex selection)  
        .equ USART3_CR3_IRLP, 1 << 2   @ bitWidth 1 (Ir low-power)  
        .equ USART3_CR3_IREN, 1 << 1   @ bitWidth 1 (Ir mode enable)  
        .equ USART3_CR3_EIE, 1 << 0   @ bitWidth 1 (Error interrupt enable)  
 
    .equ USART3_BRR, USART3_BASE + 0xC @ (Baud rate register) 
        .equ USART3_BRR_BRR_4_15_Shift, 4   @ bitWidth 12 (DIV_Mantissa)  
        .equ USART3_BRR_BRR_0_3_Shift, 0   @ bitWidth 4 (DIV_Fraction)  
 
    .equ USART3_GTPR, USART3_BASE + 0x10 @ (Guard time and prescaler  register) 
        .equ USART3_GTPR_GT_Shift, 8   @ bitWidth 8 (Guard time value)  
        .equ USART3_GTPR_PSC_Shift, 0   @ bitWidth 8 (Prescaler value)  
 
    .equ USART3_RTOR, USART3_BASE + 0x14 @ (Receiver timeout register) 
        .equ USART3_RTOR_BLEN_Shift, 24   @ bitWidth 8 (Block Length)  
        .equ USART3_RTOR_RTO_Shift, 0   @ bitWidth 24 (Receiver timeout value)  
 
    .equ USART3_RQR, USART3_BASE + 0x18 @ (Request register) 
        .equ USART3_RQR_TXFRQ, 1 << 4   @ bitWidth 1 (Transmit data flush  request)  
        .equ USART3_RQR_RXFRQ, 1 << 3   @ bitWidth 1 (Receive data flush request)  
        .equ USART3_RQR_MMRQ, 1 << 2   @ bitWidth 1 (Mute mode request)  
        .equ USART3_RQR_SBKRQ, 1 << 1   @ bitWidth 1 (Send break request)  
        .equ USART3_RQR_ABRRQ, 1 << 0   @ bitWidth 1 (Auto baud rate request)  
 
    .equ USART3_ISR, USART3_BASE + 0x1C @ (Interrupt & status  register) 
        .equ USART3_ISR_TXFT, 1 << 27   @ bitWidth 1 (TXFIFO threshold flag)  
        .equ USART3_ISR_RXFT, 1 << 26   @ bitWidth 1 (RXFIFO threshold flag)  
        .equ USART3_ISR_TCBGT, 1 << 25   @ bitWidth 1 (Transmission complete before guard time  flag)  
        .equ USART3_ISR_RXFF, 1 << 24   @ bitWidth 1 (RXFIFO Full)  
        .equ USART3_ISR_TXFE, 1 << 23   @ bitWidth 1 (TXFIFO Empty)  
        .equ USART3_ISR_REACK, 1 << 22   @ bitWidth 1 (REACK)  
        .equ USART3_ISR_TEACK, 1 << 21   @ bitWidth 1 (TEACK)  
        .equ USART3_ISR_WUF, 1 << 20   @ bitWidth 1 (WUF)  
        .equ USART3_ISR_RWU, 1 << 19   @ bitWidth 1 (RWU)  
        .equ USART3_ISR_SBKF, 1 << 18   @ bitWidth 1 (SBKF)  
        .equ USART3_ISR_CMF, 1 << 17   @ bitWidth 1 (CMF)  
        .equ USART3_ISR_BUSY, 1 << 16   @ bitWidth 1 (BUSY)  
        .equ USART3_ISR_ABRF, 1 << 15   @ bitWidth 1 (ABRF)  
        .equ USART3_ISR_ABRE, 1 << 14   @ bitWidth 1 (ABRE)  
        .equ USART3_ISR_UDR, 1 << 13   @ bitWidth 1 (SPI slave underrun error  flag)  
        .equ USART3_ISR_EOBF, 1 << 12   @ bitWidth 1 (EOBF)  
        .equ USART3_ISR_RTOF, 1 << 11   @ bitWidth 1 (RTOF)  
        .equ USART3_ISR_CTS, 1 << 10   @ bitWidth 1 (CTS)  
        .equ USART3_ISR_CTSIF, 1 << 9   @ bitWidth 1 (CTSIF)  
        .equ USART3_ISR_LBDF, 1 << 8   @ bitWidth 1 (LBDF)  
        .equ USART3_ISR_TXE, 1 << 7   @ bitWidth 1 (TXE)  
        .equ USART3_ISR_TC, 1 << 6   @ bitWidth 1 (TC)  
        .equ USART3_ISR_RXNE, 1 << 5   @ bitWidth 1 (RXNE)  
        .equ USART3_ISR_IDLE, 1 << 4   @ bitWidth 1 (IDLE)  
        .equ USART3_ISR_ORE, 1 << 3   @ bitWidth 1 (ORE)  
        .equ USART3_ISR_NF, 1 << 2   @ bitWidth 1 (NF)  
        .equ USART3_ISR_FE, 1 << 1   @ bitWidth 1 (FE)  
        .equ USART3_ISR_PE, 1 << 0   @ bitWidth 1 (PE)  
 
    .equ USART3_ICR, USART3_BASE + 0x20 @ (Interrupt flag clear register) 
        .equ USART3_ICR_WUCF, 1 << 20   @ bitWidth 1 (Wakeup from Stop mode clear  flag)  
        .equ USART3_ICR_CMCF, 1 << 17   @ bitWidth 1 (Character match clear flag)  
        .equ USART3_ICR_UDRCF, 1 << 13   @ bitWidth 1 (SPI slave underrun clear  flag)  
        .equ USART3_ICR_EOBCF, 1 << 12   @ bitWidth 1 (End of block clear flag)  
        .equ USART3_ICR_RTOCF, 1 << 11   @ bitWidth 1 (Receiver timeout clear  flag)  
        .equ USART3_ICR_CTSCF, 1 << 9   @ bitWidth 1 (CTS clear flag)  
        .equ USART3_ICR_LBDCF, 1 << 8   @ bitWidth 1 (LIN break detection clear  flag)  
        .equ USART3_ICR_TCBGTC, 1 << 7   @ bitWidth 1 (Transmission complete before Guard time  clear flag)  
        .equ USART3_ICR_TCCF, 1 << 6   @ bitWidth 1 (Transmission complete clear  flag)  
        .equ USART3_ICR_TXFECF, 1 << 5   @ bitWidth 1 (TXFIFO empty clear flag)  
        .equ USART3_ICR_IDLECF, 1 << 4   @ bitWidth 1 (Idle line detected clear  flag)  
        .equ USART3_ICR_ORECF, 1 << 3   @ bitWidth 1 (Overrun error clear flag)  
        .equ USART3_ICR_NCF, 1 << 2   @ bitWidth 1 (Noise detected clear flag)  
        .equ USART3_ICR_FECF, 1 << 1   @ bitWidth 1 (Framing error clear flag)  
        .equ USART3_ICR_PECF, 1 << 0   @ bitWidth 1 (Parity error clear flag)  
 
    .equ USART3_RDR, USART3_BASE + 0x24 @ (Receive data register) 
        .equ USART3_RDR_RDR_Shift, 0   @ bitWidth 9 (Receive data value)  
 
    .equ USART3_TDR, USART3_BASE + 0x28 @ (Transmit data register) 
        .equ USART3_TDR_TDR_Shift, 0   @ bitWidth 9 (Transmit data value)  
 
    .equ USART3_PRESC, USART3_BASE + 0x2C @ (USART prescaler register) 
        .equ USART3_PRESC_PRESCALER_Shift, 0   @ bitWidth 4 (Clock prescaler)  
 

@=========================== UART4 ===========================@
.equ UART4_BASE, 0x40004C00 @ (Universal synchronous asynchronous receiver  transmitter) 
    .equ UART4_CR1, UART4_BASE + 0x0 @ (Control register 1) 
        .equ UART4_CR1_RXFFIE, 1 << 31   @ bitWidth 1 (RXFIFO Full interrupt  enable)  
        .equ UART4_CR1_TXFEIE, 1 << 30   @ bitWidth 1 (TXFIFO empty interrupt  enable)  
        .equ UART4_CR1_FIFOEN, 1 << 29   @ bitWidth 1 (FIFO mode enable)  
        .equ UART4_CR1_M1, 1 << 28   @ bitWidth 1 (Word length)  
        .equ UART4_CR1_EOBIE, 1 << 27   @ bitWidth 1 (End of Block interrupt  enable)  
        .equ UART4_CR1_RTOIE, 1 << 26   @ bitWidth 1 (Receiver timeout interrupt  enable)  
        .equ UART4_CR1_DEAT4, 1 << 25   @ bitWidth 1 (Driver Enable assertion  time)  
        .equ UART4_CR1_DEAT3, 1 << 24   @ bitWidth 1 (DEAT3)  
        .equ UART4_CR1_DEAT2, 1 << 23   @ bitWidth 1 (DEAT2)  
        .equ UART4_CR1_DEAT1, 1 << 22   @ bitWidth 1 (DEAT1)  
        .equ UART4_CR1_DEAT0, 1 << 21   @ bitWidth 1 (DEAT0)  
        .equ UART4_CR1_DEDT4, 1 << 20   @ bitWidth 1 (Driver Enable de-assertion  time)  
        .equ UART4_CR1_DEDT3, 1 << 19   @ bitWidth 1 (DEDT3)  
        .equ UART4_CR1_DEDT2, 1 << 18   @ bitWidth 1 (DEDT2)  
        .equ UART4_CR1_DEDT1, 1 << 17   @ bitWidth 1 (DEDT1)  
        .equ UART4_CR1_DEDT0, 1 << 16   @ bitWidth 1 (DEDT0)  
        .equ UART4_CR1_OVER8, 1 << 15   @ bitWidth 1 (Oversampling mode)  
        .equ UART4_CR1_CMIE, 1 << 14   @ bitWidth 1 (Character match interrupt  enable)  
        .equ UART4_CR1_MME, 1 << 13   @ bitWidth 1 (Mute mode enable)  
        .equ UART4_CR1_M0, 1 << 12   @ bitWidth 1 (Word length)  
        .equ UART4_CR1_WAKE, 1 << 11   @ bitWidth 1 (Receiver wakeup method)  
        .equ UART4_CR1_PCE, 1 << 10   @ bitWidth 1 (Parity control enable)  
        .equ UART4_CR1_PS, 1 << 9   @ bitWidth 1 (Parity selection)  
        .equ UART4_CR1_PEIE, 1 << 8   @ bitWidth 1 (PE interrupt enable)  
        .equ UART4_CR1_TXEIE, 1 << 7   @ bitWidth 1 (interrupt enable)  
        .equ UART4_CR1_TCIE, 1 << 6   @ bitWidth 1 (Transmission complete interrupt  enable)  
        .equ UART4_CR1_RXNEIE, 1 << 5   @ bitWidth 1 (RXNE interrupt enable)  
        .equ UART4_CR1_IDLEIE, 1 << 4   @ bitWidth 1 (IDLE interrupt enable)  
        .equ UART4_CR1_TE, 1 << 3   @ bitWidth 1 (Transmitter enable)  
        .equ UART4_CR1_RE, 1 << 2   @ bitWidth 1 (Receiver enable)  
        .equ UART4_CR1_UESM, 1 << 1   @ bitWidth 1 (USART enable in Stop mode)  
        .equ UART4_CR1_UE, 1 << 0   @ bitWidth 1 (USART enable)  
 
    .equ UART4_CR2, UART4_BASE + 0x4 @ (Control register 2) 
        .equ UART4_CR2_ADD4_7_Shift, 28   @ bitWidth 4 (Address of the USART node)  
        .equ UART4_CR2_ADD0_3_Shift, 24   @ bitWidth 4 (Address of the USART node)  
        .equ UART4_CR2_RTOEN, 1 << 23   @ bitWidth 1 (Receiver timeout enable)  
        .equ UART4_CR2_ABRMOD1, 1 << 22   @ bitWidth 1 (Auto baud rate mode)  
        .equ UART4_CR2_ABRMOD0, 1 << 21   @ bitWidth 1 (ABRMOD0)  
        .equ UART4_CR2_ABREN, 1 << 20   @ bitWidth 1 (Auto baud rate enable)  
        .equ UART4_CR2_MSBFIRST, 1 << 19   @ bitWidth 1 (Most significant bit first)  
        .equ UART4_CR2_TAINV, 1 << 18   @ bitWidth 1 (Binary data inversion)  
        .equ UART4_CR2_TXINV, 1 << 17   @ bitWidth 1 (TX pin active level  inversion)  
        .equ UART4_CR2_RXINV, 1 << 16   @ bitWidth 1 (RX pin active level  inversion)  
        .equ UART4_CR2_SWAP, 1 << 15   @ bitWidth 1 (Swap TX/RX pins)  
        .equ UART4_CR2_LINEN, 1 << 14   @ bitWidth 1 (LIN mode enable)  
        .equ UART4_CR2_STOP_Shift, 12   @ bitWidth 2 (STOP bits)  
        .equ UART4_CR2_CLKEN, 1 << 11   @ bitWidth 1 (Clock enable)  
        .equ UART4_CR2_CPOL, 1 << 10   @ bitWidth 1 (Clock polarity)  
        .equ UART4_CR2_CPHA, 1 << 9   @ bitWidth 1 (Clock phase)  
        .equ UART4_CR2_LBCL, 1 << 8   @ bitWidth 1 (Last bit clock pulse)  
        .equ UART4_CR2_LBDIE, 1 << 6   @ bitWidth 1 (LIN break detection interrupt  enable)  
        .equ UART4_CR2_LBDL, 1 << 5   @ bitWidth 1 (LIN break detection length)  
        .equ UART4_CR2_ADDM7, 1 << 4   @ bitWidth 1 (7-bit Address Detection/4-bit Address  Detection)  
        .equ UART4_CR2_DIS_NSS, 1 << 3   @ bitWidth 1 (When the DSI_NSS bit is set, the NSS pin  input is ignored)  
        .equ UART4_CR2_SLVEN, 1 << 0   @ bitWidth 1 (Synchronous Slave mode  enable)  
 
    .equ UART4_CR3, UART4_BASE + 0x8 @ (Control register 3) 
        .equ UART4_CR3_TXFTCFG_Shift, 29   @ bitWidth 3 (TXFIFO threshold  configuration)  
        .equ UART4_CR3_RXFTIE, 1 << 28   @ bitWidth 1 (RXFIFO threshold interrupt  enable)  
        .equ UART4_CR3_RXFTCFG_Shift, 25   @ bitWidth 3 (Receive FIFO threshold  configuration)  
        .equ UART4_CR3_TCBGTIE, 1 << 24   @ bitWidth 1 (Transmission Complete before guard time,  interrupt enable)  
        .equ UART4_CR3_TXFTIE, 1 << 23   @ bitWidth 1 (TXFIFO threshold interrupt  enable)  
        .equ UART4_CR3_WUFIE, 1 << 22   @ bitWidth 1 (Wakeup from Stop mode interrupt  enable)  
        .equ UART4_CR3_WUS_Shift, 20   @ bitWidth 2 (Wakeup from Stop mode interrupt flag  selection)  
        .equ UART4_CR3_SCARCNT_Shift, 17   @ bitWidth 3 (Smartcard auto-retry count)  
        .equ UART4_CR3_DEP, 1 << 15   @ bitWidth 1 (Driver enable polarity  selection)  
        .equ UART4_CR3_DEM, 1 << 14   @ bitWidth 1 (Driver enable mode)  
        .equ UART4_CR3_DDRE, 1 << 13   @ bitWidth 1 (DMA Disable on Reception  Error)  
        .equ UART4_CR3_OVRDIS, 1 << 12   @ bitWidth 1 (Overrun Disable)  
        .equ UART4_CR3_ONEBIT, 1 << 11   @ bitWidth 1 (One sample bit method  enable)  
        .equ UART4_CR3_CTSIE, 1 << 10   @ bitWidth 1 (CTS interrupt enable)  
        .equ UART4_CR3_CTSE, 1 << 9   @ bitWidth 1 (CTS enable)  
        .equ UART4_CR3_RTSE, 1 << 8   @ bitWidth 1 (RTS enable)  
        .equ UART4_CR3_DMAT, 1 << 7   @ bitWidth 1 (DMA enable transmitter)  
        .equ UART4_CR3_DMAR, 1 << 6   @ bitWidth 1 (DMA enable receiver)  
        .equ UART4_CR3_SCEN, 1 << 5   @ bitWidth 1 (Smartcard mode enable)  
        .equ UART4_CR3_NACK, 1 << 4   @ bitWidth 1 (Smartcard NACK enable)  
        .equ UART4_CR3_HDSEL, 1 << 3   @ bitWidth 1 (Half-duplex selection)  
        .equ UART4_CR3_IRLP, 1 << 2   @ bitWidth 1 (Ir low-power)  
        .equ UART4_CR3_IREN, 1 << 1   @ bitWidth 1 (Ir mode enable)  
        .equ UART4_CR3_EIE, 1 << 0   @ bitWidth 1 (Error interrupt enable)  
 
    .equ UART4_BRR, UART4_BASE + 0xC @ (Baud rate register) 
        .equ UART4_BRR_BRR_4_15_Shift, 4   @ bitWidth 12 (DIV_Mantissa)  
        .equ UART4_BRR_BRR_0_3_Shift, 0   @ bitWidth 4 (DIV_Fraction)  
 
    .equ UART4_GTPR, UART4_BASE + 0x10 @ (Guard time and prescaler  register) 
        .equ UART4_GTPR_GT_Shift, 8   @ bitWidth 8 (Guard time value)  
        .equ UART4_GTPR_PSC_Shift, 0   @ bitWidth 8 (Prescaler value)  
 
    .equ UART4_RTOR, UART4_BASE + 0x14 @ (Receiver timeout register) 
        .equ UART4_RTOR_BLEN_Shift, 24   @ bitWidth 8 (Block Length)  
        .equ UART4_RTOR_RTO_Shift, 0   @ bitWidth 24 (Receiver timeout value)  
 
    .equ UART4_RQR, UART4_BASE + 0x18 @ (Request register) 
        .equ UART4_RQR_TXFRQ, 1 << 4   @ bitWidth 1 (Transmit data flush  request)  
        .equ UART4_RQR_RXFRQ, 1 << 3   @ bitWidth 1 (Receive data flush request)  
        .equ UART4_RQR_MMRQ, 1 << 2   @ bitWidth 1 (Mute mode request)  
        .equ UART4_RQR_SBKRQ, 1 << 1   @ bitWidth 1 (Send break request)  
        .equ UART4_RQR_ABRRQ, 1 << 0   @ bitWidth 1 (Auto baud rate request)  
 
    .equ UART4_ISR, UART4_BASE + 0x1C @ (Interrupt & status  register) 
        .equ UART4_ISR_TXFT, 1 << 27   @ bitWidth 1 (TXFIFO threshold flag)  
        .equ UART4_ISR_RXFT, 1 << 26   @ bitWidth 1 (RXFIFO threshold flag)  
        .equ UART4_ISR_TCBGT, 1 << 25   @ bitWidth 1 (Transmission complete before guard time  flag)  
        .equ UART4_ISR_RXFF, 1 << 24   @ bitWidth 1 (RXFIFO Full)  
        .equ UART4_ISR_TXFE, 1 << 23   @ bitWidth 1 (TXFIFO Empty)  
        .equ UART4_ISR_REACK, 1 << 22   @ bitWidth 1 (REACK)  
        .equ UART4_ISR_TEACK, 1 << 21   @ bitWidth 1 (TEACK)  
        .equ UART4_ISR_WUF, 1 << 20   @ bitWidth 1 (WUF)  
        .equ UART4_ISR_RWU, 1 << 19   @ bitWidth 1 (RWU)  
        .equ UART4_ISR_SBKF, 1 << 18   @ bitWidth 1 (SBKF)  
        .equ UART4_ISR_CMF, 1 << 17   @ bitWidth 1 (CMF)  
        .equ UART4_ISR_BUSY, 1 << 16   @ bitWidth 1 (BUSY)  
        .equ UART4_ISR_ABRF, 1 << 15   @ bitWidth 1 (ABRF)  
        .equ UART4_ISR_ABRE, 1 << 14   @ bitWidth 1 (ABRE)  
        .equ UART4_ISR_UDR, 1 << 13   @ bitWidth 1 (SPI slave underrun error  flag)  
        .equ UART4_ISR_EOBF, 1 << 12   @ bitWidth 1 (EOBF)  
        .equ UART4_ISR_RTOF, 1 << 11   @ bitWidth 1 (RTOF)  
        .equ UART4_ISR_CTS, 1 << 10   @ bitWidth 1 (CTS)  
        .equ UART4_ISR_CTSIF, 1 << 9   @ bitWidth 1 (CTSIF)  
        .equ UART4_ISR_LBDF, 1 << 8   @ bitWidth 1 (LBDF)  
        .equ UART4_ISR_TXE, 1 << 7   @ bitWidth 1 (TXE)  
        .equ UART4_ISR_TC, 1 << 6   @ bitWidth 1 (TC)  
        .equ UART4_ISR_RXNE, 1 << 5   @ bitWidth 1 (RXNE)  
        .equ UART4_ISR_IDLE, 1 << 4   @ bitWidth 1 (IDLE)  
        .equ UART4_ISR_ORE, 1 << 3   @ bitWidth 1 (ORE)  
        .equ UART4_ISR_NF, 1 << 2   @ bitWidth 1 (NF)  
        .equ UART4_ISR_FE, 1 << 1   @ bitWidth 1 (FE)  
        .equ UART4_ISR_PE, 1 << 0   @ bitWidth 1 (PE)  
 
    .equ UART4_ICR, UART4_BASE + 0x20 @ (Interrupt flag clear register) 
        .equ UART4_ICR_WUCF, 1 << 20   @ bitWidth 1 (Wakeup from Stop mode clear  flag)  
        .equ UART4_ICR_CMCF, 1 << 17   @ bitWidth 1 (Character match clear flag)  
        .equ UART4_ICR_UDRCF, 1 << 13   @ bitWidth 1 (SPI slave underrun clear  flag)  
        .equ UART4_ICR_EOBCF, 1 << 12   @ bitWidth 1 (End of block clear flag)  
        .equ UART4_ICR_RTOCF, 1 << 11   @ bitWidth 1 (Receiver timeout clear  flag)  
        .equ UART4_ICR_CTSCF, 1 << 9   @ bitWidth 1 (CTS clear flag)  
        .equ UART4_ICR_LBDCF, 1 << 8   @ bitWidth 1 (LIN break detection clear  flag)  
        .equ UART4_ICR_TCBGTC, 1 << 7   @ bitWidth 1 (Transmission complete before Guard time  clear flag)  
        .equ UART4_ICR_TCCF, 1 << 6   @ bitWidth 1 (Transmission complete clear  flag)  
        .equ UART4_ICR_TXFECF, 1 << 5   @ bitWidth 1 (TXFIFO empty clear flag)  
        .equ UART4_ICR_IDLECF, 1 << 4   @ bitWidth 1 (Idle line detected clear  flag)  
        .equ UART4_ICR_ORECF, 1 << 3   @ bitWidth 1 (Overrun error clear flag)  
        .equ UART4_ICR_NCF, 1 << 2   @ bitWidth 1 (Noise detected clear flag)  
        .equ UART4_ICR_FECF, 1 << 1   @ bitWidth 1 (Framing error clear flag)  
        .equ UART4_ICR_PECF, 1 << 0   @ bitWidth 1 (Parity error clear flag)  
 
    .equ UART4_RDR, UART4_BASE + 0x24 @ (Receive data register) 
        .equ UART4_RDR_RDR_Shift, 0   @ bitWidth 9 (Receive data value)  
 
    .equ UART4_TDR, UART4_BASE + 0x28 @ (Transmit data register) 
        .equ UART4_TDR_TDR_Shift, 0   @ bitWidth 9 (Transmit data value)  
 
    .equ UART4_PRESC, UART4_BASE + 0x2C @ (USART prescaler register) 
        .equ UART4_PRESC_PRESCALER_Shift, 0   @ bitWidth 4 (Clock prescaler)  
 

@=========================== UART5 ===========================@
.equ UART5_BASE, 0x40005000 @ (Universal synchronous asynchronous receiver  transmitter) 
    .equ UART5_CR1, UART5_BASE + 0x0 @ (Control register 1) 
        .equ UART5_CR1_RXFFIE, 1 << 31   @ bitWidth 1 (RXFIFO Full interrupt  enable)  
        .equ UART5_CR1_TXFEIE, 1 << 30   @ bitWidth 1 (TXFIFO empty interrupt  enable)  
        .equ UART5_CR1_FIFOEN, 1 << 29   @ bitWidth 1 (FIFO mode enable)  
        .equ UART5_CR1_M1, 1 << 28   @ bitWidth 1 (Word length)  
        .equ UART5_CR1_EOBIE, 1 << 27   @ bitWidth 1 (End of Block interrupt  enable)  
        .equ UART5_CR1_RTOIE, 1 << 26   @ bitWidth 1 (Receiver timeout interrupt  enable)  
        .equ UART5_CR1_DEAT4, 1 << 25   @ bitWidth 1 (Driver Enable assertion  time)  
        .equ UART5_CR1_DEAT3, 1 << 24   @ bitWidth 1 (DEAT3)  
        .equ UART5_CR1_DEAT2, 1 << 23   @ bitWidth 1 (DEAT2)  
        .equ UART5_CR1_DEAT1, 1 << 22   @ bitWidth 1 (DEAT1)  
        .equ UART5_CR1_DEAT0, 1 << 21   @ bitWidth 1 (DEAT0)  
        .equ UART5_CR1_DEDT4, 1 << 20   @ bitWidth 1 (Driver Enable de-assertion  time)  
        .equ UART5_CR1_DEDT3, 1 << 19   @ bitWidth 1 (DEDT3)  
        .equ UART5_CR1_DEDT2, 1 << 18   @ bitWidth 1 (DEDT2)  
        .equ UART5_CR1_DEDT1, 1 << 17   @ bitWidth 1 (DEDT1)  
        .equ UART5_CR1_DEDT0, 1 << 16   @ bitWidth 1 (DEDT0)  
        .equ UART5_CR1_OVER8, 1 << 15   @ bitWidth 1 (Oversampling mode)  
        .equ UART5_CR1_CMIE, 1 << 14   @ bitWidth 1 (Character match interrupt  enable)  
        .equ UART5_CR1_MME, 1 << 13   @ bitWidth 1 (Mute mode enable)  
        .equ UART5_CR1_M0, 1 << 12   @ bitWidth 1 (Word length)  
        .equ UART5_CR1_WAKE, 1 << 11   @ bitWidth 1 (Receiver wakeup method)  
        .equ UART5_CR1_PCE, 1 << 10   @ bitWidth 1 (Parity control enable)  
        .equ UART5_CR1_PS, 1 << 9   @ bitWidth 1 (Parity selection)  
        .equ UART5_CR1_PEIE, 1 << 8   @ bitWidth 1 (PE interrupt enable)  
        .equ UART5_CR1_TXEIE, 1 << 7   @ bitWidth 1 (interrupt enable)  
        .equ UART5_CR1_TCIE, 1 << 6   @ bitWidth 1 (Transmission complete interrupt  enable)  
        .equ UART5_CR1_RXNEIE, 1 << 5   @ bitWidth 1 (RXNE interrupt enable)  
        .equ UART5_CR1_IDLEIE, 1 << 4   @ bitWidth 1 (IDLE interrupt enable)  
        .equ UART5_CR1_TE, 1 << 3   @ bitWidth 1 (Transmitter enable)  
        .equ UART5_CR1_RE, 1 << 2   @ bitWidth 1 (Receiver enable)  
        .equ UART5_CR1_UESM, 1 << 1   @ bitWidth 1 (USART enable in Stop mode)  
        .equ UART5_CR1_UE, 1 << 0   @ bitWidth 1 (USART enable)  
 
    .equ UART5_CR2, UART5_BASE + 0x4 @ (Control register 2) 
        .equ UART5_CR2_ADD4_7_Shift, 28   @ bitWidth 4 (Address of the USART node)  
        .equ UART5_CR2_ADD0_3_Shift, 24   @ bitWidth 4 (Address of the USART node)  
        .equ UART5_CR2_RTOEN, 1 << 23   @ bitWidth 1 (Receiver timeout enable)  
        .equ UART5_CR2_ABRMOD1, 1 << 22   @ bitWidth 1 (Auto baud rate mode)  
        .equ UART5_CR2_ABRMOD0, 1 << 21   @ bitWidth 1 (ABRMOD0)  
        .equ UART5_CR2_ABREN, 1 << 20   @ bitWidth 1 (Auto baud rate enable)  
        .equ UART5_CR2_MSBFIRST, 1 << 19   @ bitWidth 1 (Most significant bit first)  
        .equ UART5_CR2_TAINV, 1 << 18   @ bitWidth 1 (Binary data inversion)  
        .equ UART5_CR2_TXINV, 1 << 17   @ bitWidth 1 (TX pin active level  inversion)  
        .equ UART5_CR2_RXINV, 1 << 16   @ bitWidth 1 (RX pin active level  inversion)  
        .equ UART5_CR2_SWAP, 1 << 15   @ bitWidth 1 (Swap TX/RX pins)  
        .equ UART5_CR2_LINEN, 1 << 14   @ bitWidth 1 (LIN mode enable)  
        .equ UART5_CR2_STOP_Shift, 12   @ bitWidth 2 (STOP bits)  
        .equ UART5_CR2_CLKEN, 1 << 11   @ bitWidth 1 (Clock enable)  
        .equ UART5_CR2_CPOL, 1 << 10   @ bitWidth 1 (Clock polarity)  
        .equ UART5_CR2_CPHA, 1 << 9   @ bitWidth 1 (Clock phase)  
        .equ UART5_CR2_LBCL, 1 << 8   @ bitWidth 1 (Last bit clock pulse)  
        .equ UART5_CR2_LBDIE, 1 << 6   @ bitWidth 1 (LIN break detection interrupt  enable)  
        .equ UART5_CR2_LBDL, 1 << 5   @ bitWidth 1 (LIN break detection length)  
        .equ UART5_CR2_ADDM7, 1 << 4   @ bitWidth 1 (7-bit Address Detection/4-bit Address  Detection)  
        .equ UART5_CR2_DIS_NSS, 1 << 3   @ bitWidth 1 (When the DSI_NSS bit is set, the NSS pin  input is ignored)  
        .equ UART5_CR2_SLVEN, 1 << 0   @ bitWidth 1 (Synchronous Slave mode  enable)  
 
    .equ UART5_CR3, UART5_BASE + 0x8 @ (Control register 3) 
        .equ UART5_CR3_TXFTCFG_Shift, 29   @ bitWidth 3 (TXFIFO threshold  configuration)  
        .equ UART5_CR3_RXFTIE, 1 << 28   @ bitWidth 1 (RXFIFO threshold interrupt  enable)  
        .equ UART5_CR3_RXFTCFG_Shift, 25   @ bitWidth 3 (Receive FIFO threshold  configuration)  
        .equ UART5_CR3_TCBGTIE, 1 << 24   @ bitWidth 1 (Transmission Complete before guard time,  interrupt enable)  
        .equ UART5_CR3_TXFTIE, 1 << 23   @ bitWidth 1 (TXFIFO threshold interrupt  enable)  
        .equ UART5_CR3_WUFIE, 1 << 22   @ bitWidth 1 (Wakeup from Stop mode interrupt  enable)  
        .equ UART5_CR3_WUS_Shift, 20   @ bitWidth 2 (Wakeup from Stop mode interrupt flag  selection)  
        .equ UART5_CR3_SCARCNT_Shift, 17   @ bitWidth 3 (Smartcard auto-retry count)  
        .equ UART5_CR3_DEP, 1 << 15   @ bitWidth 1 (Driver enable polarity  selection)  
        .equ UART5_CR3_DEM, 1 << 14   @ bitWidth 1 (Driver enable mode)  
        .equ UART5_CR3_DDRE, 1 << 13   @ bitWidth 1 (DMA Disable on Reception  Error)  
        .equ UART5_CR3_OVRDIS, 1 << 12   @ bitWidth 1 (Overrun Disable)  
        .equ UART5_CR3_ONEBIT, 1 << 11   @ bitWidth 1 (One sample bit method  enable)  
        .equ UART5_CR3_CTSIE, 1 << 10   @ bitWidth 1 (CTS interrupt enable)  
        .equ UART5_CR3_CTSE, 1 << 9   @ bitWidth 1 (CTS enable)  
        .equ UART5_CR3_RTSE, 1 << 8   @ bitWidth 1 (RTS enable)  
        .equ UART5_CR3_DMAT, 1 << 7   @ bitWidth 1 (DMA enable transmitter)  
        .equ UART5_CR3_DMAR, 1 << 6   @ bitWidth 1 (DMA enable receiver)  
        .equ UART5_CR3_SCEN, 1 << 5   @ bitWidth 1 (Smartcard mode enable)  
        .equ UART5_CR3_NACK, 1 << 4   @ bitWidth 1 (Smartcard NACK enable)  
        .equ UART5_CR3_HDSEL, 1 << 3   @ bitWidth 1 (Half-duplex selection)  
        .equ UART5_CR3_IRLP, 1 << 2   @ bitWidth 1 (Ir low-power)  
        .equ UART5_CR3_IREN, 1 << 1   @ bitWidth 1 (Ir mode enable)  
        .equ UART5_CR3_EIE, 1 << 0   @ bitWidth 1 (Error interrupt enable)  
 
    .equ UART5_BRR, UART5_BASE + 0xC @ (Baud rate register) 
        .equ UART5_BRR_BRR_4_15_Shift, 4   @ bitWidth 12 (DIV_Mantissa)  
        .equ UART5_BRR_BRR_0_3_Shift, 0   @ bitWidth 4 (DIV_Fraction)  
 
    .equ UART5_GTPR, UART5_BASE + 0x10 @ (Guard time and prescaler  register) 
        .equ UART5_GTPR_GT_Shift, 8   @ bitWidth 8 (Guard time value)  
        .equ UART5_GTPR_PSC_Shift, 0   @ bitWidth 8 (Prescaler value)  
 
    .equ UART5_RTOR, UART5_BASE + 0x14 @ (Receiver timeout register) 
        .equ UART5_RTOR_BLEN_Shift, 24   @ bitWidth 8 (Block Length)  
        .equ UART5_RTOR_RTO_Shift, 0   @ bitWidth 24 (Receiver timeout value)  
 
    .equ UART5_RQR, UART5_BASE + 0x18 @ (Request register) 
        .equ UART5_RQR_TXFRQ, 1 << 4   @ bitWidth 1 (Transmit data flush  request)  
        .equ UART5_RQR_RXFRQ, 1 << 3   @ bitWidth 1 (Receive data flush request)  
        .equ UART5_RQR_MMRQ, 1 << 2   @ bitWidth 1 (Mute mode request)  
        .equ UART5_RQR_SBKRQ, 1 << 1   @ bitWidth 1 (Send break request)  
        .equ UART5_RQR_ABRRQ, 1 << 0   @ bitWidth 1 (Auto baud rate request)  
 
    .equ UART5_ISR, UART5_BASE + 0x1C @ (Interrupt & status  register) 
        .equ UART5_ISR_TXFT, 1 << 27   @ bitWidth 1 (TXFIFO threshold flag)  
        .equ UART5_ISR_RXFT, 1 << 26   @ bitWidth 1 (RXFIFO threshold flag)  
        .equ UART5_ISR_TCBGT, 1 << 25   @ bitWidth 1 (Transmission complete before guard time  flag)  
        .equ UART5_ISR_RXFF, 1 << 24   @ bitWidth 1 (RXFIFO Full)  
        .equ UART5_ISR_TXFE, 1 << 23   @ bitWidth 1 (TXFIFO Empty)  
        .equ UART5_ISR_REACK, 1 << 22   @ bitWidth 1 (REACK)  
        .equ UART5_ISR_TEACK, 1 << 21   @ bitWidth 1 (TEACK)  
        .equ UART5_ISR_WUF, 1 << 20   @ bitWidth 1 (WUF)  
        .equ UART5_ISR_RWU, 1 << 19   @ bitWidth 1 (RWU)  
        .equ UART5_ISR_SBKF, 1 << 18   @ bitWidth 1 (SBKF)  
        .equ UART5_ISR_CMF, 1 << 17   @ bitWidth 1 (CMF)  
        .equ UART5_ISR_BUSY, 1 << 16   @ bitWidth 1 (BUSY)  
        .equ UART5_ISR_ABRF, 1 << 15   @ bitWidth 1 (ABRF)  
        .equ UART5_ISR_ABRE, 1 << 14   @ bitWidth 1 (ABRE)  
        .equ UART5_ISR_UDR, 1 << 13   @ bitWidth 1 (SPI slave underrun error  flag)  
        .equ UART5_ISR_EOBF, 1 << 12   @ bitWidth 1 (EOBF)  
        .equ UART5_ISR_RTOF, 1 << 11   @ bitWidth 1 (RTOF)  
        .equ UART5_ISR_CTS, 1 << 10   @ bitWidth 1 (CTS)  
        .equ UART5_ISR_CTSIF, 1 << 9   @ bitWidth 1 (CTSIF)  
        .equ UART5_ISR_LBDF, 1 << 8   @ bitWidth 1 (LBDF)  
        .equ UART5_ISR_TXE, 1 << 7   @ bitWidth 1 (TXE)  
        .equ UART5_ISR_TC, 1 << 6   @ bitWidth 1 (TC)  
        .equ UART5_ISR_RXNE, 1 << 5   @ bitWidth 1 (RXNE)  
        .equ UART5_ISR_IDLE, 1 << 4   @ bitWidth 1 (IDLE)  
        .equ UART5_ISR_ORE, 1 << 3   @ bitWidth 1 (ORE)  
        .equ UART5_ISR_NF, 1 << 2   @ bitWidth 1 (NF)  
        .equ UART5_ISR_FE, 1 << 1   @ bitWidth 1 (FE)  
        .equ UART5_ISR_PE, 1 << 0   @ bitWidth 1 (PE)  
 
    .equ UART5_ICR, UART5_BASE + 0x20 @ (Interrupt flag clear register) 
        .equ UART5_ICR_WUCF, 1 << 20   @ bitWidth 1 (Wakeup from Stop mode clear  flag)  
        .equ UART5_ICR_CMCF, 1 << 17   @ bitWidth 1 (Character match clear flag)  
        .equ UART5_ICR_UDRCF, 1 << 13   @ bitWidth 1 (SPI slave underrun clear  flag)  
        .equ UART5_ICR_EOBCF, 1 << 12   @ bitWidth 1 (End of block clear flag)  
        .equ UART5_ICR_RTOCF, 1 << 11   @ bitWidth 1 (Receiver timeout clear  flag)  
        .equ UART5_ICR_CTSCF, 1 << 9   @ bitWidth 1 (CTS clear flag)  
        .equ UART5_ICR_LBDCF, 1 << 8   @ bitWidth 1 (LIN break detection clear  flag)  
        .equ UART5_ICR_TCBGTC, 1 << 7   @ bitWidth 1 (Transmission complete before Guard time  clear flag)  
        .equ UART5_ICR_TCCF, 1 << 6   @ bitWidth 1 (Transmission complete clear  flag)  
        .equ UART5_ICR_TXFECF, 1 << 5   @ bitWidth 1 (TXFIFO empty clear flag)  
        .equ UART5_ICR_IDLECF, 1 << 4   @ bitWidth 1 (Idle line detected clear  flag)  
        .equ UART5_ICR_ORECF, 1 << 3   @ bitWidth 1 (Overrun error clear flag)  
        .equ UART5_ICR_NCF, 1 << 2   @ bitWidth 1 (Noise detected clear flag)  
        .equ UART5_ICR_FECF, 1 << 1   @ bitWidth 1 (Framing error clear flag)  
        .equ UART5_ICR_PECF, 1 << 0   @ bitWidth 1 (Parity error clear flag)  
 
    .equ UART5_RDR, UART5_BASE + 0x24 @ (Receive data register) 
        .equ UART5_RDR_RDR_Shift, 0   @ bitWidth 9 (Receive data value)  
 
    .equ UART5_TDR, UART5_BASE + 0x28 @ (Transmit data register) 
        .equ UART5_TDR_TDR_Shift, 0   @ bitWidth 9 (Transmit data value)  
 
    .equ UART5_PRESC, UART5_BASE + 0x2C @ (USART prescaler register) 
        .equ UART5_PRESC_PRESCALER_Shift, 0   @ bitWidth 4 (Clock prescaler)  
 

@=========================== USART6 ===========================@
.equ USART6_BASE, 0x40011400 @ (Universal synchronous asynchronous receiver  transmitter) 
    .equ USART6_CR1, USART6_BASE + 0x0 @ (Control register 1) 
        .equ USART6_CR1_RXFFIE, 1 << 31   @ bitWidth 1 (RXFIFO Full interrupt  enable)  
        .equ USART6_CR1_TXFEIE, 1 << 30   @ bitWidth 1 (TXFIFO empty interrupt  enable)  
        .equ USART6_CR1_FIFOEN, 1 << 29   @ bitWidth 1 (FIFO mode enable)  
        .equ USART6_CR1_M1, 1 << 28   @ bitWidth 1 (Word length)  
        .equ USART6_CR1_EOBIE, 1 << 27   @ bitWidth 1 (End of Block interrupt  enable)  
        .equ USART6_CR1_RTOIE, 1 << 26   @ bitWidth 1 (Receiver timeout interrupt  enable)  
        .equ USART6_CR1_DEAT4, 1 << 25   @ bitWidth 1 (Driver Enable assertion  time)  
        .equ USART6_CR1_DEAT3, 1 << 24   @ bitWidth 1 (DEAT3)  
        .equ USART6_CR1_DEAT2, 1 << 23   @ bitWidth 1 (DEAT2)  
        .equ USART6_CR1_DEAT1, 1 << 22   @ bitWidth 1 (DEAT1)  
        .equ USART6_CR1_DEAT0, 1 << 21   @ bitWidth 1 (DEAT0)  
        .equ USART6_CR1_DEDT4, 1 << 20   @ bitWidth 1 (Driver Enable de-assertion  time)  
        .equ USART6_CR1_DEDT3, 1 << 19   @ bitWidth 1 (DEDT3)  
        .equ USART6_CR1_DEDT2, 1 << 18   @ bitWidth 1 (DEDT2)  
        .equ USART6_CR1_DEDT1, 1 << 17   @ bitWidth 1 (DEDT1)  
        .equ USART6_CR1_DEDT0, 1 << 16   @ bitWidth 1 (DEDT0)  
        .equ USART6_CR1_OVER8, 1 << 15   @ bitWidth 1 (Oversampling mode)  
        .equ USART6_CR1_CMIE, 1 << 14   @ bitWidth 1 (Character match interrupt  enable)  
        .equ USART6_CR1_MME, 1 << 13   @ bitWidth 1 (Mute mode enable)  
        .equ USART6_CR1_M0, 1 << 12   @ bitWidth 1 (Word length)  
        .equ USART6_CR1_WAKE, 1 << 11   @ bitWidth 1 (Receiver wakeup method)  
        .equ USART6_CR1_PCE, 1 << 10   @ bitWidth 1 (Parity control enable)  
        .equ USART6_CR1_PS, 1 << 9   @ bitWidth 1 (Parity selection)  
        .equ USART6_CR1_PEIE, 1 << 8   @ bitWidth 1 (PE interrupt enable)  
        .equ USART6_CR1_TXEIE, 1 << 7   @ bitWidth 1 (interrupt enable)  
        .equ USART6_CR1_TCIE, 1 << 6   @ bitWidth 1 (Transmission complete interrupt  enable)  
        .equ USART6_CR1_RXNEIE, 1 << 5   @ bitWidth 1 (RXNE interrupt enable)  
        .equ USART6_CR1_IDLEIE, 1 << 4   @ bitWidth 1 (IDLE interrupt enable)  
        .equ USART6_CR1_TE, 1 << 3   @ bitWidth 1 (Transmitter enable)  
        .equ USART6_CR1_RE, 1 << 2   @ bitWidth 1 (Receiver enable)  
        .equ USART6_CR1_UESM, 1 << 1   @ bitWidth 1 (USART enable in Stop mode)  
        .equ USART6_CR1_UE, 1 << 0   @ bitWidth 1 (USART enable)  
 
    .equ USART6_CR2, USART6_BASE + 0x4 @ (Control register 2) 
        .equ USART6_CR2_ADD4_7_Shift, 28   @ bitWidth 4 (Address of the USART node)  
        .equ USART6_CR2_ADD0_3_Shift, 24   @ bitWidth 4 (Address of the USART node)  
        .equ USART6_CR2_RTOEN, 1 << 23   @ bitWidth 1 (Receiver timeout enable)  
        .equ USART6_CR2_ABRMOD1, 1 << 22   @ bitWidth 1 (Auto baud rate mode)  
        .equ USART6_CR2_ABRMOD0, 1 << 21   @ bitWidth 1 (ABRMOD0)  
        .equ USART6_CR2_ABREN, 1 << 20   @ bitWidth 1 (Auto baud rate enable)  
        .equ USART6_CR2_MSBFIRST, 1 << 19   @ bitWidth 1 (Most significant bit first)  
        .equ USART6_CR2_TAINV, 1 << 18   @ bitWidth 1 (Binary data inversion)  
        .equ USART6_CR2_TXINV, 1 << 17   @ bitWidth 1 (TX pin active level  inversion)  
        .equ USART6_CR2_RXINV, 1 << 16   @ bitWidth 1 (RX pin active level  inversion)  
        .equ USART6_CR2_SWAP, 1 << 15   @ bitWidth 1 (Swap TX/RX pins)  
        .equ USART6_CR2_LINEN, 1 << 14   @ bitWidth 1 (LIN mode enable)  
        .equ USART6_CR2_STOP_Shift, 12   @ bitWidth 2 (STOP bits)  
        .equ USART6_CR2_CLKEN, 1 << 11   @ bitWidth 1 (Clock enable)  
        .equ USART6_CR2_CPOL, 1 << 10   @ bitWidth 1 (Clock polarity)  
        .equ USART6_CR2_CPHA, 1 << 9   @ bitWidth 1 (Clock phase)  
        .equ USART6_CR2_LBCL, 1 << 8   @ bitWidth 1 (Last bit clock pulse)  
        .equ USART6_CR2_LBDIE, 1 << 6   @ bitWidth 1 (LIN break detection interrupt  enable)  
        .equ USART6_CR2_LBDL, 1 << 5   @ bitWidth 1 (LIN break detection length)  
        .equ USART6_CR2_ADDM7, 1 << 4   @ bitWidth 1 (7-bit Address Detection/4-bit Address  Detection)  
        .equ USART6_CR2_DIS_NSS, 1 << 3   @ bitWidth 1 (When the DSI_NSS bit is set, the NSS pin  input is ignored)  
        .equ USART6_CR2_SLVEN, 1 << 0   @ bitWidth 1 (Synchronous Slave mode  enable)  
 
    .equ USART6_CR3, USART6_BASE + 0x8 @ (Control register 3) 
        .equ USART6_CR3_TXFTCFG_Shift, 29   @ bitWidth 3 (TXFIFO threshold  configuration)  
        .equ USART6_CR3_RXFTIE, 1 << 28   @ bitWidth 1 (RXFIFO threshold interrupt  enable)  
        .equ USART6_CR3_RXFTCFG_Shift, 25   @ bitWidth 3 (Receive FIFO threshold  configuration)  
        .equ USART6_CR3_TCBGTIE, 1 << 24   @ bitWidth 1 (Transmission Complete before guard time,  interrupt enable)  
        .equ USART6_CR3_TXFTIE, 1 << 23   @ bitWidth 1 (TXFIFO threshold interrupt  enable)  
        .equ USART6_CR3_WUFIE, 1 << 22   @ bitWidth 1 (Wakeup from Stop mode interrupt  enable)  
        .equ USART6_CR3_WUS_Shift, 20   @ bitWidth 2 (Wakeup from Stop mode interrupt flag  selection)  
        .equ USART6_CR3_SCARCNT_Shift, 17   @ bitWidth 3 (Smartcard auto-retry count)  
        .equ USART6_CR3_DEP, 1 << 15   @ bitWidth 1 (Driver enable polarity  selection)  
        .equ USART6_CR3_DEM, 1 << 14   @ bitWidth 1 (Driver enable mode)  
        .equ USART6_CR3_DDRE, 1 << 13   @ bitWidth 1 (DMA Disable on Reception  Error)  
        .equ USART6_CR3_OVRDIS, 1 << 12   @ bitWidth 1 (Overrun Disable)  
        .equ USART6_CR3_ONEBIT, 1 << 11   @ bitWidth 1 (One sample bit method  enable)  
        .equ USART6_CR3_CTSIE, 1 << 10   @ bitWidth 1 (CTS interrupt enable)  
        .equ USART6_CR3_CTSE, 1 << 9   @ bitWidth 1 (CTS enable)  
        .equ USART6_CR3_RTSE, 1 << 8   @ bitWidth 1 (RTS enable)  
        .equ USART6_CR3_DMAT, 1 << 7   @ bitWidth 1 (DMA enable transmitter)  
        .equ USART6_CR3_DMAR, 1 << 6   @ bitWidth 1 (DMA enable receiver)  
        .equ USART6_CR3_SCEN, 1 << 5   @ bitWidth 1 (Smartcard mode enable)  
        .equ USART6_CR3_NACK, 1 << 4   @ bitWidth 1 (Smartcard NACK enable)  
        .equ USART6_CR3_HDSEL, 1 << 3   @ bitWidth 1 (Half-duplex selection)  
        .equ USART6_CR3_IRLP, 1 << 2   @ bitWidth 1 (Ir low-power)  
        .equ USART6_CR3_IREN, 1 << 1   @ bitWidth 1 (Ir mode enable)  
        .equ USART6_CR3_EIE, 1 << 0   @ bitWidth 1 (Error interrupt enable)  
 
    .equ USART6_BRR, USART6_BASE + 0xC @ (Baud rate register) 
        .equ USART6_BRR_BRR_4_15_Shift, 4   @ bitWidth 12 (DIV_Mantissa)  
        .equ USART6_BRR_BRR_0_3_Shift, 0   @ bitWidth 4 (DIV_Fraction)  
 
    .equ USART6_GTPR, USART6_BASE + 0x10 @ (Guard time and prescaler  register) 
        .equ USART6_GTPR_GT_Shift, 8   @ bitWidth 8 (Guard time value)  
        .equ USART6_GTPR_PSC_Shift, 0   @ bitWidth 8 (Prescaler value)  
 
    .equ USART6_RTOR, USART6_BASE + 0x14 @ (Receiver timeout register) 
        .equ USART6_RTOR_BLEN_Shift, 24   @ bitWidth 8 (Block Length)  
        .equ USART6_RTOR_RTO_Shift, 0   @ bitWidth 24 (Receiver timeout value)  
 
    .equ USART6_RQR, USART6_BASE + 0x18 @ (Request register) 
        .equ USART6_RQR_TXFRQ, 1 << 4   @ bitWidth 1 (Transmit data flush  request)  
        .equ USART6_RQR_RXFRQ, 1 << 3   @ bitWidth 1 (Receive data flush request)  
        .equ USART6_RQR_MMRQ, 1 << 2   @ bitWidth 1 (Mute mode request)  
        .equ USART6_RQR_SBKRQ, 1 << 1   @ bitWidth 1 (Send break request)  
        .equ USART6_RQR_ABRRQ, 1 << 0   @ bitWidth 1 (Auto baud rate request)  
 
    .equ USART6_ISR, USART6_BASE + 0x1C @ (Interrupt & status  register) 
        .equ USART6_ISR_TXFT, 1 << 27   @ bitWidth 1 (TXFIFO threshold flag)  
        .equ USART6_ISR_RXFT, 1 << 26   @ bitWidth 1 (RXFIFO threshold flag)  
        .equ USART6_ISR_TCBGT, 1 << 25   @ bitWidth 1 (Transmission complete before guard time  flag)  
        .equ USART6_ISR_RXFF, 1 << 24   @ bitWidth 1 (RXFIFO Full)  
        .equ USART6_ISR_TXFE, 1 << 23   @ bitWidth 1 (TXFIFO Empty)  
        .equ USART6_ISR_REACK, 1 << 22   @ bitWidth 1 (REACK)  
        .equ USART6_ISR_TEACK, 1 << 21   @ bitWidth 1 (TEACK)  
        .equ USART6_ISR_WUF, 1 << 20   @ bitWidth 1 (WUF)  
        .equ USART6_ISR_RWU, 1 << 19   @ bitWidth 1 (RWU)  
        .equ USART6_ISR_SBKF, 1 << 18   @ bitWidth 1 (SBKF)  
        .equ USART6_ISR_CMF, 1 << 17   @ bitWidth 1 (CMF)  
        .equ USART6_ISR_BUSY, 1 << 16   @ bitWidth 1 (BUSY)  
        .equ USART6_ISR_ABRF, 1 << 15   @ bitWidth 1 (ABRF)  
        .equ USART6_ISR_ABRE, 1 << 14   @ bitWidth 1 (ABRE)  
        .equ USART6_ISR_UDR, 1 << 13   @ bitWidth 1 (SPI slave underrun error  flag)  
        .equ USART6_ISR_EOBF, 1 << 12   @ bitWidth 1 (EOBF)  
        .equ USART6_ISR_RTOF, 1 << 11   @ bitWidth 1 (RTOF)  
        .equ USART6_ISR_CTS, 1 << 10   @ bitWidth 1 (CTS)  
        .equ USART6_ISR_CTSIF, 1 << 9   @ bitWidth 1 (CTSIF)  
        .equ USART6_ISR_LBDF, 1 << 8   @ bitWidth 1 (LBDF)  
        .equ USART6_ISR_TXE, 1 << 7   @ bitWidth 1 (TXE)  
        .equ USART6_ISR_TC, 1 << 6   @ bitWidth 1 (TC)  
        .equ USART6_ISR_RXNE, 1 << 5   @ bitWidth 1 (RXNE)  
        .equ USART6_ISR_IDLE, 1 << 4   @ bitWidth 1 (IDLE)  
        .equ USART6_ISR_ORE, 1 << 3   @ bitWidth 1 (ORE)  
        .equ USART6_ISR_NF, 1 << 2   @ bitWidth 1 (NF)  
        .equ USART6_ISR_FE, 1 << 1   @ bitWidth 1 (FE)  
        .equ USART6_ISR_PE, 1 << 0   @ bitWidth 1 (PE)  
 
    .equ USART6_ICR, USART6_BASE + 0x20 @ (Interrupt flag clear register) 
        .equ USART6_ICR_WUCF, 1 << 20   @ bitWidth 1 (Wakeup from Stop mode clear  flag)  
        .equ USART6_ICR_CMCF, 1 << 17   @ bitWidth 1 (Character match clear flag)  
        .equ USART6_ICR_UDRCF, 1 << 13   @ bitWidth 1 (SPI slave underrun clear  flag)  
        .equ USART6_ICR_EOBCF, 1 << 12   @ bitWidth 1 (End of block clear flag)  
        .equ USART6_ICR_RTOCF, 1 << 11   @ bitWidth 1 (Receiver timeout clear  flag)  
        .equ USART6_ICR_CTSCF, 1 << 9   @ bitWidth 1 (CTS clear flag)  
        .equ USART6_ICR_LBDCF, 1 << 8   @ bitWidth 1 (LIN break detection clear  flag)  
        .equ USART6_ICR_TCBGTC, 1 << 7   @ bitWidth 1 (Transmission complete before Guard time  clear flag)  
        .equ USART6_ICR_TCCF, 1 << 6   @ bitWidth 1 (Transmission complete clear  flag)  
        .equ USART6_ICR_TXFECF, 1 << 5   @ bitWidth 1 (TXFIFO empty clear flag)  
        .equ USART6_ICR_IDLECF, 1 << 4   @ bitWidth 1 (Idle line detected clear  flag)  
        .equ USART6_ICR_ORECF, 1 << 3   @ bitWidth 1 (Overrun error clear flag)  
        .equ USART6_ICR_NCF, 1 << 2   @ bitWidth 1 (Noise detected clear flag)  
        .equ USART6_ICR_FECF, 1 << 1   @ bitWidth 1 (Framing error clear flag)  
        .equ USART6_ICR_PECF, 1 << 0   @ bitWidth 1 (Parity error clear flag)  
 
    .equ USART6_RDR, USART6_BASE + 0x24 @ (Receive data register) 
        .equ USART6_RDR_RDR_Shift, 0   @ bitWidth 9 (Receive data value)  
 
    .equ USART6_TDR, USART6_BASE + 0x28 @ (Transmit data register) 
        .equ USART6_TDR_TDR_Shift, 0   @ bitWidth 9 (Transmit data value)  
 
    .equ USART6_PRESC, USART6_BASE + 0x2C @ (USART prescaler register) 
        .equ USART6_PRESC_PRESCALER_Shift, 0   @ bitWidth 4 (Clock prescaler)  
 

@=========================== UART7 ===========================@
.equ UART7_BASE, 0x40007800 @ (Universal synchronous asynchronous receiver  transmitter) 
    .equ UART7_CR1, UART7_BASE + 0x0 @ (Control register 1) 
        .equ UART7_CR1_RXFFIE, 1 << 31   @ bitWidth 1 (RXFIFO Full interrupt  enable)  
        .equ UART7_CR1_TXFEIE, 1 << 30   @ bitWidth 1 (TXFIFO empty interrupt  enable)  
        .equ UART7_CR1_FIFOEN, 1 << 29   @ bitWidth 1 (FIFO mode enable)  
        .equ UART7_CR1_M1, 1 << 28   @ bitWidth 1 (Word length)  
        .equ UART7_CR1_EOBIE, 1 << 27   @ bitWidth 1 (End of Block interrupt  enable)  
        .equ UART7_CR1_RTOIE, 1 << 26   @ bitWidth 1 (Receiver timeout interrupt  enable)  
        .equ UART7_CR1_DEAT4, 1 << 25   @ bitWidth 1 (Driver Enable assertion  time)  
        .equ UART7_CR1_DEAT3, 1 << 24   @ bitWidth 1 (DEAT3)  
        .equ UART7_CR1_DEAT2, 1 << 23   @ bitWidth 1 (DEAT2)  
        .equ UART7_CR1_DEAT1, 1 << 22   @ bitWidth 1 (DEAT1)  
        .equ UART7_CR1_DEAT0, 1 << 21   @ bitWidth 1 (DEAT0)  
        .equ UART7_CR1_DEDT4, 1 << 20   @ bitWidth 1 (Driver Enable de-assertion  time)  
        .equ UART7_CR1_DEDT3, 1 << 19   @ bitWidth 1 (DEDT3)  
        .equ UART7_CR1_DEDT2, 1 << 18   @ bitWidth 1 (DEDT2)  
        .equ UART7_CR1_DEDT1, 1 << 17   @ bitWidth 1 (DEDT1)  
        .equ UART7_CR1_DEDT0, 1 << 16   @ bitWidth 1 (DEDT0)  
        .equ UART7_CR1_OVER8, 1 << 15   @ bitWidth 1 (Oversampling mode)  
        .equ UART7_CR1_CMIE, 1 << 14   @ bitWidth 1 (Character match interrupt  enable)  
        .equ UART7_CR1_MME, 1 << 13   @ bitWidth 1 (Mute mode enable)  
        .equ UART7_CR1_M0, 1 << 12   @ bitWidth 1 (Word length)  
        .equ UART7_CR1_WAKE, 1 << 11   @ bitWidth 1 (Receiver wakeup method)  
        .equ UART7_CR1_PCE, 1 << 10   @ bitWidth 1 (Parity control enable)  
        .equ UART7_CR1_PS, 1 << 9   @ bitWidth 1 (Parity selection)  
        .equ UART7_CR1_PEIE, 1 << 8   @ bitWidth 1 (PE interrupt enable)  
        .equ UART7_CR1_TXEIE, 1 << 7   @ bitWidth 1 (interrupt enable)  
        .equ UART7_CR1_TCIE, 1 << 6   @ bitWidth 1 (Transmission complete interrupt  enable)  
        .equ UART7_CR1_RXNEIE, 1 << 5   @ bitWidth 1 (RXNE interrupt enable)  
        .equ UART7_CR1_IDLEIE, 1 << 4   @ bitWidth 1 (IDLE interrupt enable)  
        .equ UART7_CR1_TE, 1 << 3   @ bitWidth 1 (Transmitter enable)  
        .equ UART7_CR1_RE, 1 << 2   @ bitWidth 1 (Receiver enable)  
        .equ UART7_CR1_UESM, 1 << 1   @ bitWidth 1 (USART enable in Stop mode)  
        .equ UART7_CR1_UE, 1 << 0   @ bitWidth 1 (USART enable)  
 
    .equ UART7_CR2, UART7_BASE + 0x4 @ (Control register 2) 
        .equ UART7_CR2_ADD4_7_Shift, 28   @ bitWidth 4 (Address of the USART node)  
        .equ UART7_CR2_ADD0_3_Shift, 24   @ bitWidth 4 (Address of the USART node)  
        .equ UART7_CR2_RTOEN, 1 << 23   @ bitWidth 1 (Receiver timeout enable)  
        .equ UART7_CR2_ABRMOD1, 1 << 22   @ bitWidth 1 (Auto baud rate mode)  
        .equ UART7_CR2_ABRMOD0, 1 << 21   @ bitWidth 1 (ABRMOD0)  
        .equ UART7_CR2_ABREN, 1 << 20   @ bitWidth 1 (Auto baud rate enable)  
        .equ UART7_CR2_MSBFIRST, 1 << 19   @ bitWidth 1 (Most significant bit first)  
        .equ UART7_CR2_TAINV, 1 << 18   @ bitWidth 1 (Binary data inversion)  
        .equ UART7_CR2_TXINV, 1 << 17   @ bitWidth 1 (TX pin active level  inversion)  
        .equ UART7_CR2_RXINV, 1 << 16   @ bitWidth 1 (RX pin active level  inversion)  
        .equ UART7_CR2_SWAP, 1 << 15   @ bitWidth 1 (Swap TX/RX pins)  
        .equ UART7_CR2_LINEN, 1 << 14   @ bitWidth 1 (LIN mode enable)  
        .equ UART7_CR2_STOP_Shift, 12   @ bitWidth 2 (STOP bits)  
        .equ UART7_CR2_CLKEN, 1 << 11   @ bitWidth 1 (Clock enable)  
        .equ UART7_CR2_CPOL, 1 << 10   @ bitWidth 1 (Clock polarity)  
        .equ UART7_CR2_CPHA, 1 << 9   @ bitWidth 1 (Clock phase)  
        .equ UART7_CR2_LBCL, 1 << 8   @ bitWidth 1 (Last bit clock pulse)  
        .equ UART7_CR2_LBDIE, 1 << 6   @ bitWidth 1 (LIN break detection interrupt  enable)  
        .equ UART7_CR2_LBDL, 1 << 5   @ bitWidth 1 (LIN break detection length)  
        .equ UART7_CR2_ADDM7, 1 << 4   @ bitWidth 1 (7-bit Address Detection/4-bit Address  Detection)  
        .equ UART7_CR2_DIS_NSS, 1 << 3   @ bitWidth 1 (When the DSI_NSS bit is set, the NSS pin  input is ignored)  
        .equ UART7_CR2_SLVEN, 1 << 0   @ bitWidth 1 (Synchronous Slave mode  enable)  
 
    .equ UART7_CR3, UART7_BASE + 0x8 @ (Control register 3) 
        .equ UART7_CR3_TXFTCFG_Shift, 29   @ bitWidth 3 (TXFIFO threshold  configuration)  
        .equ UART7_CR3_RXFTIE, 1 << 28   @ bitWidth 1 (RXFIFO threshold interrupt  enable)  
        .equ UART7_CR3_RXFTCFG_Shift, 25   @ bitWidth 3 (Receive FIFO threshold  configuration)  
        .equ UART7_CR3_TCBGTIE, 1 << 24   @ bitWidth 1 (Transmission Complete before guard time,  interrupt enable)  
        .equ UART7_CR3_TXFTIE, 1 << 23   @ bitWidth 1 (TXFIFO threshold interrupt  enable)  
        .equ UART7_CR3_WUFIE, 1 << 22   @ bitWidth 1 (Wakeup from Stop mode interrupt  enable)  
        .equ UART7_CR3_WUS_Shift, 20   @ bitWidth 2 (Wakeup from Stop mode interrupt flag  selection)  
        .equ UART7_CR3_SCARCNT_Shift, 17   @ bitWidth 3 (Smartcard auto-retry count)  
        .equ UART7_CR3_DEP, 1 << 15   @ bitWidth 1 (Driver enable polarity  selection)  
        .equ UART7_CR3_DEM, 1 << 14   @ bitWidth 1 (Driver enable mode)  
        .equ UART7_CR3_DDRE, 1 << 13   @ bitWidth 1 (DMA Disable on Reception  Error)  
        .equ UART7_CR3_OVRDIS, 1 << 12   @ bitWidth 1 (Overrun Disable)  
        .equ UART7_CR3_ONEBIT, 1 << 11   @ bitWidth 1 (One sample bit method  enable)  
        .equ UART7_CR3_CTSIE, 1 << 10   @ bitWidth 1 (CTS interrupt enable)  
        .equ UART7_CR3_CTSE, 1 << 9   @ bitWidth 1 (CTS enable)  
        .equ UART7_CR3_RTSE, 1 << 8   @ bitWidth 1 (RTS enable)  
        .equ UART7_CR3_DMAT, 1 << 7   @ bitWidth 1 (DMA enable transmitter)  
        .equ UART7_CR3_DMAR, 1 << 6   @ bitWidth 1 (DMA enable receiver)  
        .equ UART7_CR3_SCEN, 1 << 5   @ bitWidth 1 (Smartcard mode enable)  
        .equ UART7_CR3_NACK, 1 << 4   @ bitWidth 1 (Smartcard NACK enable)  
        .equ UART7_CR3_HDSEL, 1 << 3   @ bitWidth 1 (Half-duplex selection)  
        .equ UART7_CR3_IRLP, 1 << 2   @ bitWidth 1 (Ir low-power)  
        .equ UART7_CR3_IREN, 1 << 1   @ bitWidth 1 (Ir mode enable)  
        .equ UART7_CR3_EIE, 1 << 0   @ bitWidth 1 (Error interrupt enable)  
 
    .equ UART7_BRR, UART7_BASE + 0xC @ (Baud rate register) 
        .equ UART7_BRR_BRR_4_15_Shift, 4   @ bitWidth 12 (DIV_Mantissa)  
        .equ UART7_BRR_BRR_0_3_Shift, 0   @ bitWidth 4 (DIV_Fraction)  
 
    .equ UART7_GTPR, UART7_BASE + 0x10 @ (Guard time and prescaler  register) 
        .equ UART7_GTPR_GT_Shift, 8   @ bitWidth 8 (Guard time value)  
        .equ UART7_GTPR_PSC_Shift, 0   @ bitWidth 8 (Prescaler value)  
 
    .equ UART7_RTOR, UART7_BASE + 0x14 @ (Receiver timeout register) 
        .equ UART7_RTOR_BLEN_Shift, 24   @ bitWidth 8 (Block Length)  
        .equ UART7_RTOR_RTO_Shift, 0   @ bitWidth 24 (Receiver timeout value)  
 
    .equ UART7_RQR, UART7_BASE + 0x18 @ (Request register) 
        .equ UART7_RQR_TXFRQ, 1 << 4   @ bitWidth 1 (Transmit data flush  request)  
        .equ UART7_RQR_RXFRQ, 1 << 3   @ bitWidth 1 (Receive data flush request)  
        .equ UART7_RQR_MMRQ, 1 << 2   @ bitWidth 1 (Mute mode request)  
        .equ UART7_RQR_SBKRQ, 1 << 1   @ bitWidth 1 (Send break request)  
        .equ UART7_RQR_ABRRQ, 1 << 0   @ bitWidth 1 (Auto baud rate request)  
 
    .equ UART7_ISR, UART7_BASE + 0x1C @ (Interrupt & status  register) 
        .equ UART7_ISR_TXFT, 1 << 27   @ bitWidth 1 (TXFIFO threshold flag)  
        .equ UART7_ISR_RXFT, 1 << 26   @ bitWidth 1 (RXFIFO threshold flag)  
        .equ UART7_ISR_TCBGT, 1 << 25   @ bitWidth 1 (Transmission complete before guard time  flag)  
        .equ UART7_ISR_RXFF, 1 << 24   @ bitWidth 1 (RXFIFO Full)  
        .equ UART7_ISR_TXFE, 1 << 23   @ bitWidth 1 (TXFIFO Empty)  
        .equ UART7_ISR_REACK, 1 << 22   @ bitWidth 1 (REACK)  
        .equ UART7_ISR_TEACK, 1 << 21   @ bitWidth 1 (TEACK)  
        .equ UART7_ISR_WUF, 1 << 20   @ bitWidth 1 (WUF)  
        .equ UART7_ISR_RWU, 1 << 19   @ bitWidth 1 (RWU)  
        .equ UART7_ISR_SBKF, 1 << 18   @ bitWidth 1 (SBKF)  
        .equ UART7_ISR_CMF, 1 << 17   @ bitWidth 1 (CMF)  
        .equ UART7_ISR_BUSY, 1 << 16   @ bitWidth 1 (BUSY)  
        .equ UART7_ISR_ABRF, 1 << 15   @ bitWidth 1 (ABRF)  
        .equ UART7_ISR_ABRE, 1 << 14   @ bitWidth 1 (ABRE)  
        .equ UART7_ISR_UDR, 1 << 13   @ bitWidth 1 (SPI slave underrun error  flag)  
        .equ UART7_ISR_EOBF, 1 << 12   @ bitWidth 1 (EOBF)  
        .equ UART7_ISR_RTOF, 1 << 11   @ bitWidth 1 (RTOF)  
        .equ UART7_ISR_CTS, 1 << 10   @ bitWidth 1 (CTS)  
        .equ UART7_ISR_CTSIF, 1 << 9   @ bitWidth 1 (CTSIF)  
        .equ UART7_ISR_LBDF, 1 << 8   @ bitWidth 1 (LBDF)  
        .equ UART7_ISR_TXE, 1 << 7   @ bitWidth 1 (TXE)  
        .equ UART7_ISR_TC, 1 << 6   @ bitWidth 1 (TC)  
        .equ UART7_ISR_RXNE, 1 << 5   @ bitWidth 1 (RXNE)  
        .equ UART7_ISR_IDLE, 1 << 4   @ bitWidth 1 (IDLE)  
        .equ UART7_ISR_ORE, 1 << 3   @ bitWidth 1 (ORE)  
        .equ UART7_ISR_NF, 1 << 2   @ bitWidth 1 (NF)  
        .equ UART7_ISR_FE, 1 << 1   @ bitWidth 1 (FE)  
        .equ UART7_ISR_PE, 1 << 0   @ bitWidth 1 (PE)  
 
    .equ UART7_ICR, UART7_BASE + 0x20 @ (Interrupt flag clear register) 
        .equ UART7_ICR_WUCF, 1 << 20   @ bitWidth 1 (Wakeup from Stop mode clear  flag)  
        .equ UART7_ICR_CMCF, 1 << 17   @ bitWidth 1 (Character match clear flag)  
        .equ UART7_ICR_UDRCF, 1 << 13   @ bitWidth 1 (SPI slave underrun clear  flag)  
        .equ UART7_ICR_EOBCF, 1 << 12   @ bitWidth 1 (End of block clear flag)  
        .equ UART7_ICR_RTOCF, 1 << 11   @ bitWidth 1 (Receiver timeout clear  flag)  
        .equ UART7_ICR_CTSCF, 1 << 9   @ bitWidth 1 (CTS clear flag)  
        .equ UART7_ICR_LBDCF, 1 << 8   @ bitWidth 1 (LIN break detection clear  flag)  
        .equ UART7_ICR_TCBGTC, 1 << 7   @ bitWidth 1 (Transmission complete before Guard time  clear flag)  
        .equ UART7_ICR_TCCF, 1 << 6   @ bitWidth 1 (Transmission complete clear  flag)  
        .equ UART7_ICR_TXFECF, 1 << 5   @ bitWidth 1 (TXFIFO empty clear flag)  
        .equ UART7_ICR_IDLECF, 1 << 4   @ bitWidth 1 (Idle line detected clear  flag)  
        .equ UART7_ICR_ORECF, 1 << 3   @ bitWidth 1 (Overrun error clear flag)  
        .equ UART7_ICR_NCF, 1 << 2   @ bitWidth 1 (Noise detected clear flag)  
        .equ UART7_ICR_FECF, 1 << 1   @ bitWidth 1 (Framing error clear flag)  
        .equ UART7_ICR_PECF, 1 << 0   @ bitWidth 1 (Parity error clear flag)  
 
    .equ UART7_RDR, UART7_BASE + 0x24 @ (Receive data register) 
        .equ UART7_RDR_RDR_Shift, 0   @ bitWidth 9 (Receive data value)  
 
    .equ UART7_TDR, UART7_BASE + 0x28 @ (Transmit data register) 
        .equ UART7_TDR_TDR_Shift, 0   @ bitWidth 9 (Transmit data value)  
 
    .equ UART7_PRESC, UART7_BASE + 0x2C @ (USART prescaler register) 
        .equ UART7_PRESC_PRESCALER_Shift, 0   @ bitWidth 4 (Clock prescaler)  
 

@=========================== UART8 ===========================@
.equ UART8_BASE, 0x40007C00 @ (Universal synchronous asynchronous receiver  transmitter) 
    .equ UART8_CR1, UART8_BASE + 0x0 @ (Control register 1) 
        .equ UART8_CR1_RXFFIE, 1 << 31   @ bitWidth 1 (RXFIFO Full interrupt  enable)  
        .equ UART8_CR1_TXFEIE, 1 << 30   @ bitWidth 1 (TXFIFO empty interrupt  enable)  
        .equ UART8_CR1_FIFOEN, 1 << 29   @ bitWidth 1 (FIFO mode enable)  
        .equ UART8_CR1_M1, 1 << 28   @ bitWidth 1 (Word length)  
        .equ UART8_CR1_EOBIE, 1 << 27   @ bitWidth 1 (End of Block interrupt  enable)  
        .equ UART8_CR1_RTOIE, 1 << 26   @ bitWidth 1 (Receiver timeout interrupt  enable)  
        .equ UART8_CR1_DEAT4, 1 << 25   @ bitWidth 1 (Driver Enable assertion  time)  
        .equ UART8_CR1_DEAT3, 1 << 24   @ bitWidth 1 (DEAT3)  
        .equ UART8_CR1_DEAT2, 1 << 23   @ bitWidth 1 (DEAT2)  
        .equ UART8_CR1_DEAT1, 1 << 22   @ bitWidth 1 (DEAT1)  
        .equ UART8_CR1_DEAT0, 1 << 21   @ bitWidth 1 (DEAT0)  
        .equ UART8_CR1_DEDT4, 1 << 20   @ bitWidth 1 (Driver Enable de-assertion  time)  
        .equ UART8_CR1_DEDT3, 1 << 19   @ bitWidth 1 (DEDT3)  
        .equ UART8_CR1_DEDT2, 1 << 18   @ bitWidth 1 (DEDT2)  
        .equ UART8_CR1_DEDT1, 1 << 17   @ bitWidth 1 (DEDT1)  
        .equ UART8_CR1_DEDT0, 1 << 16   @ bitWidth 1 (DEDT0)  
        .equ UART8_CR1_OVER8, 1 << 15   @ bitWidth 1 (Oversampling mode)  
        .equ UART8_CR1_CMIE, 1 << 14   @ bitWidth 1 (Character match interrupt  enable)  
        .equ UART8_CR1_MME, 1 << 13   @ bitWidth 1 (Mute mode enable)  
        .equ UART8_CR1_M0, 1 << 12   @ bitWidth 1 (Word length)  
        .equ UART8_CR1_WAKE, 1 << 11   @ bitWidth 1 (Receiver wakeup method)  
        .equ UART8_CR1_PCE, 1 << 10   @ bitWidth 1 (Parity control enable)  
        .equ UART8_CR1_PS, 1 << 9   @ bitWidth 1 (Parity selection)  
        .equ UART8_CR1_PEIE, 1 << 8   @ bitWidth 1 (PE interrupt enable)  
        .equ UART8_CR1_TXEIE, 1 << 7   @ bitWidth 1 (interrupt enable)  
        .equ UART8_CR1_TCIE, 1 << 6   @ bitWidth 1 (Transmission complete interrupt  enable)  
        .equ UART8_CR1_RXNEIE, 1 << 5   @ bitWidth 1 (RXNE interrupt enable)  
        .equ UART8_CR1_IDLEIE, 1 << 4   @ bitWidth 1 (IDLE interrupt enable)  
        .equ UART8_CR1_TE, 1 << 3   @ bitWidth 1 (Transmitter enable)  
        .equ UART8_CR1_RE, 1 << 2   @ bitWidth 1 (Receiver enable)  
        .equ UART8_CR1_UESM, 1 << 1   @ bitWidth 1 (USART enable in Stop mode)  
        .equ UART8_CR1_UE, 1 << 0   @ bitWidth 1 (USART enable)  
 
    .equ UART8_CR2, UART8_BASE + 0x4 @ (Control register 2) 
        .equ UART8_CR2_ADD4_7_Shift, 28   @ bitWidth 4 (Address of the USART node)  
        .equ UART8_CR2_ADD0_3_Shift, 24   @ bitWidth 4 (Address of the USART node)  
        .equ UART8_CR2_RTOEN, 1 << 23   @ bitWidth 1 (Receiver timeout enable)  
        .equ UART8_CR2_ABRMOD1, 1 << 22   @ bitWidth 1 (Auto baud rate mode)  
        .equ UART8_CR2_ABRMOD0, 1 << 21   @ bitWidth 1 (ABRMOD0)  
        .equ UART8_CR2_ABREN, 1 << 20   @ bitWidth 1 (Auto baud rate enable)  
        .equ UART8_CR2_MSBFIRST, 1 << 19   @ bitWidth 1 (Most significant bit first)  
        .equ UART8_CR2_TAINV, 1 << 18   @ bitWidth 1 (Binary data inversion)  
        .equ UART8_CR2_TXINV, 1 << 17   @ bitWidth 1 (TX pin active level  inversion)  
        .equ UART8_CR2_RXINV, 1 << 16   @ bitWidth 1 (RX pin active level  inversion)  
        .equ UART8_CR2_SWAP, 1 << 15   @ bitWidth 1 (Swap TX/RX pins)  
        .equ UART8_CR2_LINEN, 1 << 14   @ bitWidth 1 (LIN mode enable)  
        .equ UART8_CR2_STOP_Shift, 12   @ bitWidth 2 (STOP bits)  
        .equ UART8_CR2_CLKEN, 1 << 11   @ bitWidth 1 (Clock enable)  
        .equ UART8_CR2_CPOL, 1 << 10   @ bitWidth 1 (Clock polarity)  
        .equ UART8_CR2_CPHA, 1 << 9   @ bitWidth 1 (Clock phase)  
        .equ UART8_CR2_LBCL, 1 << 8   @ bitWidth 1 (Last bit clock pulse)  
        .equ UART8_CR2_LBDIE, 1 << 6   @ bitWidth 1 (LIN break detection interrupt  enable)  
        .equ UART8_CR2_LBDL, 1 << 5   @ bitWidth 1 (LIN break detection length)  
        .equ UART8_CR2_ADDM7, 1 << 4   @ bitWidth 1 (7-bit Address Detection/4-bit Address  Detection)  
        .equ UART8_CR2_DIS_NSS, 1 << 3   @ bitWidth 1 (When the DSI_NSS bit is set, the NSS pin  input is ignored)  
        .equ UART8_CR2_SLVEN, 1 << 0   @ bitWidth 1 (Synchronous Slave mode  enable)  
 
    .equ UART8_CR3, UART8_BASE + 0x8 @ (Control register 3) 
        .equ UART8_CR3_TXFTCFG_Shift, 29   @ bitWidth 3 (TXFIFO threshold  configuration)  
        .equ UART8_CR3_RXFTIE, 1 << 28   @ bitWidth 1 (RXFIFO threshold interrupt  enable)  
        .equ UART8_CR3_RXFTCFG_Shift, 25   @ bitWidth 3 (Receive FIFO threshold  configuration)  
        .equ UART8_CR3_TCBGTIE, 1 << 24   @ bitWidth 1 (Transmission Complete before guard time,  interrupt enable)  
        .equ UART8_CR3_TXFTIE, 1 << 23   @ bitWidth 1 (TXFIFO threshold interrupt  enable)  
        .equ UART8_CR3_WUFIE, 1 << 22   @ bitWidth 1 (Wakeup from Stop mode interrupt  enable)  
        .equ UART8_CR3_WUS_Shift, 20   @ bitWidth 2 (Wakeup from Stop mode interrupt flag  selection)  
        .equ UART8_CR3_SCARCNT_Shift, 17   @ bitWidth 3 (Smartcard auto-retry count)  
        .equ UART8_CR3_DEP, 1 << 15   @ bitWidth 1 (Driver enable polarity  selection)  
        .equ UART8_CR3_DEM, 1 << 14   @ bitWidth 1 (Driver enable mode)  
        .equ UART8_CR3_DDRE, 1 << 13   @ bitWidth 1 (DMA Disable on Reception  Error)  
        .equ UART8_CR3_OVRDIS, 1 << 12   @ bitWidth 1 (Overrun Disable)  
        .equ UART8_CR3_ONEBIT, 1 << 11   @ bitWidth 1 (One sample bit method  enable)  
        .equ UART8_CR3_CTSIE, 1 << 10   @ bitWidth 1 (CTS interrupt enable)  
        .equ UART8_CR3_CTSE, 1 << 9   @ bitWidth 1 (CTS enable)  
        .equ UART8_CR3_RTSE, 1 << 8   @ bitWidth 1 (RTS enable)  
        .equ UART8_CR3_DMAT, 1 << 7   @ bitWidth 1 (DMA enable transmitter)  
        .equ UART8_CR3_DMAR, 1 << 6   @ bitWidth 1 (DMA enable receiver)  
        .equ UART8_CR3_SCEN, 1 << 5   @ bitWidth 1 (Smartcard mode enable)  
        .equ UART8_CR3_NACK, 1 << 4   @ bitWidth 1 (Smartcard NACK enable)  
        .equ UART8_CR3_HDSEL, 1 << 3   @ bitWidth 1 (Half-duplex selection)  
        .equ UART8_CR3_IRLP, 1 << 2   @ bitWidth 1 (Ir low-power)  
        .equ UART8_CR3_IREN, 1 << 1   @ bitWidth 1 (Ir mode enable)  
        .equ UART8_CR3_EIE, 1 << 0   @ bitWidth 1 (Error interrupt enable)  
 
    .equ UART8_BRR, UART8_BASE + 0xC @ (Baud rate register) 
        .equ UART8_BRR_BRR_4_15_Shift, 4   @ bitWidth 12 (DIV_Mantissa)  
        .equ UART8_BRR_BRR_0_3_Shift, 0   @ bitWidth 4 (DIV_Fraction)  
 
    .equ UART8_GTPR, UART8_BASE + 0x10 @ (Guard time and prescaler  register) 
        .equ UART8_GTPR_GT_Shift, 8   @ bitWidth 8 (Guard time value)  
        .equ UART8_GTPR_PSC_Shift, 0   @ bitWidth 8 (Prescaler value)  
 
    .equ UART8_RTOR, UART8_BASE + 0x14 @ (Receiver timeout register) 
        .equ UART8_RTOR_BLEN_Shift, 24   @ bitWidth 8 (Block Length)  
        .equ UART8_RTOR_RTO_Shift, 0   @ bitWidth 24 (Receiver timeout value)  
 
    .equ UART8_RQR, UART8_BASE + 0x18 @ (Request register) 
        .equ UART8_RQR_TXFRQ, 1 << 4   @ bitWidth 1 (Transmit data flush  request)  
        .equ UART8_RQR_RXFRQ, 1 << 3   @ bitWidth 1 (Receive data flush request)  
        .equ UART8_RQR_MMRQ, 1 << 2   @ bitWidth 1 (Mute mode request)  
        .equ UART8_RQR_SBKRQ, 1 << 1   @ bitWidth 1 (Send break request)  
        .equ UART8_RQR_ABRRQ, 1 << 0   @ bitWidth 1 (Auto baud rate request)  
 
    .equ UART8_ISR, UART8_BASE + 0x1C @ (Interrupt & status  register) 
        .equ UART8_ISR_TXFT, 1 << 27   @ bitWidth 1 (TXFIFO threshold flag)  
        .equ UART8_ISR_RXFT, 1 << 26   @ bitWidth 1 (RXFIFO threshold flag)  
        .equ UART8_ISR_TCBGT, 1 << 25   @ bitWidth 1 (Transmission complete before guard time  flag)  
        .equ UART8_ISR_RXFF, 1 << 24   @ bitWidth 1 (RXFIFO Full)  
        .equ UART8_ISR_TXFE, 1 << 23   @ bitWidth 1 (TXFIFO Empty)  
        .equ UART8_ISR_REACK, 1 << 22   @ bitWidth 1 (REACK)  
        .equ UART8_ISR_TEACK, 1 << 21   @ bitWidth 1 (TEACK)  
        .equ UART8_ISR_WUF, 1 << 20   @ bitWidth 1 (WUF)  
        .equ UART8_ISR_RWU, 1 << 19   @ bitWidth 1 (RWU)  
        .equ UART8_ISR_SBKF, 1 << 18   @ bitWidth 1 (SBKF)  
        .equ UART8_ISR_CMF, 1 << 17   @ bitWidth 1 (CMF)  
        .equ UART8_ISR_BUSY, 1 << 16   @ bitWidth 1 (BUSY)  
        .equ UART8_ISR_ABRF, 1 << 15   @ bitWidth 1 (ABRF)  
        .equ UART8_ISR_ABRE, 1 << 14   @ bitWidth 1 (ABRE)  
        .equ UART8_ISR_UDR, 1 << 13   @ bitWidth 1 (SPI slave underrun error  flag)  
        .equ UART8_ISR_EOBF, 1 << 12   @ bitWidth 1 (EOBF)  
        .equ UART8_ISR_RTOF, 1 << 11   @ bitWidth 1 (RTOF)  
        .equ UART8_ISR_CTS, 1 << 10   @ bitWidth 1 (CTS)  
        .equ UART8_ISR_CTSIF, 1 << 9   @ bitWidth 1 (CTSIF)  
        .equ UART8_ISR_LBDF, 1 << 8   @ bitWidth 1 (LBDF)  
        .equ UART8_ISR_TXE, 1 << 7   @ bitWidth 1 (TXE)  
        .equ UART8_ISR_TC, 1 << 6   @ bitWidth 1 (TC)  
        .equ UART8_ISR_RXNE, 1 << 5   @ bitWidth 1 (RXNE)  
        .equ UART8_ISR_IDLE, 1 << 4   @ bitWidth 1 (IDLE)  
        .equ UART8_ISR_ORE, 1 << 3   @ bitWidth 1 (ORE)  
        .equ UART8_ISR_NF, 1 << 2   @ bitWidth 1 (NF)  
        .equ UART8_ISR_FE, 1 << 1   @ bitWidth 1 (FE)  
        .equ UART8_ISR_PE, 1 << 0   @ bitWidth 1 (PE)  
 
    .equ UART8_ICR, UART8_BASE + 0x20 @ (Interrupt flag clear register) 
        .equ UART8_ICR_WUCF, 1 << 20   @ bitWidth 1 (Wakeup from Stop mode clear  flag)  
        .equ UART8_ICR_CMCF, 1 << 17   @ bitWidth 1 (Character match clear flag)  
        .equ UART8_ICR_UDRCF, 1 << 13   @ bitWidth 1 (SPI slave underrun clear  flag)  
        .equ UART8_ICR_EOBCF, 1 << 12   @ bitWidth 1 (End of block clear flag)  
        .equ UART8_ICR_RTOCF, 1 << 11   @ bitWidth 1 (Receiver timeout clear  flag)  
        .equ UART8_ICR_CTSCF, 1 << 9   @ bitWidth 1 (CTS clear flag)  
        .equ UART8_ICR_LBDCF, 1 << 8   @ bitWidth 1 (LIN break detection clear  flag)  
        .equ UART8_ICR_TCBGTC, 1 << 7   @ bitWidth 1 (Transmission complete before Guard time  clear flag)  
        .equ UART8_ICR_TCCF, 1 << 6   @ bitWidth 1 (Transmission complete clear  flag)  
        .equ UART8_ICR_TXFECF, 1 << 5   @ bitWidth 1 (TXFIFO empty clear flag)  
        .equ UART8_ICR_IDLECF, 1 << 4   @ bitWidth 1 (Idle line detected clear  flag)  
        .equ UART8_ICR_ORECF, 1 << 3   @ bitWidth 1 (Overrun error clear flag)  
        .equ UART8_ICR_NCF, 1 << 2   @ bitWidth 1 (Noise detected clear flag)  
        .equ UART8_ICR_FECF, 1 << 1   @ bitWidth 1 (Framing error clear flag)  
        .equ UART8_ICR_PECF, 1 << 0   @ bitWidth 1 (Parity error clear flag)  
 
    .equ UART8_RDR, UART8_BASE + 0x24 @ (Receive data register) 
        .equ UART8_RDR_RDR_Shift, 0   @ bitWidth 9 (Receive data value)  
 
    .equ UART8_TDR, UART8_BASE + 0x28 @ (Transmit data register) 
        .equ UART8_TDR_TDR_Shift, 0   @ bitWidth 9 (Transmit data value)  
 
    .equ UART8_PRESC, UART8_BASE + 0x2C @ (USART prescaler register) 
        .equ UART8_PRESC_PRESCALER_Shift, 0   @ bitWidth 4 (Clock prescaler)  
 

@=========================== TIM1 ===========================@
.equ TIM1_BASE, 0x40010000 @ (Advanced-timers) 
    .equ TIM1_CR1, TIM1_BASE + 0x0 @ (control register 1) 
        .equ TIM1_CR1_CEN, 1 << 0   @ bitWidth 1 (Counter enable)  
        .equ TIM1_CR1_UDIS, 1 << 1   @ bitWidth 1 (Update disable)  
        .equ TIM1_CR1_URS, 1 << 2   @ bitWidth 1 (Update request source)  
        .equ TIM1_CR1_OPM, 1 << 3   @ bitWidth 1 (One-pulse mode)  
        .equ TIM1_CR1_DIR, 1 << 4   @ bitWidth 1 (Direction)  
        .equ TIM1_CR1_CMS_Shift, 5   @ bitWidth 2 (Center-aligned mode  selection)  
        .equ TIM1_CR1_ARPE, 1 << 7   @ bitWidth 1 (Auto-reload preload enable)  
        .equ TIM1_CR1_CKD_Shift, 8   @ bitWidth 2 (Clock division)  
        .equ TIM1_CR1_UIFREMAP, 1 << 11   @ bitWidth 1 (UIF status bit remapping)  
 
    .equ TIM1_CR2, TIM1_BASE + 0x4 @ (control register 2) 
        .equ TIM1_CR2_MMS2_Shift, 20   @ bitWidth 4 (Master mode selection 2)  
        .equ TIM1_CR2_OIS6, 1 << 18   @ bitWidth 1 (Output Idle state 6)  
        .equ TIM1_CR2_OIS5, 1 << 16   @ bitWidth 1 (Output Idle state 5)  
        .equ TIM1_CR2_OIS4, 1 << 14   @ bitWidth 1 (Output Idle state 4)  
        .equ TIM1_CR2_OIS3N, 1 << 13   @ bitWidth 1 (Output Idle state 3)  
        .equ TIM1_CR2_OIS3, 1 << 12   @ bitWidth 1 (Output Idle state 3)  
        .equ TIM1_CR2_OIS2N, 1 << 11   @ bitWidth 1 (Output Idle state 2)  
        .equ TIM1_CR2_OIS2, 1 << 10   @ bitWidth 1 (Output Idle state 2)  
        .equ TIM1_CR2_OIS1N, 1 << 9   @ bitWidth 1 (Output Idle state 1)  
        .equ TIM1_CR2_OIS1, 1 << 8   @ bitWidth 1 (Output Idle state 1)  
        .equ TIM1_CR2_TI1S, 1 << 7   @ bitWidth 1 (TI1 selection)  
        .equ TIM1_CR2_MMS_Shift, 4   @ bitWidth 3 (Master mode selection)  
        .equ TIM1_CR2_CCDS, 1 << 3   @ bitWidth 1 (Capture/compare DMA  selection)  
        .equ TIM1_CR2_CCUS, 1 << 2   @ bitWidth 1 (Capture/compare control update  selection)  
        .equ TIM1_CR2_CCPC, 1 << 0   @ bitWidth 1 (Capture/compare preloaded  control)  
 
    .equ TIM1_SMCR, TIM1_BASE + 0x8 @ (slave mode control register) 
        .equ TIM1_SMCR_SMS_Shift, 0   @ bitWidth 3 (Slave mode selection)  
        .equ TIM1_SMCR_TS_Shift, 4   @ bitWidth 3 (Trigger selection)  
        .equ TIM1_SMCR_MSM, 1 << 7   @ bitWidth 1 (Master/Slave mode)  
        .equ TIM1_SMCR_ETF_Shift, 8   @ bitWidth 4 (External trigger filter)  
        .equ TIM1_SMCR_ETPS_Shift, 12   @ bitWidth 2 (External trigger prescaler)  
        .equ TIM1_SMCR_ECE, 1 << 14   @ bitWidth 1 (External clock enable)  
        .equ TIM1_SMCR_ETP, 1 << 15   @ bitWidth 1 (External trigger polarity)  
        .equ TIM1_SMCR_SMS_3, 1 << 16   @ bitWidth 1 (Slave mode selection - bit  3)  
        .equ TIM1_SMCR_TS_4_3_Shift, 20   @ bitWidth 2 (Trigger selection - bit  4:3)  
 
    .equ TIM1_DIER, TIM1_BASE + 0xC @ (DMA/Interrupt enable register) 
        .equ TIM1_DIER_TDE, 1 << 14   @ bitWidth 1 (Trigger DMA request enable)  
        .equ TIM1_DIER_COMDE, 1 << 13   @ bitWidth 1 (COM DMA request enable)  
        .equ TIM1_DIER_CC4DE, 1 << 12   @ bitWidth 1 (Capture/Compare 4 DMA request  enable)  
        .equ TIM1_DIER_CC3DE, 1 << 11   @ bitWidth 1 (Capture/Compare 3 DMA request  enable)  
        .equ TIM1_DIER_CC2DE, 1 << 10   @ bitWidth 1 (Capture/Compare 2 DMA request  enable)  
        .equ TIM1_DIER_CC1DE, 1 << 9   @ bitWidth 1 (Capture/Compare 1 DMA request  enable)  
        .equ TIM1_DIER_UDE, 1 << 8   @ bitWidth 1 (Update DMA request enable)  
        .equ TIM1_DIER_TIE, 1 << 6   @ bitWidth 1 (Trigger interrupt enable)  
        .equ TIM1_DIER_CC4IE, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  enable)  
        .equ TIM1_DIER_CC3IE, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  enable)  
        .equ TIM1_DIER_CC2IE, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  enable)  
        .equ TIM1_DIER_CC1IE, 1 << 1   @ bitWidth 1 (Capture/Compare 1 interrupt  enable)  
        .equ TIM1_DIER_UIE, 1 << 0   @ bitWidth 1 (Update interrupt enable)  
        .equ TIM1_DIER_BIE, 1 << 7   @ bitWidth 1 (Break interrupt enable)  
        .equ TIM1_DIER_COMIE, 1 << 5   @ bitWidth 1 (COM interrupt enable)  
 
    .equ TIM1_SR, TIM1_BASE + 0x10 @ (status register) 
        .equ TIM1_SR_CC6IF, 1 << 17   @ bitWidth 1 (Compare 6 interrupt flag)  
        .equ TIM1_SR_CC5IF, 1 << 16   @ bitWidth 1 (Compare 5 interrupt flag)  
        .equ TIM1_SR_SBIF, 1 << 13   @ bitWidth 1 (System Break interrupt  flag)  
        .equ TIM1_SR_CC4OF, 1 << 12   @ bitWidth 1 (Capture/Compare 4 overcapture  flag)  
        .equ TIM1_SR_CC3OF, 1 << 11   @ bitWidth 1 (Capture/Compare 3 overcapture  flag)  
        .equ TIM1_SR_CC2OF, 1 << 10   @ bitWidth 1 (Capture/compare 2 overcapture  flag)  
        .equ TIM1_SR_CC1OF, 1 << 9   @ bitWidth 1 (Capture/Compare 1 overcapture  flag)  
        .equ TIM1_SR_B2IF, 1 << 8   @ bitWidth 1 (Break 2 interrupt flag)  
        .equ TIM1_SR_BIF, 1 << 7   @ bitWidth 1 (Break interrupt flag)  
        .equ TIM1_SR_TIF, 1 << 6   @ bitWidth 1 (Trigger interrupt flag)  
        .equ TIM1_SR_COMIF, 1 << 5   @ bitWidth 1 (COM interrupt flag)  
        .equ TIM1_SR_CC4IF, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  flag)  
        .equ TIM1_SR_CC3IF, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  flag)  
        .equ TIM1_SR_CC2IF, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  flag)  
        .equ TIM1_SR_CC1IF, 1 << 1   @ bitWidth 1 (Capture/compare 1 interrupt  flag)  
        .equ TIM1_SR_UIF, 1 << 0   @ bitWidth 1 (Update interrupt flag)  
 
    .equ TIM1_EGR, TIM1_BASE + 0x14 @ (event generation register) 
        .equ TIM1_EGR_UG, 1 << 0   @ bitWidth 1 (Update generation)  
        .equ TIM1_EGR_CC1G, 1 << 1   @ bitWidth 1 (Capture/compare 1  generation)  
        .equ TIM1_EGR_CC2G, 1 << 2   @ bitWidth 1 (Capture/compare 2  generation)  
        .equ TIM1_EGR_CC3G, 1 << 3   @ bitWidth 1 (Capture/compare 3  generation)  
        .equ TIM1_EGR_CC4G, 1 << 4   @ bitWidth 1 (Capture/compare 4  generation)  
        .equ TIM1_EGR_COMG, 1 << 5   @ bitWidth 1 (Capture/Compare control update  generation)  
        .equ TIM1_EGR_TG, 1 << 6   @ bitWidth 1 (Trigger generation)  
        .equ TIM1_EGR_BG, 1 << 7   @ bitWidth 1 (Break generation)  
        .equ TIM1_EGR_B2G, 1 << 8   @ bitWidth 1 (Break 2 generation)  
 
    .equ TIM1_CCMR1_Output, TIM1_BASE + 0x18 @ (capture/compare mode register 1 output  mode) 
        .equ TIM1_CCMR1_Output_CC1S_Shift, 0   @ bitWidth 2 (Capture/Compare 1  selection)  
        .equ TIM1_CCMR1_Output_OC1FE, 1 << 2   @ bitWidth 1 (Output Compare 1 fast  enable)  
        .equ TIM1_CCMR1_Output_OC1PE, 1 << 3   @ bitWidth 1 (Output Compare 1 preload  enable)  
        .equ TIM1_CCMR1_Output_OC1M_Shift, 4   @ bitWidth 3 (Output Compare 1 mode)  
        .equ TIM1_CCMR1_Output_OC1CE, 1 << 7   @ bitWidth 1 (Output Compare 1 clear  enable)  
        .equ TIM1_CCMR1_Output_CC2S_Shift, 8   @ bitWidth 2 (Capture/Compare 2  selection)  
        .equ TIM1_CCMR1_Output_OC2FE, 1 << 10   @ bitWidth 1 (Output Compare 2 fast  enable)  
        .equ TIM1_CCMR1_Output_OC2PE, 1 << 11   @ bitWidth 1 (Output Compare 2 preload  enable)  
        .equ TIM1_CCMR1_Output_OC2M_Shift, 12   @ bitWidth 3 (Output Compare 2 mode)  
        .equ TIM1_CCMR1_Output_OC2CE, 1 << 15   @ bitWidth 1 (Output Compare 2 clear  enable)  
        .equ TIM1_CCMR1_Output_OC1M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode - bit  3)  
        .equ TIM1_CCMR1_Output_OC2M_3, 1 << 24   @ bitWidth 1 (Output Compare 2 mode - bit  3)  
 
    .equ TIM1_CCMR1_Input, TIM1_BASE + 0x18 @ (capture/compare mode register 1 input  mode) 
        .equ TIM1_CCMR1_Input_IC2F_Shift, 12   @ bitWidth 4 (Input capture 2 filter)  
        .equ TIM1_CCMR1_Input_IC2PCS_Shift, 10   @ bitWidth 2 (Input capture 2 prescaler)  
        .equ TIM1_CCMR1_Input_CC2S_Shift, 8   @ bitWidth 2 (Capture/Compare 2  selection)  
        .equ TIM1_CCMR1_Input_IC1F_Shift, 4   @ bitWidth 4 (Input capture 1 filter)  
        .equ TIM1_CCMR1_Input_ICPCS_Shift, 2   @ bitWidth 2 (Input capture 1 prescaler)  
        .equ TIM1_CCMR1_Input_CC1S_Shift, 0   @ bitWidth 2 (Capture/Compare 1  selection)  
 
    .equ TIM1_CCMR2_Output, TIM1_BASE + 0x1C @ (capture/compare mode register 2 output  mode) 
        .equ TIM1_CCMR2_Output_CC3S_Shift, 0   @ bitWidth 2 (Capture/Compare 3  selection)  
        .equ TIM1_CCMR2_Output_OC3FE, 1 << 2   @ bitWidth 1 (Output compare 3 fast  enable)  
        .equ TIM1_CCMR2_Output_OC3PE, 1 << 3   @ bitWidth 1 (Output compare 3 preload  enable)  
        .equ TIM1_CCMR2_Output_OC3M_Shift, 4   @ bitWidth 3 (Output compare 3 mode)  
        .equ TIM1_CCMR2_Output_OC3CE, 1 << 7   @ bitWidth 1 (Output compare 3 clear  enable)  
        .equ TIM1_CCMR2_Output_CC4S_Shift, 8   @ bitWidth 2 (Capture/Compare 4  selection)  
        .equ TIM1_CCMR2_Output_OC4FE, 1 << 10   @ bitWidth 1 (Output compare 4 fast  enable)  
        .equ TIM1_CCMR2_Output_OC4PE, 1 << 11   @ bitWidth 1 (Output compare 4 preload  enable)  
        .equ TIM1_CCMR2_Output_OC4M_Shift, 12   @ bitWidth 3 (Output compare 4 mode)  
        .equ TIM1_CCMR2_Output_OC4CE, 1 << 15   @ bitWidth 1 (Output compare 4 clear  enable)  
        .equ TIM1_CCMR2_Output_OC3M_3, 1 << 16   @ bitWidth 1 (Output Compare 3 mode - bit  3)  
        .equ TIM1_CCMR2_Output_OC4M_4, 1 << 24   @ bitWidth 1 (Output Compare 4 mode - bit  3)  
 
    .equ TIM1_CCMR2_Input, TIM1_BASE + 0x1C @ (capture/compare mode register 2 input  mode) 
        .equ TIM1_CCMR2_Input_IC4F_Shift, 12   @ bitWidth 4 (Input capture 4 filter)  
        .equ TIM1_CCMR2_Input_IC4PSC_Shift, 10   @ bitWidth 2 (Input capture 4 prescaler)  
        .equ TIM1_CCMR2_Input_CC4S_Shift, 8   @ bitWidth 2 (Capture/Compare 4  selection)  
        .equ TIM1_CCMR2_Input_IC3F_Shift, 4   @ bitWidth 4 (Input capture 3 filter)  
        .equ TIM1_CCMR2_Input_IC3PSC_Shift, 2   @ bitWidth 2 (Input capture 3 prescaler)  
        .equ TIM1_CCMR2_Input_CC3S_Shift, 0   @ bitWidth 2 (Capture/compare 3  selection)  
 
    .equ TIM1_CCER, TIM1_BASE + 0x20 @ (capture/compare enable  register) 
        .equ TIM1_CCER_CC1E, 1 << 0   @ bitWidth 1 (Capture/Compare 1 output  enable)  
        .equ TIM1_CCER_CC1P, 1 << 1   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM1_CCER_CC1NE, 1 << 2   @ bitWidth 1 (Capture/Compare 1 complementary output  enable)  
        .equ TIM1_CCER_CC1NP, 1 << 3   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM1_CCER_CC2E, 1 << 4   @ bitWidth 1 (Capture/Compare 2 output  enable)  
        .equ TIM1_CCER_CC2P, 1 << 5   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM1_CCER_CC2NE, 1 << 6   @ bitWidth 1 (Capture/Compare 2 complementary output  enable)  
        .equ TIM1_CCER_CC2NP, 1 << 7   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM1_CCER_CC3E, 1 << 8   @ bitWidth 1 (Capture/Compare 3 output  enable)  
        .equ TIM1_CCER_CC3P, 1 << 9   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM1_CCER_CC3NE, 1 << 10   @ bitWidth 1 (Capture/Compare 3 complementary output  enable)  
        .equ TIM1_CCER_CC3NP, 1 << 11   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM1_CCER_CC4E, 1 << 12   @ bitWidth 1 (Capture/Compare 4 output  enable)  
        .equ TIM1_CCER_CC4P, 1 << 13   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM1_CCER_CC4NP, 1 << 15   @ bitWidth 1 (Capture/Compare 4 complementary output  polarity)  
        .equ TIM1_CCER_CC5E, 1 << 16   @ bitWidth 1 (Capture/Compare 5 output  enable)  
        .equ TIM1_CCER_CC5P, 1 << 17   @ bitWidth 1 (Capture/Compare 5 output  polarity)  
        .equ TIM1_CCER_CC6E, 1 << 20   @ bitWidth 1 (Capture/Compare 6 output  enable)  
        .equ TIM1_CCER_CC6P, 1 << 21   @ bitWidth 1 (Capture/Compare 6 output  polarity)  
 
    .equ TIM1_CNT, TIM1_BASE + 0x24 @ (counter) 
        .equ TIM1_CNT_CNT_Shift, 0   @ bitWidth 16 (counter value)  
        .equ TIM1_CNT_UIFCPY, 1 << 31   @ bitWidth 1 (UIF copy)  
 
    .equ TIM1_PSC, TIM1_BASE + 0x28 @ (prescaler) 
        .equ TIM1_PSC_PSC_Shift, 0   @ bitWidth 16 (Prescaler value)  
 
    .equ TIM1_ARR, TIM1_BASE + 0x2C @ (auto-reload register) 
        .equ TIM1_ARR_ARR_Shift, 0   @ bitWidth 16 (Auto-reload value)  
 
    .equ TIM1_CCR1, TIM1_BASE + 0x34 @ (capture/compare register 1) 
        .equ TIM1_CCR1_CCR1_Shift, 0   @ bitWidth 16 (Capture/Compare 1 value)  
 
    .equ TIM1_CCR2, TIM1_BASE + 0x38 @ (capture/compare register 2) 
        .equ TIM1_CCR2_CCR2_Shift, 0   @ bitWidth 16 (Capture/Compare 2 value)  
 
    .equ TIM1_CCR3, TIM1_BASE + 0x3C @ (capture/compare register 3) 
        .equ TIM1_CCR3_CCR3_Shift, 0   @ bitWidth 16 (Capture/Compare value)  
 
    .equ TIM1_CCR4, TIM1_BASE + 0x40 @ (capture/compare register 4) 
        .equ TIM1_CCR4_CCR4_Shift, 0   @ bitWidth 16 (Capture/Compare value)  
 
    .equ TIM1_DCR, TIM1_BASE + 0x48 @ (DMA control register) 
        .equ TIM1_DCR_DBL_Shift, 8   @ bitWidth 5 (DMA burst length)  
        .equ TIM1_DCR_DBA_Shift, 0   @ bitWidth 5 (DMA base address)  
 
    .equ TIM1_DMAR, TIM1_BASE + 0x4C @ (DMA address for full transfer) 
        .equ TIM1_DMAR_DMAB_Shift, 0   @ bitWidth 16 (DMA register for burst  accesses)  
 
    .equ TIM1_RCR, TIM1_BASE + 0x30 @ (repetition counter register) 
        .equ TIM1_RCR_REP_Shift, 0   @ bitWidth 8 (Repetition counter value)  
 
    .equ TIM1_BDTR, TIM1_BASE + 0x44 @ (break and dead-time register) 
        .equ TIM1_BDTR_DTG_Shift, 0   @ bitWidth 8 (Dead-time generator setup)  
        .equ TIM1_BDTR_LOCK_Shift, 8   @ bitWidth 2 (Lock configuration)  
        .equ TIM1_BDTR_OSSI, 1 << 10   @ bitWidth 1 (Off-state selection for Idle  mode)  
        .equ TIM1_BDTR_OSSR, 1 << 11   @ bitWidth 1 (Off-state selection for Run  mode)  
        .equ TIM1_BDTR_BKE, 1 << 12   @ bitWidth 1 (Break enable)  
        .equ TIM1_BDTR_BKP, 1 << 13   @ bitWidth 1 (Break polarity)  
        .equ TIM1_BDTR_AOE, 1 << 14   @ bitWidth 1 (Automatic output enable)  
        .equ TIM1_BDTR_MOE, 1 << 15   @ bitWidth 1 (Main output enable)  
        .equ TIM1_BDTR_BKF_Shift, 16   @ bitWidth 4 (Break filter)  
        .equ TIM1_BDTR_BK2F_Shift, 20   @ bitWidth 4 (Break 2 filter)  
        .equ TIM1_BDTR_BK2E, 1 << 24   @ bitWidth 1 (Break 2 enable)  
        .equ TIM1_BDTR_BK2P, 1 << 25   @ bitWidth 1 (Break 2 polarity)  
 
    .equ TIM1_CCMR3_Output, TIM1_BASE + 0x54 @ (capture/compare mode register 3 output  mode) 
        .equ TIM1_CCMR3_Output_OC5FE, 1 << 2   @ bitWidth 1 (Output compare 5 fast  enable)  
        .equ TIM1_CCMR3_Output_OC5PE, 1 << 3   @ bitWidth 1 (Output compare 5 preload  enable)  
        .equ TIM1_CCMR3_Output_OC5M_Shift, 4   @ bitWidth 3 (Output compare 5 mode)  
        .equ TIM1_CCMR3_Output_OC5CE, 1 << 7   @ bitWidth 1 (Output compare 5 clear  enable)  
        .equ TIM1_CCMR3_Output_OC6FE, 1 << 10   @ bitWidth 1 (Output compare 6 fast  enable)  
        .equ TIM1_CCMR3_Output_OC6PE, 1 << 11   @ bitWidth 1 (Output compare 6 preload  enable)  
        .equ TIM1_CCMR3_Output_OC6M_Shift, 12   @ bitWidth 3 (Output compare 6 mode)  
        .equ TIM1_CCMR3_Output_OC6CE, 1 << 15   @ bitWidth 1 (Output compare 6 clear  enable)  
        .equ TIM1_CCMR3_Output_OC5M3, 1 << 16   @ bitWidth 1 (Output Compare 5 mode)  
        .equ TIM1_CCMR3_Output_OC6M3, 1 << 24   @ bitWidth 1 (Output Compare 6 mode)  
 
    .equ TIM1_CCR5, TIM1_BASE + 0x58 @ (capture/compare register 5) 
        .equ TIM1_CCR5_CCR5_Shift, 0   @ bitWidth 16 (Capture/Compare 5 value)  
        .equ TIM1_CCR5_GC5C1, 1 << 29   @ bitWidth 1 (Group Channel 5 and Channel  1)  
        .equ TIM1_CCR5_GC5C2, 1 << 30   @ bitWidth 1 (Group Channel 5 and Channel  2)  
        .equ TIM1_CCR5_GC5C3, 1 << 31   @ bitWidth 1 (Group Channel 5 and Channel  3)  
 
    .equ TIM1_CRR6, TIM1_BASE + 0x5C @ (capture/compare register 6) 
        .equ TIM1_CRR6_CCR6_Shift, 0   @ bitWidth 16 (Capture/Compare 6 value)  
 
    .equ TIM1_AF1, TIM1_BASE + 0x60 @ (TIM1 alternate function option register  1) 
        .equ TIM1_AF1_BKINE, 1 << 0   @ bitWidth 1 (BRK BKIN input enable)  
        .equ TIM1_AF1_BKCMP1E, 1 << 1   @ bitWidth 1 (BRK COMP1 enable)  
        .equ TIM1_AF1_BKCMP2E, 1 << 2   @ bitWidth 1 (BRK COMP2 enable)  
        .equ TIM1_AF1_BKDF1BK0E, 1 << 8   @ bitWidth 1 (BRK dfsdm1_break[0] enable)  
        .equ TIM1_AF1_BKINP, 1 << 9   @ bitWidth 1 (BRK BKIN input polarity)  
        .equ TIM1_AF1_BKCMP1P, 1 << 10   @ bitWidth 1 (BRK COMP1 input polarity)  
        .equ TIM1_AF1_BKCMP2P, 1 << 11   @ bitWidth 1 (BRK COMP2 input polarity)  
        .equ TIM1_AF1_ETRSEL_Shift, 14   @ bitWidth 4 (ETR source selection)  
 
    .equ TIM1_AF2, TIM1_BASE + 0x64 @ (TIM1 Alternate function odfsdm1_breakster  2) 
        .equ TIM1_AF2_BK2INE, 1 << 0   @ bitWidth 1 (BRK2 BKIN input enable)  
        .equ TIM1_AF2_BK2CMP1E, 1 << 1   @ bitWidth 1 (BRK2 COMP1 enable)  
        .equ TIM1_AF2_BK2CMP2E, 1 << 2   @ bitWidth 1 (BRK2 COMP2 enable)  
        .equ TIM1_AF2_BK2DF1BK1E, 1 << 8   @ bitWidth 1 (BRK2 dfsdm1_break[1]  enable)  
        .equ TIM1_AF2_BK2INP, 1 << 9   @ bitWidth 1 (BRK2 BKIN2 input polarity)  
        .equ TIM1_AF2_BK2CMP1P, 1 << 10   @ bitWidth 1 (BRK2 COMP1 input polarit)  
        .equ TIM1_AF2_BK2CMP2P, 1 << 11   @ bitWidth 1 (BRK2 COMP2 input polarity)  
 
    .equ TIM1_TISEL, TIM1_BASE + 0x68 @ (TIM1 timer input selection  register) 
        .equ TIM1_TISEL_TI1SEL_Shift, 0   @ bitWidth 4 (selects TI1[0] to TI1[15]  input)  
        .equ TIM1_TISEL_TI2SEL_Shift, 8   @ bitWidth 4 (selects TI2[0] to TI2[15]  input)  
        .equ TIM1_TISEL_TI3SEL_Shift, 16   @ bitWidth 4 (selects TI3[0] to TI3[15]  input)  
        .equ TIM1_TISEL_TI4SEL_Shift, 24   @ bitWidth 4 (selects TI4[0] to TI4[15]  input)  
 

@=========================== TIM8 ===========================@
.equ TIM8_BASE, 0x40010400 @ (Advanced-timers) 
    .equ TIM8_CR1, TIM8_BASE + 0x0 @ (control register 1) 
        .equ TIM8_CR1_CEN, 1 << 0   @ bitWidth 1 (Counter enable)  
        .equ TIM8_CR1_UDIS, 1 << 1   @ bitWidth 1 (Update disable)  
        .equ TIM8_CR1_URS, 1 << 2   @ bitWidth 1 (Update request source)  
        .equ TIM8_CR1_OPM, 1 << 3   @ bitWidth 1 (One-pulse mode)  
        .equ TIM8_CR1_DIR, 1 << 4   @ bitWidth 1 (Direction)  
        .equ TIM8_CR1_CMS_Shift, 5   @ bitWidth 2 (Center-aligned mode  selection)  
        .equ TIM8_CR1_ARPE, 1 << 7   @ bitWidth 1 (Auto-reload preload enable)  
        .equ TIM8_CR1_CKD_Shift, 8   @ bitWidth 2 (Clock division)  
        .equ TIM8_CR1_UIFREMAP, 1 << 11   @ bitWidth 1 (UIF status bit remapping)  
 
    .equ TIM8_CR2, TIM8_BASE + 0x4 @ (control register 2) 
        .equ TIM8_CR2_MMS2_Shift, 20   @ bitWidth 4 (Master mode selection 2)  
        .equ TIM8_CR2_OIS6, 1 << 18   @ bitWidth 1 (Output Idle state 6)  
        .equ TIM8_CR2_OIS5, 1 << 16   @ bitWidth 1 (Output Idle state 5)  
        .equ TIM8_CR2_OIS4, 1 << 14   @ bitWidth 1 (Output Idle state 4)  
        .equ TIM8_CR2_OIS3N, 1 << 13   @ bitWidth 1 (Output Idle state 3)  
        .equ TIM8_CR2_OIS3, 1 << 12   @ bitWidth 1 (Output Idle state 3)  
        .equ TIM8_CR2_OIS2N, 1 << 11   @ bitWidth 1 (Output Idle state 2)  
        .equ TIM8_CR2_OIS2, 1 << 10   @ bitWidth 1 (Output Idle state 2)  
        .equ TIM8_CR2_OIS1N, 1 << 9   @ bitWidth 1 (Output Idle state 1)  
        .equ TIM8_CR2_OIS1, 1 << 8   @ bitWidth 1 (Output Idle state 1)  
        .equ TIM8_CR2_TI1S, 1 << 7   @ bitWidth 1 (TI1 selection)  
        .equ TIM8_CR2_MMS_Shift, 4   @ bitWidth 3 (Master mode selection)  
        .equ TIM8_CR2_CCDS, 1 << 3   @ bitWidth 1 (Capture/compare DMA  selection)  
        .equ TIM8_CR2_CCUS, 1 << 2   @ bitWidth 1 (Capture/compare control update  selection)  
        .equ TIM8_CR2_CCPC, 1 << 0   @ bitWidth 1 (Capture/compare preloaded  control)  
 
    .equ TIM8_SMCR, TIM8_BASE + 0x8 @ (slave mode control register) 
        .equ TIM8_SMCR_SMS_Shift, 0   @ bitWidth 3 (Slave mode selection)  
        .equ TIM8_SMCR_TS_Shift, 4   @ bitWidth 3 (Trigger selection)  
        .equ TIM8_SMCR_MSM, 1 << 7   @ bitWidth 1 (Master/Slave mode)  
        .equ TIM8_SMCR_ETF_Shift, 8   @ bitWidth 4 (External trigger filter)  
        .equ TIM8_SMCR_ETPS_Shift, 12   @ bitWidth 2 (External trigger prescaler)  
        .equ TIM8_SMCR_ECE, 1 << 14   @ bitWidth 1 (External clock enable)  
        .equ TIM8_SMCR_ETP, 1 << 15   @ bitWidth 1 (External trigger polarity)  
        .equ TIM8_SMCR_SMS_3, 1 << 16   @ bitWidth 1 (Slave mode selection - bit  3)  
        .equ TIM8_SMCR_TS_4_3_Shift, 20   @ bitWidth 2 (Trigger selection - bit  4:3)  
 
    .equ TIM8_DIER, TIM8_BASE + 0xC @ (DMA/Interrupt enable register) 
        .equ TIM8_DIER_TDE, 1 << 14   @ bitWidth 1 (Trigger DMA request enable)  
        .equ TIM8_DIER_COMDE, 1 << 13   @ bitWidth 1 (COM DMA request enable)  
        .equ TIM8_DIER_CC4DE, 1 << 12   @ bitWidth 1 (Capture/Compare 4 DMA request  enable)  
        .equ TIM8_DIER_CC3DE, 1 << 11   @ bitWidth 1 (Capture/Compare 3 DMA request  enable)  
        .equ TIM8_DIER_CC2DE, 1 << 10   @ bitWidth 1 (Capture/Compare 2 DMA request  enable)  
        .equ TIM8_DIER_CC1DE, 1 << 9   @ bitWidth 1 (Capture/Compare 1 DMA request  enable)  
        .equ TIM8_DIER_UDE, 1 << 8   @ bitWidth 1 (Update DMA request enable)  
        .equ TIM8_DIER_TIE, 1 << 6   @ bitWidth 1 (Trigger interrupt enable)  
        .equ TIM8_DIER_CC4IE, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  enable)  
        .equ TIM8_DIER_CC3IE, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  enable)  
        .equ TIM8_DIER_CC2IE, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  enable)  
        .equ TIM8_DIER_CC1IE, 1 << 1   @ bitWidth 1 (Capture/Compare 1 interrupt  enable)  
        .equ TIM8_DIER_UIE, 1 << 0   @ bitWidth 1 (Update interrupt enable)  
        .equ TIM8_DIER_BIE, 1 << 7   @ bitWidth 1 (Break interrupt enable)  
        .equ TIM8_DIER_COMIE, 1 << 5   @ bitWidth 1 (COM interrupt enable)  
 
    .equ TIM8_SR, TIM8_BASE + 0x10 @ (status register) 
        .equ TIM8_SR_CC6IF, 1 << 17   @ bitWidth 1 (Compare 6 interrupt flag)  
        .equ TIM8_SR_CC5IF, 1 << 16   @ bitWidth 1 (Compare 5 interrupt flag)  
        .equ TIM8_SR_SBIF, 1 << 13   @ bitWidth 1 (System Break interrupt  flag)  
        .equ TIM8_SR_CC4OF, 1 << 12   @ bitWidth 1 (Capture/Compare 4 overcapture  flag)  
        .equ TIM8_SR_CC3OF, 1 << 11   @ bitWidth 1 (Capture/Compare 3 overcapture  flag)  
        .equ TIM8_SR_CC2OF, 1 << 10   @ bitWidth 1 (Capture/compare 2 overcapture  flag)  
        .equ TIM8_SR_CC1OF, 1 << 9   @ bitWidth 1 (Capture/Compare 1 overcapture  flag)  
        .equ TIM8_SR_B2IF, 1 << 8   @ bitWidth 1 (Break 2 interrupt flag)  
        .equ TIM8_SR_BIF, 1 << 7   @ bitWidth 1 (Break interrupt flag)  
        .equ TIM8_SR_TIF, 1 << 6   @ bitWidth 1 (Trigger interrupt flag)  
        .equ TIM8_SR_COMIF, 1 << 5   @ bitWidth 1 (COM interrupt flag)  
        .equ TIM8_SR_CC4IF, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  flag)  
        .equ TIM8_SR_CC3IF, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  flag)  
        .equ TIM8_SR_CC2IF, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  flag)  
        .equ TIM8_SR_CC1IF, 1 << 1   @ bitWidth 1 (Capture/compare 1 interrupt  flag)  
        .equ TIM8_SR_UIF, 1 << 0   @ bitWidth 1 (Update interrupt flag)  
 
    .equ TIM8_EGR, TIM8_BASE + 0x14 @ (event generation register) 
        .equ TIM8_EGR_UG, 1 << 0   @ bitWidth 1 (Update generation)  
        .equ TIM8_EGR_CC1G, 1 << 1   @ bitWidth 1 (Capture/compare 1  generation)  
        .equ TIM8_EGR_CC2G, 1 << 2   @ bitWidth 1 (Capture/compare 2  generation)  
        .equ TIM8_EGR_CC3G, 1 << 3   @ bitWidth 1 (Capture/compare 3  generation)  
        .equ TIM8_EGR_CC4G, 1 << 4   @ bitWidth 1 (Capture/compare 4  generation)  
        .equ TIM8_EGR_COMG, 1 << 5   @ bitWidth 1 (Capture/Compare control update  generation)  
        .equ TIM8_EGR_TG, 1 << 6   @ bitWidth 1 (Trigger generation)  
        .equ TIM8_EGR_BG, 1 << 7   @ bitWidth 1 (Break generation)  
        .equ TIM8_EGR_B2G, 1 << 8   @ bitWidth 1 (Break 2 generation)  
 
    .equ TIM8_CCMR1_Output, TIM8_BASE + 0x18 @ (capture/compare mode register 1 output  mode) 
        .equ TIM8_CCMR1_Output_CC1S_Shift, 0   @ bitWidth 2 (Capture/Compare 1  selection)  
        .equ TIM8_CCMR1_Output_OC1FE, 1 << 2   @ bitWidth 1 (Output Compare 1 fast  enable)  
        .equ TIM8_CCMR1_Output_OC1PE, 1 << 3   @ bitWidth 1 (Output Compare 1 preload  enable)  
        .equ TIM8_CCMR1_Output_OC1M_Shift, 4   @ bitWidth 3 (Output Compare 1 mode)  
        .equ TIM8_CCMR1_Output_OC1CE, 1 << 7   @ bitWidth 1 (Output Compare 1 clear  enable)  
        .equ TIM8_CCMR1_Output_CC2S_Shift, 8   @ bitWidth 2 (Capture/Compare 2  selection)  
        .equ TIM8_CCMR1_Output_OC2FE, 1 << 10   @ bitWidth 1 (Output Compare 2 fast  enable)  
        .equ TIM8_CCMR1_Output_OC2PE, 1 << 11   @ bitWidth 1 (Output Compare 2 preload  enable)  
        .equ TIM8_CCMR1_Output_OC2M_Shift, 12   @ bitWidth 3 (Output Compare 2 mode)  
        .equ TIM8_CCMR1_Output_OC2CE, 1 << 15   @ bitWidth 1 (Output Compare 2 clear  enable)  
        .equ TIM8_CCMR1_Output_OC1M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode - bit  3)  
        .equ TIM8_CCMR1_Output_OC2M_3, 1 << 24   @ bitWidth 1 (Output Compare 2 mode - bit  3)  
 
    .equ TIM8_CCMR1_Input, TIM8_BASE + 0x18 @ (capture/compare mode register 1 input  mode) 
        .equ TIM8_CCMR1_Input_IC2F_Shift, 12   @ bitWidth 4 (Input capture 2 filter)  
        .equ TIM8_CCMR1_Input_IC2PCS_Shift, 10   @ bitWidth 2 (Input capture 2 prescaler)  
        .equ TIM8_CCMR1_Input_CC2S_Shift, 8   @ bitWidth 2 (Capture/Compare 2  selection)  
        .equ TIM8_CCMR1_Input_IC1F_Shift, 4   @ bitWidth 4 (Input capture 1 filter)  
        .equ TIM8_CCMR1_Input_ICPCS_Shift, 2   @ bitWidth 2 (Input capture 1 prescaler)  
        .equ TIM8_CCMR1_Input_CC1S_Shift, 0   @ bitWidth 2 (Capture/Compare 1  selection)  
 
    .equ TIM8_CCMR2_Output, TIM8_BASE + 0x1C @ (capture/compare mode register 2 output  mode) 
        .equ TIM8_CCMR2_Output_CC3S_Shift, 0   @ bitWidth 2 (Capture/Compare 3  selection)  
        .equ TIM8_CCMR2_Output_OC3FE, 1 << 2   @ bitWidth 1 (Output compare 3 fast  enable)  
        .equ TIM8_CCMR2_Output_OC3PE, 1 << 3   @ bitWidth 1 (Output compare 3 preload  enable)  
        .equ TIM8_CCMR2_Output_OC3M_Shift, 4   @ bitWidth 3 (Output compare 3 mode)  
        .equ TIM8_CCMR2_Output_OC3CE, 1 << 7   @ bitWidth 1 (Output compare 3 clear  enable)  
        .equ TIM8_CCMR2_Output_CC4S_Shift, 8   @ bitWidth 2 (Capture/Compare 4  selection)  
        .equ TIM8_CCMR2_Output_OC4FE, 1 << 10   @ bitWidth 1 (Output compare 4 fast  enable)  
        .equ TIM8_CCMR2_Output_OC4PE, 1 << 11   @ bitWidth 1 (Output compare 4 preload  enable)  
        .equ TIM8_CCMR2_Output_OC4M_Shift, 12   @ bitWidth 3 (Output compare 4 mode)  
        .equ TIM8_CCMR2_Output_OC4CE, 1 << 15   @ bitWidth 1 (Output compare 4 clear  enable)  
        .equ TIM8_CCMR2_Output_OC3M_3, 1 << 16   @ bitWidth 1 (Output Compare 3 mode - bit  3)  
        .equ TIM8_CCMR2_Output_OC4M_4, 1 << 24   @ bitWidth 1 (Output Compare 4 mode - bit  3)  
 
    .equ TIM8_CCMR2_Input, TIM8_BASE + 0x1C @ (capture/compare mode register 2 input  mode) 
        .equ TIM8_CCMR2_Input_IC4F_Shift, 12   @ bitWidth 4 (Input capture 4 filter)  
        .equ TIM8_CCMR2_Input_IC4PSC_Shift, 10   @ bitWidth 2 (Input capture 4 prescaler)  
        .equ TIM8_CCMR2_Input_CC4S_Shift, 8   @ bitWidth 2 (Capture/Compare 4  selection)  
        .equ TIM8_CCMR2_Input_IC3F_Shift, 4   @ bitWidth 4 (Input capture 3 filter)  
        .equ TIM8_CCMR2_Input_IC3PSC_Shift, 2   @ bitWidth 2 (Input capture 3 prescaler)  
        .equ TIM8_CCMR2_Input_CC3S_Shift, 0   @ bitWidth 2 (Capture/compare 3  selection)  
 
    .equ TIM8_CCER, TIM8_BASE + 0x20 @ (capture/compare enable  register) 
        .equ TIM8_CCER_CC1E, 1 << 0   @ bitWidth 1 (Capture/Compare 1 output  enable)  
        .equ TIM8_CCER_CC1P, 1 << 1   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM8_CCER_CC1NE, 1 << 2   @ bitWidth 1 (Capture/Compare 1 complementary output  enable)  
        .equ TIM8_CCER_CC1NP, 1 << 3   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM8_CCER_CC2E, 1 << 4   @ bitWidth 1 (Capture/Compare 2 output  enable)  
        .equ TIM8_CCER_CC2P, 1 << 5   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM8_CCER_CC2NE, 1 << 6   @ bitWidth 1 (Capture/Compare 2 complementary output  enable)  
        .equ TIM8_CCER_CC2NP, 1 << 7   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM8_CCER_CC3E, 1 << 8   @ bitWidth 1 (Capture/Compare 3 output  enable)  
        .equ TIM8_CCER_CC3P, 1 << 9   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM8_CCER_CC3NE, 1 << 10   @ bitWidth 1 (Capture/Compare 3 complementary output  enable)  
        .equ TIM8_CCER_CC3NP, 1 << 11   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM8_CCER_CC4E, 1 << 12   @ bitWidth 1 (Capture/Compare 4 output  enable)  
        .equ TIM8_CCER_CC4P, 1 << 13   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM8_CCER_CC4NP, 1 << 15   @ bitWidth 1 (Capture/Compare 4 complementary output  polarity)  
        .equ TIM8_CCER_CC5E, 1 << 16   @ bitWidth 1 (Capture/Compare 5 output  enable)  
        .equ TIM8_CCER_CC5P, 1 << 17   @ bitWidth 1 (Capture/Compare 5 output  polarity)  
        .equ TIM8_CCER_CC6E, 1 << 20   @ bitWidth 1 (Capture/Compare 6 output  enable)  
        .equ TIM8_CCER_CC6P, 1 << 21   @ bitWidth 1 (Capture/Compare 6 output  polarity)  
 
    .equ TIM8_CNT, TIM8_BASE + 0x24 @ (counter) 
        .equ TIM8_CNT_CNT_Shift, 0   @ bitWidth 16 (counter value)  
        .equ TIM8_CNT_UIFCPY, 1 << 31   @ bitWidth 1 (UIF copy)  
 
    .equ TIM8_PSC, TIM8_BASE + 0x28 @ (prescaler) 
        .equ TIM8_PSC_PSC_Shift, 0   @ bitWidth 16 (Prescaler value)  
 
    .equ TIM8_ARR, TIM8_BASE + 0x2C @ (auto-reload register) 
        .equ TIM8_ARR_ARR_Shift, 0   @ bitWidth 16 (Auto-reload value)  
 
    .equ TIM8_CCR1, TIM8_BASE + 0x34 @ (capture/compare register 1) 
        .equ TIM8_CCR1_CCR1_Shift, 0   @ bitWidth 16 (Capture/Compare 1 value)  
 
    .equ TIM8_CCR2, TIM8_BASE + 0x38 @ (capture/compare register 2) 
        .equ TIM8_CCR2_CCR2_Shift, 0   @ bitWidth 16 (Capture/Compare 2 value)  
 
    .equ TIM8_CCR3, TIM8_BASE + 0x3C @ (capture/compare register 3) 
        .equ TIM8_CCR3_CCR3_Shift, 0   @ bitWidth 16 (Capture/Compare value)  
 
    .equ TIM8_CCR4, TIM8_BASE + 0x40 @ (capture/compare register 4) 
        .equ TIM8_CCR4_CCR4_Shift, 0   @ bitWidth 16 (Capture/Compare value)  
 
    .equ TIM8_DCR, TIM8_BASE + 0x48 @ (DMA control register) 
        .equ TIM8_DCR_DBL_Shift, 8   @ bitWidth 5 (DMA burst length)  
        .equ TIM8_DCR_DBA_Shift, 0   @ bitWidth 5 (DMA base address)  
 
    .equ TIM8_DMAR, TIM8_BASE + 0x4C @ (DMA address for full transfer) 
        .equ TIM8_DMAR_DMAB_Shift, 0   @ bitWidth 16 (DMA register for burst  accesses)  
 
    .equ TIM8_RCR, TIM8_BASE + 0x30 @ (repetition counter register) 
        .equ TIM8_RCR_REP_Shift, 0   @ bitWidth 8 (Repetition counter value)  
 
    .equ TIM8_BDTR, TIM8_BASE + 0x44 @ (break and dead-time register) 
        .equ TIM8_BDTR_DTG_Shift, 0   @ bitWidth 8 (Dead-time generator setup)  
        .equ TIM8_BDTR_LOCK_Shift, 8   @ bitWidth 2 (Lock configuration)  
        .equ TIM8_BDTR_OSSI, 1 << 10   @ bitWidth 1 (Off-state selection for Idle  mode)  
        .equ TIM8_BDTR_OSSR, 1 << 11   @ bitWidth 1 (Off-state selection for Run  mode)  
        .equ TIM8_BDTR_BKE, 1 << 12   @ bitWidth 1 (Break enable)  
        .equ TIM8_BDTR_BKP, 1 << 13   @ bitWidth 1 (Break polarity)  
        .equ TIM8_BDTR_AOE, 1 << 14   @ bitWidth 1 (Automatic output enable)  
        .equ TIM8_BDTR_MOE, 1 << 15   @ bitWidth 1 (Main output enable)  
        .equ TIM8_BDTR_BKF_Shift, 16   @ bitWidth 4 (Break filter)  
        .equ TIM8_BDTR_BK2F_Shift, 20   @ bitWidth 4 (Break 2 filter)  
        .equ TIM8_BDTR_BK2E, 1 << 24   @ bitWidth 1 (Break 2 enable)  
        .equ TIM8_BDTR_BK2P, 1 << 25   @ bitWidth 1 (Break 2 polarity)  
 
    .equ TIM8_CCMR3_Output, TIM8_BASE + 0x54 @ (capture/compare mode register 3 output  mode) 
        .equ TIM8_CCMR3_Output_OC5FE, 1 << 2   @ bitWidth 1 (Output compare 5 fast  enable)  
        .equ TIM8_CCMR3_Output_OC5PE, 1 << 3   @ bitWidth 1 (Output compare 5 preload  enable)  
        .equ TIM8_CCMR3_Output_OC5M_Shift, 4   @ bitWidth 3 (Output compare 5 mode)  
        .equ TIM8_CCMR3_Output_OC5CE, 1 << 7   @ bitWidth 1 (Output compare 5 clear  enable)  
        .equ TIM8_CCMR3_Output_OC6FE, 1 << 10   @ bitWidth 1 (Output compare 6 fast  enable)  
        .equ TIM8_CCMR3_Output_OC6PE, 1 << 11   @ bitWidth 1 (Output compare 6 preload  enable)  
        .equ TIM8_CCMR3_Output_OC6M_Shift, 12   @ bitWidth 3 (Output compare 6 mode)  
        .equ TIM8_CCMR3_Output_OC6CE, 1 << 15   @ bitWidth 1 (Output compare 6 clear  enable)  
        .equ TIM8_CCMR3_Output_OC5M3, 1 << 16   @ bitWidth 1 (Output Compare 5 mode)  
        .equ TIM8_CCMR3_Output_OC6M3, 1 << 24   @ bitWidth 1 (Output Compare 6 mode)  
 
    .equ TIM8_CCR5, TIM8_BASE + 0x58 @ (capture/compare register 5) 
        .equ TIM8_CCR5_CCR5_Shift, 0   @ bitWidth 16 (Capture/Compare 5 value)  
        .equ TIM8_CCR5_GC5C1, 1 << 29   @ bitWidth 1 (Group Channel 5 and Channel  1)  
        .equ TIM8_CCR5_GC5C2, 1 << 30   @ bitWidth 1 (Group Channel 5 and Channel  2)  
        .equ TIM8_CCR5_GC5C3, 1 << 31   @ bitWidth 1 (Group Channel 5 and Channel  3)  
 
    .equ TIM8_CRR6, TIM8_BASE + 0x5C @ (capture/compare register 6) 
        .equ TIM8_CRR6_CCR6_Shift, 0   @ bitWidth 16 (Capture/Compare 6 value)  
 
    .equ TIM8_AF1, TIM8_BASE + 0x60 @ (TIM1 alternate function option register  1) 
        .equ TIM8_AF1_BKINE, 1 << 0   @ bitWidth 1 (BRK BKIN input enable)  
        .equ TIM8_AF1_BKCMP1E, 1 << 1   @ bitWidth 1 (BRK COMP1 enable)  
        .equ TIM8_AF1_BKCMP2E, 1 << 2   @ bitWidth 1 (BRK COMP2 enable)  
        .equ TIM8_AF1_BKDF1BK0E, 1 << 8   @ bitWidth 1 (BRK dfsdm1_break[0] enable)  
        .equ TIM8_AF1_BKINP, 1 << 9   @ bitWidth 1 (BRK BKIN input polarity)  
        .equ TIM8_AF1_BKCMP1P, 1 << 10   @ bitWidth 1 (BRK COMP1 input polarity)  
        .equ TIM8_AF1_BKCMP2P, 1 << 11   @ bitWidth 1 (BRK COMP2 input polarity)  
        .equ TIM8_AF1_ETRSEL_Shift, 14   @ bitWidth 4 (ETR source selection)  
 
    .equ TIM8_AF2, TIM8_BASE + 0x64 @ (TIM1 Alternate function odfsdm1_breakster  2) 
        .equ TIM8_AF2_BK2INE, 1 << 0   @ bitWidth 1 (BRK2 BKIN input enable)  
        .equ TIM8_AF2_BK2CMP1E, 1 << 1   @ bitWidth 1 (BRK2 COMP1 enable)  
        .equ TIM8_AF2_BK2CMP2E, 1 << 2   @ bitWidth 1 (BRK2 COMP2 enable)  
        .equ TIM8_AF2_BK2DF1BK1E, 1 << 8   @ bitWidth 1 (BRK2 dfsdm1_break[1]  enable)  
        .equ TIM8_AF2_BK2INP, 1 << 9   @ bitWidth 1 (BRK2 BKIN2 input polarity)  
        .equ TIM8_AF2_BK2CMP1P, 1 << 10   @ bitWidth 1 (BRK2 COMP1 input polarit)  
        .equ TIM8_AF2_BK2CMP2P, 1 << 11   @ bitWidth 1 (BRK2 COMP2 input polarity)  
 
    .equ TIM8_TISEL, TIM8_BASE + 0x68 @ (TIM1 timer input selection  register) 
        .equ TIM8_TISEL_TI1SEL_Shift, 0   @ bitWidth 4 (selects TI1[0] to TI1[15]  input)  
        .equ TIM8_TISEL_TI2SEL_Shift, 8   @ bitWidth 4 (selects TI2[0] to TI2[15]  input)  
        .equ TIM8_TISEL_TI3SEL_Shift, 16   @ bitWidth 4 (selects TI3[0] to TI3[15]  input)  
        .equ TIM8_TISEL_TI4SEL_Shift, 24   @ bitWidth 4 (selects TI4[0] to TI4[15]  input)  
 

@=========================== FDCAN1 ===========================@
.equ FDCAN1_BASE, 0x4000A000 @ (FDCAN1) 
    .equ FDCAN1_FDCAN_CREL, FDCAN1_BASE + 0x0 @ (FDCAN Core Release Register) 
        .equ FDCAN1_FDCAN_CREL_REL_Shift, 28   @ bitWidth 4 (Core release)  
        .equ FDCAN1_FDCAN_CREL_STEP_Shift, 24   @ bitWidth 4 (Step of Core release)  
        .equ FDCAN1_FDCAN_CREL_SUBSTEP_Shift, 20   @ bitWidth 4 (Sub-step of Core release)  
        .equ FDCAN1_FDCAN_CREL_YEAR_Shift, 16   @ bitWidth 4 (Timestamp Year)  
        .equ FDCAN1_FDCAN_CREL_MON_Shift, 8   @ bitWidth 8 (Timestamp Month)  
        .equ FDCAN1_FDCAN_CREL_DAY_Shift, 0   @ bitWidth 8 (Timestamp Day)  
 
    .equ FDCAN1_FDCAN_ENDN, FDCAN1_BASE + 0x4 @ (FDCAN Core Release Register) 
        .equ FDCAN1_FDCAN_ENDN_ETV_Shift, 0   @ bitWidth 32 (Endiannes Test Value)  
 
    .equ FDCAN1_FDCAN_DBTP, FDCAN1_BASE + 0xC @ (FDCAN Data Bit Timing and Prescaler  Register) 
        .equ FDCAN1_FDCAN_DBTP_DSJW_Shift, 0   @ bitWidth 4 (Synchronization Jump Width)  
        .equ FDCAN1_FDCAN_DBTP_DTSEG2_Shift, 4   @ bitWidth 4 (Data time segment after sample  point)  
        .equ FDCAN1_FDCAN_DBTP_DTSEG1_Shift, 8   @ bitWidth 5 (Data time segment after sample  point)  
        .equ FDCAN1_FDCAN_DBTP_DBRP_Shift, 16   @ bitWidth 5 (Data BIt Rate Prescaler)  
        .equ FDCAN1_FDCAN_DBTP_TDC, 1 << 23   @ bitWidth 1 (Transceiver Delay  Compensation)  
 
    .equ FDCAN1_FDCAN_TEST, FDCAN1_BASE + 0x10 @ (FDCAN Test Register) 
        .equ FDCAN1_FDCAN_TEST_LBCK, 1 << 4   @ bitWidth 1 (Loop Back mode)  
        .equ FDCAN1_FDCAN_TEST_TX_Shift, 5   @ bitWidth 2 (Loop Back mode)  
        .equ FDCAN1_FDCAN_TEST_RX, 1 << 7   @ bitWidth 1 (Control of Transmit Pin)  
 
    .equ FDCAN1_FDCAN_RWD, FDCAN1_BASE + 0x14 @ (FDCAN RAM Watchdog Register) 
        .equ FDCAN1_FDCAN_RWD_WDV_Shift, 8   @ bitWidth 8 (Watchdog value)  
        .equ FDCAN1_FDCAN_RWD_WDC_Shift, 0   @ bitWidth 8 (Watchdog configuration)  
 
    .equ FDCAN1_FDCAN_CCCR, FDCAN1_BASE + 0x18 @ (FDCAN CC Control Register) 
        .equ FDCAN1_FDCAN_CCCR_INIT, 1 << 0   @ bitWidth 1 (Initialization)  
        .equ FDCAN1_FDCAN_CCCR_CCE, 1 << 1   @ bitWidth 1 (Configuration Change  Enable)  
        .equ FDCAN1_FDCAN_CCCR_ASM, 1 << 2   @ bitWidth 1 (ASM Restricted Operation  Mode)  
        .equ FDCAN1_FDCAN_CCCR_CSA, 1 << 3   @ bitWidth 1 (Clock Stop Acknowledge)  
        .equ FDCAN1_FDCAN_CCCR_CSR, 1 << 4   @ bitWidth 1 (Clock Stop Request)  
        .equ FDCAN1_FDCAN_CCCR_MON, 1 << 5   @ bitWidth 1 (Bus Monitoring Mode)  
        .equ FDCAN1_FDCAN_CCCR_DAR, 1 << 6   @ bitWidth 1 (Disable Automatic  Retransmission)  
        .equ FDCAN1_FDCAN_CCCR_TEST, 1 << 7   @ bitWidth 1 (Test Mode Enable)  
        .equ FDCAN1_FDCAN_CCCR_FDOE, 1 << 8   @ bitWidth 1 (FD Operation Enable)  
        .equ FDCAN1_FDCAN_CCCR_BSE, 1 << 9   @ bitWidth 1 (FDCAN Bit Rate Switching)  
        .equ FDCAN1_FDCAN_CCCR_PXHD, 1 << 12   @ bitWidth 1 (Protocol Exception Handling  Disable)  
        .equ FDCAN1_FDCAN_CCCR_EFBI, 1 << 13   @ bitWidth 1 (Edge Filtering during Bus  Integration)  
        .equ FDCAN1_FDCAN_CCCR_TXP, 1 << 14   @ bitWidth 1 (TXP)  
        .equ FDCAN1_FDCAN_CCCR_NISO, 1 << 15   @ bitWidth 1 (Non ISO Operation)  
 
    .equ FDCAN1_FDCAN_NBTP, FDCAN1_BASE + 0x1C @ (FDCAN Nominal Bit Timing and Prescaler  Register) 
        .equ FDCAN1_FDCAN_NBTP_NSJW_Shift, 25   @ bitWidth 7 (NSJW: Nominal ReSynchronization Jump  Width)  
        .equ FDCAN1_FDCAN_NBTP_NBRP_Shift, 16   @ bitWidth 9 (Bit Rate Prescaler)  
        .equ FDCAN1_FDCAN_NBTP_NTSEG1_Shift, 8   @ bitWidth 8 (Nominal Time segment before sample  point)  
        .equ FDCAN1_FDCAN_NBTP_TSEG2_Shift, 0   @ bitWidth 7 (Nominal Time segment after sample  point)  
 
    .equ FDCAN1_FDCAN_TSCC, FDCAN1_BASE + 0x20 @ (FDCAN Timestamp Counter Configuration  Register) 
        .equ FDCAN1_FDCAN_TSCC_TCP_Shift, 16   @ bitWidth 4 (Timestamp Counter  Prescaler)  
        .equ FDCAN1_FDCAN_TSCC_TSS_Shift, 0   @ bitWidth 2 (Timestamp Select)  
 
    .equ FDCAN1_FDCAN_TSCV, FDCAN1_BASE + 0x24 @ (FDCAN Timestamp Counter Value  Register) 
        .equ FDCAN1_FDCAN_TSCV_TSC_Shift, 0   @ bitWidth 16 (Timestamp Counter)  
 
    .equ FDCAN1_FDCAN_TOCC, FDCAN1_BASE + 0x28 @ (FDCAN Timeout Counter Configuration  Register) 
        .equ FDCAN1_FDCAN_TOCC_ETOC, 1 << 0   @ bitWidth 1 (Enable Timeout Counter)  
        .equ FDCAN1_FDCAN_TOCC_TOS_Shift, 1   @ bitWidth 2 (Timeout Select)  
        .equ FDCAN1_FDCAN_TOCC_TOP_Shift, 16   @ bitWidth 16 (Timeout Period)  
 
    .equ FDCAN1_FDCAN_TOCV, FDCAN1_BASE + 0x2C @ (FDCAN Timeout Counter Value  Register) 
        .equ FDCAN1_FDCAN_TOCV_TOC_Shift, 0   @ bitWidth 16 (Timeout Counter)  
 
    .equ FDCAN1_FDCAN_ECR, FDCAN1_BASE + 0x40 @ (FDCAN Error Counter Register) 
        .equ FDCAN1_FDCAN_ECR_CEL_Shift, 16   @ bitWidth 8 (AN Error Logging)  
        .equ FDCAN1_FDCAN_ECR_RP, 1 << 15   @ bitWidth 1 (Receive Error Passive)  
        .equ FDCAN1_FDCAN_ECR_TREC_Shift, 8   @ bitWidth 7 (Receive Error Counter)  
        .equ FDCAN1_FDCAN_ECR_TEC_Shift, 0   @ bitWidth 8 (Transmit Error Counter)  
 
    .equ FDCAN1_FDCAN_PSR, FDCAN1_BASE + 0x44 @ (FDCAN Protocol Status Register) 
        .equ FDCAN1_FDCAN_PSR_LEC_Shift, 0   @ bitWidth 3 (Last Error Code)  
        .equ FDCAN1_FDCAN_PSR_ACT_Shift, 3   @ bitWidth 2 (Activity)  
        .equ FDCAN1_FDCAN_PSR_EP, 1 << 5   @ bitWidth 1 (Error Passive)  
        .equ FDCAN1_FDCAN_PSR_EW, 1 << 6   @ bitWidth 1 (Warning Status)  
        .equ FDCAN1_FDCAN_PSR_BO, 1 << 7   @ bitWidth 1 (Bus_Off Status)  
        .equ FDCAN1_FDCAN_PSR_DLEC_Shift, 8   @ bitWidth 3 (Data Last Error Code)  
        .equ FDCAN1_FDCAN_PSR_RESI, 1 << 11   @ bitWidth 1 (ESI flag of last received FDCAN  Message)  
        .equ FDCAN1_FDCAN_PSR_RBRS, 1 << 12   @ bitWidth 1 (BRS flag of last received FDCAN  Message)  
        .equ FDCAN1_FDCAN_PSR_REDL, 1 << 13   @ bitWidth 1 (Received FDCAN Message)  
        .equ FDCAN1_FDCAN_PSR_PXE, 1 << 14   @ bitWidth 1 (Protocol Exception Event)  
        .equ FDCAN1_FDCAN_PSR_TDCV_Shift, 16   @ bitWidth 7 (Transmitter Delay Compensation  Value)  
 
    .equ FDCAN1_FDCAN_TDCR, FDCAN1_BASE + 0x48 @ (FDCAN Transmitter Delay Compensation  Register) 
        .equ FDCAN1_FDCAN_TDCR_TDCF_Shift, 0   @ bitWidth 7 (Transmitter Delay Compensation Filter  Window Length)  
        .equ FDCAN1_FDCAN_TDCR_TDCO_Shift, 8   @ bitWidth 7 (Transmitter Delay Compensation  Offset)  
 
    .equ FDCAN1_FDCAN_IR, FDCAN1_BASE + 0x50 @ (FDCAN Interrupt Register) 
        .equ FDCAN1_FDCAN_IR_RF0N, 1 << 0   @ bitWidth 1 (Rx FIFO 0 New Message)  
        .equ FDCAN1_FDCAN_IR_RF0W, 1 << 1   @ bitWidth 1 (Rx FIFO 0 Full)  
        .equ FDCAN1_FDCAN_IR_RF0F, 1 << 2   @ bitWidth 1 (Rx FIFO 0 Full)  
        .equ FDCAN1_FDCAN_IR_RF0L, 1 << 3   @ bitWidth 1 (Rx FIFO 0 Message Lost)  
        .equ FDCAN1_FDCAN_IR_RF1N, 1 << 4   @ bitWidth 1 (Rx FIFO 1 New Message)  
        .equ FDCAN1_FDCAN_IR_RF1W, 1 << 5   @ bitWidth 1 (Rx FIFO 1 Watermark  Reached)  
        .equ FDCAN1_FDCAN_IR_RF1F, 1 << 6   @ bitWidth 1 (Rx FIFO 1 Watermark  Reached)  
        .equ FDCAN1_FDCAN_IR_RF1L, 1 << 7   @ bitWidth 1 (Rx FIFO 1 Message Lost)  
        .equ FDCAN1_FDCAN_IR_HPM, 1 << 8   @ bitWidth 1 (High Priority Message)  
        .equ FDCAN1_FDCAN_IR_TC, 1 << 9   @ bitWidth 1 (Transmission Completed)  
        .equ FDCAN1_FDCAN_IR_TCF, 1 << 10   @ bitWidth 1 (Transmission Cancellation  Finished)  
        .equ FDCAN1_FDCAN_IR_TEF, 1 << 11   @ bitWidth 1 (Tx FIFO Empty)  
        .equ FDCAN1_FDCAN_IR_TEFN, 1 << 12   @ bitWidth 1 (Tx Event FIFO New Entry)  
        .equ FDCAN1_FDCAN_IR_TEFW, 1 << 13   @ bitWidth 1 (Tx Event FIFO Watermark  Reached)  
        .equ FDCAN1_FDCAN_IR_TEFF, 1 << 14   @ bitWidth 1 (Tx Event FIFO Full)  
        .equ FDCAN1_FDCAN_IR_TEFL, 1 << 15   @ bitWidth 1 (Tx Event FIFO Element Lost)  
        .equ FDCAN1_FDCAN_IR_TSW, 1 << 16   @ bitWidth 1 (Timestamp Wraparound)  
        .equ FDCAN1_FDCAN_IR_MRAF, 1 << 17   @ bitWidth 1 (Message RAM Access Failure)  
        .equ FDCAN1_FDCAN_IR_TOO, 1 << 18   @ bitWidth 1 (Timeout Occurred)  
        .equ FDCAN1_FDCAN_IR_DRX, 1 << 19   @ bitWidth 1 (Message stored to Dedicated Rx  Buffer)  
        .equ FDCAN1_FDCAN_IR_ELO, 1 << 22   @ bitWidth 1 (Error Logging Overflow)  
        .equ FDCAN1_FDCAN_IR_EP, 1 << 23   @ bitWidth 1 (Error Passive)  
        .equ FDCAN1_FDCAN_IR_EW, 1 << 24   @ bitWidth 1 (Warning Status)  
        .equ FDCAN1_FDCAN_IR_BO, 1 << 25   @ bitWidth 1 (Bus_Off Status)  
        .equ FDCAN1_FDCAN_IR_WDI, 1 << 26   @ bitWidth 1 (Watchdog Interrupt)  
        .equ FDCAN1_FDCAN_IR_PEA, 1 << 27   @ bitWidth 1 (Protocol Error in Arbitration Phase  Nominal Bit Time is used)  
        .equ FDCAN1_FDCAN_IR_PED, 1 << 28   @ bitWidth 1 (Protocol Error in Data Phase Data Bit  Time is used)  
        .equ FDCAN1_FDCAN_IR_ARA, 1 << 29   @ bitWidth 1 (Access to Reserved Address)  
 
    .equ FDCAN1_FDCAN_IE, FDCAN1_BASE + 0x54 @ (FDCAN Interrupt Enable  Register) 
        .equ FDCAN1_FDCAN_IE_RF0NE, 1 << 0   @ bitWidth 1 (Rx FIFO 0 New Message  Enable)  
        .equ FDCAN1_FDCAN_IE_RF0WE, 1 << 1   @ bitWidth 1 (Rx FIFO 0 Full Enable)  
        .equ FDCAN1_FDCAN_IE_RF0FE, 1 << 2   @ bitWidth 1 (Rx FIFO 0 Full Enable)  
        .equ FDCAN1_FDCAN_IE_RF0LE, 1 << 3   @ bitWidth 1 (Rx FIFO 0 Message Lost  Enable)  
        .equ FDCAN1_FDCAN_IE_RF1NE, 1 << 4   @ bitWidth 1 (Rx FIFO 1 New Message  Enable)  
        .equ FDCAN1_FDCAN_IE_RF1WE, 1 << 5   @ bitWidth 1 (Rx FIFO 1 Watermark Reached  Enable)  
        .equ FDCAN1_FDCAN_IE_RF1FE, 1 << 6   @ bitWidth 1 (Rx FIFO 1 Watermark Reached  Enable)  
        .equ FDCAN1_FDCAN_IE_RF1LE, 1 << 7   @ bitWidth 1 (Rx FIFO 1 Message Lost  Enable)  
        .equ FDCAN1_FDCAN_IE_HPME, 1 << 8   @ bitWidth 1 (High Priority Message  Enable)  
        .equ FDCAN1_FDCAN_IE_TCE, 1 << 9   @ bitWidth 1 (Transmission Completed  Enable)  
        .equ FDCAN1_FDCAN_IE_TCFE, 1 << 10   @ bitWidth 1 (Transmission Cancellation Finished  Enable)  
        .equ FDCAN1_FDCAN_IE_TEFE, 1 << 11   @ bitWidth 1 (Tx FIFO Empty Enable)  
        .equ FDCAN1_FDCAN_IE_TEFNE, 1 << 12   @ bitWidth 1 (Tx Event FIFO New Entry  Enable)  
        .equ FDCAN1_FDCAN_IE_TEFWE, 1 << 13   @ bitWidth 1 (Tx Event FIFO Watermark Reached  Enable)  
        .equ FDCAN1_FDCAN_IE_TEFFE, 1 << 14   @ bitWidth 1 (Tx Event FIFO Full Enable)  
        .equ FDCAN1_FDCAN_IE_TEFLE, 1 << 15   @ bitWidth 1 (Tx Event FIFO Element Lost  Enable)  
        .equ FDCAN1_FDCAN_IE_TSWE, 1 << 16   @ bitWidth 1 (Timestamp Wraparound  Enable)  
        .equ FDCAN1_FDCAN_IE_MRAFE, 1 << 17   @ bitWidth 1 (Message RAM Access Failure  Enable)  
        .equ FDCAN1_FDCAN_IE_TOOE, 1 << 18   @ bitWidth 1 (Timeout Occurred Enable)  
        .equ FDCAN1_FDCAN_IE_DRXE, 1 << 19   @ bitWidth 1 (Message stored to Dedicated Rx Buffer  Enable)  
        .equ FDCAN1_FDCAN_IE_BECE, 1 << 20   @ bitWidth 1 (Bit Error Corrected Interrupt  Enable)  
        .equ FDCAN1_FDCAN_IE_BEUE, 1 << 21   @ bitWidth 1 (Bit Error Uncorrected Interrupt  Enable)  
        .equ FDCAN1_FDCAN_IE_ELOE, 1 << 22   @ bitWidth 1 (Error Logging Overflow  Enable)  
        .equ FDCAN1_FDCAN_IE_EPE, 1 << 23   @ bitWidth 1 (Error Passive Enable)  
        .equ FDCAN1_FDCAN_IE_EWE, 1 << 24   @ bitWidth 1 (Warning Status Enable)  
        .equ FDCAN1_FDCAN_IE_BOE, 1 << 25   @ bitWidth 1 (Bus_Off Status Enable)  
        .equ FDCAN1_FDCAN_IE_WDIE, 1 << 26   @ bitWidth 1 (Watchdog Interrupt Enable)  
        .equ FDCAN1_FDCAN_IE_PEAE, 1 << 27   @ bitWidth 1 (Protocol Error in Arbitration Phase  Enable)  
        .equ FDCAN1_FDCAN_IE_PEDE, 1 << 28   @ bitWidth 1 (Protocol Error in Data Phase  Enable)  
        .equ FDCAN1_FDCAN_IE_ARAE, 1 << 29   @ bitWidth 1 (Access to Reserved Address  Enable)  
 
    .equ FDCAN1_FDCAN_ILS, FDCAN1_BASE + 0x58 @ (FDCAN Interrupt Line Select  Register) 
        .equ FDCAN1_FDCAN_ILS_RF0NL, 1 << 0   @ bitWidth 1 (Rx FIFO 0 New Message Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_RF0WL, 1 << 1   @ bitWidth 1 (Rx FIFO 0 Watermark Reached Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_RF0FL, 1 << 2   @ bitWidth 1 (Rx FIFO 0 Full Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_RF0LL, 1 << 3   @ bitWidth 1 (Rx FIFO 0 Message Lost Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_RF1NL, 1 << 4   @ bitWidth 1 (Rx FIFO 1 New Message Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_RF1WL, 1 << 5   @ bitWidth 1 (Rx FIFO 1 Watermark Reached Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_RF1FL, 1 << 6   @ bitWidth 1 (Rx FIFO 1 Full Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_RF1LL, 1 << 7   @ bitWidth 1 (Rx FIFO 1 Message Lost Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_HPML, 1 << 8   @ bitWidth 1 (High Priority Message Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_TCL, 1 << 9   @ bitWidth 1 (Transmission Completed Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_TCFL, 1 << 10   @ bitWidth 1 (Transmission Cancellation Finished  Interrupt Line)  
        .equ FDCAN1_FDCAN_ILS_TEFL, 1 << 11   @ bitWidth 1 (Tx FIFO Empty Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_TEFNL, 1 << 12   @ bitWidth 1 (Tx Event FIFO New Entry Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_TEFWL, 1 << 13   @ bitWidth 1 (Tx Event FIFO Watermark Reached  Interrupt Line)  
        .equ FDCAN1_FDCAN_ILS_TEFFL, 1 << 14   @ bitWidth 1 (Tx Event FIFO Full Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_TEFLL, 1 << 15   @ bitWidth 1 (Tx Event FIFO Element Lost Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_TSWL, 1 << 16   @ bitWidth 1 (Timestamp Wraparound Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_MRAFL, 1 << 17   @ bitWidth 1 (Message RAM Access Failure Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_TOOL, 1 << 18   @ bitWidth 1 (Timeout Occurred Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_DRXL, 1 << 19   @ bitWidth 1 (Message stored to Dedicated Rx Buffer  Interrupt Line)  
        .equ FDCAN1_FDCAN_ILS_BECL, 1 << 20   @ bitWidth 1 (Bit Error Corrected Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_BEUL, 1 << 21   @ bitWidth 1 (Bit Error Uncorrected Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_ELOL, 1 << 22   @ bitWidth 1 (Error Logging Overflow Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_EPL, 1 << 23   @ bitWidth 1 (Error Passive Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_EWL, 1 << 24   @ bitWidth 1 (Warning Status Interrupt  Line)  
        .equ FDCAN1_FDCAN_ILS_BOL, 1 << 25   @ bitWidth 1 (Bus_Off Status)  
        .equ FDCAN1_FDCAN_ILS_WDIL, 1 << 26   @ bitWidth 1 (Watchdog Interrupt Line)  
        .equ FDCAN1_FDCAN_ILS_PEAL, 1 << 27   @ bitWidth 1 (Protocol Error in Arbitration Phase  Line)  
        .equ FDCAN1_FDCAN_ILS_PEDL, 1 << 28   @ bitWidth 1 (Protocol Error in Data Phase  Line)  
        .equ FDCAN1_FDCAN_ILS_ARAL, 1 << 29   @ bitWidth 1 (Access to Reserved Address  Line)  
 
    .equ FDCAN1_FDCAN_ILE, FDCAN1_BASE + 0x5C @ (FDCAN Interrupt Line Enable  Register) 
        .equ FDCAN1_FDCAN_ILE_EINT0, 1 << 0   @ bitWidth 1 (Enable Interrupt Line 0)  
        .equ FDCAN1_FDCAN_ILE_EINT1, 1 << 1   @ bitWidth 1 (Enable Interrupt Line 1)  
 
    .equ FDCAN1_FDCAN_GFC, FDCAN1_BASE + 0x80 @ (FDCAN Global Filter Configuration  Register) 
        .equ FDCAN1_FDCAN_GFC_RRFE, 1 << 0   @ bitWidth 1 (Reject Remote Frames  Extended)  
        .equ FDCAN1_FDCAN_GFC_RRFS, 1 << 1   @ bitWidth 1 (Reject Remote Frames  Standard)  
        .equ FDCAN1_FDCAN_GFC_ANFE_Shift, 2   @ bitWidth 2 (Accept Non-matching Frames  Extended)  
        .equ FDCAN1_FDCAN_GFC_ANFS_Shift, 4   @ bitWidth 2 (Accept Non-matching Frames  Standard)  
 
    .equ FDCAN1_FDCAN_SIDFC, FDCAN1_BASE + 0x84 @ (FDCAN Standard ID Filter Configuration  Register) 
        .equ FDCAN1_FDCAN_SIDFC_FLSSA_Shift, 2   @ bitWidth 14 (Filter List Standard Start  Address)  
        .equ FDCAN1_FDCAN_SIDFC_LSS_Shift, 16   @ bitWidth 8 (List Size Standard)  
 
    .equ FDCAN1_FDCAN_XIDFC, FDCAN1_BASE + 0x88 @ (FDCAN Extended ID Filter Configuration  Register) 
        .equ FDCAN1_FDCAN_XIDFC_FLESA_Shift, 2   @ bitWidth 14 (Filter List Standard Start  Address)  
        .equ FDCAN1_FDCAN_XIDFC_LSE_Shift, 16   @ bitWidth 8 (List Size Extended)  
 
    .equ FDCAN1_FDCAN_XIDAM, FDCAN1_BASE + 0x90 @ (FDCAN Extended ID and Mask  Register) 
        .equ FDCAN1_FDCAN_XIDAM_EIDM_Shift, 0   @ bitWidth 29 (Extended ID Mask)  
 
    .equ FDCAN1_FDCAN_HPMS, FDCAN1_BASE + 0x94 @ (FDCAN High Priority Message Status  Register) 
        .equ FDCAN1_FDCAN_HPMS_BIDX_Shift, 0   @ bitWidth 6 (Buffer Index)  
        .equ FDCAN1_FDCAN_HPMS_MSI_Shift, 6   @ bitWidth 2 (Message Storage Indicator)  
        .equ FDCAN1_FDCAN_HPMS_FIDX_Shift, 8   @ bitWidth 7 (Filter Index)  
        .equ FDCAN1_FDCAN_HPMS_FLST, 1 << 15   @ bitWidth 1 (Filter List)  
 
    .equ FDCAN1_FDCAN_NDAT1, FDCAN1_BASE + 0x98 @ (FDCAN New Data 1 Register) 
        .equ FDCAN1_FDCAN_NDAT1_ND0, 1 << 0   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND1, 1 << 1   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND2, 1 << 2   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND3, 1 << 3   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND4, 1 << 4   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND5, 1 << 5   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND6, 1 << 6   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND7, 1 << 7   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND8, 1 << 8   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND9, 1 << 9   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND10, 1 << 10   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND11, 1 << 11   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND12, 1 << 12   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND13, 1 << 13   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND14, 1 << 14   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND15, 1 << 15   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND16, 1 << 16   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND17, 1 << 17   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND18, 1 << 18   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND19, 1 << 19   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND20, 1 << 20   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND21, 1 << 21   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND22, 1 << 22   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND23, 1 << 23   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND24, 1 << 24   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND25, 1 << 25   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND26, 1 << 26   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND27, 1 << 27   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND28, 1 << 28   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND29, 1 << 29   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND30, 1 << 30   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT1_ND31, 1 << 31   @ bitWidth 1 (New data)  
 
    .equ FDCAN1_FDCAN_NDAT2, FDCAN1_BASE + 0x9C @ (FDCAN New Data 2 Register) 
        .equ FDCAN1_FDCAN_NDAT2_ND32, 1 << 0   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND33, 1 << 1   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND34, 1 << 2   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND35, 1 << 3   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND36, 1 << 4   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND37, 1 << 5   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND38, 1 << 6   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND39, 1 << 7   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND40, 1 << 8   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND41, 1 << 9   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND42, 1 << 10   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND43, 1 << 11   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND44, 1 << 12   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND45, 1 << 13   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND46, 1 << 14   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND47, 1 << 15   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND48, 1 << 16   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND49, 1 << 17   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND50, 1 << 18   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND51, 1 << 19   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND52, 1 << 20   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND53, 1 << 21   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND54, 1 << 22   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND55, 1 << 23   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND56, 1 << 24   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND57, 1 << 25   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND58, 1 << 26   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND59, 1 << 27   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND60, 1 << 28   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND61, 1 << 29   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND62, 1 << 30   @ bitWidth 1 (New data)  
        .equ FDCAN1_FDCAN_NDAT2_ND63, 1 << 31   @ bitWidth 1 (New data)  
 
    .equ FDCAN1_FDCAN_RXF0C, FDCAN1_BASE + 0xA0 @ (FDCAN Rx FIFO 0 Configuration  Register) 
        .equ FDCAN1_FDCAN_RXF0C_F0SA_Shift, 2   @ bitWidth 14 (Rx FIFO 0 Start Address)  
        .equ FDCAN1_FDCAN_RXF0C_F0S_Shift, 16   @ bitWidth 8 (Rx FIFO 0 Size)  
        .equ FDCAN1_FDCAN_RXF0C_F0WM_Shift, 24   @ bitWidth 8 (FIFO 0 Watermark)  
 
    .equ FDCAN1_FDCAN_RXF0S, FDCAN1_BASE + 0xA4 @ (FDCAN Rx FIFO 0 Status  Register) 
        .equ FDCAN1_FDCAN_RXF0S_F0FL_Shift, 0   @ bitWidth 7 (Rx FIFO 0 Fill Level)  
        .equ FDCAN1_FDCAN_RXF0S_F0G_Shift, 8   @ bitWidth 6 (Rx FIFO 0 Get Index)  
        .equ FDCAN1_FDCAN_RXF0S_F0P_Shift, 16   @ bitWidth 6 (Rx FIFO 0 Put Index)  
        .equ FDCAN1_FDCAN_RXF0S_F0F, 1 << 24   @ bitWidth 1 (Rx FIFO 0 Full)  
        .equ FDCAN1_FDCAN_RXF0S_RF0L, 1 << 25   @ bitWidth 1 (Rx FIFO 0 Message Lost)  
 
    .equ FDCAN1_FDCAN_RXF0A, FDCAN1_BASE + 0xA8 @ (CAN Rx FIFO 0 Acknowledge  Register) 
        .equ FDCAN1_FDCAN_RXF0A_FA01_Shift, 0   @ bitWidth 6 (Rx FIFO 0 Acknowledge  Index)  
 
    .equ FDCAN1_FDCAN_RXBC, FDCAN1_BASE + 0xAC @ (FDCAN Rx Buffer Configuration  Register) 
        .equ FDCAN1_FDCAN_RXBC_RBSA_Shift, 2   @ bitWidth 14 (Rx Buffer Start Address)  
 
    .equ FDCAN1_FDCAN_RXF1C, FDCAN1_BASE + 0xB0 @ (FDCAN Rx FIFO 1 Configuration  Register) 
        .equ FDCAN1_FDCAN_RXF1C_F1SA_Shift, 2   @ bitWidth 14 (Rx FIFO 1 Start Address)  
        .equ FDCAN1_FDCAN_RXF1C_F1S_Shift, 16   @ bitWidth 7 (Rx FIFO 1 Size)  
        .equ FDCAN1_FDCAN_RXF1C_F1WM_Shift, 24   @ bitWidth 7 (Rx FIFO 1 Watermark)  
 
    .equ FDCAN1_FDCAN_RXF1S, FDCAN1_BASE + 0xB4 @ (FDCAN Rx FIFO 1 Status  Register) 
        .equ FDCAN1_FDCAN_RXF1S_F1FL_Shift, 0   @ bitWidth 7 (Rx FIFO 1 Fill Level)  
        .equ FDCAN1_FDCAN_RXF1S_F1GI_Shift, 8   @ bitWidth 7 (Rx FIFO 1 Get Index)  
        .equ FDCAN1_FDCAN_RXF1S_F1PI_Shift, 16   @ bitWidth 7 (Rx FIFO 1 Put Index)  
        .equ FDCAN1_FDCAN_RXF1S_F1F, 1 << 24   @ bitWidth 1 (Rx FIFO 1 Full)  
        .equ FDCAN1_FDCAN_RXF1S_RF1L, 1 << 25   @ bitWidth 1 (Rx FIFO 1 Message Lost)  
        .equ FDCAN1_FDCAN_RXF1S_DMS_Shift, 30   @ bitWidth 2 (Debug Message Status)  
 
    .equ FDCAN1_FDCAN_RXF1A, FDCAN1_BASE + 0xB8 @ (FDCAN Rx FIFO 1 Acknowledge  Register) 
        .equ FDCAN1_FDCAN_RXF1A_F1AI_Shift, 0   @ bitWidth 6 (Rx FIFO 1 Acknowledge  Index)  
 
    .equ FDCAN1_FDCAN_RXESC, FDCAN1_BASE + 0xBC @ (FDCAN Rx Buffer Element Size Configuration  Register) 
        .equ FDCAN1_FDCAN_RXESC_F0DS_Shift, 0   @ bitWidth 3 (Rx FIFO 1 Data Field Size:)  
        .equ FDCAN1_FDCAN_RXESC_F1DS_Shift, 4   @ bitWidth 3 (Rx FIFO 0 Data Field Size:)  
        .equ FDCAN1_FDCAN_RXESC_RBDS_Shift, 8   @ bitWidth 3 (Rx Buffer Data Field Size:)  
 
    .equ FDCAN1_FDCAN_TXBC, FDCAN1_BASE + 0xC0 @ (FDCAN Tx Buffer Configuration  Register) 
        .equ FDCAN1_FDCAN_TXBC_TBSA_Shift, 2   @ bitWidth 14 (Tx Buffers Start Address)  
        .equ FDCAN1_FDCAN_TXBC_NDTB_Shift, 16   @ bitWidth 6 (Number of Dedicated Transmit  Buffers)  
        .equ FDCAN1_FDCAN_TXBC_TFQS_Shift, 24   @ bitWidth 6 (Transmit FIFO/Queue Size)  
        .equ FDCAN1_FDCAN_TXBC_TFQM, 1 << 30   @ bitWidth 1 (Tx FIFO/Queue Mode)  
 
    .equ FDCAN1_FDCAN_TXFQS, FDCAN1_BASE + 0xC4 @ (FDCAN Tx FIFO/Queue Status  Register) 
        .equ FDCAN1_FDCAN_TXFQS_TFFL_Shift, 0   @ bitWidth 6 (Tx FIFO Free Level)  
        .equ FDCAN1_FDCAN_TXFQS_TFGI_Shift, 8   @ bitWidth 5 (TFGI)  
        .equ FDCAN1_FDCAN_TXFQS_TFQPI_Shift, 16   @ bitWidth 5 (Tx FIFO/Queue Put Index)  
        .equ FDCAN1_FDCAN_TXFQS_TFQF, 1 << 21   @ bitWidth 1 (Tx FIFO/Queue Full)  
 
    .equ FDCAN1_FDCAN_TXESC, FDCAN1_BASE + 0xC8 @ (FDCAN Tx Buffer Element Size Configuration  Register) 
        .equ FDCAN1_FDCAN_TXESC_TBDS_Shift, 0   @ bitWidth 3 (Tx Buffer Data Field Size:)  
 
    .equ FDCAN1_FDCAN_TXBRP, FDCAN1_BASE + 0xCC @ (FDCAN Tx Buffer Request Pending  Register) 
        .equ FDCAN1_FDCAN_TXBRP_TRP_Shift, 0   @ bitWidth 32 (Transmission Request  Pending)  
 
    .equ FDCAN1_FDCAN_TXBAR, FDCAN1_BASE + 0xD0 @ (FDCAN Tx Buffer Add Request  Register) 
        .equ FDCAN1_FDCAN_TXBAR_AR_Shift, 0   @ bitWidth 32 (Add Request)  
 
    .equ FDCAN1_FDCAN_TXBCR, FDCAN1_BASE + 0xD4 @ (FDCAN Tx Buffer Cancellation Request  Register) 
        .equ FDCAN1_FDCAN_TXBCR_CR_Shift, 0   @ bitWidth 32 (Cancellation Request)  
 
    .equ FDCAN1_FDCAN_TXBTO, FDCAN1_BASE + 0xD8 @ (FDCAN Tx Buffer Transmission Occurred  Register) 
        .equ FDCAN1_FDCAN_TXBTO_TO_Shift, 0   @ bitWidth 32 (Transmission Occurred.)  
 
    .equ FDCAN1_FDCAN_TXBCF, FDCAN1_BASE + 0xDC @ (FDCAN Tx Buffer Cancellation Finished  Register) 
        .equ FDCAN1_FDCAN_TXBCF_CF_Shift, 0   @ bitWidth 32 (Cancellation Finished)  
 
    .equ FDCAN1_FDCAN_TXBTIE, FDCAN1_BASE + 0xE0 @ (FDCAN Tx Buffer Transmission Interrupt  Enable Register) 
        .equ FDCAN1_FDCAN_TXBTIE_TIE_Shift, 0   @ bitWidth 32 (Transmission Interrupt  Enable)  
 
    .equ FDCAN1_FDCAN_TXBCIE, FDCAN1_BASE + 0xE4 @ (FDCAN Tx Buffer Cancellation Finished  Interrupt Enable Register) 
        .equ FDCAN1_FDCAN_TXBCIE_CF_Shift, 0   @ bitWidth 32 (Cancellation Finished Interrupt  Enable)  
 
    .equ FDCAN1_FDCAN_TXEFC, FDCAN1_BASE + 0xF0 @ (FDCAN Tx Event FIFO Configuration  Register) 
        .equ FDCAN1_FDCAN_TXEFC_EFSA_Shift, 2   @ bitWidth 14 (Event FIFO Start Address)  
        .equ FDCAN1_FDCAN_TXEFC_EFS_Shift, 16   @ bitWidth 6 (Event FIFO Size)  
        .equ FDCAN1_FDCAN_TXEFC_EFWM_Shift, 24   @ bitWidth 6 (Event FIFO Watermark)  
 
    .equ FDCAN1_FDCAN_TXEFS, FDCAN1_BASE + 0xF4 @ (FDCAN Tx Event FIFO Status  Register) 
        .equ FDCAN1_FDCAN_TXEFS_EFFL_Shift, 0   @ bitWidth 6 (Event FIFO Fill Level)  
        .equ FDCAN1_FDCAN_TXEFS_EFGI_Shift, 8   @ bitWidth 5 (Event FIFO Get Index.)  
        .equ FDCAN1_FDCAN_TXEFS_EFF, 1 << 24   @ bitWidth 1 (Event FIFO Full.)  
        .equ FDCAN1_FDCAN_TXEFS_TEFL, 1 << 25   @ bitWidth 1 (Tx Event FIFO Element  Lost.)  
 
    .equ FDCAN1_FDCAN_TXEFA, FDCAN1_BASE + 0xF8 @ (FDCAN Tx Event FIFO Acknowledge  Register) 
        .equ FDCAN1_FDCAN_TXEFA_EFAI_Shift, 0   @ bitWidth 5 (Event FIFO Acknowledge  Index)  
 
    .equ FDCAN1_FDCAN_TTTMC, FDCAN1_BASE + 0x100 @ (FDCAN TT Trigger Memory Configuration  Register) 
        .equ FDCAN1_FDCAN_TTTMC_TMSA_Shift, 2   @ bitWidth 14 (Trigger Memory Start  Address)  
        .equ FDCAN1_FDCAN_TTTMC_TME_Shift, 16   @ bitWidth 7 (Trigger Memory Elements)  
 
    .equ FDCAN1_FDCAN_TTRMC, FDCAN1_BASE + 0x104 @ (FDCAN TT Reference Message Configuration  Register) 
        .equ FDCAN1_FDCAN_TTRMC_RID_Shift, 0   @ bitWidth 29 (Reference Identifier.)  
        .equ FDCAN1_FDCAN_TTRMC_XTD, 1 << 30   @ bitWidth 1 (Extended Identifier)  
        .equ FDCAN1_FDCAN_TTRMC_RMPS, 1 << 31   @ bitWidth 1 (Reference Message Payload  Select)  
 
    .equ FDCAN1_FDCAN_TTOCF, FDCAN1_BASE + 0x108 @ (FDCAN TT Operation Configuration  Register) 
        .equ FDCAN1_FDCAN_TTOCF_OM_Shift, 0   @ bitWidth 2 (Operation Mode)  
        .equ FDCAN1_FDCAN_TTOCF_GEN, 1 << 3   @ bitWidth 1 (Gap Enable)  
        .equ FDCAN1_FDCAN_TTOCF_TM, 1 << 4   @ bitWidth 1 (Time Master)  
        .equ FDCAN1_FDCAN_TTOCF_LDSDL_Shift, 5   @ bitWidth 3 (LD of Synchronization Deviation  Limit)  
        .equ FDCAN1_FDCAN_TTOCF_IRTO_Shift, 8   @ bitWidth 7 (Initial Reference Trigger  Offset)  
        .equ FDCAN1_FDCAN_TTOCF_EECS, 1 << 15   @ bitWidth 1 (Enable External Clock  Synchronization)  
        .equ FDCAN1_FDCAN_TTOCF_AWL_Shift, 16   @ bitWidth 8 (Application Watchdog Limit)  
        .equ FDCAN1_FDCAN_TTOCF_EGTF, 1 << 24   @ bitWidth 1 (Enable Global Time  Filtering)  
        .equ FDCAN1_FDCAN_TTOCF_ECC, 1 << 25   @ bitWidth 1 (Enable Clock Calibration)  
        .equ FDCAN1_FDCAN_TTOCF_EVTP, 1 << 26   @ bitWidth 1 (Event Trigger Polarity)  
 
    .equ FDCAN1_FDCAN_TTMLM, FDCAN1_BASE + 0x10C @ (FDCAN TT Matrix Limits  Register) 
        .equ FDCAN1_FDCAN_TTMLM_CCM_Shift, 0   @ bitWidth 6 (Cycle Count Max)  
        .equ FDCAN1_FDCAN_TTMLM_CSS_Shift, 6   @ bitWidth 2 (Cycle Start  Synchronization)  
        .equ FDCAN1_FDCAN_TTMLM_TXEW_Shift, 8   @ bitWidth 4 (Tx Enable Window)  
        .equ FDCAN1_FDCAN_TTMLM_ENTT_Shift, 16   @ bitWidth 12 (Expected Number of Tx  Triggers)  
 
    .equ FDCAN1_FDCAN_TURCF, FDCAN1_BASE + 0x110 @ (FDCAN TUR Configuration  Register) 
        .equ FDCAN1_FDCAN_TURCF_NCL_Shift, 0   @ bitWidth 16 (Numerator Configuration  Low.)  
        .equ FDCAN1_FDCAN_TURCF_DC_Shift, 16   @ bitWidth 14 (Denominator Configuration.)  
        .equ FDCAN1_FDCAN_TURCF_ELT, 1 << 31   @ bitWidth 1 (Enable Local Time)  
 
    .equ FDCAN1_FDCAN_TTOCN, FDCAN1_BASE + 0x114 @ (FDCAN TT Operation Control  Register) 
        .equ FDCAN1_FDCAN_TTOCN_SGT, 1 << 0   @ bitWidth 1 (Set Global time)  
        .equ FDCAN1_FDCAN_TTOCN_ECS, 1 << 1   @ bitWidth 1 (External Clock  Synchronization)  
        .equ FDCAN1_FDCAN_TTOCN_SWP, 1 << 2   @ bitWidth 1 (Stop Watch Polarity)  
        .equ FDCAN1_FDCAN_TTOCN_SWS_Shift, 3   @ bitWidth 2 (Stop Watch Source.)  
        .equ FDCAN1_FDCAN_TTOCN_RTIE, 1 << 5   @ bitWidth 1 (Register Time Mark Interrupt Pulse  Enable)  
        .equ FDCAN1_FDCAN_TTOCN_TMC_Shift, 6   @ bitWidth 2 (Register Time Mark Compare)  
        .equ FDCAN1_FDCAN_TTOCN_TTIE, 1 << 8   @ bitWidth 1 (Trigger Time Mark Interrupt Pulse  Enable)  
        .equ FDCAN1_FDCAN_TTOCN_GCS, 1 << 9   @ bitWidth 1 (Gap Control Select)  
        .equ FDCAN1_FDCAN_TTOCN_FGP, 1 << 10   @ bitWidth 1 (Finish Gap.)  
        .equ FDCAN1_FDCAN_TTOCN_TMG, 1 << 11   @ bitWidth 1 (Time Mark Gap)  
        .equ FDCAN1_FDCAN_TTOCN_NIG, 1 << 12   @ bitWidth 1 (Next is Gap)  
        .equ FDCAN1_FDCAN_TTOCN_ESCN, 1 << 13   @ bitWidth 1 (External Synchronization  Control)  
        .equ FDCAN1_FDCAN_TTOCN_LCKC, 1 << 15   @ bitWidth 1 (TT Operation Control Register  Locked)  
 
    .equ FDCAN1_CAN_TTGTP, FDCAN1_BASE + 0x118 @ (FDCAN TT Global Time Preset  Register) 
        .equ FDCAN1_CAN_TTGTP_NCL_Shift, 0   @ bitWidth 16 (Time Preset)  
        .equ FDCAN1_CAN_TTGTP_CTP_Shift, 16   @ bitWidth 16 (Cycle Time Target Phase)  
 
    .equ FDCAN1_FDCAN_TTTMK, FDCAN1_BASE + 0x11C @ (FDCAN TT Time Mark Register) 
        .equ FDCAN1_FDCAN_TTTMK_TM_Shift, 0   @ bitWidth 16 (Time Mark)  
        .equ FDCAN1_FDCAN_TTTMK_TICC_Shift, 16   @ bitWidth 7 (Time Mark Cycle Code)  
        .equ FDCAN1_FDCAN_TTTMK_LCKM, 1 << 31   @ bitWidth 1 (TT Time Mark Register  Locked)  
 
    .equ FDCAN1_FDCAN_TTIR, FDCAN1_BASE + 0x120 @ (FDCAN TT Interrupt Register) 
        .equ FDCAN1_FDCAN_TTIR_SBC, 1 << 0   @ bitWidth 1 (Start of Basic Cycle)  
        .equ FDCAN1_FDCAN_TTIR_SMC, 1 << 1   @ bitWidth 1 (Start of Matrix Cycle)  
        .equ FDCAN1_FDCAN_TTIR_CSM, 1 << 2   @ bitWidth 1 (Change of Synchronization  Mode)  
        .equ FDCAN1_FDCAN_TTIR_SOG, 1 << 3   @ bitWidth 1 (Start of Gap)  
        .equ FDCAN1_FDCAN_TTIR_RTMI, 1 << 4   @ bitWidth 1 (Register Time Mark  Interrupt.)  
        .equ FDCAN1_FDCAN_TTIR_TTMI, 1 << 5   @ bitWidth 1 (Trigger Time Mark Event  Internal)  
        .equ FDCAN1_FDCAN_TTIR_SWE, 1 << 6   @ bitWidth 1 (Stop Watch Event)  
        .equ FDCAN1_FDCAN_TTIR_GTW, 1 << 7   @ bitWidth 1 (Global Time Wrap)  
        .equ FDCAN1_FDCAN_TTIR_GTD, 1 << 8   @ bitWidth 1 (Global Time Discontinuity)  
        .equ FDCAN1_FDCAN_TTIR_GTE, 1 << 9   @ bitWidth 1 (Global Time Error)  
        .equ FDCAN1_FDCAN_TTIR_TXU, 1 << 10   @ bitWidth 1 (Tx Count Underflow)  
        .equ FDCAN1_FDCAN_TTIR_TXO, 1 << 11   @ bitWidth 1 (Tx Count Overflow)  
        .equ FDCAN1_FDCAN_TTIR_SE1, 1 << 12   @ bitWidth 1 (Scheduling Error 1)  
        .equ FDCAN1_FDCAN_TTIR_SE2, 1 << 13   @ bitWidth 1 (Scheduling Error 2)  
        .equ FDCAN1_FDCAN_TTIR_ELC, 1 << 14   @ bitWidth 1 (Error Level Changed.)  
        .equ FDCAN1_FDCAN_TTIR_IWTG, 1 << 15   @ bitWidth 1 (Initialization Watch  Trigger)  
        .equ FDCAN1_FDCAN_TTIR_WT, 1 << 16   @ bitWidth 1 (Watch Trigger)  
        .equ FDCAN1_FDCAN_TTIR_AW, 1 << 17   @ bitWidth 1 (Application Watchdog)  
        .equ FDCAN1_FDCAN_TTIR_CER, 1 << 18   @ bitWidth 1 (Configuration Error)  
 
    .equ FDCAN1_FDCAN_TTIE, FDCAN1_BASE + 0x124 @ (FDCAN TT Interrupt Enable  Register) 
        .equ FDCAN1_FDCAN_TTIE_SBCE, 1 << 0   @ bitWidth 1 (Start of Basic Cycle Interrupt  Enable)  
        .equ FDCAN1_FDCAN_TTIE_SMCE, 1 << 1   @ bitWidth 1 (Start of Matrix Cycle Interrupt  Enable)  
        .equ FDCAN1_FDCAN_TTIE_CSME, 1 << 2   @ bitWidth 1 (Change of Synchronization Mode Interrupt  Enable)  
        .equ FDCAN1_FDCAN_TTIE_SOGE, 1 << 3   @ bitWidth 1 (Start of Gap Interrupt  Enable)  
        .equ FDCAN1_FDCAN_TTIE_RTMIE, 1 << 4   @ bitWidth 1 (Register Time Mark Interrupt  Enable)  
        .equ FDCAN1_FDCAN_TTIE_TTMIE, 1 << 5   @ bitWidth 1 (Trigger Time Mark Event Internal  Interrupt Enable)  
        .equ FDCAN1_FDCAN_TTIE_SWEE, 1 << 6   @ bitWidth 1 (Stop Watch Event Interrupt  Enable)  
        .equ FDCAN1_FDCAN_TTIE_GTWE, 1 << 7   @ bitWidth 1 (Global Time Wrap Interrupt  Enable)  
        .equ FDCAN1_FDCAN_TTIE_GTDE, 1 << 8   @ bitWidth 1 (Global Time Discontinuity Interrupt  Enable)  
        .equ FDCAN1_FDCAN_TTIE_GTEE, 1 << 9   @ bitWidth 1 (Global Time Error Interrupt  Enable)  
        .equ FDCAN1_FDCAN_TTIE_TXUE, 1 << 10   @ bitWidth 1 (Tx Count Underflow Interrupt  Enable)  
        .equ FDCAN1_FDCAN_TTIE_TXOE, 1 << 11   @ bitWidth 1 (Tx Count Overflow Interrupt  Enable)  
        .equ FDCAN1_FDCAN_TTIE_SE1E, 1 << 12   @ bitWidth 1 (Scheduling Error 1 Interrupt  Enable)  
        .equ FDCAN1_FDCAN_TTIE_SE2E, 1 << 13   @ bitWidth 1 (Scheduling Error 2 Interrupt  Enable)  
        .equ FDCAN1_FDCAN_TTIE_ELCE, 1 << 14   @ bitWidth 1 (Change Error Level Interrupt  Enable)  
        .equ FDCAN1_FDCAN_TTIE_IWTGE, 1 << 15   @ bitWidth 1 (Initialization Watch Trigger Interrupt  Enable)  
        .equ FDCAN1_FDCAN_TTIE_WTE, 1 << 16   @ bitWidth 1 (Watch Trigger Interrupt  Enable)  
        .equ FDCAN1_FDCAN_TTIE_AWE, 1 << 17   @ bitWidth 1 (Application Watchdog Interrupt  Enable)  
        .equ FDCAN1_FDCAN_TTIE_CERE, 1 << 18   @ bitWidth 1 (Configuration Error Interrupt  Enable)  
 
    .equ FDCAN1_FDCAN_TTILS, FDCAN1_BASE + 0x128 @ (FDCAN TT Interrupt Line Select  Register) 
        .equ FDCAN1_FDCAN_TTILS_SBCL, 1 << 0   @ bitWidth 1 (Start of Basic Cycle Interrupt  Line)  
        .equ FDCAN1_FDCAN_TTILS_SMCL, 1 << 1   @ bitWidth 1 (Start of Matrix Cycle Interrupt  Line)  
        .equ FDCAN1_FDCAN_TTILS_CSML, 1 << 2   @ bitWidth 1 (Change of Synchronization Mode Interrupt  Line)  
        .equ FDCAN1_FDCAN_TTILS_SOGL, 1 << 3   @ bitWidth 1 (Start of Gap Interrupt  Line)  
        .equ FDCAN1_FDCAN_TTILS_RTMIL, 1 << 4   @ bitWidth 1 (Register Time Mark Interrupt  Line)  
        .equ FDCAN1_FDCAN_TTILS_TTMIL, 1 << 5   @ bitWidth 1 (Trigger Time Mark Event Internal  Interrupt Line)  
        .equ FDCAN1_FDCAN_TTILS_SWEL, 1 << 6   @ bitWidth 1 (Stop Watch Event Interrupt  Line)  
        .equ FDCAN1_FDCAN_TTILS_GTWL, 1 << 7   @ bitWidth 1 (Global Time Wrap Interrupt  Line)  
        .equ FDCAN1_FDCAN_TTILS_GTDL, 1 << 8   @ bitWidth 1 (Global Time Discontinuity Interrupt  Line)  
        .equ FDCAN1_FDCAN_TTILS_GTEL, 1 << 9   @ bitWidth 1 (Global Time Error Interrupt  Line)  
        .equ FDCAN1_FDCAN_TTILS_TXUL, 1 << 10   @ bitWidth 1 (Tx Count Underflow Interrupt  Line)  
        .equ FDCAN1_FDCAN_TTILS_TXOL, 1 << 11   @ bitWidth 1 (Tx Count Overflow Interrupt  Line)  
        .equ FDCAN1_FDCAN_TTILS_SE1L, 1 << 12   @ bitWidth 1 (Scheduling Error 1 Interrupt  Line)  
        .equ FDCAN1_FDCAN_TTILS_SE2L, 1 << 13   @ bitWidth 1 (Scheduling Error 2 Interrupt  Line)  
        .equ FDCAN1_FDCAN_TTILS_ELCL, 1 << 14   @ bitWidth 1 (Change Error Level Interrupt  Line)  
        .equ FDCAN1_FDCAN_TTILS_IWTGL, 1 << 15   @ bitWidth 1 (Initialization Watch Trigger Interrupt  Line)  
        .equ FDCAN1_FDCAN_TTILS_WTL, 1 << 16   @ bitWidth 1 (Watch Trigger Interrupt  Line)  
        .equ FDCAN1_FDCAN_TTILS_AWL, 1 << 17   @ bitWidth 1 (Application Watchdog Interrupt  Line)  
        .equ FDCAN1_FDCAN_TTILS_CERL, 1 << 18   @ bitWidth 1 (Configuration Error Interrupt  Line)  
 
    .equ FDCAN1_FDCAN_TTOST, FDCAN1_BASE + 0x12C @ (FDCAN TT Operation Status  Register) 
        .equ FDCAN1_FDCAN_TTOST_EL_Shift, 0   @ bitWidth 2 (Error Level)  
        .equ FDCAN1_FDCAN_TTOST_MS_Shift, 2   @ bitWidth 2 (Master State.)  
        .equ FDCAN1_FDCAN_TTOST_SYS_Shift, 4   @ bitWidth 2 (Synchronization State)  
        .equ FDCAN1_FDCAN_TTOST_GTP, 1 << 6   @ bitWidth 1 (Quality of Global Time  Phase)  
        .equ FDCAN1_FDCAN_TTOST_QCS, 1 << 7   @ bitWidth 1 (Quality of Clock Speed)  
        .equ FDCAN1_FDCAN_TTOST_RTO_Shift, 8   @ bitWidth 8 (Reference Trigger Offset)  
        .equ FDCAN1_FDCAN_TTOST_WGTD, 1 << 22   @ bitWidth 1 (Wait for Global Time  Discontinuity)  
        .equ FDCAN1_FDCAN_TTOST_GFI, 1 << 23   @ bitWidth 1 (Gap Finished Indicator.)  
        .equ FDCAN1_FDCAN_TTOST_TMP_Shift, 24   @ bitWidth 3 (Time Master Priority)  
        .equ FDCAN1_FDCAN_TTOST_GSI, 1 << 27   @ bitWidth 1 (Gap Started Indicator.)  
        .equ FDCAN1_FDCAN_TTOST_WFE, 1 << 28   @ bitWidth 1 (Wait for Event)  
        .equ FDCAN1_FDCAN_TTOST_AWE, 1 << 29   @ bitWidth 1 (Application Watchdog Event)  
        .equ FDCAN1_FDCAN_TTOST_WECS, 1 << 30   @ bitWidth 1 (Wait for External Clock  Synchronization)  
        .equ FDCAN1_FDCAN_TTOST_SPL, 1 << 31   @ bitWidth 1 (Schedule Phase Lock)  
 
    .equ FDCAN1_FDCAN_TURNA, FDCAN1_BASE + 0x130 @ (FDCAN TUR Numerator Actual  Register) 
        .equ FDCAN1_FDCAN_TURNA_NAV_Shift, 0   @ bitWidth 18 (Numerator Actual Value)  
 
    .equ FDCAN1_FDCAN_TTLGT, FDCAN1_BASE + 0x134 @ (FDCAN TT Local and Global Time  Register) 
        .equ FDCAN1_FDCAN_TTLGT_LT_Shift, 0   @ bitWidth 16 (Local Time)  
        .equ FDCAN1_FDCAN_TTLGT_GT_Shift, 16   @ bitWidth 16 (Global Time)  
 
    .equ FDCAN1_FDCAN_TTCTC, FDCAN1_BASE + 0x138 @ (FDCAN TT Cycle Time and Count  Register) 
        .equ FDCAN1_FDCAN_TTCTC_CT_Shift, 0   @ bitWidth 16 (Cycle Time)  
        .equ FDCAN1_FDCAN_TTCTC_CC_Shift, 16   @ bitWidth 6 (Cycle Count)  
 
    .equ FDCAN1_FDCAN_TTCPT, FDCAN1_BASE + 0x13C @ (FDCAN TT Capture Time Register) 
        .equ FDCAN1_FDCAN_TTCPT_CT_Shift, 0   @ bitWidth 6 (Cycle Count Value)  
        .equ FDCAN1_FDCAN_TTCPT_SWV_Shift, 16   @ bitWidth 16 (Stop Watch Value)  
 
    .equ FDCAN1_FDCAN_TTCSM, FDCAN1_BASE + 0x140 @ (FDCAN TT Cycle Sync Mark  Register) 
        .equ FDCAN1_FDCAN_TTCSM_CSM_Shift, 0   @ bitWidth 16 (Cycle Sync Mark)  
 
    .equ FDCAN1_FDCAN_TTTS, FDCAN1_BASE + 0x300 @ (FDCAN TT Trigger Select  Register) 
        .equ FDCAN1_FDCAN_TTTS_SWTDEL_Shift, 0   @ bitWidth 2 (Stop watch trigger input  selection)  
        .equ FDCAN1_FDCAN_TTTS_EVTSEL_Shift, 4   @ bitWidth 2 (Event trigger input  selection)  
 

@=========================== FDCAN2 ===========================@
.equ FDCAN2_BASE, 0x4000A400 @ (FDCAN1) 
    .equ FDCAN2_FDCAN_CREL, FDCAN2_BASE + 0x0 @ (FDCAN Core Release Register) 
        .equ FDCAN2_FDCAN_CREL_REL_Shift, 28   @ bitWidth 4 (Core release)  
        .equ FDCAN2_FDCAN_CREL_STEP_Shift, 24   @ bitWidth 4 (Step of Core release)  
        .equ FDCAN2_FDCAN_CREL_SUBSTEP_Shift, 20   @ bitWidth 4 (Sub-step of Core release)  
        .equ FDCAN2_FDCAN_CREL_YEAR_Shift, 16   @ bitWidth 4 (Timestamp Year)  
        .equ FDCAN2_FDCAN_CREL_MON_Shift, 8   @ bitWidth 8 (Timestamp Month)  
        .equ FDCAN2_FDCAN_CREL_DAY_Shift, 0   @ bitWidth 8 (Timestamp Day)  
 
    .equ FDCAN2_FDCAN_ENDN, FDCAN2_BASE + 0x4 @ (FDCAN Core Release Register) 
        .equ FDCAN2_FDCAN_ENDN_ETV_Shift, 0   @ bitWidth 32 (Endiannes Test Value)  
 
    .equ FDCAN2_FDCAN_DBTP, FDCAN2_BASE + 0xC @ (FDCAN Data Bit Timing and Prescaler  Register) 
        .equ FDCAN2_FDCAN_DBTP_DSJW_Shift, 0   @ bitWidth 4 (Synchronization Jump Width)  
        .equ FDCAN2_FDCAN_DBTP_DTSEG2_Shift, 4   @ bitWidth 4 (Data time segment after sample  point)  
        .equ FDCAN2_FDCAN_DBTP_DTSEG1_Shift, 8   @ bitWidth 5 (Data time segment after sample  point)  
        .equ FDCAN2_FDCAN_DBTP_DBRP_Shift, 16   @ bitWidth 5 (Data BIt Rate Prescaler)  
        .equ FDCAN2_FDCAN_DBTP_TDC, 1 << 23   @ bitWidth 1 (Transceiver Delay  Compensation)  
 
    .equ FDCAN2_FDCAN_TEST, FDCAN2_BASE + 0x10 @ (FDCAN Test Register) 
        .equ FDCAN2_FDCAN_TEST_LBCK, 1 << 4   @ bitWidth 1 (Loop Back mode)  
        .equ FDCAN2_FDCAN_TEST_TX_Shift, 5   @ bitWidth 2 (Loop Back mode)  
        .equ FDCAN2_FDCAN_TEST_RX, 1 << 7   @ bitWidth 1 (Control of Transmit Pin)  
 
    .equ FDCAN2_FDCAN_RWD, FDCAN2_BASE + 0x14 @ (FDCAN RAM Watchdog Register) 
        .equ FDCAN2_FDCAN_RWD_WDV_Shift, 8   @ bitWidth 8 (Watchdog value)  
        .equ FDCAN2_FDCAN_RWD_WDC_Shift, 0   @ bitWidth 8 (Watchdog configuration)  
 
    .equ FDCAN2_FDCAN_CCCR, FDCAN2_BASE + 0x18 @ (FDCAN CC Control Register) 
        .equ FDCAN2_FDCAN_CCCR_INIT, 1 << 0   @ bitWidth 1 (Initialization)  
        .equ FDCAN2_FDCAN_CCCR_CCE, 1 << 1   @ bitWidth 1 (Configuration Change  Enable)  
        .equ FDCAN2_FDCAN_CCCR_ASM, 1 << 2   @ bitWidth 1 (ASM Restricted Operation  Mode)  
        .equ FDCAN2_FDCAN_CCCR_CSA, 1 << 3   @ bitWidth 1 (Clock Stop Acknowledge)  
        .equ FDCAN2_FDCAN_CCCR_CSR, 1 << 4   @ bitWidth 1 (Clock Stop Request)  
        .equ FDCAN2_FDCAN_CCCR_MON, 1 << 5   @ bitWidth 1 (Bus Monitoring Mode)  
        .equ FDCAN2_FDCAN_CCCR_DAR, 1 << 6   @ bitWidth 1 (Disable Automatic  Retransmission)  
        .equ FDCAN2_FDCAN_CCCR_TEST, 1 << 7   @ bitWidth 1 (Test Mode Enable)  
        .equ FDCAN2_FDCAN_CCCR_FDOE, 1 << 8   @ bitWidth 1 (FD Operation Enable)  
        .equ FDCAN2_FDCAN_CCCR_BSE, 1 << 9   @ bitWidth 1 (FDCAN Bit Rate Switching)  
        .equ FDCAN2_FDCAN_CCCR_PXHD, 1 << 12   @ bitWidth 1 (Protocol Exception Handling  Disable)  
        .equ FDCAN2_FDCAN_CCCR_EFBI, 1 << 13   @ bitWidth 1 (Edge Filtering during Bus  Integration)  
        .equ FDCAN2_FDCAN_CCCR_TXP, 1 << 14   @ bitWidth 1 (TXP)  
        .equ FDCAN2_FDCAN_CCCR_NISO, 1 << 15   @ bitWidth 1 (Non ISO Operation)  
 
    .equ FDCAN2_FDCAN_NBTP, FDCAN2_BASE + 0x1C @ (FDCAN Nominal Bit Timing and Prescaler  Register) 
        .equ FDCAN2_FDCAN_NBTP_NSJW_Shift, 25   @ bitWidth 7 (NSJW: Nominal ReSynchronization Jump  Width)  
        .equ FDCAN2_FDCAN_NBTP_NBRP_Shift, 16   @ bitWidth 9 (Bit Rate Prescaler)  
        .equ FDCAN2_FDCAN_NBTP_NTSEG1_Shift, 8   @ bitWidth 8 (Nominal Time segment before sample  point)  
        .equ FDCAN2_FDCAN_NBTP_TSEG2_Shift, 0   @ bitWidth 7 (Nominal Time segment after sample  point)  
 
    .equ FDCAN2_FDCAN_TSCC, FDCAN2_BASE + 0x20 @ (FDCAN Timestamp Counter Configuration  Register) 
        .equ FDCAN2_FDCAN_TSCC_TCP_Shift, 16   @ bitWidth 4 (Timestamp Counter  Prescaler)  
        .equ FDCAN2_FDCAN_TSCC_TSS_Shift, 0   @ bitWidth 2 (Timestamp Select)  
 
    .equ FDCAN2_FDCAN_TSCV, FDCAN2_BASE + 0x24 @ (FDCAN Timestamp Counter Value  Register) 
        .equ FDCAN2_FDCAN_TSCV_TSC_Shift, 0   @ bitWidth 16 (Timestamp Counter)  
 
    .equ FDCAN2_FDCAN_TOCC, FDCAN2_BASE + 0x28 @ (FDCAN Timeout Counter Configuration  Register) 
        .equ FDCAN2_FDCAN_TOCC_ETOC, 1 << 0   @ bitWidth 1 (Enable Timeout Counter)  
        .equ FDCAN2_FDCAN_TOCC_TOS_Shift, 1   @ bitWidth 2 (Timeout Select)  
        .equ FDCAN2_FDCAN_TOCC_TOP_Shift, 16   @ bitWidth 16 (Timeout Period)  
 
    .equ FDCAN2_FDCAN_TOCV, FDCAN2_BASE + 0x2C @ (FDCAN Timeout Counter Value  Register) 
        .equ FDCAN2_FDCAN_TOCV_TOC_Shift, 0   @ bitWidth 16 (Timeout Counter)  
 
    .equ FDCAN2_FDCAN_ECR, FDCAN2_BASE + 0x40 @ (FDCAN Error Counter Register) 
        .equ FDCAN2_FDCAN_ECR_CEL_Shift, 16   @ bitWidth 8 (AN Error Logging)  
        .equ FDCAN2_FDCAN_ECR_RP, 1 << 15   @ bitWidth 1 (Receive Error Passive)  
        .equ FDCAN2_FDCAN_ECR_TREC_Shift, 8   @ bitWidth 7 (Receive Error Counter)  
        .equ FDCAN2_FDCAN_ECR_TEC_Shift, 0   @ bitWidth 8 (Transmit Error Counter)  
 
    .equ FDCAN2_FDCAN_PSR, FDCAN2_BASE + 0x44 @ (FDCAN Protocol Status Register) 
        .equ FDCAN2_FDCAN_PSR_LEC_Shift, 0   @ bitWidth 3 (Last Error Code)  
        .equ FDCAN2_FDCAN_PSR_ACT_Shift, 3   @ bitWidth 2 (Activity)  
        .equ FDCAN2_FDCAN_PSR_EP, 1 << 5   @ bitWidth 1 (Error Passive)  
        .equ FDCAN2_FDCAN_PSR_EW, 1 << 6   @ bitWidth 1 (Warning Status)  
        .equ FDCAN2_FDCAN_PSR_BO, 1 << 7   @ bitWidth 1 (Bus_Off Status)  
        .equ FDCAN2_FDCAN_PSR_DLEC_Shift, 8   @ bitWidth 3 (Data Last Error Code)  
        .equ FDCAN2_FDCAN_PSR_RESI, 1 << 11   @ bitWidth 1 (ESI flag of last received FDCAN  Message)  
        .equ FDCAN2_FDCAN_PSR_RBRS, 1 << 12   @ bitWidth 1 (BRS flag of last received FDCAN  Message)  
        .equ FDCAN2_FDCAN_PSR_REDL, 1 << 13   @ bitWidth 1 (Received FDCAN Message)  
        .equ FDCAN2_FDCAN_PSR_PXE, 1 << 14   @ bitWidth 1 (Protocol Exception Event)  
        .equ FDCAN2_FDCAN_PSR_TDCV_Shift, 16   @ bitWidth 7 (Transmitter Delay Compensation  Value)  
 
    .equ FDCAN2_FDCAN_TDCR, FDCAN2_BASE + 0x48 @ (FDCAN Transmitter Delay Compensation  Register) 
        .equ FDCAN2_FDCAN_TDCR_TDCF_Shift, 0   @ bitWidth 7 (Transmitter Delay Compensation Filter  Window Length)  
        .equ FDCAN2_FDCAN_TDCR_TDCO_Shift, 8   @ bitWidth 7 (Transmitter Delay Compensation  Offset)  
 
    .equ FDCAN2_FDCAN_IR, FDCAN2_BASE + 0x50 @ (FDCAN Interrupt Register) 
        .equ FDCAN2_FDCAN_IR_RF0N, 1 << 0   @ bitWidth 1 (Rx FIFO 0 New Message)  
        .equ FDCAN2_FDCAN_IR_RF0W, 1 << 1   @ bitWidth 1 (Rx FIFO 0 Full)  
        .equ FDCAN2_FDCAN_IR_RF0F, 1 << 2   @ bitWidth 1 (Rx FIFO 0 Full)  
        .equ FDCAN2_FDCAN_IR_RF0L, 1 << 3   @ bitWidth 1 (Rx FIFO 0 Message Lost)  
        .equ FDCAN2_FDCAN_IR_RF1N, 1 << 4   @ bitWidth 1 (Rx FIFO 1 New Message)  
        .equ FDCAN2_FDCAN_IR_RF1W, 1 << 5   @ bitWidth 1 (Rx FIFO 1 Watermark  Reached)  
        .equ FDCAN2_FDCAN_IR_RF1F, 1 << 6   @ bitWidth 1 (Rx FIFO 1 Watermark  Reached)  
        .equ FDCAN2_FDCAN_IR_RF1L, 1 << 7   @ bitWidth 1 (Rx FIFO 1 Message Lost)  
        .equ FDCAN2_FDCAN_IR_HPM, 1 << 8   @ bitWidth 1 (High Priority Message)  
        .equ FDCAN2_FDCAN_IR_TC, 1 << 9   @ bitWidth 1 (Transmission Completed)  
        .equ FDCAN2_FDCAN_IR_TCF, 1 << 10   @ bitWidth 1 (Transmission Cancellation  Finished)  
        .equ FDCAN2_FDCAN_IR_TEF, 1 << 11   @ bitWidth 1 (Tx FIFO Empty)  
        .equ FDCAN2_FDCAN_IR_TEFN, 1 << 12   @ bitWidth 1 (Tx Event FIFO New Entry)  
        .equ FDCAN2_FDCAN_IR_TEFW, 1 << 13   @ bitWidth 1 (Tx Event FIFO Watermark  Reached)  
        .equ FDCAN2_FDCAN_IR_TEFF, 1 << 14   @ bitWidth 1 (Tx Event FIFO Full)  
        .equ FDCAN2_FDCAN_IR_TEFL, 1 << 15   @ bitWidth 1 (Tx Event FIFO Element Lost)  
        .equ FDCAN2_FDCAN_IR_TSW, 1 << 16   @ bitWidth 1 (Timestamp Wraparound)  
        .equ FDCAN2_FDCAN_IR_MRAF, 1 << 17   @ bitWidth 1 (Message RAM Access Failure)  
        .equ FDCAN2_FDCAN_IR_TOO, 1 << 18   @ bitWidth 1 (Timeout Occurred)  
        .equ FDCAN2_FDCAN_IR_DRX, 1 << 19   @ bitWidth 1 (Message stored to Dedicated Rx  Buffer)  
        .equ FDCAN2_FDCAN_IR_ELO, 1 << 22   @ bitWidth 1 (Error Logging Overflow)  
        .equ FDCAN2_FDCAN_IR_EP, 1 << 23   @ bitWidth 1 (Error Passive)  
        .equ FDCAN2_FDCAN_IR_EW, 1 << 24   @ bitWidth 1 (Warning Status)  
        .equ FDCAN2_FDCAN_IR_BO, 1 << 25   @ bitWidth 1 (Bus_Off Status)  
        .equ FDCAN2_FDCAN_IR_WDI, 1 << 26   @ bitWidth 1 (Watchdog Interrupt)  
        .equ FDCAN2_FDCAN_IR_PEA, 1 << 27   @ bitWidth 1 (Protocol Error in Arbitration Phase  Nominal Bit Time is used)  
        .equ FDCAN2_FDCAN_IR_PED, 1 << 28   @ bitWidth 1 (Protocol Error in Data Phase Data Bit  Time is used)  
        .equ FDCAN2_FDCAN_IR_ARA, 1 << 29   @ bitWidth 1 (Access to Reserved Address)  
 
    .equ FDCAN2_FDCAN_IE, FDCAN2_BASE + 0x54 @ (FDCAN Interrupt Enable  Register) 
        .equ FDCAN2_FDCAN_IE_RF0NE, 1 << 0   @ bitWidth 1 (Rx FIFO 0 New Message  Enable)  
        .equ FDCAN2_FDCAN_IE_RF0WE, 1 << 1   @ bitWidth 1 (Rx FIFO 0 Full Enable)  
        .equ FDCAN2_FDCAN_IE_RF0FE, 1 << 2   @ bitWidth 1 (Rx FIFO 0 Full Enable)  
        .equ FDCAN2_FDCAN_IE_RF0LE, 1 << 3   @ bitWidth 1 (Rx FIFO 0 Message Lost  Enable)  
        .equ FDCAN2_FDCAN_IE_RF1NE, 1 << 4   @ bitWidth 1 (Rx FIFO 1 New Message  Enable)  
        .equ FDCAN2_FDCAN_IE_RF1WE, 1 << 5   @ bitWidth 1 (Rx FIFO 1 Watermark Reached  Enable)  
        .equ FDCAN2_FDCAN_IE_RF1FE, 1 << 6   @ bitWidth 1 (Rx FIFO 1 Watermark Reached  Enable)  
        .equ FDCAN2_FDCAN_IE_RF1LE, 1 << 7   @ bitWidth 1 (Rx FIFO 1 Message Lost  Enable)  
        .equ FDCAN2_FDCAN_IE_HPME, 1 << 8   @ bitWidth 1 (High Priority Message  Enable)  
        .equ FDCAN2_FDCAN_IE_TCE, 1 << 9   @ bitWidth 1 (Transmission Completed  Enable)  
        .equ FDCAN2_FDCAN_IE_TCFE, 1 << 10   @ bitWidth 1 (Transmission Cancellation Finished  Enable)  
        .equ FDCAN2_FDCAN_IE_TEFE, 1 << 11   @ bitWidth 1 (Tx FIFO Empty Enable)  
        .equ FDCAN2_FDCAN_IE_TEFNE, 1 << 12   @ bitWidth 1 (Tx Event FIFO New Entry  Enable)  
        .equ FDCAN2_FDCAN_IE_TEFWE, 1 << 13   @ bitWidth 1 (Tx Event FIFO Watermark Reached  Enable)  
        .equ FDCAN2_FDCAN_IE_TEFFE, 1 << 14   @ bitWidth 1 (Tx Event FIFO Full Enable)  
        .equ FDCAN2_FDCAN_IE_TEFLE, 1 << 15   @ bitWidth 1 (Tx Event FIFO Element Lost  Enable)  
        .equ FDCAN2_FDCAN_IE_TSWE, 1 << 16   @ bitWidth 1 (Timestamp Wraparound  Enable)  
        .equ FDCAN2_FDCAN_IE_MRAFE, 1 << 17   @ bitWidth 1 (Message RAM Access Failure  Enable)  
        .equ FDCAN2_FDCAN_IE_TOOE, 1 << 18   @ bitWidth 1 (Timeout Occurred Enable)  
        .equ FDCAN2_FDCAN_IE_DRXE, 1 << 19   @ bitWidth 1 (Message stored to Dedicated Rx Buffer  Enable)  
        .equ FDCAN2_FDCAN_IE_BECE, 1 << 20   @ bitWidth 1 (Bit Error Corrected Interrupt  Enable)  
        .equ FDCAN2_FDCAN_IE_BEUE, 1 << 21   @ bitWidth 1 (Bit Error Uncorrected Interrupt  Enable)  
        .equ FDCAN2_FDCAN_IE_ELOE, 1 << 22   @ bitWidth 1 (Error Logging Overflow  Enable)  
        .equ FDCAN2_FDCAN_IE_EPE, 1 << 23   @ bitWidth 1 (Error Passive Enable)  
        .equ FDCAN2_FDCAN_IE_EWE, 1 << 24   @ bitWidth 1 (Warning Status Enable)  
        .equ FDCAN2_FDCAN_IE_BOE, 1 << 25   @ bitWidth 1 (Bus_Off Status Enable)  
        .equ FDCAN2_FDCAN_IE_WDIE, 1 << 26   @ bitWidth 1 (Watchdog Interrupt Enable)  
        .equ FDCAN2_FDCAN_IE_PEAE, 1 << 27   @ bitWidth 1 (Protocol Error in Arbitration Phase  Enable)  
        .equ FDCAN2_FDCAN_IE_PEDE, 1 << 28   @ bitWidth 1 (Protocol Error in Data Phase  Enable)  
        .equ FDCAN2_FDCAN_IE_ARAE, 1 << 29   @ bitWidth 1 (Access to Reserved Address  Enable)  
 
    .equ FDCAN2_FDCAN_ILS, FDCAN2_BASE + 0x58 @ (FDCAN Interrupt Line Select  Register) 
        .equ FDCAN2_FDCAN_ILS_RF0NL, 1 << 0   @ bitWidth 1 (Rx FIFO 0 New Message Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_RF0WL, 1 << 1   @ bitWidth 1 (Rx FIFO 0 Watermark Reached Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_RF0FL, 1 << 2   @ bitWidth 1 (Rx FIFO 0 Full Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_RF0LL, 1 << 3   @ bitWidth 1 (Rx FIFO 0 Message Lost Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_RF1NL, 1 << 4   @ bitWidth 1 (Rx FIFO 1 New Message Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_RF1WL, 1 << 5   @ bitWidth 1 (Rx FIFO 1 Watermark Reached Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_RF1FL, 1 << 6   @ bitWidth 1 (Rx FIFO 1 Full Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_RF1LL, 1 << 7   @ bitWidth 1 (Rx FIFO 1 Message Lost Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_HPML, 1 << 8   @ bitWidth 1 (High Priority Message Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_TCL, 1 << 9   @ bitWidth 1 (Transmission Completed Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_TCFL, 1 << 10   @ bitWidth 1 (Transmission Cancellation Finished  Interrupt Line)  
        .equ FDCAN2_FDCAN_ILS_TEFL, 1 << 11   @ bitWidth 1 (Tx FIFO Empty Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_TEFNL, 1 << 12   @ bitWidth 1 (Tx Event FIFO New Entry Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_TEFWL, 1 << 13   @ bitWidth 1 (Tx Event FIFO Watermark Reached  Interrupt Line)  
        .equ FDCAN2_FDCAN_ILS_TEFFL, 1 << 14   @ bitWidth 1 (Tx Event FIFO Full Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_TEFLL, 1 << 15   @ bitWidth 1 (Tx Event FIFO Element Lost Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_TSWL, 1 << 16   @ bitWidth 1 (Timestamp Wraparound Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_MRAFL, 1 << 17   @ bitWidth 1 (Message RAM Access Failure Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_TOOL, 1 << 18   @ bitWidth 1 (Timeout Occurred Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_DRXL, 1 << 19   @ bitWidth 1 (Message stored to Dedicated Rx Buffer  Interrupt Line)  
        .equ FDCAN2_FDCAN_ILS_BECL, 1 << 20   @ bitWidth 1 (Bit Error Corrected Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_BEUL, 1 << 21   @ bitWidth 1 (Bit Error Uncorrected Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_ELOL, 1 << 22   @ bitWidth 1 (Error Logging Overflow Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_EPL, 1 << 23   @ bitWidth 1 (Error Passive Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_EWL, 1 << 24   @ bitWidth 1 (Warning Status Interrupt  Line)  
        .equ FDCAN2_FDCAN_ILS_BOL, 1 << 25   @ bitWidth 1 (Bus_Off Status)  
        .equ FDCAN2_FDCAN_ILS_WDIL, 1 << 26   @ bitWidth 1 (Watchdog Interrupt Line)  
        .equ FDCAN2_FDCAN_ILS_PEAL, 1 << 27   @ bitWidth 1 (Protocol Error in Arbitration Phase  Line)  
        .equ FDCAN2_FDCAN_ILS_PEDL, 1 << 28   @ bitWidth 1 (Protocol Error in Data Phase  Line)  
        .equ FDCAN2_FDCAN_ILS_ARAL, 1 << 29   @ bitWidth 1 (Access to Reserved Address  Line)  
 
    .equ FDCAN2_FDCAN_ILE, FDCAN2_BASE + 0x5C @ (FDCAN Interrupt Line Enable  Register) 
        .equ FDCAN2_FDCAN_ILE_EINT0, 1 << 0   @ bitWidth 1 (Enable Interrupt Line 0)  
        .equ FDCAN2_FDCAN_ILE_EINT1, 1 << 1   @ bitWidth 1 (Enable Interrupt Line 1)  
 
    .equ FDCAN2_FDCAN_GFC, FDCAN2_BASE + 0x80 @ (FDCAN Global Filter Configuration  Register) 
        .equ FDCAN2_FDCAN_GFC_RRFE, 1 << 0   @ bitWidth 1 (Reject Remote Frames  Extended)  
        .equ FDCAN2_FDCAN_GFC_RRFS, 1 << 1   @ bitWidth 1 (Reject Remote Frames  Standard)  
        .equ FDCAN2_FDCAN_GFC_ANFE_Shift, 2   @ bitWidth 2 (Accept Non-matching Frames  Extended)  
        .equ FDCAN2_FDCAN_GFC_ANFS_Shift, 4   @ bitWidth 2 (Accept Non-matching Frames  Standard)  
 
    .equ FDCAN2_FDCAN_SIDFC, FDCAN2_BASE + 0x84 @ (FDCAN Standard ID Filter Configuration  Register) 
        .equ FDCAN2_FDCAN_SIDFC_FLSSA_Shift, 2   @ bitWidth 14 (Filter List Standard Start  Address)  
        .equ FDCAN2_FDCAN_SIDFC_LSS_Shift, 16   @ bitWidth 8 (List Size Standard)  
 
    .equ FDCAN2_FDCAN_XIDFC, FDCAN2_BASE + 0x88 @ (FDCAN Extended ID Filter Configuration  Register) 
        .equ FDCAN2_FDCAN_XIDFC_FLESA_Shift, 2   @ bitWidth 14 (Filter List Standard Start  Address)  
        .equ FDCAN2_FDCAN_XIDFC_LSE_Shift, 16   @ bitWidth 8 (List Size Extended)  
 
    .equ FDCAN2_FDCAN_XIDAM, FDCAN2_BASE + 0x90 @ (FDCAN Extended ID and Mask  Register) 
        .equ FDCAN2_FDCAN_XIDAM_EIDM_Shift, 0   @ bitWidth 29 (Extended ID Mask)  
 
    .equ FDCAN2_FDCAN_HPMS, FDCAN2_BASE + 0x94 @ (FDCAN High Priority Message Status  Register) 
        .equ FDCAN2_FDCAN_HPMS_BIDX_Shift, 0   @ bitWidth 6 (Buffer Index)  
        .equ FDCAN2_FDCAN_HPMS_MSI_Shift, 6   @ bitWidth 2 (Message Storage Indicator)  
        .equ FDCAN2_FDCAN_HPMS_FIDX_Shift, 8   @ bitWidth 7 (Filter Index)  
        .equ FDCAN2_FDCAN_HPMS_FLST, 1 << 15   @ bitWidth 1 (Filter List)  
 
    .equ FDCAN2_FDCAN_NDAT1, FDCAN2_BASE + 0x98 @ (FDCAN New Data 1 Register) 
        .equ FDCAN2_FDCAN_NDAT1_ND0, 1 << 0   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND1, 1 << 1   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND2, 1 << 2   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND3, 1 << 3   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND4, 1 << 4   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND5, 1 << 5   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND6, 1 << 6   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND7, 1 << 7   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND8, 1 << 8   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND9, 1 << 9   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND10, 1 << 10   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND11, 1 << 11   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND12, 1 << 12   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND13, 1 << 13   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND14, 1 << 14   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND15, 1 << 15   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND16, 1 << 16   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND17, 1 << 17   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND18, 1 << 18   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND19, 1 << 19   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND20, 1 << 20   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND21, 1 << 21   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND22, 1 << 22   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND23, 1 << 23   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND24, 1 << 24   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND25, 1 << 25   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND26, 1 << 26   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND27, 1 << 27   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND28, 1 << 28   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND29, 1 << 29   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND30, 1 << 30   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT1_ND31, 1 << 31   @ bitWidth 1 (New data)  
 
    .equ FDCAN2_FDCAN_NDAT2, FDCAN2_BASE + 0x9C @ (FDCAN New Data 2 Register) 
        .equ FDCAN2_FDCAN_NDAT2_ND32, 1 << 0   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND33, 1 << 1   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND34, 1 << 2   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND35, 1 << 3   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND36, 1 << 4   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND37, 1 << 5   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND38, 1 << 6   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND39, 1 << 7   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND40, 1 << 8   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND41, 1 << 9   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND42, 1 << 10   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND43, 1 << 11   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND44, 1 << 12   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND45, 1 << 13   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND46, 1 << 14   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND47, 1 << 15   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND48, 1 << 16   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND49, 1 << 17   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND50, 1 << 18   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND51, 1 << 19   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND52, 1 << 20   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND53, 1 << 21   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND54, 1 << 22   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND55, 1 << 23   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND56, 1 << 24   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND57, 1 << 25   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND58, 1 << 26   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND59, 1 << 27   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND60, 1 << 28   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND61, 1 << 29   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND62, 1 << 30   @ bitWidth 1 (New data)  
        .equ FDCAN2_FDCAN_NDAT2_ND63, 1 << 31   @ bitWidth 1 (New data)  
 
    .equ FDCAN2_FDCAN_RXF0C, FDCAN2_BASE + 0xA0 @ (FDCAN Rx FIFO 0 Configuration  Register) 
        .equ FDCAN2_FDCAN_RXF0C_F0SA_Shift, 2   @ bitWidth 14 (Rx FIFO 0 Start Address)  
        .equ FDCAN2_FDCAN_RXF0C_F0S_Shift, 16   @ bitWidth 8 (Rx FIFO 0 Size)  
        .equ FDCAN2_FDCAN_RXF0C_F0WM_Shift, 24   @ bitWidth 8 (FIFO 0 Watermark)  
 
    .equ FDCAN2_FDCAN_RXF0S, FDCAN2_BASE + 0xA4 @ (FDCAN Rx FIFO 0 Status  Register) 
        .equ FDCAN2_FDCAN_RXF0S_F0FL_Shift, 0   @ bitWidth 7 (Rx FIFO 0 Fill Level)  
        .equ FDCAN2_FDCAN_RXF0S_F0G_Shift, 8   @ bitWidth 6 (Rx FIFO 0 Get Index)  
        .equ FDCAN2_FDCAN_RXF0S_F0P_Shift, 16   @ bitWidth 6 (Rx FIFO 0 Put Index)  
        .equ FDCAN2_FDCAN_RXF0S_F0F, 1 << 24   @ bitWidth 1 (Rx FIFO 0 Full)  
        .equ FDCAN2_FDCAN_RXF0S_RF0L, 1 << 25   @ bitWidth 1 (Rx FIFO 0 Message Lost)  
 
    .equ FDCAN2_FDCAN_RXF0A, FDCAN2_BASE + 0xA8 @ (CAN Rx FIFO 0 Acknowledge  Register) 
        .equ FDCAN2_FDCAN_RXF0A_FA01_Shift, 0   @ bitWidth 6 (Rx FIFO 0 Acknowledge  Index)  
 
    .equ FDCAN2_FDCAN_RXBC, FDCAN2_BASE + 0xAC @ (FDCAN Rx Buffer Configuration  Register) 
        .equ FDCAN2_FDCAN_RXBC_RBSA_Shift, 2   @ bitWidth 14 (Rx Buffer Start Address)  
 
    .equ FDCAN2_FDCAN_RXF1C, FDCAN2_BASE + 0xB0 @ (FDCAN Rx FIFO 1 Configuration  Register) 
        .equ FDCAN2_FDCAN_RXF1C_F1SA_Shift, 2   @ bitWidth 14 (Rx FIFO 1 Start Address)  
        .equ FDCAN2_FDCAN_RXF1C_F1S_Shift, 16   @ bitWidth 7 (Rx FIFO 1 Size)  
        .equ FDCAN2_FDCAN_RXF1C_F1WM_Shift, 24   @ bitWidth 7 (Rx FIFO 1 Watermark)  
 
    .equ FDCAN2_FDCAN_RXF1S, FDCAN2_BASE + 0xB4 @ (FDCAN Rx FIFO 1 Status  Register) 
        .equ FDCAN2_FDCAN_RXF1S_F1FL_Shift, 0   @ bitWidth 7 (Rx FIFO 1 Fill Level)  
        .equ FDCAN2_FDCAN_RXF1S_F1GI_Shift, 8   @ bitWidth 7 (Rx FIFO 1 Get Index)  
        .equ FDCAN2_FDCAN_RXF1S_F1PI_Shift, 16   @ bitWidth 7 (Rx FIFO 1 Put Index)  
        .equ FDCAN2_FDCAN_RXF1S_F1F, 1 << 24   @ bitWidth 1 (Rx FIFO 1 Full)  
        .equ FDCAN2_FDCAN_RXF1S_RF1L, 1 << 25   @ bitWidth 1 (Rx FIFO 1 Message Lost)  
        .equ FDCAN2_FDCAN_RXF1S_DMS_Shift, 30   @ bitWidth 2 (Debug Message Status)  
 
    .equ FDCAN2_FDCAN_RXF1A, FDCAN2_BASE + 0xB8 @ (FDCAN Rx FIFO 1 Acknowledge  Register) 
        .equ FDCAN2_FDCAN_RXF1A_F1AI_Shift, 0   @ bitWidth 6 (Rx FIFO 1 Acknowledge  Index)  
 
    .equ FDCAN2_FDCAN_RXESC, FDCAN2_BASE + 0xBC @ (FDCAN Rx Buffer Element Size Configuration  Register) 
        .equ FDCAN2_FDCAN_RXESC_F0DS_Shift, 0   @ bitWidth 3 (Rx FIFO 1 Data Field Size:)  
        .equ FDCAN2_FDCAN_RXESC_F1DS_Shift, 4   @ bitWidth 3 (Rx FIFO 0 Data Field Size:)  
        .equ FDCAN2_FDCAN_RXESC_RBDS_Shift, 8   @ bitWidth 3 (Rx Buffer Data Field Size:)  
 
    .equ FDCAN2_FDCAN_TXBC, FDCAN2_BASE + 0xC0 @ (FDCAN Tx Buffer Configuration  Register) 
        .equ FDCAN2_FDCAN_TXBC_TBSA_Shift, 2   @ bitWidth 14 (Tx Buffers Start Address)  
        .equ FDCAN2_FDCAN_TXBC_NDTB_Shift, 16   @ bitWidth 6 (Number of Dedicated Transmit  Buffers)  
        .equ FDCAN2_FDCAN_TXBC_TFQS_Shift, 24   @ bitWidth 6 (Transmit FIFO/Queue Size)  
        .equ FDCAN2_FDCAN_TXBC_TFQM, 1 << 30   @ bitWidth 1 (Tx FIFO/Queue Mode)  
 
    .equ FDCAN2_FDCAN_TXFQS, FDCAN2_BASE + 0xC4 @ (FDCAN Tx FIFO/Queue Status  Register) 
        .equ FDCAN2_FDCAN_TXFQS_TFFL_Shift, 0   @ bitWidth 6 (Tx FIFO Free Level)  
        .equ FDCAN2_FDCAN_TXFQS_TFGI_Shift, 8   @ bitWidth 5 (TFGI)  
        .equ FDCAN2_FDCAN_TXFQS_TFQPI_Shift, 16   @ bitWidth 5 (Tx FIFO/Queue Put Index)  
        .equ FDCAN2_FDCAN_TXFQS_TFQF, 1 << 21   @ bitWidth 1 (Tx FIFO/Queue Full)  
 
    .equ FDCAN2_FDCAN_TXESC, FDCAN2_BASE + 0xC8 @ (FDCAN Tx Buffer Element Size Configuration  Register) 
        .equ FDCAN2_FDCAN_TXESC_TBDS_Shift, 0   @ bitWidth 3 (Tx Buffer Data Field Size:)  
 
    .equ FDCAN2_FDCAN_TXBRP, FDCAN2_BASE + 0xCC @ (FDCAN Tx Buffer Request Pending  Register) 
        .equ FDCAN2_FDCAN_TXBRP_TRP_Shift, 0   @ bitWidth 32 (Transmission Request  Pending)  
 
    .equ FDCAN2_FDCAN_TXBAR, FDCAN2_BASE + 0xD0 @ (FDCAN Tx Buffer Add Request  Register) 
        .equ FDCAN2_FDCAN_TXBAR_AR_Shift, 0   @ bitWidth 32 (Add Request)  
 
    .equ FDCAN2_FDCAN_TXBCR, FDCAN2_BASE + 0xD4 @ (FDCAN Tx Buffer Cancellation Request  Register) 
        .equ FDCAN2_FDCAN_TXBCR_CR_Shift, 0   @ bitWidth 32 (Cancellation Request)  
 
    .equ FDCAN2_FDCAN_TXBTO, FDCAN2_BASE + 0xD8 @ (FDCAN Tx Buffer Transmission Occurred  Register) 
        .equ FDCAN2_FDCAN_TXBTO_TO_Shift, 0   @ bitWidth 32 (Transmission Occurred.)  
 
    .equ FDCAN2_FDCAN_TXBCF, FDCAN2_BASE + 0xDC @ (FDCAN Tx Buffer Cancellation Finished  Register) 
        .equ FDCAN2_FDCAN_TXBCF_CF_Shift, 0   @ bitWidth 32 (Cancellation Finished)  
 
    .equ FDCAN2_FDCAN_TXBTIE, FDCAN2_BASE + 0xE0 @ (FDCAN Tx Buffer Transmission Interrupt  Enable Register) 
        .equ FDCAN2_FDCAN_TXBTIE_TIE_Shift, 0   @ bitWidth 32 (Transmission Interrupt  Enable)  
 
    .equ FDCAN2_FDCAN_TXBCIE, FDCAN2_BASE + 0xE4 @ (FDCAN Tx Buffer Cancellation Finished  Interrupt Enable Register) 
        .equ FDCAN2_FDCAN_TXBCIE_CF_Shift, 0   @ bitWidth 32 (Cancellation Finished Interrupt  Enable)  
 
    .equ FDCAN2_FDCAN_TXEFC, FDCAN2_BASE + 0xF0 @ (FDCAN Tx Event FIFO Configuration  Register) 
        .equ FDCAN2_FDCAN_TXEFC_EFSA_Shift, 2   @ bitWidth 14 (Event FIFO Start Address)  
        .equ FDCAN2_FDCAN_TXEFC_EFS_Shift, 16   @ bitWidth 6 (Event FIFO Size)  
        .equ FDCAN2_FDCAN_TXEFC_EFWM_Shift, 24   @ bitWidth 6 (Event FIFO Watermark)  
 
    .equ FDCAN2_FDCAN_TXEFS, FDCAN2_BASE + 0xF4 @ (FDCAN Tx Event FIFO Status  Register) 
        .equ FDCAN2_FDCAN_TXEFS_EFFL_Shift, 0   @ bitWidth 6 (Event FIFO Fill Level)  
        .equ FDCAN2_FDCAN_TXEFS_EFGI_Shift, 8   @ bitWidth 5 (Event FIFO Get Index.)  
        .equ FDCAN2_FDCAN_TXEFS_EFF, 1 << 24   @ bitWidth 1 (Event FIFO Full.)  
        .equ FDCAN2_FDCAN_TXEFS_TEFL, 1 << 25   @ bitWidth 1 (Tx Event FIFO Element  Lost.)  
 
    .equ FDCAN2_FDCAN_TXEFA, FDCAN2_BASE + 0xF8 @ (FDCAN Tx Event FIFO Acknowledge  Register) 
        .equ FDCAN2_FDCAN_TXEFA_EFAI_Shift, 0   @ bitWidth 5 (Event FIFO Acknowledge  Index)  
 
    .equ FDCAN2_FDCAN_TTTMC, FDCAN2_BASE + 0x100 @ (FDCAN TT Trigger Memory Configuration  Register) 
        .equ FDCAN2_FDCAN_TTTMC_TMSA_Shift, 2   @ bitWidth 14 (Trigger Memory Start  Address)  
        .equ FDCAN2_FDCAN_TTTMC_TME_Shift, 16   @ bitWidth 7 (Trigger Memory Elements)  
 
    .equ FDCAN2_FDCAN_TTRMC, FDCAN2_BASE + 0x104 @ (FDCAN TT Reference Message Configuration  Register) 
        .equ FDCAN2_FDCAN_TTRMC_RID_Shift, 0   @ bitWidth 29 (Reference Identifier.)  
        .equ FDCAN2_FDCAN_TTRMC_XTD, 1 << 30   @ bitWidth 1 (Extended Identifier)  
        .equ FDCAN2_FDCAN_TTRMC_RMPS, 1 << 31   @ bitWidth 1 (Reference Message Payload  Select)  
 
    .equ FDCAN2_FDCAN_TTOCF, FDCAN2_BASE + 0x108 @ (FDCAN TT Operation Configuration  Register) 
        .equ FDCAN2_FDCAN_TTOCF_OM_Shift, 0   @ bitWidth 2 (Operation Mode)  
        .equ FDCAN2_FDCAN_TTOCF_GEN, 1 << 3   @ bitWidth 1 (Gap Enable)  
        .equ FDCAN2_FDCAN_TTOCF_TM, 1 << 4   @ bitWidth 1 (Time Master)  
        .equ FDCAN2_FDCAN_TTOCF_LDSDL_Shift, 5   @ bitWidth 3 (LD of Synchronization Deviation  Limit)  
        .equ FDCAN2_FDCAN_TTOCF_IRTO_Shift, 8   @ bitWidth 7 (Initial Reference Trigger  Offset)  
        .equ FDCAN2_FDCAN_TTOCF_EECS, 1 << 15   @ bitWidth 1 (Enable External Clock  Synchronization)  
        .equ FDCAN2_FDCAN_TTOCF_AWL_Shift, 16   @ bitWidth 8 (Application Watchdog Limit)  
        .equ FDCAN2_FDCAN_TTOCF_EGTF, 1 << 24   @ bitWidth 1 (Enable Global Time  Filtering)  
        .equ FDCAN2_FDCAN_TTOCF_ECC, 1 << 25   @ bitWidth 1 (Enable Clock Calibration)  
        .equ FDCAN2_FDCAN_TTOCF_EVTP, 1 << 26   @ bitWidth 1 (Event Trigger Polarity)  
 
    .equ FDCAN2_FDCAN_TTMLM, FDCAN2_BASE + 0x10C @ (FDCAN TT Matrix Limits  Register) 
        .equ FDCAN2_FDCAN_TTMLM_CCM_Shift, 0   @ bitWidth 6 (Cycle Count Max)  
        .equ FDCAN2_FDCAN_TTMLM_CSS_Shift, 6   @ bitWidth 2 (Cycle Start  Synchronization)  
        .equ FDCAN2_FDCAN_TTMLM_TXEW_Shift, 8   @ bitWidth 4 (Tx Enable Window)  
        .equ FDCAN2_FDCAN_TTMLM_ENTT_Shift, 16   @ bitWidth 12 (Expected Number of Tx  Triggers)  
 
    .equ FDCAN2_FDCAN_TURCF, FDCAN2_BASE + 0x110 @ (FDCAN TUR Configuration  Register) 
        .equ FDCAN2_FDCAN_TURCF_NCL_Shift, 0   @ bitWidth 16 (Numerator Configuration  Low.)  
        .equ FDCAN2_FDCAN_TURCF_DC_Shift, 16   @ bitWidth 14 (Denominator Configuration.)  
        .equ FDCAN2_FDCAN_TURCF_ELT, 1 << 31   @ bitWidth 1 (Enable Local Time)  
 
    .equ FDCAN2_FDCAN_TTOCN, FDCAN2_BASE + 0x114 @ (FDCAN TT Operation Control  Register) 
        .equ FDCAN2_FDCAN_TTOCN_SGT, 1 << 0   @ bitWidth 1 (Set Global time)  
        .equ FDCAN2_FDCAN_TTOCN_ECS, 1 << 1   @ bitWidth 1 (External Clock  Synchronization)  
        .equ FDCAN2_FDCAN_TTOCN_SWP, 1 << 2   @ bitWidth 1 (Stop Watch Polarity)  
        .equ FDCAN2_FDCAN_TTOCN_SWS_Shift, 3   @ bitWidth 2 (Stop Watch Source.)  
        .equ FDCAN2_FDCAN_TTOCN_RTIE, 1 << 5   @ bitWidth 1 (Register Time Mark Interrupt Pulse  Enable)  
        .equ FDCAN2_FDCAN_TTOCN_TMC_Shift, 6   @ bitWidth 2 (Register Time Mark Compare)  
        .equ FDCAN2_FDCAN_TTOCN_TTIE, 1 << 8   @ bitWidth 1 (Trigger Time Mark Interrupt Pulse  Enable)  
        .equ FDCAN2_FDCAN_TTOCN_GCS, 1 << 9   @ bitWidth 1 (Gap Control Select)  
        .equ FDCAN2_FDCAN_TTOCN_FGP, 1 << 10   @ bitWidth 1 (Finish Gap.)  
        .equ FDCAN2_FDCAN_TTOCN_TMG, 1 << 11   @ bitWidth 1 (Time Mark Gap)  
        .equ FDCAN2_FDCAN_TTOCN_NIG, 1 << 12   @ bitWidth 1 (Next is Gap)  
        .equ FDCAN2_FDCAN_TTOCN_ESCN, 1 << 13   @ bitWidth 1 (External Synchronization  Control)  
        .equ FDCAN2_FDCAN_TTOCN_LCKC, 1 << 15   @ bitWidth 1 (TT Operation Control Register  Locked)  
 
    .equ FDCAN2_CAN_TTGTP, FDCAN2_BASE + 0x118 @ (FDCAN TT Global Time Preset  Register) 
        .equ FDCAN2_CAN_TTGTP_NCL_Shift, 0   @ bitWidth 16 (Time Preset)  
        .equ FDCAN2_CAN_TTGTP_CTP_Shift, 16   @ bitWidth 16 (Cycle Time Target Phase)  
 
    .equ FDCAN2_FDCAN_TTTMK, FDCAN2_BASE + 0x11C @ (FDCAN TT Time Mark Register) 
        .equ FDCAN2_FDCAN_TTTMK_TM_Shift, 0   @ bitWidth 16 (Time Mark)  
        .equ FDCAN2_FDCAN_TTTMK_TICC_Shift, 16   @ bitWidth 7 (Time Mark Cycle Code)  
        .equ FDCAN2_FDCAN_TTTMK_LCKM, 1 << 31   @ bitWidth 1 (TT Time Mark Register  Locked)  
 
    .equ FDCAN2_FDCAN_TTIR, FDCAN2_BASE + 0x120 @ (FDCAN TT Interrupt Register) 
        .equ FDCAN2_FDCAN_TTIR_SBC, 1 << 0   @ bitWidth 1 (Start of Basic Cycle)  
        .equ FDCAN2_FDCAN_TTIR_SMC, 1 << 1   @ bitWidth 1 (Start of Matrix Cycle)  
        .equ FDCAN2_FDCAN_TTIR_CSM, 1 << 2   @ bitWidth 1 (Change of Synchronization  Mode)  
        .equ FDCAN2_FDCAN_TTIR_SOG, 1 << 3   @ bitWidth 1 (Start of Gap)  
        .equ FDCAN2_FDCAN_TTIR_RTMI, 1 << 4   @ bitWidth 1 (Register Time Mark  Interrupt.)  
        .equ FDCAN2_FDCAN_TTIR_TTMI, 1 << 5   @ bitWidth 1 (Trigger Time Mark Event  Internal)  
        .equ FDCAN2_FDCAN_TTIR_SWE, 1 << 6   @ bitWidth 1 (Stop Watch Event)  
        .equ FDCAN2_FDCAN_TTIR_GTW, 1 << 7   @ bitWidth 1 (Global Time Wrap)  
        .equ FDCAN2_FDCAN_TTIR_GTD, 1 << 8   @ bitWidth 1 (Global Time Discontinuity)  
        .equ FDCAN2_FDCAN_TTIR_GTE, 1 << 9   @ bitWidth 1 (Global Time Error)  
        .equ FDCAN2_FDCAN_TTIR_TXU, 1 << 10   @ bitWidth 1 (Tx Count Underflow)  
        .equ FDCAN2_FDCAN_TTIR_TXO, 1 << 11   @ bitWidth 1 (Tx Count Overflow)  
        .equ FDCAN2_FDCAN_TTIR_SE1, 1 << 12   @ bitWidth 1 (Scheduling Error 1)  
        .equ FDCAN2_FDCAN_TTIR_SE2, 1 << 13   @ bitWidth 1 (Scheduling Error 2)  
        .equ FDCAN2_FDCAN_TTIR_ELC, 1 << 14   @ bitWidth 1 (Error Level Changed.)  
        .equ FDCAN2_FDCAN_TTIR_IWTG, 1 << 15   @ bitWidth 1 (Initialization Watch  Trigger)  
        .equ FDCAN2_FDCAN_TTIR_WT, 1 << 16   @ bitWidth 1 (Watch Trigger)  
        .equ FDCAN2_FDCAN_TTIR_AW, 1 << 17   @ bitWidth 1 (Application Watchdog)  
        .equ FDCAN2_FDCAN_TTIR_CER, 1 << 18   @ bitWidth 1 (Configuration Error)  
 
    .equ FDCAN2_FDCAN_TTIE, FDCAN2_BASE + 0x124 @ (FDCAN TT Interrupt Enable  Register) 
        .equ FDCAN2_FDCAN_TTIE_SBCE, 1 << 0   @ bitWidth 1 (Start of Basic Cycle Interrupt  Enable)  
        .equ FDCAN2_FDCAN_TTIE_SMCE, 1 << 1   @ bitWidth 1 (Start of Matrix Cycle Interrupt  Enable)  
        .equ FDCAN2_FDCAN_TTIE_CSME, 1 << 2   @ bitWidth 1 (Change of Synchronization Mode Interrupt  Enable)  
        .equ FDCAN2_FDCAN_TTIE_SOGE, 1 << 3   @ bitWidth 1 (Start of Gap Interrupt  Enable)  
        .equ FDCAN2_FDCAN_TTIE_RTMIE, 1 << 4   @ bitWidth 1 (Register Time Mark Interrupt  Enable)  
        .equ FDCAN2_FDCAN_TTIE_TTMIE, 1 << 5   @ bitWidth 1 (Trigger Time Mark Event Internal  Interrupt Enable)  
        .equ FDCAN2_FDCAN_TTIE_SWEE, 1 << 6   @ bitWidth 1 (Stop Watch Event Interrupt  Enable)  
        .equ FDCAN2_FDCAN_TTIE_GTWE, 1 << 7   @ bitWidth 1 (Global Time Wrap Interrupt  Enable)  
        .equ FDCAN2_FDCAN_TTIE_GTDE, 1 << 8   @ bitWidth 1 (Global Time Discontinuity Interrupt  Enable)  
        .equ FDCAN2_FDCAN_TTIE_GTEE, 1 << 9   @ bitWidth 1 (Global Time Error Interrupt  Enable)  
        .equ FDCAN2_FDCAN_TTIE_TXUE, 1 << 10   @ bitWidth 1 (Tx Count Underflow Interrupt  Enable)  
        .equ FDCAN2_FDCAN_TTIE_TXOE, 1 << 11   @ bitWidth 1 (Tx Count Overflow Interrupt  Enable)  
        .equ FDCAN2_FDCAN_TTIE_SE1E, 1 << 12   @ bitWidth 1 (Scheduling Error 1 Interrupt  Enable)  
        .equ FDCAN2_FDCAN_TTIE_SE2E, 1 << 13   @ bitWidth 1 (Scheduling Error 2 Interrupt  Enable)  
        .equ FDCAN2_FDCAN_TTIE_ELCE, 1 << 14   @ bitWidth 1 (Change Error Level Interrupt  Enable)  
        .equ FDCAN2_FDCAN_TTIE_IWTGE, 1 << 15   @ bitWidth 1 (Initialization Watch Trigger Interrupt  Enable)  
        .equ FDCAN2_FDCAN_TTIE_WTE, 1 << 16   @ bitWidth 1 (Watch Trigger Interrupt  Enable)  
        .equ FDCAN2_FDCAN_TTIE_AWE, 1 << 17   @ bitWidth 1 (Application Watchdog Interrupt  Enable)  
        .equ FDCAN2_FDCAN_TTIE_CERE, 1 << 18   @ bitWidth 1 (Configuration Error Interrupt  Enable)  
 
    .equ FDCAN2_FDCAN_TTILS, FDCAN2_BASE + 0x128 @ (FDCAN TT Interrupt Line Select  Register) 
        .equ FDCAN2_FDCAN_TTILS_SBCL, 1 << 0   @ bitWidth 1 (Start of Basic Cycle Interrupt  Line)  
        .equ FDCAN2_FDCAN_TTILS_SMCL, 1 << 1   @ bitWidth 1 (Start of Matrix Cycle Interrupt  Line)  
        .equ FDCAN2_FDCAN_TTILS_CSML, 1 << 2   @ bitWidth 1 (Change of Synchronization Mode Interrupt  Line)  
        .equ FDCAN2_FDCAN_TTILS_SOGL, 1 << 3   @ bitWidth 1 (Start of Gap Interrupt  Line)  
        .equ FDCAN2_FDCAN_TTILS_RTMIL, 1 << 4   @ bitWidth 1 (Register Time Mark Interrupt  Line)  
        .equ FDCAN2_FDCAN_TTILS_TTMIL, 1 << 5   @ bitWidth 1 (Trigger Time Mark Event Internal  Interrupt Line)  
        .equ FDCAN2_FDCAN_TTILS_SWEL, 1 << 6   @ bitWidth 1 (Stop Watch Event Interrupt  Line)  
        .equ FDCAN2_FDCAN_TTILS_GTWL, 1 << 7   @ bitWidth 1 (Global Time Wrap Interrupt  Line)  
        .equ FDCAN2_FDCAN_TTILS_GTDL, 1 << 8   @ bitWidth 1 (Global Time Discontinuity Interrupt  Line)  
        .equ FDCAN2_FDCAN_TTILS_GTEL, 1 << 9   @ bitWidth 1 (Global Time Error Interrupt  Line)  
        .equ FDCAN2_FDCAN_TTILS_TXUL, 1 << 10   @ bitWidth 1 (Tx Count Underflow Interrupt  Line)  
        .equ FDCAN2_FDCAN_TTILS_TXOL, 1 << 11   @ bitWidth 1 (Tx Count Overflow Interrupt  Line)  
        .equ FDCAN2_FDCAN_TTILS_SE1L, 1 << 12   @ bitWidth 1 (Scheduling Error 1 Interrupt  Line)  
        .equ FDCAN2_FDCAN_TTILS_SE2L, 1 << 13   @ bitWidth 1 (Scheduling Error 2 Interrupt  Line)  
        .equ FDCAN2_FDCAN_TTILS_ELCL, 1 << 14   @ bitWidth 1 (Change Error Level Interrupt  Line)  
        .equ FDCAN2_FDCAN_TTILS_IWTGL, 1 << 15   @ bitWidth 1 (Initialization Watch Trigger Interrupt  Line)  
        .equ FDCAN2_FDCAN_TTILS_WTL, 1 << 16   @ bitWidth 1 (Watch Trigger Interrupt  Line)  
        .equ FDCAN2_FDCAN_TTILS_AWL, 1 << 17   @ bitWidth 1 (Application Watchdog Interrupt  Line)  
        .equ FDCAN2_FDCAN_TTILS_CERL, 1 << 18   @ bitWidth 1 (Configuration Error Interrupt  Line)  
 
    .equ FDCAN2_FDCAN_TTOST, FDCAN2_BASE + 0x12C @ (FDCAN TT Operation Status  Register) 
        .equ FDCAN2_FDCAN_TTOST_EL_Shift, 0   @ bitWidth 2 (Error Level)  
        .equ FDCAN2_FDCAN_TTOST_MS_Shift, 2   @ bitWidth 2 (Master State.)  
        .equ FDCAN2_FDCAN_TTOST_SYS_Shift, 4   @ bitWidth 2 (Synchronization State)  
        .equ FDCAN2_FDCAN_TTOST_GTP, 1 << 6   @ bitWidth 1 (Quality of Global Time  Phase)  
        .equ FDCAN2_FDCAN_TTOST_QCS, 1 << 7   @ bitWidth 1 (Quality of Clock Speed)  
        .equ FDCAN2_FDCAN_TTOST_RTO_Shift, 8   @ bitWidth 8 (Reference Trigger Offset)  
        .equ FDCAN2_FDCAN_TTOST_WGTD, 1 << 22   @ bitWidth 1 (Wait for Global Time  Discontinuity)  
        .equ FDCAN2_FDCAN_TTOST_GFI, 1 << 23   @ bitWidth 1 (Gap Finished Indicator.)  
        .equ FDCAN2_FDCAN_TTOST_TMP_Shift, 24   @ bitWidth 3 (Time Master Priority)  
        .equ FDCAN2_FDCAN_TTOST_GSI, 1 << 27   @ bitWidth 1 (Gap Started Indicator.)  
        .equ FDCAN2_FDCAN_TTOST_WFE, 1 << 28   @ bitWidth 1 (Wait for Event)  
        .equ FDCAN2_FDCAN_TTOST_AWE, 1 << 29   @ bitWidth 1 (Application Watchdog Event)  
        .equ FDCAN2_FDCAN_TTOST_WECS, 1 << 30   @ bitWidth 1 (Wait for External Clock  Synchronization)  
        .equ FDCAN2_FDCAN_TTOST_SPL, 1 << 31   @ bitWidth 1 (Schedule Phase Lock)  
 
    .equ FDCAN2_FDCAN_TURNA, FDCAN2_BASE + 0x130 @ (FDCAN TUR Numerator Actual  Register) 
        .equ FDCAN2_FDCAN_TURNA_NAV_Shift, 0   @ bitWidth 18 (Numerator Actual Value)  
 
    .equ FDCAN2_FDCAN_TTLGT, FDCAN2_BASE + 0x134 @ (FDCAN TT Local and Global Time  Register) 
        .equ FDCAN2_FDCAN_TTLGT_LT_Shift, 0   @ bitWidth 16 (Local Time)  
        .equ FDCAN2_FDCAN_TTLGT_GT_Shift, 16   @ bitWidth 16 (Global Time)  
 
    .equ FDCAN2_FDCAN_TTCTC, FDCAN2_BASE + 0x138 @ (FDCAN TT Cycle Time and Count  Register) 
        .equ FDCAN2_FDCAN_TTCTC_CT_Shift, 0   @ bitWidth 16 (Cycle Time)  
        .equ FDCAN2_FDCAN_TTCTC_CC_Shift, 16   @ bitWidth 6 (Cycle Count)  
 
    .equ FDCAN2_FDCAN_TTCPT, FDCAN2_BASE + 0x13C @ (FDCAN TT Capture Time Register) 
        .equ FDCAN2_FDCAN_TTCPT_CT_Shift, 0   @ bitWidth 6 (Cycle Count Value)  
        .equ FDCAN2_FDCAN_TTCPT_SWV_Shift, 16   @ bitWidth 16 (Stop Watch Value)  
 
    .equ FDCAN2_FDCAN_TTCSM, FDCAN2_BASE + 0x140 @ (FDCAN TT Cycle Sync Mark  Register) 
        .equ FDCAN2_FDCAN_TTCSM_CSM_Shift, 0   @ bitWidth 16 (Cycle Sync Mark)  
 
    .equ FDCAN2_FDCAN_TTTS, FDCAN2_BASE + 0x300 @ (FDCAN TT Trigger Select  Register) 
        .equ FDCAN2_FDCAN_TTTS_SWTDEL_Shift, 0   @ bitWidth 2 (Stop watch trigger input  selection)  
        .equ FDCAN2_FDCAN_TTTS_EVTSEL_Shift, 4   @ bitWidth 2 (Event trigger input  selection)  
 

@=========================== CAN_CCU ===========================@
.equ CAN_CCU_BASE, 0x4000A800 @ (CCU registers) 
    .equ CAN_CCU_CREL, CAN_CCU_BASE + 0x0 @ (Clock Calibration Unit Core Release  Register) 
        .equ CAN_CCU_CREL_DAY_Shift, 0   @ bitWidth 8 (Time Stamp Day)  
        .equ CAN_CCU_CREL_MON_Shift, 8   @ bitWidth 8 (Time Stamp Month)  
        .equ CAN_CCU_CREL_YEAR_Shift, 16   @ bitWidth 4 (Time Stamp Year)  
        .equ CAN_CCU_CREL_SUBSTEP_Shift, 20   @ bitWidth 4 (Sub-step of Core Release)  
        .equ CAN_CCU_CREL_STEP_Shift, 24   @ bitWidth 4 (Step of Core Release)  
        .equ CAN_CCU_CREL_REL_Shift, 28   @ bitWidth 4 (Core Release)  
 
    .equ CAN_CCU_CCFG, CAN_CCU_BASE + 0x4 @ (Calibration Configuration  Register) 
        .equ CAN_CCU_CCFG_TQBT_Shift, 0   @ bitWidth 5 (Time Quanta per Bit Time)  
        .equ CAN_CCU_CCFG_BCC, 1 << 6   @ bitWidth 1 (Bypass Clock Calibration)  
        .equ CAN_CCU_CCFG_CFL, 1 << 7   @ bitWidth 1 (Calibration Field Length)  
        .equ CAN_CCU_CCFG_OCPM_Shift, 8   @ bitWidth 8 (Oscillator Clock Periods  Minimum)  
        .equ CAN_CCU_CCFG_CDIV_Shift, 16   @ bitWidth 4 (Clock Divider)  
        .equ CAN_CCU_CCFG_SWR, 1 << 31   @ bitWidth 1 (Software Reset)  
 
    .equ CAN_CCU_CSTAT, CAN_CCU_BASE + 0x8 @ (Calibration Status Register) 
        .equ CAN_CCU_CSTAT_OCPC_Shift, 0   @ bitWidth 18 (Oscillator Clock Period  Counter)  
        .equ CAN_CCU_CSTAT_TQC_Shift, 18   @ bitWidth 11 (Time Quanta Counter)  
        .equ CAN_CCU_CSTAT_CALS_Shift, 30   @ bitWidth 2 (Calibration State)  
 
    .equ CAN_CCU_CWD, CAN_CCU_BASE + 0xC @ (Calibration Watchdog Register) 
        .equ CAN_CCU_CWD_WDC_Shift, 0   @ bitWidth 16 (WDC)  
        .equ CAN_CCU_CWD_WDV_Shift, 16   @ bitWidth 16 (WDV)  
 
    .equ CAN_CCU_IR, CAN_CCU_BASE + 0x10 @ (Clock Calibration Unit Interrupt  Register) 
        .equ CAN_CCU_IR_CWE, 1 << 0   @ bitWidth 1 (Calibration Watchdog Event)  
        .equ CAN_CCU_IR_CSC, 1 << 1   @ bitWidth 1 (Calibration State Changed)  
 
    .equ CAN_CCU_IE, CAN_CCU_BASE + 0x14 @ (Clock Calibration Unit Interrupt Enable  Register) 
        .equ CAN_CCU_IE_CWEE, 1 << 0   @ bitWidth 1 (Calibration Watchdog Event  Enable)  
        .equ CAN_CCU_IE_CSCE, 1 << 1   @ bitWidth 1 (Calibration State Changed  Enable)  
 

@=========================== MDIOS ===========================@
.equ MDIOS_BASE, 0x40009400 @ (Management data input/output slave) 
    .equ MDIOS_CR, MDIOS_BASE + 0x0 @ (MDIOS configuration register) 
        .equ MDIOS_CR_EN, 1 << 0   @ bitWidth 1 (Peripheral enable)  
        .equ MDIOS_CR_WRIE, 1 << 1   @ bitWidth 1 (Register write interrupt  enable)  
        .equ MDIOS_CR_RDIE, 1 << 2   @ bitWidth 1 (Register Read Interrupt  Enable)  
        .equ MDIOS_CR_EIE, 1 << 3   @ bitWidth 1 (Error interrupt enable)  
        .equ MDIOS_CR_DPC, 1 << 7   @ bitWidth 1 (Disable Preamble Check)  
        .equ MDIOS_CR_PORT_ADDRESS_Shift, 8   @ bitWidth 5 (Slaves's address)  
 
    .equ MDIOS_WRFR, MDIOS_BASE + 0x4 @ (MDIOS write flag register) 
        .equ MDIOS_WRFR_WRF_Shift, 0   @ bitWidth 32 (Write flags for MDIO registers 0 to  31)  
 
    .equ MDIOS_CWRFR, MDIOS_BASE + 0x8 @ (MDIOS clear write flag  register) 
        .equ MDIOS_CWRFR_CWRF_Shift, 0   @ bitWidth 32 (Clear the write flag)  
 
    .equ MDIOS_RDFR, MDIOS_BASE + 0xC @ (MDIOS read flag register) 
        .equ MDIOS_RDFR_RDF_Shift, 0   @ bitWidth 32 (Read flags for MDIO registers 0 to  31)  
 
    .equ MDIOS_CRDFR, MDIOS_BASE + 0x10 @ (MDIOS clear read flag register) 
        .equ MDIOS_CRDFR_CRDF_Shift, 0   @ bitWidth 32 (Clear the read flag)  
 
    .equ MDIOS_SR, MDIOS_BASE + 0x14 @ (MDIOS status register) 
        .equ MDIOS_SR_PERF, 1 << 0   @ bitWidth 1 (Preamble error flag)  
        .equ MDIOS_SR_SERF, 1 << 1   @ bitWidth 1 (Start error flag)  
        .equ MDIOS_SR_TERF, 1 << 2   @ bitWidth 1 (Turnaround error flag)  
 
    .equ MDIOS_CLRFR, MDIOS_BASE + 0x18 @ (MDIOS clear flag register) 
        .equ MDIOS_CLRFR_CPERF, 1 << 0   @ bitWidth 1 (Clear the preamble error  flag)  
        .equ MDIOS_CLRFR_CSERF, 1 << 1   @ bitWidth 1 (Clear the start error flag)  
        .equ MDIOS_CLRFR_CTERF, 1 << 2   @ bitWidth 1 (Clear the turnaround error  flag)  
 
    .equ MDIOS_DINR0, MDIOS_BASE + 0x1C @ (MDIOS input data register 0) 
        .equ MDIOS_DINR0_DIN0_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR1, MDIOS_BASE + 0x20 @ (MDIOS input data register 1) 
        .equ MDIOS_DINR1_DIN1_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR2, MDIOS_BASE + 0x24 @ (MDIOS input data register 2) 
        .equ MDIOS_DINR2_DIN2_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR3, MDIOS_BASE + 0x28 @ (MDIOS input data register 3) 
        .equ MDIOS_DINR3_DIN3_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR4, MDIOS_BASE + 0x2C @ (MDIOS input data register 4) 
        .equ MDIOS_DINR4_DIN4_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR5, MDIOS_BASE + 0x30 @ (MDIOS input data register 5) 
        .equ MDIOS_DINR5_DIN5_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR6, MDIOS_BASE + 0x34 @ (MDIOS input data register 6) 
        .equ MDIOS_DINR6_DIN6_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR7, MDIOS_BASE + 0x38 @ (MDIOS input data register 7) 
        .equ MDIOS_DINR7_DIN7_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR8, MDIOS_BASE + 0x3C @ (MDIOS input data register 8) 
        .equ MDIOS_DINR8_DIN8_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR9, MDIOS_BASE + 0x40 @ (MDIOS input data register 9) 
        .equ MDIOS_DINR9_DIN9_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR10, MDIOS_BASE + 0x44 @ (MDIOS input data register 10) 
        .equ MDIOS_DINR10_DIN10_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR11, MDIOS_BASE + 0x48 @ (MDIOS input data register 11) 
        .equ MDIOS_DINR11_DIN11_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR12, MDIOS_BASE + 0x4C @ (MDIOS input data register 12) 
        .equ MDIOS_DINR12_DIN12_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR13, MDIOS_BASE + 0x50 @ (MDIOS input data register 13) 
        .equ MDIOS_DINR13_DIN13_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR14, MDIOS_BASE + 0x54 @ (MDIOS input data register 14) 
        .equ MDIOS_DINR14_DIN14_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR15, MDIOS_BASE + 0x58 @ (MDIOS input data register 15) 
        .equ MDIOS_DINR15_DIN15_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR16, MDIOS_BASE + 0x5C @ (MDIOS input data register 16) 
        .equ MDIOS_DINR16_DIN16_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR17, MDIOS_BASE + 0x60 @ (MDIOS input data register 17) 
        .equ MDIOS_DINR17_DIN17_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR18, MDIOS_BASE + 0x64 @ (MDIOS input data register 18) 
        .equ MDIOS_DINR18_DIN18_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR19, MDIOS_BASE + 0x68 @ (MDIOS input data register 19) 
        .equ MDIOS_DINR19_DIN19_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR20, MDIOS_BASE + 0x6C @ (MDIOS input data register 20) 
        .equ MDIOS_DINR20_DIN20_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR21, MDIOS_BASE + 0x70 @ (MDIOS input data register 21) 
        .equ MDIOS_DINR21_DIN21_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR22, MDIOS_BASE + 0x74 @ (MDIOS input data register 22) 
        .equ MDIOS_DINR22_DIN22_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR23, MDIOS_BASE + 0x78 @ (MDIOS input data register 23) 
        .equ MDIOS_DINR23_DIN23_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR24, MDIOS_BASE + 0x7C @ (MDIOS input data register 24) 
        .equ MDIOS_DINR24_DIN24_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR25, MDIOS_BASE + 0x80 @ (MDIOS input data register 25) 
        .equ MDIOS_DINR25_DIN25_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR26, MDIOS_BASE + 0x84 @ (MDIOS input data register 26) 
        .equ MDIOS_DINR26_DIN26_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR27, MDIOS_BASE + 0x88 @ (MDIOS input data register 27) 
        .equ MDIOS_DINR27_DIN27_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR28, MDIOS_BASE + 0x8C @ (MDIOS input data register 28) 
        .equ MDIOS_DINR28_DIN28_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR29, MDIOS_BASE + 0x90 @ (MDIOS input data register 29) 
        .equ MDIOS_DINR29_DIN29_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR30, MDIOS_BASE + 0x94 @ (MDIOS input data register 30) 
        .equ MDIOS_DINR30_DIN30_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DINR31, MDIOS_BASE + 0x98 @ (MDIOS input data register 31) 
        .equ MDIOS_DINR31_DIN31_Shift, 0   @ bitWidth 16 (Input data received from MDIO Master  during write frames)  
 
    .equ MDIOS_DOUTR0, MDIOS_BASE + 0x9C @ (MDIOS output data register 0) 
        .equ MDIOS_DOUTR0_DOUT0_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR1, MDIOS_BASE + 0xA0 @ (MDIOS output data register 1) 
        .equ MDIOS_DOUTR1_DOUT1_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR2, MDIOS_BASE + 0xA4 @ (MDIOS output data register 2) 
        .equ MDIOS_DOUTR2_DOUT2_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR3, MDIOS_BASE + 0xA8 @ (MDIOS output data register 3) 
        .equ MDIOS_DOUTR3_DOUT3_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR4, MDIOS_BASE + 0xAC @ (MDIOS output data register 4) 
        .equ MDIOS_DOUTR4_DOUT4_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR5, MDIOS_BASE + 0xB0 @ (MDIOS output data register 5) 
        .equ MDIOS_DOUTR5_DOUT5_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR6, MDIOS_BASE + 0xB4 @ (MDIOS output data register 6) 
        .equ MDIOS_DOUTR6_DOUT6_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR7, MDIOS_BASE + 0xB8 @ (MDIOS output data register 7) 
        .equ MDIOS_DOUTR7_DOUT7_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR8, MDIOS_BASE + 0xBC @ (MDIOS output data register 8) 
        .equ MDIOS_DOUTR8_DOUT8_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR9, MDIOS_BASE + 0xC0 @ (MDIOS output data register 9) 
        .equ MDIOS_DOUTR9_DOUT9_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR10, MDIOS_BASE + 0xC4 @ (MDIOS output data register 10) 
        .equ MDIOS_DOUTR10_DOUT10_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR11, MDIOS_BASE + 0xC8 @ (MDIOS output data register 11) 
        .equ MDIOS_DOUTR11_DOUT11_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR12, MDIOS_BASE + 0xCC @ (MDIOS output data register 12) 
        .equ MDIOS_DOUTR12_DOUT12_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR13, MDIOS_BASE + 0xD0 @ (MDIOS output data register 13) 
        .equ MDIOS_DOUTR13_DOUT13_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR14, MDIOS_BASE + 0xD4 @ (MDIOS output data register 14) 
        .equ MDIOS_DOUTR14_DOUT14_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR15, MDIOS_BASE + 0xD8 @ (MDIOS output data register 15) 
        .equ MDIOS_DOUTR15_DOUT15_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR16, MDIOS_BASE + 0xDC @ (MDIOS output data register 16) 
        .equ MDIOS_DOUTR16_DOUT16_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR17, MDIOS_BASE + 0xE0 @ (MDIOS output data register 17) 
        .equ MDIOS_DOUTR17_DOUT17_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR18, MDIOS_BASE + 0xE4 @ (MDIOS output data register 18) 
        .equ MDIOS_DOUTR18_DOUT18_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR19, MDIOS_BASE + 0xE8 @ (MDIOS output data register 19) 
        .equ MDIOS_DOUTR19_DOUT19_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR20, MDIOS_BASE + 0xEC @ (MDIOS output data register 20) 
        .equ MDIOS_DOUTR20_DOUT20_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR21, MDIOS_BASE + 0xF0 @ (MDIOS output data register 21) 
        .equ MDIOS_DOUTR21_DOUT21_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR22, MDIOS_BASE + 0xF4 @ (MDIOS output data register 22) 
        .equ MDIOS_DOUTR22_DOUT22_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR23, MDIOS_BASE + 0xF8 @ (MDIOS output data register 23) 
        .equ MDIOS_DOUTR23_DOUT23_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR24, MDIOS_BASE + 0xFC @ (MDIOS output data register 24) 
        .equ MDIOS_DOUTR24_DOUT24_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR25, MDIOS_BASE + 0x100 @ (MDIOS output data register 25) 
        .equ MDIOS_DOUTR25_DOUT25_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR26, MDIOS_BASE + 0x104 @ (MDIOS output data register 26) 
        .equ MDIOS_DOUTR26_DOUT26_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR27, MDIOS_BASE + 0x108 @ (MDIOS output data register 27) 
        .equ MDIOS_DOUTR27_DOUT27_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR28, MDIOS_BASE + 0x10C @ (MDIOS output data register 28) 
        .equ MDIOS_DOUTR28_DOUT28_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR29, MDIOS_BASE + 0x110 @ (MDIOS output data register 29) 
        .equ MDIOS_DOUTR29_DOUT29_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR30, MDIOS_BASE + 0x114 @ (MDIOS output data register 30) 
        .equ MDIOS_DOUTR30_DOUT30_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 
    .equ MDIOS_DOUTR31, MDIOS_BASE + 0x118 @ (MDIOS output data register 31) 
        .equ MDIOS_DOUTR31_DOUT31_Shift, 0   @ bitWidth 16 (Output data sent to MDIO Master during  read frames)  
 

@=========================== OPAMP ===========================@
.equ OPAMP_BASE, 0x40009000 @ (Operational amplifiers) 
    .equ OPAMP_OPAMP1_CSR, OPAMP_BASE + 0x0 @ (OPAMP1 control/status register) 
        .equ OPAMP_OPAMP1_CSR_OPAEN, 1 << 0   @ bitWidth 1 (Operational amplifier  Enable)  
        .equ OPAMP_OPAMP1_CSR_FORCE_VP, 1 << 1   @ bitWidth 1 (Force internal reference on VP reserved  for test)  
        .equ OPAMP_OPAMP1_CSR_VP_SEL_Shift, 2   @ bitWidth 2 (Operational amplifier PGA  mode)  
        .equ OPAMP_OPAMP1_CSR_VM_SEL_Shift, 5   @ bitWidth 2 (Inverting input selection)  
        .equ OPAMP_OPAMP1_CSR_OPAHSM, 1 << 8   @ bitWidth 1 (Operational amplifier high-speed  mode)  
        .equ OPAMP_OPAMP1_CSR_CALON, 1 << 11   @ bitWidth 1 (Calibration mode enabled)  
        .equ OPAMP_OPAMP1_CSR_CALSEL_Shift, 12   @ bitWidth 2 (Calibration selection)  
        .equ OPAMP_OPAMP1_CSR_PGA_GAIN_Shift, 14   @ bitWidth 4 (allows to switch from AOP offset trimmed  values to AOP offset)  
        .equ OPAMP_OPAMP1_CSR_USERTRIM, 1 << 18   @ bitWidth 1 (User trimming enable)  
        .equ OPAMP_OPAMP1_CSR_TSTREF, 1 << 29   @ bitWidth 1 (OPAMP calibration reference voltage  output control reserved for test)  
        .equ OPAMP_OPAMP1_CSR_CALOUT, 1 << 30   @ bitWidth 1 (Operational amplifier calibration  output)  
 
    .equ OPAMP_OPAMP1_OTR, OPAMP_BASE + 0x4 @ (OPAMP1 offset trimming register in normal  mode) 
        .equ OPAMP_OPAMP1_OTR_TRIMOFFSETN_Shift, 0   @ bitWidth 5 (Trim for NMOS differential  pairs)  
        .equ OPAMP_OPAMP1_OTR_TRIMOFFSETP_Shift, 8   @ bitWidth 5 (Trim for PMOS differential  pairs)  
 
    .equ OPAMP_OPAMP1_HSOTR, OPAMP_BASE + 0x8 @ (OPAMP1 offset trimming register in low-power  mode) 
        .equ OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETN_Shift, 0   @ bitWidth 5 (Trim for NMOS differential  pairs)  
        .equ OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETP_Shift, 8   @ bitWidth 5 (Trim for PMOS differential  pairs)  
 
    .equ OPAMP_OPAMP2_CSR, OPAMP_BASE + 0x10 @ (OPAMP2 control/status register) 
        .equ OPAMP_OPAMP2_CSR_OPAEN, 1 << 0   @ bitWidth 1 (Operational amplifier  Enable)  
        .equ OPAMP_OPAMP2_CSR_FORCE_VP, 1 << 1   @ bitWidth 1 (Force internal reference on VP reserved  for test)  
        .equ OPAMP_OPAMP2_CSR_VM_SEL_Shift, 5   @ bitWidth 2 (Inverting input selection)  
        .equ OPAMP_OPAMP2_CSR_OPAHSM, 1 << 8   @ bitWidth 1 (Operational amplifier high-speed  mode)  
        .equ OPAMP_OPAMP2_CSR_CALON, 1 << 11   @ bitWidth 1 (Calibration mode enabled)  
        .equ OPAMP_OPAMP2_CSR_CALSEL_Shift, 12   @ bitWidth 2 (Calibration selection)  
        .equ OPAMP_OPAMP2_CSR_PGA_GAIN_Shift, 14   @ bitWidth 4 (Operational amplifier Programmable  amplifier gain value)  
        .equ OPAMP_OPAMP2_CSR_USERTRIM, 1 << 18   @ bitWidth 1 (User trimming enable)  
        .equ OPAMP_OPAMP2_CSR_TSTREF, 1 << 29   @ bitWidth 1 (OPAMP calibration reference voltage  output control reserved for test)  
        .equ OPAMP_OPAMP2_CSR_CALOUT, 1 << 30   @ bitWidth 1 (Operational amplifier calibration  output)  
 
    .equ OPAMP_OPAMP2_OTR, OPAMP_BASE + 0x14 @ (OPAMP2 offset trimming register in normal  mode) 
        .equ OPAMP_OPAMP2_OTR_TRIMOFFSETN_Shift, 0   @ bitWidth 5 (Trim for NMOS differential  pairs)  
        .equ OPAMP_OPAMP2_OTR_TRIMOFFSETP_Shift, 8   @ bitWidth 5 (Trim for PMOS differential  pairs)  
 
    .equ OPAMP_OPAMP2_HSOTR, OPAMP_BASE + 0x18 @ (OPAMP2 offset trimming register in low-power  mode) 
        .equ OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETN_Shift, 0   @ bitWidth 5 (Trim for NMOS differential  pairs)  
        .equ OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETP_Shift, 8   @ bitWidth 5 (Trim for PMOS differential  pairs)  
 

@=========================== SWPMI ===========================@
.equ SWPMI_BASE, 0x40008800 @ (Single Wire Protocol Master  Interface) 
    .equ SWPMI_CR, SWPMI_BASE + 0x0 @ (SWPMI Configuration/Control  register) 
        .equ SWPMI_CR_RXDMA, 1 << 0   @ bitWidth 1 (Reception DMA enable)  
        .equ SWPMI_CR_TXDMA, 1 << 1   @ bitWidth 1 (Transmission DMA enable)  
        .equ SWPMI_CR_RXMODE, 1 << 2   @ bitWidth 1 (Reception buffering mode)  
        .equ SWPMI_CR_TXMODE, 1 << 3   @ bitWidth 1 (Transmission buffering  mode)  
        .equ SWPMI_CR_LPBK, 1 << 4   @ bitWidth 1 (Loopback mode enable)  
        .equ SWPMI_CR_SWPACT, 1 << 5   @ bitWidth 1 (Single wire protocol master interface  activate)  
        .equ SWPMI_CR_DEACT, 1 << 10   @ bitWidth 1 (Single wire protocol master interface  deactivate)  
        .equ SWPMI_CR_SWPTEN, 1 << 11   @ bitWidth 1 (Single wire protocol master transceiver  enable)  
 
    .equ SWPMI_BRR, SWPMI_BASE + 0x4 @ (SWPMI Bitrate register) 
        .equ SWPMI_BRR_BR_Shift, 0   @ bitWidth 8 (Bitrate prescaler)  
 
    .equ SWPMI_ISR, SWPMI_BASE + 0xC @ (SWPMI Interrupt and Status  register) 
        .equ SWPMI_ISR_RXBFF, 1 << 0   @ bitWidth 1 (Receive buffer full flag)  
        .equ SWPMI_ISR_TXBEF, 1 << 1   @ bitWidth 1 (Transmit buffer empty flag)  
        .equ SWPMI_ISR_RXBERF, 1 << 2   @ bitWidth 1 (Receive CRC error flag)  
        .equ SWPMI_ISR_RXOVRF, 1 << 3   @ bitWidth 1 (Receive overrun error flag)  
        .equ SWPMI_ISR_TXUNRF, 1 << 4   @ bitWidth 1 (Transmit underrun error  flag)  
        .equ SWPMI_ISR_RXNE, 1 << 5   @ bitWidth 1 (Receive data register not  empty)  
        .equ SWPMI_ISR_TXE, 1 << 6   @ bitWidth 1 (Transmit data register  empty)  
        .equ SWPMI_ISR_TCF, 1 << 7   @ bitWidth 1 (Transfer complete flag)  
        .equ SWPMI_ISR_SRF, 1 << 8   @ bitWidth 1 (Slave resume flag)  
        .equ SWPMI_ISR_SUSP, 1 << 9   @ bitWidth 1 (SUSPEND flag)  
        .equ SWPMI_ISR_DEACTF, 1 << 10   @ bitWidth 1 (DEACTIVATED flag)  
        .equ SWPMI_ISR_RDYF, 1 << 11   @ bitWidth 1 (transceiver ready flag)  
 
    .equ SWPMI_ICR, SWPMI_BASE + 0x10 @ (SWPMI Interrupt Flag Clear  register) 
        .equ SWPMI_ICR_CRXBFF, 1 << 0   @ bitWidth 1 (Clear receive buffer full  flag)  
        .equ SWPMI_ICR_CTXBEF, 1 << 1   @ bitWidth 1 (Clear transmit buffer empty  flag)  
        .equ SWPMI_ICR_CRXBERF, 1 << 2   @ bitWidth 1 (Clear receive CRC error  flag)  
        .equ SWPMI_ICR_CRXOVRF, 1 << 3   @ bitWidth 1 (Clear receive overrun error  flag)  
        .equ SWPMI_ICR_CTXUNRF, 1 << 4   @ bitWidth 1 (Clear transmit underrun error  flag)  
        .equ SWPMI_ICR_CTCF, 1 << 7   @ bitWidth 1 (Clear transfer complete  flag)  
        .equ SWPMI_ICR_CSRF, 1 << 8   @ bitWidth 1 (Clear slave resume flag)  
        .equ SWPMI_ICR_CRDYF, 1 << 11   @ bitWidth 1 (Clear transceiver ready  flag)  
 
    .equ SWPMI_IER, SWPMI_BASE + 0x14 @ (SWPMI Interrupt Enable  register) 
        .equ SWPMI_IER_RXBFIE, 1 << 0   @ bitWidth 1 (Receive buffer full interrupt  enable)  
        .equ SWPMI_IER_TXBEIE, 1 << 1   @ bitWidth 1 (Transmit buffer empty interrupt  enable)  
        .equ SWPMI_IER_RXBERIE, 1 << 2   @ bitWidth 1 (Receive CRC error interrupt  enable)  
        .equ SWPMI_IER_RXOVRIE, 1 << 3   @ bitWidth 1 (Receive overrun error interrupt  enable)  
        .equ SWPMI_IER_TXUNRIE, 1 << 4   @ bitWidth 1 (Transmit underrun error interrupt  enable)  
        .equ SWPMI_IER_RIE, 1 << 5   @ bitWidth 1 (Receive interrupt enable)  
        .equ SWPMI_IER_TIE, 1 << 6   @ bitWidth 1 (Transmit interrupt enable)  
        .equ SWPMI_IER_TCIE, 1 << 7   @ bitWidth 1 (Transmit complete interrupt  enable)  
        .equ SWPMI_IER_SRIE, 1 << 8   @ bitWidth 1 (Slave resume interrupt  enable)  
        .equ SWPMI_IER_RDYIE, 1 << 11   @ bitWidth 1 (Transceiver ready interrupt  enable)  
 
    .equ SWPMI_RFL, SWPMI_BASE + 0x18 @ (SWPMI Receive Frame Length  register) 
        .equ SWPMI_RFL_RFL_Shift, 0   @ bitWidth 5 (Receive frame length)  
 
    .equ SWPMI_TDR, SWPMI_BASE + 0x1C @ (SWPMI Transmit data register) 
        .equ SWPMI_TDR_TD_Shift, 0   @ bitWidth 32 (Transmit data)  
 
    .equ SWPMI_RDR, SWPMI_BASE + 0x20 @ (SWPMI Receive data register) 
        .equ SWPMI_RDR_RD_Shift, 0   @ bitWidth 32 (received data)  
 
    .equ SWPMI_OR, SWPMI_BASE + 0x24 @ (SWPMI Option register) 
        .equ SWPMI_OR_SWP_TBYP, 1 << 0   @ bitWidth 1 (SWP transceiver bypass)  
        .equ SWPMI_OR_SWP_CLASS, 1 << 1   @ bitWidth 1 (SWP class selection)  
 

@=========================== TIM2 ===========================@
.equ TIM2_BASE, 0x40000000 @ (General purpose timers) 
    .equ TIM2_CR1, TIM2_BASE + 0x0 @ (control register 1) 
        .equ TIM2_CR1_UIFREMAP, 1 << 11   @ bitWidth 1 (UIF status bit remapping)  
        .equ TIM2_CR1_CKD_Shift, 8   @ bitWidth 2 (Clock division)  
        .equ TIM2_CR1_ARPE, 1 << 7   @ bitWidth 1 (Auto-reload preload enable)  
        .equ TIM2_CR1_CMS_Shift, 5   @ bitWidth 2 (Center-aligned mode  selection)  
        .equ TIM2_CR1_DIR, 1 << 4   @ bitWidth 1 (Direction)  
        .equ TIM2_CR1_OPM, 1 << 3   @ bitWidth 1 (One-pulse mode)  
        .equ TIM2_CR1_URS, 1 << 2   @ bitWidth 1 (Update request source)  
        .equ TIM2_CR1_UDIS, 1 << 1   @ bitWidth 1 (Update disable)  
        .equ TIM2_CR1_CEN, 1 << 0   @ bitWidth 1 (Counter enable)  
 
    .equ TIM2_CR2, TIM2_BASE + 0x4 @ (control register 2) 
        .equ TIM2_CR2_TI1S, 1 << 7   @ bitWidth 1 (TI1 selection)  
        .equ TIM2_CR2_MMS_Shift, 4   @ bitWidth 3 (Master mode selection)  
        .equ TIM2_CR2_CCDS, 1 << 3   @ bitWidth 1 (Capture/compare DMA  selection)  
 
    .equ TIM2_SMCR, TIM2_BASE + 0x8 @ (slave mode control register) 
        .equ TIM2_SMCR_TS_4_3_Shift, 20   @ bitWidth 2 (Trigger selection)  
        .equ TIM2_SMCR_SMS_3, 1 << 16   @ bitWidth 1 (Slave mode selection - bit  3)  
        .equ TIM2_SMCR_ETP, 1 << 15   @ bitWidth 1 (External trigger polarity)  
        .equ TIM2_SMCR_ECE, 1 << 14   @ bitWidth 1 (External clock enable)  
        .equ TIM2_SMCR_ETPS_Shift, 12   @ bitWidth 2 (External trigger prescaler)  
        .equ TIM2_SMCR_ETF_Shift, 8   @ bitWidth 4 (External trigger filter)  
        .equ TIM2_SMCR_MSM, 1 << 7   @ bitWidth 1 (Master/Slave mode)  
        .equ TIM2_SMCR_TS_Shift, 4   @ bitWidth 3 (Trigger selection)  
        .equ TIM2_SMCR_SMS_Shift, 0   @ bitWidth 3 (Slave mode selection)  
 
    .equ TIM2_DIER, TIM2_BASE + 0xC @ (DMA/Interrupt enable register) 
        .equ TIM2_DIER_TDE, 1 << 14   @ bitWidth 1 (Trigger DMA request enable)  
        .equ TIM2_DIER_CC4DE, 1 << 12   @ bitWidth 1 (Capture/Compare 4 DMA request  enable)  
        .equ TIM2_DIER_CC3DE, 1 << 11   @ bitWidth 1 (Capture/Compare 3 DMA request  enable)  
        .equ TIM2_DIER_CC2DE, 1 << 10   @ bitWidth 1 (Capture/Compare 2 DMA request  enable)  
        .equ TIM2_DIER_CC1DE, 1 << 9   @ bitWidth 1 (Capture/Compare 1 DMA request  enable)  
        .equ TIM2_DIER_UDE, 1 << 8   @ bitWidth 1 (Update DMA request enable)  
        .equ TIM2_DIER_TIE, 1 << 6   @ bitWidth 1 (Trigger interrupt enable)  
        .equ TIM2_DIER_CC4IE, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  enable)  
        .equ TIM2_DIER_CC3IE, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  enable)  
        .equ TIM2_DIER_CC2IE, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  enable)  
        .equ TIM2_DIER_CC1IE, 1 << 1   @ bitWidth 1 (Capture/Compare 1 interrupt  enable)  
        .equ TIM2_DIER_UIE, 1 << 0   @ bitWidth 1 (Update interrupt enable)  
 
    .equ TIM2_SR, TIM2_BASE + 0x10 @ (status register) 
        .equ TIM2_SR_CC4OF, 1 << 12   @ bitWidth 1 (Capture/Compare 4 overcapture  flag)  
        .equ TIM2_SR_CC3OF, 1 << 11   @ bitWidth 1 (Capture/Compare 3 overcapture  flag)  
        .equ TIM2_SR_CC2OF, 1 << 10   @ bitWidth 1 (Capture/compare 2 overcapture  flag)  
        .equ TIM2_SR_CC1OF, 1 << 9   @ bitWidth 1 (Capture/Compare 1 overcapture  flag)  
        .equ TIM2_SR_TIF, 1 << 6   @ bitWidth 1 (Trigger interrupt flag)  
        .equ TIM2_SR_CC4IF, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  flag)  
        .equ TIM2_SR_CC3IF, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  flag)  
        .equ TIM2_SR_CC2IF, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  flag)  
        .equ TIM2_SR_CC1IF, 1 << 1   @ bitWidth 1 (Capture/compare 1 interrupt  flag)  
        .equ TIM2_SR_UIF, 1 << 0   @ bitWidth 1 (Update interrupt flag)  
 
    .equ TIM2_EGR, TIM2_BASE + 0x14 @ (event generation register) 
        .equ TIM2_EGR_TG, 1 << 6   @ bitWidth 1 (Trigger generation)  
        .equ TIM2_EGR_CC4G, 1 << 4   @ bitWidth 1 (Capture/compare 4  generation)  
        .equ TIM2_EGR_CC3G, 1 << 3   @ bitWidth 1 (Capture/compare 3  generation)  
        .equ TIM2_EGR_CC2G, 1 << 2   @ bitWidth 1 (Capture/compare 2  generation)  
        .equ TIM2_EGR_CC1G, 1 << 1   @ bitWidth 1 (Capture/compare 1  generation)  
        .equ TIM2_EGR_UG, 1 << 0   @ bitWidth 1 (Update generation)  
 
    .equ TIM2_CCMR1_Output, TIM2_BASE + 0x18 @ (capture/compare mode register 1 output  mode) 
        .equ TIM2_CCMR1_Output_CC1S_Shift, 0   @ bitWidth 2 (CC1S)  
        .equ TIM2_CCMR1_Output_OC1FE, 1 << 2   @ bitWidth 1 (OC1FE)  
        .equ TIM2_CCMR1_Output_OC1PE, 1 << 3   @ bitWidth 1 (OC1PE)  
        .equ TIM2_CCMR1_Output_OC1M_Shift, 4   @ bitWidth 3 (OC1M)  
        .equ TIM2_CCMR1_Output_OC1CE, 1 << 7   @ bitWidth 1 (OC1CE)  
        .equ TIM2_CCMR1_Output_CC2S_Shift, 8   @ bitWidth 2 (CC2S)  
        .equ TIM2_CCMR1_Output_OC2FE, 1 << 10   @ bitWidth 1 (OC2FE)  
        .equ TIM2_CCMR1_Output_OC2PE, 1 << 11   @ bitWidth 1 (OC2PE)  
        .equ TIM2_CCMR1_Output_OC2M_Shift, 12   @ bitWidth 3 (OC2M)  
        .equ TIM2_CCMR1_Output_OC2CE, 1 << 15   @ bitWidth 1 (OC2CE)  
        .equ TIM2_CCMR1_Output_OC1M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode - bit  3)  
        .equ TIM2_CCMR1_Output_OC2M_3, 1 << 24   @ bitWidth 1 (Output Compare 2 mode - bit  3)  
 
    .equ TIM2_CCMR1_Input, TIM2_BASE + 0x18 @ (capture/compare mode register 1 input  mode) 
        .equ TIM2_CCMR1_Input_IC2F_Shift, 12   @ bitWidth 4 (Input capture 2 filter)  
        .equ TIM2_CCMR1_Input_IC2PCS_Shift, 10   @ bitWidth 2 (Input capture 2 prescaler)  
        .equ TIM2_CCMR1_Input_CC2S_Shift, 8   @ bitWidth 2 (Capture/Compare 2  selection)  
        .equ TIM2_CCMR1_Input_IC1F_Shift, 4   @ bitWidth 4 (Input capture 1 filter)  
        .equ TIM2_CCMR1_Input_ICPCS_Shift, 2   @ bitWidth 2 (Input capture 1 prescaler)  
        .equ TIM2_CCMR1_Input_CC1S_Shift, 0   @ bitWidth 2 (Capture/Compare 1  selection)  
 
    .equ TIM2_CCMR2_Output, TIM2_BASE + 0x1C @ (capture/compare mode register 2 output  mode) 
        .equ TIM2_CCMR2_Output_OC4M_3, 1 << 24   @ bitWidth 1 (Output Compare 2 mode - bit  3)  
        .equ TIM2_CCMR2_Output_OC3M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode - bit  3)  
        .equ TIM2_CCMR2_Output_O24CE, 1 << 15   @ bitWidth 1 (O24CE)  
        .equ TIM2_CCMR2_Output_OC4M_Shift, 12   @ bitWidth 3 (OC4M)  
        .equ TIM2_CCMR2_Output_OC4PE, 1 << 11   @ bitWidth 1 (OC4PE)  
        .equ TIM2_CCMR2_Output_OC4FE, 1 << 10   @ bitWidth 1 (OC4FE)  
        .equ TIM2_CCMR2_Output_CC4S_Shift, 8   @ bitWidth 2 (CC4S)  
        .equ TIM2_CCMR2_Output_OC3CE, 1 << 7   @ bitWidth 1 (OC3CE)  
        .equ TIM2_CCMR2_Output_OC3M_Shift, 4   @ bitWidth 3 (OC3M)  
        .equ TIM2_CCMR2_Output_OC3PE, 1 << 3   @ bitWidth 1 (OC3PE)  
        .equ TIM2_CCMR2_Output_OC3FE, 1 << 2   @ bitWidth 1 (OC3FE)  
        .equ TIM2_CCMR2_Output_CC3S_Shift, 0   @ bitWidth 2 (CC3S)  
 
    .equ TIM2_CCMR2_Input, TIM2_BASE + 0x1C @ (capture/compare mode register 2 input  mode) 
        .equ TIM2_CCMR2_Input_IC4F_Shift, 12   @ bitWidth 4 (Input capture 4 filter)  
        .equ TIM2_CCMR2_Input_IC4PSC_Shift, 10   @ bitWidth 2 (Input capture 4 prescaler)  
        .equ TIM2_CCMR2_Input_CC4S_Shift, 8   @ bitWidth 2 (Capture/Compare 4  selection)  
        .equ TIM2_CCMR2_Input_IC3F_Shift, 4   @ bitWidth 4 (Input capture 3 filter)  
        .equ TIM2_CCMR2_Input_IC3PSC_Shift, 2   @ bitWidth 2 (Input capture 3 prescaler)  
        .equ TIM2_CCMR2_Input_CC3S_Shift, 0   @ bitWidth 2 (Capture/compare 3  selection)  
 
    .equ TIM2_CCER, TIM2_BASE + 0x20 @ (capture/compare enable  register) 
        .equ TIM2_CCER_CC4NP, 1 << 15   @ bitWidth 1 (Capture/Compare 4 output  Polarity)  
        .equ TIM2_CCER_CC4P, 1 << 13   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM2_CCER_CC4E, 1 << 12   @ bitWidth 1 (Capture/Compare 4 output  enable)  
        .equ TIM2_CCER_CC3NP, 1 << 11   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM2_CCER_CC3P, 1 << 9   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM2_CCER_CC3E, 1 << 8   @ bitWidth 1 (Capture/Compare 3 output  enable)  
        .equ TIM2_CCER_CC2NP, 1 << 7   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM2_CCER_CC2P, 1 << 5   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM2_CCER_CC2E, 1 << 4   @ bitWidth 1 (Capture/Compare 2 output  enable)  
        .equ TIM2_CCER_CC1NP, 1 << 3   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM2_CCER_CC1P, 1 << 1   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM2_CCER_CC1E, 1 << 0   @ bitWidth 1 (Capture/Compare 1 output  enable)  
 
    .equ TIM2_CNT, TIM2_BASE + 0x24 @ (counter) 
        .equ TIM2_CNT_CNT_L_Shift, 0   @ bitWidth 16 (low counter value)  
        .equ TIM2_CNT_CNT_H_Shift, 16   @ bitWidth 16 (High counter value)  
 
    .equ TIM2_PSC, TIM2_BASE + 0x28 @ (prescaler) 
        .equ TIM2_PSC_PSC_Shift, 0   @ bitWidth 16 (Prescaler value)  
 
    .equ TIM2_ARR, TIM2_BASE + 0x2C @ (auto-reload register) 
        .equ TIM2_ARR_ARR_H_Shift, 16   @ bitWidth 16 (High Auto-reload value)  
        .equ TIM2_ARR_ARR_L_Shift, 0   @ bitWidth 16 (Low Auto-reload value)  
 
    .equ TIM2_CCR1, TIM2_BASE + 0x34 @ (capture/compare register 1) 
        .equ TIM2_CCR1_CCR1_H_Shift, 16   @ bitWidth 16 (High Capture/Compare 1  value)  
        .equ TIM2_CCR1_CCR1_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare 1  value)  
 
    .equ TIM2_CCR2, TIM2_BASE + 0x38 @ (capture/compare register 2) 
        .equ TIM2_CCR2_CCR2_H_Shift, 16   @ bitWidth 16 (High Capture/Compare 2  value)  
        .equ TIM2_CCR2_CCR2_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare 2  value)  
 
    .equ TIM2_CCR3, TIM2_BASE + 0x3C @ (capture/compare register 3) 
        .equ TIM2_CCR3_CCR3_H_Shift, 16   @ bitWidth 16 (High Capture/Compare value)  
        .equ TIM2_CCR3_CCR3_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare value)  
 
    .equ TIM2_CCR4, TIM2_BASE + 0x40 @ (capture/compare register 4) 
        .equ TIM2_CCR4_CCR4_H_Shift, 16   @ bitWidth 16 (High Capture/Compare value)  
        .equ TIM2_CCR4_CCR4_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare value)  
 
    .equ TIM2_DCR, TIM2_BASE + 0x48 @ (DMA control register) 
        .equ TIM2_DCR_DBL_Shift, 8   @ bitWidth 5 (DMA burst length)  
        .equ TIM2_DCR_DBA_Shift, 0   @ bitWidth 5 (DMA base address)  
 
    .equ TIM2_DMAR, TIM2_BASE + 0x4C @ (DMA address for full transfer) 
        .equ TIM2_DMAR_DMAB_Shift, 0   @ bitWidth 16 (DMA register for burst  accesses)  
 
    .equ TIM2_AF1, TIM2_BASE + 0x60 @ (TIM alternate function option register  1) 
        .equ TIM2_AF1_ETRSEL_Shift, 14   @ bitWidth 4 (ETR source selection)  
 
    .equ TIM2_TISEL, TIM2_BASE + 0x68 @ (TIM timer input selection  register) 
        .equ TIM2_TISEL_TI1SEL_Shift, 0   @ bitWidth 4 (TI1[0] to TI1[15] input  selection)  
        .equ TIM2_TISEL_TI2SEL_Shift, 8   @ bitWidth 4 (TI2[0] to TI2[15] input  selection)  
        .equ TIM2_TISEL_TI3SEL_Shift, 16   @ bitWidth 4 (TI3[0] to TI3[15] input  selection)  
        .equ TIM2_TISEL_TI4SEL_Shift, 24   @ bitWidth 4 (TI4[0] to TI4[15] input  selection)  
 

@=========================== TIM3 ===========================@
.equ TIM3_BASE, 0x40000400 @ (General purpose timers) 
    .equ TIM3_CR1, TIM3_BASE + 0x0 @ (control register 1) 
        .equ TIM3_CR1_UIFREMAP, 1 << 11   @ bitWidth 1 (UIF status bit remapping)  
        .equ TIM3_CR1_CKD_Shift, 8   @ bitWidth 2 (Clock division)  
        .equ TIM3_CR1_ARPE, 1 << 7   @ bitWidth 1 (Auto-reload preload enable)  
        .equ TIM3_CR1_CMS_Shift, 5   @ bitWidth 2 (Center-aligned mode  selection)  
        .equ TIM3_CR1_DIR, 1 << 4   @ bitWidth 1 (Direction)  
        .equ TIM3_CR1_OPM, 1 << 3   @ bitWidth 1 (One-pulse mode)  
        .equ TIM3_CR1_URS, 1 << 2   @ bitWidth 1 (Update request source)  
        .equ TIM3_CR1_UDIS, 1 << 1   @ bitWidth 1 (Update disable)  
        .equ TIM3_CR1_CEN, 1 << 0   @ bitWidth 1 (Counter enable)  
 
    .equ TIM3_CR2, TIM3_BASE + 0x4 @ (control register 2) 
        .equ TIM3_CR2_TI1S, 1 << 7   @ bitWidth 1 (TI1 selection)  
        .equ TIM3_CR2_MMS_Shift, 4   @ bitWidth 3 (Master mode selection)  
        .equ TIM3_CR2_CCDS, 1 << 3   @ bitWidth 1 (Capture/compare DMA  selection)  
 
    .equ TIM3_SMCR, TIM3_BASE + 0x8 @ (slave mode control register) 
        .equ TIM3_SMCR_TS_4_3_Shift, 20   @ bitWidth 2 (Trigger selection)  
        .equ TIM3_SMCR_SMS_3, 1 << 16   @ bitWidth 1 (Slave mode selection - bit  3)  
        .equ TIM3_SMCR_ETP, 1 << 15   @ bitWidth 1 (External trigger polarity)  
        .equ TIM3_SMCR_ECE, 1 << 14   @ bitWidth 1 (External clock enable)  
        .equ TIM3_SMCR_ETPS_Shift, 12   @ bitWidth 2 (External trigger prescaler)  
        .equ TIM3_SMCR_ETF_Shift, 8   @ bitWidth 4 (External trigger filter)  
        .equ TIM3_SMCR_MSM, 1 << 7   @ bitWidth 1 (Master/Slave mode)  
        .equ TIM3_SMCR_TS_Shift, 4   @ bitWidth 3 (Trigger selection)  
        .equ TIM3_SMCR_SMS_Shift, 0   @ bitWidth 3 (Slave mode selection)  
 
    .equ TIM3_DIER, TIM3_BASE + 0xC @ (DMA/Interrupt enable register) 
        .equ TIM3_DIER_TDE, 1 << 14   @ bitWidth 1 (Trigger DMA request enable)  
        .equ TIM3_DIER_CC4DE, 1 << 12   @ bitWidth 1 (Capture/Compare 4 DMA request  enable)  
        .equ TIM3_DIER_CC3DE, 1 << 11   @ bitWidth 1 (Capture/Compare 3 DMA request  enable)  
        .equ TIM3_DIER_CC2DE, 1 << 10   @ bitWidth 1 (Capture/Compare 2 DMA request  enable)  
        .equ TIM3_DIER_CC1DE, 1 << 9   @ bitWidth 1 (Capture/Compare 1 DMA request  enable)  
        .equ TIM3_DIER_UDE, 1 << 8   @ bitWidth 1 (Update DMA request enable)  
        .equ TIM3_DIER_TIE, 1 << 6   @ bitWidth 1 (Trigger interrupt enable)  
        .equ TIM3_DIER_CC4IE, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  enable)  
        .equ TIM3_DIER_CC3IE, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  enable)  
        .equ TIM3_DIER_CC2IE, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  enable)  
        .equ TIM3_DIER_CC1IE, 1 << 1   @ bitWidth 1 (Capture/Compare 1 interrupt  enable)  
        .equ TIM3_DIER_UIE, 1 << 0   @ bitWidth 1 (Update interrupt enable)  
 
    .equ TIM3_SR, TIM3_BASE + 0x10 @ (status register) 
        .equ TIM3_SR_CC4OF, 1 << 12   @ bitWidth 1 (Capture/Compare 4 overcapture  flag)  
        .equ TIM3_SR_CC3OF, 1 << 11   @ bitWidth 1 (Capture/Compare 3 overcapture  flag)  
        .equ TIM3_SR_CC2OF, 1 << 10   @ bitWidth 1 (Capture/compare 2 overcapture  flag)  
        .equ TIM3_SR_CC1OF, 1 << 9   @ bitWidth 1 (Capture/Compare 1 overcapture  flag)  
        .equ TIM3_SR_TIF, 1 << 6   @ bitWidth 1 (Trigger interrupt flag)  
        .equ TIM3_SR_CC4IF, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  flag)  
        .equ TIM3_SR_CC3IF, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  flag)  
        .equ TIM3_SR_CC2IF, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  flag)  
        .equ TIM3_SR_CC1IF, 1 << 1   @ bitWidth 1 (Capture/compare 1 interrupt  flag)  
        .equ TIM3_SR_UIF, 1 << 0   @ bitWidth 1 (Update interrupt flag)  
 
    .equ TIM3_EGR, TIM3_BASE + 0x14 @ (event generation register) 
        .equ TIM3_EGR_TG, 1 << 6   @ bitWidth 1 (Trigger generation)  
        .equ TIM3_EGR_CC4G, 1 << 4   @ bitWidth 1 (Capture/compare 4  generation)  
        .equ TIM3_EGR_CC3G, 1 << 3   @ bitWidth 1 (Capture/compare 3  generation)  
        .equ TIM3_EGR_CC2G, 1 << 2   @ bitWidth 1 (Capture/compare 2  generation)  
        .equ TIM3_EGR_CC1G, 1 << 1   @ bitWidth 1 (Capture/compare 1  generation)  
        .equ TIM3_EGR_UG, 1 << 0   @ bitWidth 1 (Update generation)  
 
    .equ TIM3_CCMR1_Output, TIM3_BASE + 0x18 @ (capture/compare mode register 1 output  mode) 
        .equ TIM3_CCMR1_Output_CC1S_Shift, 0   @ bitWidth 2 (CC1S)  
        .equ TIM3_CCMR1_Output_OC1FE, 1 << 2   @ bitWidth 1 (OC1FE)  
        .equ TIM3_CCMR1_Output_OC1PE, 1 << 3   @ bitWidth 1 (OC1PE)  
        .equ TIM3_CCMR1_Output_OC1M_Shift, 4   @ bitWidth 3 (OC1M)  
        .equ TIM3_CCMR1_Output_OC1CE, 1 << 7   @ bitWidth 1 (OC1CE)  
        .equ TIM3_CCMR1_Output_CC2S_Shift, 8   @ bitWidth 2 (CC2S)  
        .equ TIM3_CCMR1_Output_OC2FE, 1 << 10   @ bitWidth 1 (OC2FE)  
        .equ TIM3_CCMR1_Output_OC2PE, 1 << 11   @ bitWidth 1 (OC2PE)  
        .equ TIM3_CCMR1_Output_OC2M_Shift, 12   @ bitWidth 3 (OC2M)  
        .equ TIM3_CCMR1_Output_OC2CE, 1 << 15   @ bitWidth 1 (OC2CE)  
        .equ TIM3_CCMR1_Output_OC1M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode - bit  3)  
        .equ TIM3_CCMR1_Output_OC2M_3, 1 << 24   @ bitWidth 1 (Output Compare 2 mode - bit  3)  
 
    .equ TIM3_CCMR1_Input, TIM3_BASE + 0x18 @ (capture/compare mode register 1 input  mode) 
        .equ TIM3_CCMR1_Input_IC2F_Shift, 12   @ bitWidth 4 (Input capture 2 filter)  
        .equ TIM3_CCMR1_Input_IC2PCS_Shift, 10   @ bitWidth 2 (Input capture 2 prescaler)  
        .equ TIM3_CCMR1_Input_CC2S_Shift, 8   @ bitWidth 2 (Capture/Compare 2  selection)  
        .equ TIM3_CCMR1_Input_IC1F_Shift, 4   @ bitWidth 4 (Input capture 1 filter)  
        .equ TIM3_CCMR1_Input_ICPCS_Shift, 2   @ bitWidth 2 (Input capture 1 prescaler)  
        .equ TIM3_CCMR1_Input_CC1S_Shift, 0   @ bitWidth 2 (Capture/Compare 1  selection)  
 
    .equ TIM3_CCMR2_Output, TIM3_BASE + 0x1C @ (capture/compare mode register 2 output  mode) 
        .equ TIM3_CCMR2_Output_OC4M_3, 1 << 24   @ bitWidth 1 (Output Compare 2 mode - bit  3)  
        .equ TIM3_CCMR2_Output_OC3M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode - bit  3)  
        .equ TIM3_CCMR2_Output_O24CE, 1 << 15   @ bitWidth 1 (O24CE)  
        .equ TIM3_CCMR2_Output_OC4M_Shift, 12   @ bitWidth 3 (OC4M)  
        .equ TIM3_CCMR2_Output_OC4PE, 1 << 11   @ bitWidth 1 (OC4PE)  
        .equ TIM3_CCMR2_Output_OC4FE, 1 << 10   @ bitWidth 1 (OC4FE)  
        .equ TIM3_CCMR2_Output_CC4S_Shift, 8   @ bitWidth 2 (CC4S)  
        .equ TIM3_CCMR2_Output_OC3CE, 1 << 7   @ bitWidth 1 (OC3CE)  
        .equ TIM3_CCMR2_Output_OC3M_Shift, 4   @ bitWidth 3 (OC3M)  
        .equ TIM3_CCMR2_Output_OC3PE, 1 << 3   @ bitWidth 1 (OC3PE)  
        .equ TIM3_CCMR2_Output_OC3FE, 1 << 2   @ bitWidth 1 (OC3FE)  
        .equ TIM3_CCMR2_Output_CC3S_Shift, 0   @ bitWidth 2 (CC3S)  
 
    .equ TIM3_CCMR2_Input, TIM3_BASE + 0x1C @ (capture/compare mode register 2 input  mode) 
        .equ TIM3_CCMR2_Input_IC4F_Shift, 12   @ bitWidth 4 (Input capture 4 filter)  
        .equ TIM3_CCMR2_Input_IC4PSC_Shift, 10   @ bitWidth 2 (Input capture 4 prescaler)  
        .equ TIM3_CCMR2_Input_CC4S_Shift, 8   @ bitWidth 2 (Capture/Compare 4  selection)  
        .equ TIM3_CCMR2_Input_IC3F_Shift, 4   @ bitWidth 4 (Input capture 3 filter)  
        .equ TIM3_CCMR2_Input_IC3PSC_Shift, 2   @ bitWidth 2 (Input capture 3 prescaler)  
        .equ TIM3_CCMR2_Input_CC3S_Shift, 0   @ bitWidth 2 (Capture/compare 3  selection)  
 
    .equ TIM3_CCER, TIM3_BASE + 0x20 @ (capture/compare enable  register) 
        .equ TIM3_CCER_CC4NP, 1 << 15   @ bitWidth 1 (Capture/Compare 4 output  Polarity)  
        .equ TIM3_CCER_CC4P, 1 << 13   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM3_CCER_CC4E, 1 << 12   @ bitWidth 1 (Capture/Compare 4 output  enable)  
        .equ TIM3_CCER_CC3NP, 1 << 11   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM3_CCER_CC3P, 1 << 9   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM3_CCER_CC3E, 1 << 8   @ bitWidth 1 (Capture/Compare 3 output  enable)  
        .equ TIM3_CCER_CC2NP, 1 << 7   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM3_CCER_CC2P, 1 << 5   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM3_CCER_CC2E, 1 << 4   @ bitWidth 1 (Capture/Compare 2 output  enable)  
        .equ TIM3_CCER_CC1NP, 1 << 3   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM3_CCER_CC1P, 1 << 1   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM3_CCER_CC1E, 1 << 0   @ bitWidth 1 (Capture/Compare 1 output  enable)  
 
    .equ TIM3_CNT, TIM3_BASE + 0x24 @ (counter) 
        .equ TIM3_CNT_CNT_L_Shift, 0   @ bitWidth 16 (low counter value)  
        .equ TIM3_CNT_CNT_H_Shift, 16   @ bitWidth 16 (High counter value)  
 
    .equ TIM3_PSC, TIM3_BASE + 0x28 @ (prescaler) 
        .equ TIM3_PSC_PSC_Shift, 0   @ bitWidth 16 (Prescaler value)  
 
    .equ TIM3_ARR, TIM3_BASE + 0x2C @ (auto-reload register) 
        .equ TIM3_ARR_ARR_H_Shift, 16   @ bitWidth 16 (High Auto-reload value)  
        .equ TIM3_ARR_ARR_L_Shift, 0   @ bitWidth 16 (Low Auto-reload value)  
 
    .equ TIM3_CCR1, TIM3_BASE + 0x34 @ (capture/compare register 1) 
        .equ TIM3_CCR1_CCR1_H_Shift, 16   @ bitWidth 16 (High Capture/Compare 1  value)  
        .equ TIM3_CCR1_CCR1_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare 1  value)  
 
    .equ TIM3_CCR2, TIM3_BASE + 0x38 @ (capture/compare register 2) 
        .equ TIM3_CCR2_CCR2_H_Shift, 16   @ bitWidth 16 (High Capture/Compare 2  value)  
        .equ TIM3_CCR2_CCR2_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare 2  value)  
 
    .equ TIM3_CCR3, TIM3_BASE + 0x3C @ (capture/compare register 3) 
        .equ TIM3_CCR3_CCR3_H_Shift, 16   @ bitWidth 16 (High Capture/Compare value)  
        .equ TIM3_CCR3_CCR3_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare value)  
 
    .equ TIM3_CCR4, TIM3_BASE + 0x40 @ (capture/compare register 4) 
        .equ TIM3_CCR4_CCR4_H_Shift, 16   @ bitWidth 16 (High Capture/Compare value)  
        .equ TIM3_CCR4_CCR4_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare value)  
 
    .equ TIM3_DCR, TIM3_BASE + 0x48 @ (DMA control register) 
        .equ TIM3_DCR_DBL_Shift, 8   @ bitWidth 5 (DMA burst length)  
        .equ TIM3_DCR_DBA_Shift, 0   @ bitWidth 5 (DMA base address)  
 
    .equ TIM3_DMAR, TIM3_BASE + 0x4C @ (DMA address for full transfer) 
        .equ TIM3_DMAR_DMAB_Shift, 0   @ bitWidth 16 (DMA register for burst  accesses)  
 
    .equ TIM3_AF1, TIM3_BASE + 0x60 @ (TIM alternate function option register  1) 
        .equ TIM3_AF1_ETRSEL_Shift, 14   @ bitWidth 4 (ETR source selection)  
 
    .equ TIM3_TISEL, TIM3_BASE + 0x68 @ (TIM timer input selection  register) 
        .equ TIM3_TISEL_TI1SEL_Shift, 0   @ bitWidth 4 (TI1[0] to TI1[15] input  selection)  
        .equ TIM3_TISEL_TI2SEL_Shift, 8   @ bitWidth 4 (TI2[0] to TI2[15] input  selection)  
        .equ TIM3_TISEL_TI3SEL_Shift, 16   @ bitWidth 4 (TI3[0] to TI3[15] input  selection)  
        .equ TIM3_TISEL_TI4SEL_Shift, 24   @ bitWidth 4 (TI4[0] to TI4[15] input  selection)  
 

@=========================== TIM4 ===========================@
.equ TIM4_BASE, 0x40000800 @ (General purpose timers) 
    .equ TIM4_CR1, TIM4_BASE + 0x0 @ (control register 1) 
        .equ TIM4_CR1_UIFREMAP, 1 << 11   @ bitWidth 1 (UIF status bit remapping)  
        .equ TIM4_CR1_CKD_Shift, 8   @ bitWidth 2 (Clock division)  
        .equ TIM4_CR1_ARPE, 1 << 7   @ bitWidth 1 (Auto-reload preload enable)  
        .equ TIM4_CR1_CMS_Shift, 5   @ bitWidth 2 (Center-aligned mode  selection)  
        .equ TIM4_CR1_DIR, 1 << 4   @ bitWidth 1 (Direction)  
        .equ TIM4_CR1_OPM, 1 << 3   @ bitWidth 1 (One-pulse mode)  
        .equ TIM4_CR1_URS, 1 << 2   @ bitWidth 1 (Update request source)  
        .equ TIM4_CR1_UDIS, 1 << 1   @ bitWidth 1 (Update disable)  
        .equ TIM4_CR1_CEN, 1 << 0   @ bitWidth 1 (Counter enable)  
 
    .equ TIM4_CR2, TIM4_BASE + 0x4 @ (control register 2) 
        .equ TIM4_CR2_TI1S, 1 << 7   @ bitWidth 1 (TI1 selection)  
        .equ TIM4_CR2_MMS_Shift, 4   @ bitWidth 3 (Master mode selection)  
        .equ TIM4_CR2_CCDS, 1 << 3   @ bitWidth 1 (Capture/compare DMA  selection)  
 
    .equ TIM4_SMCR, TIM4_BASE + 0x8 @ (slave mode control register) 
        .equ TIM4_SMCR_TS_4_3_Shift, 20   @ bitWidth 2 (Trigger selection)  
        .equ TIM4_SMCR_SMS_3, 1 << 16   @ bitWidth 1 (Slave mode selection - bit  3)  
        .equ TIM4_SMCR_ETP, 1 << 15   @ bitWidth 1 (External trigger polarity)  
        .equ TIM4_SMCR_ECE, 1 << 14   @ bitWidth 1 (External clock enable)  
        .equ TIM4_SMCR_ETPS_Shift, 12   @ bitWidth 2 (External trigger prescaler)  
        .equ TIM4_SMCR_ETF_Shift, 8   @ bitWidth 4 (External trigger filter)  
        .equ TIM4_SMCR_MSM, 1 << 7   @ bitWidth 1 (Master/Slave mode)  
        .equ TIM4_SMCR_TS_Shift, 4   @ bitWidth 3 (Trigger selection)  
        .equ TIM4_SMCR_SMS_Shift, 0   @ bitWidth 3 (Slave mode selection)  
 
    .equ TIM4_DIER, TIM4_BASE + 0xC @ (DMA/Interrupt enable register) 
        .equ TIM4_DIER_TDE, 1 << 14   @ bitWidth 1 (Trigger DMA request enable)  
        .equ TIM4_DIER_CC4DE, 1 << 12   @ bitWidth 1 (Capture/Compare 4 DMA request  enable)  
        .equ TIM4_DIER_CC3DE, 1 << 11   @ bitWidth 1 (Capture/Compare 3 DMA request  enable)  
        .equ TIM4_DIER_CC2DE, 1 << 10   @ bitWidth 1 (Capture/Compare 2 DMA request  enable)  
        .equ TIM4_DIER_CC1DE, 1 << 9   @ bitWidth 1 (Capture/Compare 1 DMA request  enable)  
        .equ TIM4_DIER_UDE, 1 << 8   @ bitWidth 1 (Update DMA request enable)  
        .equ TIM4_DIER_TIE, 1 << 6   @ bitWidth 1 (Trigger interrupt enable)  
        .equ TIM4_DIER_CC4IE, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  enable)  
        .equ TIM4_DIER_CC3IE, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  enable)  
        .equ TIM4_DIER_CC2IE, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  enable)  
        .equ TIM4_DIER_CC1IE, 1 << 1   @ bitWidth 1 (Capture/Compare 1 interrupt  enable)  
        .equ TIM4_DIER_UIE, 1 << 0   @ bitWidth 1 (Update interrupt enable)  
 
    .equ TIM4_SR, TIM4_BASE + 0x10 @ (status register) 
        .equ TIM4_SR_CC4OF, 1 << 12   @ bitWidth 1 (Capture/Compare 4 overcapture  flag)  
        .equ TIM4_SR_CC3OF, 1 << 11   @ bitWidth 1 (Capture/Compare 3 overcapture  flag)  
        .equ TIM4_SR_CC2OF, 1 << 10   @ bitWidth 1 (Capture/compare 2 overcapture  flag)  
        .equ TIM4_SR_CC1OF, 1 << 9   @ bitWidth 1 (Capture/Compare 1 overcapture  flag)  
        .equ TIM4_SR_TIF, 1 << 6   @ bitWidth 1 (Trigger interrupt flag)  
        .equ TIM4_SR_CC4IF, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  flag)  
        .equ TIM4_SR_CC3IF, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  flag)  
        .equ TIM4_SR_CC2IF, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  flag)  
        .equ TIM4_SR_CC1IF, 1 << 1   @ bitWidth 1 (Capture/compare 1 interrupt  flag)  
        .equ TIM4_SR_UIF, 1 << 0   @ bitWidth 1 (Update interrupt flag)  
 
    .equ TIM4_EGR, TIM4_BASE + 0x14 @ (event generation register) 
        .equ TIM4_EGR_TG, 1 << 6   @ bitWidth 1 (Trigger generation)  
        .equ TIM4_EGR_CC4G, 1 << 4   @ bitWidth 1 (Capture/compare 4  generation)  
        .equ TIM4_EGR_CC3G, 1 << 3   @ bitWidth 1 (Capture/compare 3  generation)  
        .equ TIM4_EGR_CC2G, 1 << 2   @ bitWidth 1 (Capture/compare 2  generation)  
        .equ TIM4_EGR_CC1G, 1 << 1   @ bitWidth 1 (Capture/compare 1  generation)  
        .equ TIM4_EGR_UG, 1 << 0   @ bitWidth 1 (Update generation)  
 
    .equ TIM4_CCMR1_Output, TIM4_BASE + 0x18 @ (capture/compare mode register 1 output  mode) 
        .equ TIM4_CCMR1_Output_CC1S_Shift, 0   @ bitWidth 2 (CC1S)  
        .equ TIM4_CCMR1_Output_OC1FE, 1 << 2   @ bitWidth 1 (OC1FE)  
        .equ TIM4_CCMR1_Output_OC1PE, 1 << 3   @ bitWidth 1 (OC1PE)  
        .equ TIM4_CCMR1_Output_OC1M_Shift, 4   @ bitWidth 3 (OC1M)  
        .equ TIM4_CCMR1_Output_OC1CE, 1 << 7   @ bitWidth 1 (OC1CE)  
        .equ TIM4_CCMR1_Output_CC2S_Shift, 8   @ bitWidth 2 (CC2S)  
        .equ TIM4_CCMR1_Output_OC2FE, 1 << 10   @ bitWidth 1 (OC2FE)  
        .equ TIM4_CCMR1_Output_OC2PE, 1 << 11   @ bitWidth 1 (OC2PE)  
        .equ TIM4_CCMR1_Output_OC2M_Shift, 12   @ bitWidth 3 (OC2M)  
        .equ TIM4_CCMR1_Output_OC2CE, 1 << 15   @ bitWidth 1 (OC2CE)  
        .equ TIM4_CCMR1_Output_OC1M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode - bit  3)  
        .equ TIM4_CCMR1_Output_OC2M_3, 1 << 24   @ bitWidth 1 (Output Compare 2 mode - bit  3)  
 
    .equ TIM4_CCMR1_Input, TIM4_BASE + 0x18 @ (capture/compare mode register 1 input  mode) 
        .equ TIM4_CCMR1_Input_IC2F_Shift, 12   @ bitWidth 4 (Input capture 2 filter)  
        .equ TIM4_CCMR1_Input_IC2PCS_Shift, 10   @ bitWidth 2 (Input capture 2 prescaler)  
        .equ TIM4_CCMR1_Input_CC2S_Shift, 8   @ bitWidth 2 (Capture/Compare 2  selection)  
        .equ TIM4_CCMR1_Input_IC1F_Shift, 4   @ bitWidth 4 (Input capture 1 filter)  
        .equ TIM4_CCMR1_Input_ICPCS_Shift, 2   @ bitWidth 2 (Input capture 1 prescaler)  
        .equ TIM4_CCMR1_Input_CC1S_Shift, 0   @ bitWidth 2 (Capture/Compare 1  selection)  
 
    .equ TIM4_CCMR2_Output, TIM4_BASE + 0x1C @ (capture/compare mode register 2 output  mode) 
        .equ TIM4_CCMR2_Output_OC4M_3, 1 << 24   @ bitWidth 1 (Output Compare 2 mode - bit  3)  
        .equ TIM4_CCMR2_Output_OC3M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode - bit  3)  
        .equ TIM4_CCMR2_Output_O24CE, 1 << 15   @ bitWidth 1 (O24CE)  
        .equ TIM4_CCMR2_Output_OC4M_Shift, 12   @ bitWidth 3 (OC4M)  
        .equ TIM4_CCMR2_Output_OC4PE, 1 << 11   @ bitWidth 1 (OC4PE)  
        .equ TIM4_CCMR2_Output_OC4FE, 1 << 10   @ bitWidth 1 (OC4FE)  
        .equ TIM4_CCMR2_Output_CC4S_Shift, 8   @ bitWidth 2 (CC4S)  
        .equ TIM4_CCMR2_Output_OC3CE, 1 << 7   @ bitWidth 1 (OC3CE)  
        .equ TIM4_CCMR2_Output_OC3M_Shift, 4   @ bitWidth 3 (OC3M)  
        .equ TIM4_CCMR2_Output_OC3PE, 1 << 3   @ bitWidth 1 (OC3PE)  
        .equ TIM4_CCMR2_Output_OC3FE, 1 << 2   @ bitWidth 1 (OC3FE)  
        .equ TIM4_CCMR2_Output_CC3S_Shift, 0   @ bitWidth 2 (CC3S)  
 
    .equ TIM4_CCMR2_Input, TIM4_BASE + 0x1C @ (capture/compare mode register 2 input  mode) 
        .equ TIM4_CCMR2_Input_IC4F_Shift, 12   @ bitWidth 4 (Input capture 4 filter)  
        .equ TIM4_CCMR2_Input_IC4PSC_Shift, 10   @ bitWidth 2 (Input capture 4 prescaler)  
        .equ TIM4_CCMR2_Input_CC4S_Shift, 8   @ bitWidth 2 (Capture/Compare 4  selection)  
        .equ TIM4_CCMR2_Input_IC3F_Shift, 4   @ bitWidth 4 (Input capture 3 filter)  
        .equ TIM4_CCMR2_Input_IC3PSC_Shift, 2   @ bitWidth 2 (Input capture 3 prescaler)  
        .equ TIM4_CCMR2_Input_CC3S_Shift, 0   @ bitWidth 2 (Capture/compare 3  selection)  
 
    .equ TIM4_CCER, TIM4_BASE + 0x20 @ (capture/compare enable  register) 
        .equ TIM4_CCER_CC4NP, 1 << 15   @ bitWidth 1 (Capture/Compare 4 output  Polarity)  
        .equ TIM4_CCER_CC4P, 1 << 13   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM4_CCER_CC4E, 1 << 12   @ bitWidth 1 (Capture/Compare 4 output  enable)  
        .equ TIM4_CCER_CC3NP, 1 << 11   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM4_CCER_CC3P, 1 << 9   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM4_CCER_CC3E, 1 << 8   @ bitWidth 1 (Capture/Compare 3 output  enable)  
        .equ TIM4_CCER_CC2NP, 1 << 7   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM4_CCER_CC2P, 1 << 5   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM4_CCER_CC2E, 1 << 4   @ bitWidth 1 (Capture/Compare 2 output  enable)  
        .equ TIM4_CCER_CC1NP, 1 << 3   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM4_CCER_CC1P, 1 << 1   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM4_CCER_CC1E, 1 << 0   @ bitWidth 1 (Capture/Compare 1 output  enable)  
 
    .equ TIM4_CNT, TIM4_BASE + 0x24 @ (counter) 
        .equ TIM4_CNT_CNT_L_Shift, 0   @ bitWidth 16 (low counter value)  
        .equ TIM4_CNT_CNT_H_Shift, 16   @ bitWidth 16 (High counter value)  
 
    .equ TIM4_PSC, TIM4_BASE + 0x28 @ (prescaler) 
        .equ TIM4_PSC_PSC_Shift, 0   @ bitWidth 16 (Prescaler value)  
 
    .equ TIM4_ARR, TIM4_BASE + 0x2C @ (auto-reload register) 
        .equ TIM4_ARR_ARR_H_Shift, 16   @ bitWidth 16 (High Auto-reload value)  
        .equ TIM4_ARR_ARR_L_Shift, 0   @ bitWidth 16 (Low Auto-reload value)  
 
    .equ TIM4_CCR1, TIM4_BASE + 0x34 @ (capture/compare register 1) 
        .equ TIM4_CCR1_CCR1_H_Shift, 16   @ bitWidth 16 (High Capture/Compare 1  value)  
        .equ TIM4_CCR1_CCR1_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare 1  value)  
 
    .equ TIM4_CCR2, TIM4_BASE + 0x38 @ (capture/compare register 2) 
        .equ TIM4_CCR2_CCR2_H_Shift, 16   @ bitWidth 16 (High Capture/Compare 2  value)  
        .equ TIM4_CCR2_CCR2_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare 2  value)  
 
    .equ TIM4_CCR3, TIM4_BASE + 0x3C @ (capture/compare register 3) 
        .equ TIM4_CCR3_CCR3_H_Shift, 16   @ bitWidth 16 (High Capture/Compare value)  
        .equ TIM4_CCR3_CCR3_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare value)  
 
    .equ TIM4_CCR4, TIM4_BASE + 0x40 @ (capture/compare register 4) 
        .equ TIM4_CCR4_CCR4_H_Shift, 16   @ bitWidth 16 (High Capture/Compare value)  
        .equ TIM4_CCR4_CCR4_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare value)  
 
    .equ TIM4_DCR, TIM4_BASE + 0x48 @ (DMA control register) 
        .equ TIM4_DCR_DBL_Shift, 8   @ bitWidth 5 (DMA burst length)  
        .equ TIM4_DCR_DBA_Shift, 0   @ bitWidth 5 (DMA base address)  
 
    .equ TIM4_DMAR, TIM4_BASE + 0x4C @ (DMA address for full transfer) 
        .equ TIM4_DMAR_DMAB_Shift, 0   @ bitWidth 16 (DMA register for burst  accesses)  
 
    .equ TIM4_AF1, TIM4_BASE + 0x60 @ (TIM alternate function option register  1) 
        .equ TIM4_AF1_ETRSEL_Shift, 14   @ bitWidth 4 (ETR source selection)  
 
    .equ TIM4_TISEL, TIM4_BASE + 0x68 @ (TIM timer input selection  register) 
        .equ TIM4_TISEL_TI1SEL_Shift, 0   @ bitWidth 4 (TI1[0] to TI1[15] input  selection)  
        .equ TIM4_TISEL_TI2SEL_Shift, 8   @ bitWidth 4 (TI2[0] to TI2[15] input  selection)  
        .equ TIM4_TISEL_TI3SEL_Shift, 16   @ bitWidth 4 (TI3[0] to TI3[15] input  selection)  
        .equ TIM4_TISEL_TI4SEL_Shift, 24   @ bitWidth 4 (TI4[0] to TI4[15] input  selection)  
 

@=========================== TIM5 ===========================@
.equ TIM5_BASE, 0x40000C00 @ (General purpose timers) 
    .equ TIM5_CR1, TIM5_BASE + 0x0 @ (control register 1) 
        .equ TIM5_CR1_UIFREMAP, 1 << 11   @ bitWidth 1 (UIF status bit remapping)  
        .equ TIM5_CR1_CKD_Shift, 8   @ bitWidth 2 (Clock division)  
        .equ TIM5_CR1_ARPE, 1 << 7   @ bitWidth 1 (Auto-reload preload enable)  
        .equ TIM5_CR1_CMS_Shift, 5   @ bitWidth 2 (Center-aligned mode  selection)  
        .equ TIM5_CR1_DIR, 1 << 4   @ bitWidth 1 (Direction)  
        .equ TIM5_CR1_OPM, 1 << 3   @ bitWidth 1 (One-pulse mode)  
        .equ TIM5_CR1_URS, 1 << 2   @ bitWidth 1 (Update request source)  
        .equ TIM5_CR1_UDIS, 1 << 1   @ bitWidth 1 (Update disable)  
        .equ TIM5_CR1_CEN, 1 << 0   @ bitWidth 1 (Counter enable)  
 
    .equ TIM5_CR2, TIM5_BASE + 0x4 @ (control register 2) 
        .equ TIM5_CR2_TI1S, 1 << 7   @ bitWidth 1 (TI1 selection)  
        .equ TIM5_CR2_MMS_Shift, 4   @ bitWidth 3 (Master mode selection)  
        .equ TIM5_CR2_CCDS, 1 << 3   @ bitWidth 1 (Capture/compare DMA  selection)  
 
    .equ TIM5_SMCR, TIM5_BASE + 0x8 @ (slave mode control register) 
        .equ TIM5_SMCR_TS_4_3_Shift, 20   @ bitWidth 2 (Trigger selection)  
        .equ TIM5_SMCR_SMS_3, 1 << 16   @ bitWidth 1 (Slave mode selection - bit  3)  
        .equ TIM5_SMCR_ETP, 1 << 15   @ bitWidth 1 (External trigger polarity)  
        .equ TIM5_SMCR_ECE, 1 << 14   @ bitWidth 1 (External clock enable)  
        .equ TIM5_SMCR_ETPS_Shift, 12   @ bitWidth 2 (External trigger prescaler)  
        .equ TIM5_SMCR_ETF_Shift, 8   @ bitWidth 4 (External trigger filter)  
        .equ TIM5_SMCR_MSM, 1 << 7   @ bitWidth 1 (Master/Slave mode)  
        .equ TIM5_SMCR_TS_Shift, 4   @ bitWidth 3 (Trigger selection)  
        .equ TIM5_SMCR_SMS_Shift, 0   @ bitWidth 3 (Slave mode selection)  
 
    .equ TIM5_DIER, TIM5_BASE + 0xC @ (DMA/Interrupt enable register) 
        .equ TIM5_DIER_TDE, 1 << 14   @ bitWidth 1 (Trigger DMA request enable)  
        .equ TIM5_DIER_CC4DE, 1 << 12   @ bitWidth 1 (Capture/Compare 4 DMA request  enable)  
        .equ TIM5_DIER_CC3DE, 1 << 11   @ bitWidth 1 (Capture/Compare 3 DMA request  enable)  
        .equ TIM5_DIER_CC2DE, 1 << 10   @ bitWidth 1 (Capture/Compare 2 DMA request  enable)  
        .equ TIM5_DIER_CC1DE, 1 << 9   @ bitWidth 1 (Capture/Compare 1 DMA request  enable)  
        .equ TIM5_DIER_UDE, 1 << 8   @ bitWidth 1 (Update DMA request enable)  
        .equ TIM5_DIER_TIE, 1 << 6   @ bitWidth 1 (Trigger interrupt enable)  
        .equ TIM5_DIER_CC4IE, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  enable)  
        .equ TIM5_DIER_CC3IE, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  enable)  
        .equ TIM5_DIER_CC2IE, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  enable)  
        .equ TIM5_DIER_CC1IE, 1 << 1   @ bitWidth 1 (Capture/Compare 1 interrupt  enable)  
        .equ TIM5_DIER_UIE, 1 << 0   @ bitWidth 1 (Update interrupt enable)  
 
    .equ TIM5_SR, TIM5_BASE + 0x10 @ (status register) 
        .equ TIM5_SR_CC4OF, 1 << 12   @ bitWidth 1 (Capture/Compare 4 overcapture  flag)  
        .equ TIM5_SR_CC3OF, 1 << 11   @ bitWidth 1 (Capture/Compare 3 overcapture  flag)  
        .equ TIM5_SR_CC2OF, 1 << 10   @ bitWidth 1 (Capture/compare 2 overcapture  flag)  
        .equ TIM5_SR_CC1OF, 1 << 9   @ bitWidth 1 (Capture/Compare 1 overcapture  flag)  
        .equ TIM5_SR_TIF, 1 << 6   @ bitWidth 1 (Trigger interrupt flag)  
        .equ TIM5_SR_CC4IF, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  flag)  
        .equ TIM5_SR_CC3IF, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  flag)  
        .equ TIM5_SR_CC2IF, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  flag)  
        .equ TIM5_SR_CC1IF, 1 << 1   @ bitWidth 1 (Capture/compare 1 interrupt  flag)  
        .equ TIM5_SR_UIF, 1 << 0   @ bitWidth 1 (Update interrupt flag)  
 
    .equ TIM5_EGR, TIM5_BASE + 0x14 @ (event generation register) 
        .equ TIM5_EGR_TG, 1 << 6   @ bitWidth 1 (Trigger generation)  
        .equ TIM5_EGR_CC4G, 1 << 4   @ bitWidth 1 (Capture/compare 4  generation)  
        .equ TIM5_EGR_CC3G, 1 << 3   @ bitWidth 1 (Capture/compare 3  generation)  
        .equ TIM5_EGR_CC2G, 1 << 2   @ bitWidth 1 (Capture/compare 2  generation)  
        .equ TIM5_EGR_CC1G, 1 << 1   @ bitWidth 1 (Capture/compare 1  generation)  
        .equ TIM5_EGR_UG, 1 << 0   @ bitWidth 1 (Update generation)  
 
    .equ TIM5_CCMR1_Output, TIM5_BASE + 0x18 @ (capture/compare mode register 1 output  mode) 
        .equ TIM5_CCMR1_Output_CC1S_Shift, 0   @ bitWidth 2 (CC1S)  
        .equ TIM5_CCMR1_Output_OC1FE, 1 << 2   @ bitWidth 1 (OC1FE)  
        .equ TIM5_CCMR1_Output_OC1PE, 1 << 3   @ bitWidth 1 (OC1PE)  
        .equ TIM5_CCMR1_Output_OC1M_Shift, 4   @ bitWidth 3 (OC1M)  
        .equ TIM5_CCMR1_Output_OC1CE, 1 << 7   @ bitWidth 1 (OC1CE)  
        .equ TIM5_CCMR1_Output_CC2S_Shift, 8   @ bitWidth 2 (CC2S)  
        .equ TIM5_CCMR1_Output_OC2FE, 1 << 10   @ bitWidth 1 (OC2FE)  
        .equ TIM5_CCMR1_Output_OC2PE, 1 << 11   @ bitWidth 1 (OC2PE)  
        .equ TIM5_CCMR1_Output_OC2M_Shift, 12   @ bitWidth 3 (OC2M)  
        .equ TIM5_CCMR1_Output_OC2CE, 1 << 15   @ bitWidth 1 (OC2CE)  
        .equ TIM5_CCMR1_Output_OC1M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode - bit  3)  
        .equ TIM5_CCMR1_Output_OC2M_3, 1 << 24   @ bitWidth 1 (Output Compare 2 mode - bit  3)  
 
    .equ TIM5_CCMR1_Input, TIM5_BASE + 0x18 @ (capture/compare mode register 1 input  mode) 
        .equ TIM5_CCMR1_Input_IC2F_Shift, 12   @ bitWidth 4 (Input capture 2 filter)  
        .equ TIM5_CCMR1_Input_IC2PCS_Shift, 10   @ bitWidth 2 (Input capture 2 prescaler)  
        .equ TIM5_CCMR1_Input_CC2S_Shift, 8   @ bitWidth 2 (Capture/Compare 2  selection)  
        .equ TIM5_CCMR1_Input_IC1F_Shift, 4   @ bitWidth 4 (Input capture 1 filter)  
        .equ TIM5_CCMR1_Input_ICPCS_Shift, 2   @ bitWidth 2 (Input capture 1 prescaler)  
        .equ TIM5_CCMR1_Input_CC1S_Shift, 0   @ bitWidth 2 (Capture/Compare 1  selection)  
 
    .equ TIM5_CCMR2_Output, TIM5_BASE + 0x1C @ (capture/compare mode register 2 output  mode) 
        .equ TIM5_CCMR2_Output_OC4M_3, 1 << 24   @ bitWidth 1 (Output Compare 2 mode - bit  3)  
        .equ TIM5_CCMR2_Output_OC3M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode - bit  3)  
        .equ TIM5_CCMR2_Output_O24CE, 1 << 15   @ bitWidth 1 (O24CE)  
        .equ TIM5_CCMR2_Output_OC4M_Shift, 12   @ bitWidth 3 (OC4M)  
        .equ TIM5_CCMR2_Output_OC4PE, 1 << 11   @ bitWidth 1 (OC4PE)  
        .equ TIM5_CCMR2_Output_OC4FE, 1 << 10   @ bitWidth 1 (OC4FE)  
        .equ TIM5_CCMR2_Output_CC4S_Shift, 8   @ bitWidth 2 (CC4S)  
        .equ TIM5_CCMR2_Output_OC3CE, 1 << 7   @ bitWidth 1 (OC3CE)  
        .equ TIM5_CCMR2_Output_OC3M_Shift, 4   @ bitWidth 3 (OC3M)  
        .equ TIM5_CCMR2_Output_OC3PE, 1 << 3   @ bitWidth 1 (OC3PE)  
        .equ TIM5_CCMR2_Output_OC3FE, 1 << 2   @ bitWidth 1 (OC3FE)  
        .equ TIM5_CCMR2_Output_CC3S_Shift, 0   @ bitWidth 2 (CC3S)  
 
    .equ TIM5_CCMR2_Input, TIM5_BASE + 0x1C @ (capture/compare mode register 2 input  mode) 
        .equ TIM5_CCMR2_Input_IC4F_Shift, 12   @ bitWidth 4 (Input capture 4 filter)  
        .equ TIM5_CCMR2_Input_IC4PSC_Shift, 10   @ bitWidth 2 (Input capture 4 prescaler)  
        .equ TIM5_CCMR2_Input_CC4S_Shift, 8   @ bitWidth 2 (Capture/Compare 4  selection)  
        .equ TIM5_CCMR2_Input_IC3F_Shift, 4   @ bitWidth 4 (Input capture 3 filter)  
        .equ TIM5_CCMR2_Input_IC3PSC_Shift, 2   @ bitWidth 2 (Input capture 3 prescaler)  
        .equ TIM5_CCMR2_Input_CC3S_Shift, 0   @ bitWidth 2 (Capture/compare 3  selection)  
 
    .equ TIM5_CCER, TIM5_BASE + 0x20 @ (capture/compare enable  register) 
        .equ TIM5_CCER_CC4NP, 1 << 15   @ bitWidth 1 (Capture/Compare 4 output  Polarity)  
        .equ TIM5_CCER_CC4P, 1 << 13   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM5_CCER_CC4E, 1 << 12   @ bitWidth 1 (Capture/Compare 4 output  enable)  
        .equ TIM5_CCER_CC3NP, 1 << 11   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM5_CCER_CC3P, 1 << 9   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM5_CCER_CC3E, 1 << 8   @ bitWidth 1 (Capture/Compare 3 output  enable)  
        .equ TIM5_CCER_CC2NP, 1 << 7   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM5_CCER_CC2P, 1 << 5   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM5_CCER_CC2E, 1 << 4   @ bitWidth 1 (Capture/Compare 2 output  enable)  
        .equ TIM5_CCER_CC1NP, 1 << 3   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM5_CCER_CC1P, 1 << 1   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM5_CCER_CC1E, 1 << 0   @ bitWidth 1 (Capture/Compare 1 output  enable)  
 
    .equ TIM5_CNT, TIM5_BASE + 0x24 @ (counter) 
        .equ TIM5_CNT_CNT_L_Shift, 0   @ bitWidth 16 (low counter value)  
        .equ TIM5_CNT_CNT_H_Shift, 16   @ bitWidth 16 (High counter value)  
 
    .equ TIM5_PSC, TIM5_BASE + 0x28 @ (prescaler) 
        .equ TIM5_PSC_PSC_Shift, 0   @ bitWidth 16 (Prescaler value)  
 
    .equ TIM5_ARR, TIM5_BASE + 0x2C @ (auto-reload register) 
        .equ TIM5_ARR_ARR_H_Shift, 16   @ bitWidth 16 (High Auto-reload value)  
        .equ TIM5_ARR_ARR_L_Shift, 0   @ bitWidth 16 (Low Auto-reload value)  
 
    .equ TIM5_CCR1, TIM5_BASE + 0x34 @ (capture/compare register 1) 
        .equ TIM5_CCR1_CCR1_H_Shift, 16   @ bitWidth 16 (High Capture/Compare 1  value)  
        .equ TIM5_CCR1_CCR1_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare 1  value)  
 
    .equ TIM5_CCR2, TIM5_BASE + 0x38 @ (capture/compare register 2) 
        .equ TIM5_CCR2_CCR2_H_Shift, 16   @ bitWidth 16 (High Capture/Compare 2  value)  
        .equ TIM5_CCR2_CCR2_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare 2  value)  
 
    .equ TIM5_CCR3, TIM5_BASE + 0x3C @ (capture/compare register 3) 
        .equ TIM5_CCR3_CCR3_H_Shift, 16   @ bitWidth 16 (High Capture/Compare value)  
        .equ TIM5_CCR3_CCR3_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare value)  
 
    .equ TIM5_CCR4, TIM5_BASE + 0x40 @ (capture/compare register 4) 
        .equ TIM5_CCR4_CCR4_H_Shift, 16   @ bitWidth 16 (High Capture/Compare value)  
        .equ TIM5_CCR4_CCR4_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare value)  
 
    .equ TIM5_DCR, TIM5_BASE + 0x48 @ (DMA control register) 
        .equ TIM5_DCR_DBL_Shift, 8   @ bitWidth 5 (DMA burst length)  
        .equ TIM5_DCR_DBA_Shift, 0   @ bitWidth 5 (DMA base address)  
 
    .equ TIM5_DMAR, TIM5_BASE + 0x4C @ (DMA address for full transfer) 
        .equ TIM5_DMAR_DMAB_Shift, 0   @ bitWidth 16 (DMA register for burst  accesses)  
 
    .equ TIM5_AF1, TIM5_BASE + 0x60 @ (TIM alternate function option register  1) 
        .equ TIM5_AF1_ETRSEL_Shift, 14   @ bitWidth 4 (ETR source selection)  
 
    .equ TIM5_TISEL, TIM5_BASE + 0x68 @ (TIM timer input selection  register) 
        .equ TIM5_TISEL_TI1SEL_Shift, 0   @ bitWidth 4 (TI1[0] to TI1[15] input  selection)  
        .equ TIM5_TISEL_TI2SEL_Shift, 8   @ bitWidth 4 (TI2[0] to TI2[15] input  selection)  
        .equ TIM5_TISEL_TI3SEL_Shift, 16   @ bitWidth 4 (TI3[0] to TI3[15] input  selection)  
        .equ TIM5_TISEL_TI4SEL_Shift, 24   @ bitWidth 4 (TI4[0] to TI4[15] input  selection)  
 

@=========================== TIM12 ===========================@
.equ TIM12_BASE, 0x40001800 @ (General purpose timers) 
    .equ TIM12_CR1, TIM12_BASE + 0x0 @ (control register 1) 
        .equ TIM12_CR1_UIFREMAP, 1 << 11   @ bitWidth 1 (UIF status bit remapping)  
        .equ TIM12_CR1_CKD_Shift, 8   @ bitWidth 2 (Clock division)  
        .equ TIM12_CR1_ARPE, 1 << 7   @ bitWidth 1 (Auto-reload preload enable)  
        .equ TIM12_CR1_CMS_Shift, 5   @ bitWidth 2 (Center-aligned mode  selection)  
        .equ TIM12_CR1_DIR, 1 << 4   @ bitWidth 1 (Direction)  
        .equ TIM12_CR1_OPM, 1 << 3   @ bitWidth 1 (One-pulse mode)  
        .equ TIM12_CR1_URS, 1 << 2   @ bitWidth 1 (Update request source)  
        .equ TIM12_CR1_UDIS, 1 << 1   @ bitWidth 1 (Update disable)  
        .equ TIM12_CR1_CEN, 1 << 0   @ bitWidth 1 (Counter enable)  
 
    .equ TIM12_CR2, TIM12_BASE + 0x4 @ (control register 2) 
        .equ TIM12_CR2_TI1S, 1 << 7   @ bitWidth 1 (TI1 selection)  
        .equ TIM12_CR2_MMS_Shift, 4   @ bitWidth 3 (Master mode selection)  
        .equ TIM12_CR2_CCDS, 1 << 3   @ bitWidth 1 (Capture/compare DMA  selection)  
 
    .equ TIM12_SMCR, TIM12_BASE + 0x8 @ (slave mode control register) 
        .equ TIM12_SMCR_TS_4_3_Shift, 20   @ bitWidth 2 (Trigger selection)  
        .equ TIM12_SMCR_SMS_3, 1 << 16   @ bitWidth 1 (Slave mode selection - bit  3)  
        .equ TIM12_SMCR_ETP, 1 << 15   @ bitWidth 1 (External trigger polarity)  
        .equ TIM12_SMCR_ECE, 1 << 14   @ bitWidth 1 (External clock enable)  
        .equ TIM12_SMCR_ETPS_Shift, 12   @ bitWidth 2 (External trigger prescaler)  
        .equ TIM12_SMCR_ETF_Shift, 8   @ bitWidth 4 (External trigger filter)  
        .equ TIM12_SMCR_MSM, 1 << 7   @ bitWidth 1 (Master/Slave mode)  
        .equ TIM12_SMCR_TS_Shift, 4   @ bitWidth 3 (Trigger selection)  
        .equ TIM12_SMCR_SMS_Shift, 0   @ bitWidth 3 (Slave mode selection)  
 
    .equ TIM12_DIER, TIM12_BASE + 0xC @ (DMA/Interrupt enable register) 
        .equ TIM12_DIER_TDE, 1 << 14   @ bitWidth 1 (Trigger DMA request enable)  
        .equ TIM12_DIER_CC4DE, 1 << 12   @ bitWidth 1 (Capture/Compare 4 DMA request  enable)  
        .equ TIM12_DIER_CC3DE, 1 << 11   @ bitWidth 1 (Capture/Compare 3 DMA request  enable)  
        .equ TIM12_DIER_CC2DE, 1 << 10   @ bitWidth 1 (Capture/Compare 2 DMA request  enable)  
        .equ TIM12_DIER_CC1DE, 1 << 9   @ bitWidth 1 (Capture/Compare 1 DMA request  enable)  
        .equ TIM12_DIER_UDE, 1 << 8   @ bitWidth 1 (Update DMA request enable)  
        .equ TIM12_DIER_TIE, 1 << 6   @ bitWidth 1 (Trigger interrupt enable)  
        .equ TIM12_DIER_CC4IE, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  enable)  
        .equ TIM12_DIER_CC3IE, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  enable)  
        .equ TIM12_DIER_CC2IE, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  enable)  
        .equ TIM12_DIER_CC1IE, 1 << 1   @ bitWidth 1 (Capture/Compare 1 interrupt  enable)  
        .equ TIM12_DIER_UIE, 1 << 0   @ bitWidth 1 (Update interrupt enable)  
 
    .equ TIM12_SR, TIM12_BASE + 0x10 @ (status register) 
        .equ TIM12_SR_CC4OF, 1 << 12   @ bitWidth 1 (Capture/Compare 4 overcapture  flag)  
        .equ TIM12_SR_CC3OF, 1 << 11   @ bitWidth 1 (Capture/Compare 3 overcapture  flag)  
        .equ TIM12_SR_CC2OF, 1 << 10   @ bitWidth 1 (Capture/compare 2 overcapture  flag)  
        .equ TIM12_SR_CC1OF, 1 << 9   @ bitWidth 1 (Capture/Compare 1 overcapture  flag)  
        .equ TIM12_SR_TIF, 1 << 6   @ bitWidth 1 (Trigger interrupt flag)  
        .equ TIM12_SR_CC4IF, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  flag)  
        .equ TIM12_SR_CC3IF, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  flag)  
        .equ TIM12_SR_CC2IF, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  flag)  
        .equ TIM12_SR_CC1IF, 1 << 1   @ bitWidth 1 (Capture/compare 1 interrupt  flag)  
        .equ TIM12_SR_UIF, 1 << 0   @ bitWidth 1 (Update interrupt flag)  
 
    .equ TIM12_EGR, TIM12_BASE + 0x14 @ (event generation register) 
        .equ TIM12_EGR_TG, 1 << 6   @ bitWidth 1 (Trigger generation)  
        .equ TIM12_EGR_CC4G, 1 << 4   @ bitWidth 1 (Capture/compare 4  generation)  
        .equ TIM12_EGR_CC3G, 1 << 3   @ bitWidth 1 (Capture/compare 3  generation)  
        .equ TIM12_EGR_CC2G, 1 << 2   @ bitWidth 1 (Capture/compare 2  generation)  
        .equ TIM12_EGR_CC1G, 1 << 1   @ bitWidth 1 (Capture/compare 1  generation)  
        .equ TIM12_EGR_UG, 1 << 0   @ bitWidth 1 (Update generation)  
 
    .equ TIM12_CCMR1_Output, TIM12_BASE + 0x18 @ (capture/compare mode register 1 output  mode) 
        .equ TIM12_CCMR1_Output_CC1S_Shift, 0   @ bitWidth 2 (CC1S)  
        .equ TIM12_CCMR1_Output_OC1FE, 1 << 2   @ bitWidth 1 (OC1FE)  
        .equ TIM12_CCMR1_Output_OC1PE, 1 << 3   @ bitWidth 1 (OC1PE)  
        .equ TIM12_CCMR1_Output_OC1M_Shift, 4   @ bitWidth 3 (OC1M)  
        .equ TIM12_CCMR1_Output_OC1CE, 1 << 7   @ bitWidth 1 (OC1CE)  
        .equ TIM12_CCMR1_Output_CC2S_Shift, 8   @ bitWidth 2 (CC2S)  
        .equ TIM12_CCMR1_Output_OC2FE, 1 << 10   @ bitWidth 1 (OC2FE)  
        .equ TIM12_CCMR1_Output_OC2PE, 1 << 11   @ bitWidth 1 (OC2PE)  
        .equ TIM12_CCMR1_Output_OC2M_Shift, 12   @ bitWidth 3 (OC2M)  
        .equ TIM12_CCMR1_Output_OC2CE, 1 << 15   @ bitWidth 1 (OC2CE)  
        .equ TIM12_CCMR1_Output_OC1M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode - bit  3)  
        .equ TIM12_CCMR1_Output_OC2M_3, 1 << 24   @ bitWidth 1 (Output Compare 2 mode - bit  3)  
 
    .equ TIM12_CCMR1_Input, TIM12_BASE + 0x18 @ (capture/compare mode register 1 input  mode) 
        .equ TIM12_CCMR1_Input_IC2F_Shift, 12   @ bitWidth 4 (Input capture 2 filter)  
        .equ TIM12_CCMR1_Input_IC2PCS_Shift, 10   @ bitWidth 2 (Input capture 2 prescaler)  
        .equ TIM12_CCMR1_Input_CC2S_Shift, 8   @ bitWidth 2 (Capture/Compare 2  selection)  
        .equ TIM12_CCMR1_Input_IC1F_Shift, 4   @ bitWidth 4 (Input capture 1 filter)  
        .equ TIM12_CCMR1_Input_ICPCS_Shift, 2   @ bitWidth 2 (Input capture 1 prescaler)  
        .equ TIM12_CCMR1_Input_CC1S_Shift, 0   @ bitWidth 2 (Capture/Compare 1  selection)  
 
    .equ TIM12_CCMR2_Output, TIM12_BASE + 0x1C @ (capture/compare mode register 2 output  mode) 
        .equ TIM12_CCMR2_Output_OC4M_3, 1 << 24   @ bitWidth 1 (Output Compare 2 mode - bit  3)  
        .equ TIM12_CCMR2_Output_OC3M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode - bit  3)  
        .equ TIM12_CCMR2_Output_O24CE, 1 << 15   @ bitWidth 1 (O24CE)  
        .equ TIM12_CCMR2_Output_OC4M_Shift, 12   @ bitWidth 3 (OC4M)  
        .equ TIM12_CCMR2_Output_OC4PE, 1 << 11   @ bitWidth 1 (OC4PE)  
        .equ TIM12_CCMR2_Output_OC4FE, 1 << 10   @ bitWidth 1 (OC4FE)  
        .equ TIM12_CCMR2_Output_CC4S_Shift, 8   @ bitWidth 2 (CC4S)  
        .equ TIM12_CCMR2_Output_OC3CE, 1 << 7   @ bitWidth 1 (OC3CE)  
        .equ TIM12_CCMR2_Output_OC3M_Shift, 4   @ bitWidth 3 (OC3M)  
        .equ TIM12_CCMR2_Output_OC3PE, 1 << 3   @ bitWidth 1 (OC3PE)  
        .equ TIM12_CCMR2_Output_OC3FE, 1 << 2   @ bitWidth 1 (OC3FE)  
        .equ TIM12_CCMR2_Output_CC3S_Shift, 0   @ bitWidth 2 (CC3S)  
 
    .equ TIM12_CCMR2_Input, TIM12_BASE + 0x1C @ (capture/compare mode register 2 input  mode) 
        .equ TIM12_CCMR2_Input_IC4F_Shift, 12   @ bitWidth 4 (Input capture 4 filter)  
        .equ TIM12_CCMR2_Input_IC4PSC_Shift, 10   @ bitWidth 2 (Input capture 4 prescaler)  
        .equ TIM12_CCMR2_Input_CC4S_Shift, 8   @ bitWidth 2 (Capture/Compare 4  selection)  
        .equ TIM12_CCMR2_Input_IC3F_Shift, 4   @ bitWidth 4 (Input capture 3 filter)  
        .equ TIM12_CCMR2_Input_IC3PSC_Shift, 2   @ bitWidth 2 (Input capture 3 prescaler)  
        .equ TIM12_CCMR2_Input_CC3S_Shift, 0   @ bitWidth 2 (Capture/compare 3  selection)  
 
    .equ TIM12_CCER, TIM12_BASE + 0x20 @ (capture/compare enable  register) 
        .equ TIM12_CCER_CC4NP, 1 << 15   @ bitWidth 1 (Capture/Compare 4 output  Polarity)  
        .equ TIM12_CCER_CC4P, 1 << 13   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM12_CCER_CC4E, 1 << 12   @ bitWidth 1 (Capture/Compare 4 output  enable)  
        .equ TIM12_CCER_CC3NP, 1 << 11   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM12_CCER_CC3P, 1 << 9   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM12_CCER_CC3E, 1 << 8   @ bitWidth 1 (Capture/Compare 3 output  enable)  
        .equ TIM12_CCER_CC2NP, 1 << 7   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM12_CCER_CC2P, 1 << 5   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM12_CCER_CC2E, 1 << 4   @ bitWidth 1 (Capture/Compare 2 output  enable)  
        .equ TIM12_CCER_CC1NP, 1 << 3   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM12_CCER_CC1P, 1 << 1   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM12_CCER_CC1E, 1 << 0   @ bitWidth 1 (Capture/Compare 1 output  enable)  
 
    .equ TIM12_CNT, TIM12_BASE + 0x24 @ (counter) 
        .equ TIM12_CNT_CNT_L_Shift, 0   @ bitWidth 16 (low counter value)  
        .equ TIM12_CNT_CNT_H_Shift, 16   @ bitWidth 16 (High counter value)  
 
    .equ TIM12_PSC, TIM12_BASE + 0x28 @ (prescaler) 
        .equ TIM12_PSC_PSC_Shift, 0   @ bitWidth 16 (Prescaler value)  
 
    .equ TIM12_ARR, TIM12_BASE + 0x2C @ (auto-reload register) 
        .equ TIM12_ARR_ARR_H_Shift, 16   @ bitWidth 16 (High Auto-reload value)  
        .equ TIM12_ARR_ARR_L_Shift, 0   @ bitWidth 16 (Low Auto-reload value)  
 
    .equ TIM12_CCR1, TIM12_BASE + 0x34 @ (capture/compare register 1) 
        .equ TIM12_CCR1_CCR1_H_Shift, 16   @ bitWidth 16 (High Capture/Compare 1  value)  
        .equ TIM12_CCR1_CCR1_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare 1  value)  
 
    .equ TIM12_CCR2, TIM12_BASE + 0x38 @ (capture/compare register 2) 
        .equ TIM12_CCR2_CCR2_H_Shift, 16   @ bitWidth 16 (High Capture/Compare 2  value)  
        .equ TIM12_CCR2_CCR2_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare 2  value)  
 
    .equ TIM12_CCR3, TIM12_BASE + 0x3C @ (capture/compare register 3) 
        .equ TIM12_CCR3_CCR3_H_Shift, 16   @ bitWidth 16 (High Capture/Compare value)  
        .equ TIM12_CCR3_CCR3_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare value)  
 
    .equ TIM12_CCR4, TIM12_BASE + 0x40 @ (capture/compare register 4) 
        .equ TIM12_CCR4_CCR4_H_Shift, 16   @ bitWidth 16 (High Capture/Compare value)  
        .equ TIM12_CCR4_CCR4_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare value)  
 
    .equ TIM12_DCR, TIM12_BASE + 0x48 @ (DMA control register) 
        .equ TIM12_DCR_DBL_Shift, 8   @ bitWidth 5 (DMA burst length)  
        .equ TIM12_DCR_DBA_Shift, 0   @ bitWidth 5 (DMA base address)  
 
    .equ TIM12_DMAR, TIM12_BASE + 0x4C @ (DMA address for full transfer) 
        .equ TIM12_DMAR_DMAB_Shift, 0   @ bitWidth 16 (DMA register for burst  accesses)  
 
    .equ TIM12_AF1, TIM12_BASE + 0x60 @ (TIM alternate function option register  1) 
        .equ TIM12_AF1_ETRSEL_Shift, 14   @ bitWidth 4 (ETR source selection)  
 
    .equ TIM12_TISEL, TIM12_BASE + 0x68 @ (TIM timer input selection  register) 
        .equ TIM12_TISEL_TI1SEL_Shift, 0   @ bitWidth 4 (TI1[0] to TI1[15] input  selection)  
        .equ TIM12_TISEL_TI2SEL_Shift, 8   @ bitWidth 4 (TI2[0] to TI2[15] input  selection)  
        .equ TIM12_TISEL_TI3SEL_Shift, 16   @ bitWidth 4 (TI3[0] to TI3[15] input  selection)  
        .equ TIM12_TISEL_TI4SEL_Shift, 24   @ bitWidth 4 (TI4[0] to TI4[15] input  selection)  
 

@=========================== TIM13 ===========================@
.equ TIM13_BASE, 0x40001C00 @ (General purpose timers) 
    .equ TIM13_CR1, TIM13_BASE + 0x0 @ (control register 1) 
        .equ TIM13_CR1_UIFREMAP, 1 << 11   @ bitWidth 1 (UIF status bit remapping)  
        .equ TIM13_CR1_CKD_Shift, 8   @ bitWidth 2 (Clock division)  
        .equ TIM13_CR1_ARPE, 1 << 7   @ bitWidth 1 (Auto-reload preload enable)  
        .equ TIM13_CR1_CMS_Shift, 5   @ bitWidth 2 (Center-aligned mode  selection)  
        .equ TIM13_CR1_DIR, 1 << 4   @ bitWidth 1 (Direction)  
        .equ TIM13_CR1_OPM, 1 << 3   @ bitWidth 1 (One-pulse mode)  
        .equ TIM13_CR1_URS, 1 << 2   @ bitWidth 1 (Update request source)  
        .equ TIM13_CR1_UDIS, 1 << 1   @ bitWidth 1 (Update disable)  
        .equ TIM13_CR1_CEN, 1 << 0   @ bitWidth 1 (Counter enable)  
 
    .equ TIM13_CR2, TIM13_BASE + 0x4 @ (control register 2) 
        .equ TIM13_CR2_TI1S, 1 << 7   @ bitWidth 1 (TI1 selection)  
        .equ TIM13_CR2_MMS_Shift, 4   @ bitWidth 3 (Master mode selection)  
        .equ TIM13_CR2_CCDS, 1 << 3   @ bitWidth 1 (Capture/compare DMA  selection)  
 
    .equ TIM13_SMCR, TIM13_BASE + 0x8 @ (slave mode control register) 
        .equ TIM13_SMCR_TS_4_3_Shift, 20   @ bitWidth 2 (Trigger selection)  
        .equ TIM13_SMCR_SMS_3, 1 << 16   @ bitWidth 1 (Slave mode selection - bit  3)  
        .equ TIM13_SMCR_ETP, 1 << 15   @ bitWidth 1 (External trigger polarity)  
        .equ TIM13_SMCR_ECE, 1 << 14   @ bitWidth 1 (External clock enable)  
        .equ TIM13_SMCR_ETPS_Shift, 12   @ bitWidth 2 (External trigger prescaler)  
        .equ TIM13_SMCR_ETF_Shift, 8   @ bitWidth 4 (External trigger filter)  
        .equ TIM13_SMCR_MSM, 1 << 7   @ bitWidth 1 (Master/Slave mode)  
        .equ TIM13_SMCR_TS_Shift, 4   @ bitWidth 3 (Trigger selection)  
        .equ TIM13_SMCR_SMS_Shift, 0   @ bitWidth 3 (Slave mode selection)  
 
    .equ TIM13_DIER, TIM13_BASE + 0xC @ (DMA/Interrupt enable register) 
        .equ TIM13_DIER_TDE, 1 << 14   @ bitWidth 1 (Trigger DMA request enable)  
        .equ TIM13_DIER_CC4DE, 1 << 12   @ bitWidth 1 (Capture/Compare 4 DMA request  enable)  
        .equ TIM13_DIER_CC3DE, 1 << 11   @ bitWidth 1 (Capture/Compare 3 DMA request  enable)  
        .equ TIM13_DIER_CC2DE, 1 << 10   @ bitWidth 1 (Capture/Compare 2 DMA request  enable)  
        .equ TIM13_DIER_CC1DE, 1 << 9   @ bitWidth 1 (Capture/Compare 1 DMA request  enable)  
        .equ TIM13_DIER_UDE, 1 << 8   @ bitWidth 1 (Update DMA request enable)  
        .equ TIM13_DIER_TIE, 1 << 6   @ bitWidth 1 (Trigger interrupt enable)  
        .equ TIM13_DIER_CC4IE, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  enable)  
        .equ TIM13_DIER_CC3IE, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  enable)  
        .equ TIM13_DIER_CC2IE, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  enable)  
        .equ TIM13_DIER_CC1IE, 1 << 1   @ bitWidth 1 (Capture/Compare 1 interrupt  enable)  
        .equ TIM13_DIER_UIE, 1 << 0   @ bitWidth 1 (Update interrupt enable)  
 
    .equ TIM13_SR, TIM13_BASE + 0x10 @ (status register) 
        .equ TIM13_SR_CC4OF, 1 << 12   @ bitWidth 1 (Capture/Compare 4 overcapture  flag)  
        .equ TIM13_SR_CC3OF, 1 << 11   @ bitWidth 1 (Capture/Compare 3 overcapture  flag)  
        .equ TIM13_SR_CC2OF, 1 << 10   @ bitWidth 1 (Capture/compare 2 overcapture  flag)  
        .equ TIM13_SR_CC1OF, 1 << 9   @ bitWidth 1 (Capture/Compare 1 overcapture  flag)  
        .equ TIM13_SR_TIF, 1 << 6   @ bitWidth 1 (Trigger interrupt flag)  
        .equ TIM13_SR_CC4IF, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  flag)  
        .equ TIM13_SR_CC3IF, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  flag)  
        .equ TIM13_SR_CC2IF, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  flag)  
        .equ TIM13_SR_CC1IF, 1 << 1   @ bitWidth 1 (Capture/compare 1 interrupt  flag)  
        .equ TIM13_SR_UIF, 1 << 0   @ bitWidth 1 (Update interrupt flag)  
 
    .equ TIM13_EGR, TIM13_BASE + 0x14 @ (event generation register) 
        .equ TIM13_EGR_TG, 1 << 6   @ bitWidth 1 (Trigger generation)  
        .equ TIM13_EGR_CC4G, 1 << 4   @ bitWidth 1 (Capture/compare 4  generation)  
        .equ TIM13_EGR_CC3G, 1 << 3   @ bitWidth 1 (Capture/compare 3  generation)  
        .equ TIM13_EGR_CC2G, 1 << 2   @ bitWidth 1 (Capture/compare 2  generation)  
        .equ TIM13_EGR_CC1G, 1 << 1   @ bitWidth 1 (Capture/compare 1  generation)  
        .equ TIM13_EGR_UG, 1 << 0   @ bitWidth 1 (Update generation)  
 
    .equ TIM13_CCMR1_Output, TIM13_BASE + 0x18 @ (capture/compare mode register 1 output  mode) 
        .equ TIM13_CCMR1_Output_CC1S_Shift, 0   @ bitWidth 2 (CC1S)  
        .equ TIM13_CCMR1_Output_OC1FE, 1 << 2   @ bitWidth 1 (OC1FE)  
        .equ TIM13_CCMR1_Output_OC1PE, 1 << 3   @ bitWidth 1 (OC1PE)  
        .equ TIM13_CCMR1_Output_OC1M_Shift, 4   @ bitWidth 3 (OC1M)  
        .equ TIM13_CCMR1_Output_OC1CE, 1 << 7   @ bitWidth 1 (OC1CE)  
        .equ TIM13_CCMR1_Output_CC2S_Shift, 8   @ bitWidth 2 (CC2S)  
        .equ TIM13_CCMR1_Output_OC2FE, 1 << 10   @ bitWidth 1 (OC2FE)  
        .equ TIM13_CCMR1_Output_OC2PE, 1 << 11   @ bitWidth 1 (OC2PE)  
        .equ TIM13_CCMR1_Output_OC2M_Shift, 12   @ bitWidth 3 (OC2M)  
        .equ TIM13_CCMR1_Output_OC2CE, 1 << 15   @ bitWidth 1 (OC2CE)  
        .equ TIM13_CCMR1_Output_OC1M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode - bit  3)  
        .equ TIM13_CCMR1_Output_OC2M_3, 1 << 24   @ bitWidth 1 (Output Compare 2 mode - bit  3)  
 
    .equ TIM13_CCMR1_Input, TIM13_BASE + 0x18 @ (capture/compare mode register 1 input  mode) 
        .equ TIM13_CCMR1_Input_IC2F_Shift, 12   @ bitWidth 4 (Input capture 2 filter)  
        .equ TIM13_CCMR1_Input_IC2PCS_Shift, 10   @ bitWidth 2 (Input capture 2 prescaler)  
        .equ TIM13_CCMR1_Input_CC2S_Shift, 8   @ bitWidth 2 (Capture/Compare 2  selection)  
        .equ TIM13_CCMR1_Input_IC1F_Shift, 4   @ bitWidth 4 (Input capture 1 filter)  
        .equ TIM13_CCMR1_Input_ICPCS_Shift, 2   @ bitWidth 2 (Input capture 1 prescaler)  
        .equ TIM13_CCMR1_Input_CC1S_Shift, 0   @ bitWidth 2 (Capture/Compare 1  selection)  
 
    .equ TIM13_CCMR2_Output, TIM13_BASE + 0x1C @ (capture/compare mode register 2 output  mode) 
        .equ TIM13_CCMR2_Output_OC4M_3, 1 << 24   @ bitWidth 1 (Output Compare 2 mode - bit  3)  
        .equ TIM13_CCMR2_Output_OC3M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode - bit  3)  
        .equ TIM13_CCMR2_Output_O24CE, 1 << 15   @ bitWidth 1 (O24CE)  
        .equ TIM13_CCMR2_Output_OC4M_Shift, 12   @ bitWidth 3 (OC4M)  
        .equ TIM13_CCMR2_Output_OC4PE, 1 << 11   @ bitWidth 1 (OC4PE)  
        .equ TIM13_CCMR2_Output_OC4FE, 1 << 10   @ bitWidth 1 (OC4FE)  
        .equ TIM13_CCMR2_Output_CC4S_Shift, 8   @ bitWidth 2 (CC4S)  
        .equ TIM13_CCMR2_Output_OC3CE, 1 << 7   @ bitWidth 1 (OC3CE)  
        .equ TIM13_CCMR2_Output_OC3M_Shift, 4   @ bitWidth 3 (OC3M)  
        .equ TIM13_CCMR2_Output_OC3PE, 1 << 3   @ bitWidth 1 (OC3PE)  
        .equ TIM13_CCMR2_Output_OC3FE, 1 << 2   @ bitWidth 1 (OC3FE)  
        .equ TIM13_CCMR2_Output_CC3S_Shift, 0   @ bitWidth 2 (CC3S)  
 
    .equ TIM13_CCMR2_Input, TIM13_BASE + 0x1C @ (capture/compare mode register 2 input  mode) 
        .equ TIM13_CCMR2_Input_IC4F_Shift, 12   @ bitWidth 4 (Input capture 4 filter)  
        .equ TIM13_CCMR2_Input_IC4PSC_Shift, 10   @ bitWidth 2 (Input capture 4 prescaler)  
        .equ TIM13_CCMR2_Input_CC4S_Shift, 8   @ bitWidth 2 (Capture/Compare 4  selection)  
        .equ TIM13_CCMR2_Input_IC3F_Shift, 4   @ bitWidth 4 (Input capture 3 filter)  
        .equ TIM13_CCMR2_Input_IC3PSC_Shift, 2   @ bitWidth 2 (Input capture 3 prescaler)  
        .equ TIM13_CCMR2_Input_CC3S_Shift, 0   @ bitWidth 2 (Capture/compare 3  selection)  
 
    .equ TIM13_CCER, TIM13_BASE + 0x20 @ (capture/compare enable  register) 
        .equ TIM13_CCER_CC4NP, 1 << 15   @ bitWidth 1 (Capture/Compare 4 output  Polarity)  
        .equ TIM13_CCER_CC4P, 1 << 13   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM13_CCER_CC4E, 1 << 12   @ bitWidth 1 (Capture/Compare 4 output  enable)  
        .equ TIM13_CCER_CC3NP, 1 << 11   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM13_CCER_CC3P, 1 << 9   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM13_CCER_CC3E, 1 << 8   @ bitWidth 1 (Capture/Compare 3 output  enable)  
        .equ TIM13_CCER_CC2NP, 1 << 7   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM13_CCER_CC2P, 1 << 5   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM13_CCER_CC2E, 1 << 4   @ bitWidth 1 (Capture/Compare 2 output  enable)  
        .equ TIM13_CCER_CC1NP, 1 << 3   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM13_CCER_CC1P, 1 << 1   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM13_CCER_CC1E, 1 << 0   @ bitWidth 1 (Capture/Compare 1 output  enable)  
 
    .equ TIM13_CNT, TIM13_BASE + 0x24 @ (counter) 
        .equ TIM13_CNT_CNT_L_Shift, 0   @ bitWidth 16 (low counter value)  
        .equ TIM13_CNT_CNT_H_Shift, 16   @ bitWidth 16 (High counter value)  
 
    .equ TIM13_PSC, TIM13_BASE + 0x28 @ (prescaler) 
        .equ TIM13_PSC_PSC_Shift, 0   @ bitWidth 16 (Prescaler value)  
 
    .equ TIM13_ARR, TIM13_BASE + 0x2C @ (auto-reload register) 
        .equ TIM13_ARR_ARR_H_Shift, 16   @ bitWidth 16 (High Auto-reload value)  
        .equ TIM13_ARR_ARR_L_Shift, 0   @ bitWidth 16 (Low Auto-reload value)  
 
    .equ TIM13_CCR1, TIM13_BASE + 0x34 @ (capture/compare register 1) 
        .equ TIM13_CCR1_CCR1_H_Shift, 16   @ bitWidth 16 (High Capture/Compare 1  value)  
        .equ TIM13_CCR1_CCR1_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare 1  value)  
 
    .equ TIM13_CCR2, TIM13_BASE + 0x38 @ (capture/compare register 2) 
        .equ TIM13_CCR2_CCR2_H_Shift, 16   @ bitWidth 16 (High Capture/Compare 2  value)  
        .equ TIM13_CCR2_CCR2_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare 2  value)  
 
    .equ TIM13_CCR3, TIM13_BASE + 0x3C @ (capture/compare register 3) 
        .equ TIM13_CCR3_CCR3_H_Shift, 16   @ bitWidth 16 (High Capture/Compare value)  
        .equ TIM13_CCR3_CCR3_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare value)  
 
    .equ TIM13_CCR4, TIM13_BASE + 0x40 @ (capture/compare register 4) 
        .equ TIM13_CCR4_CCR4_H_Shift, 16   @ bitWidth 16 (High Capture/Compare value)  
        .equ TIM13_CCR4_CCR4_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare value)  
 
    .equ TIM13_DCR, TIM13_BASE + 0x48 @ (DMA control register) 
        .equ TIM13_DCR_DBL_Shift, 8   @ bitWidth 5 (DMA burst length)  
        .equ TIM13_DCR_DBA_Shift, 0   @ bitWidth 5 (DMA base address)  
 
    .equ TIM13_DMAR, TIM13_BASE + 0x4C @ (DMA address for full transfer) 
        .equ TIM13_DMAR_DMAB_Shift, 0   @ bitWidth 16 (DMA register for burst  accesses)  
 
    .equ TIM13_AF1, TIM13_BASE + 0x60 @ (TIM alternate function option register  1) 
        .equ TIM13_AF1_ETRSEL_Shift, 14   @ bitWidth 4 (ETR source selection)  
 
    .equ TIM13_TISEL, TIM13_BASE + 0x68 @ (TIM timer input selection  register) 
        .equ TIM13_TISEL_TI1SEL_Shift, 0   @ bitWidth 4 (TI1[0] to TI1[15] input  selection)  
        .equ TIM13_TISEL_TI2SEL_Shift, 8   @ bitWidth 4 (TI2[0] to TI2[15] input  selection)  
        .equ TIM13_TISEL_TI3SEL_Shift, 16   @ bitWidth 4 (TI3[0] to TI3[15] input  selection)  
        .equ TIM13_TISEL_TI4SEL_Shift, 24   @ bitWidth 4 (TI4[0] to TI4[15] input  selection)  
 

@=========================== TIM14 ===========================@
.equ TIM14_BASE, 0x40002000 @ (General purpose timers) 
    .equ TIM14_CR1, TIM14_BASE + 0x0 @ (control register 1) 
        .equ TIM14_CR1_UIFREMAP, 1 << 11   @ bitWidth 1 (UIF status bit remapping)  
        .equ TIM14_CR1_CKD_Shift, 8   @ bitWidth 2 (Clock division)  
        .equ TIM14_CR1_ARPE, 1 << 7   @ bitWidth 1 (Auto-reload preload enable)  
        .equ TIM14_CR1_CMS_Shift, 5   @ bitWidth 2 (Center-aligned mode  selection)  
        .equ TIM14_CR1_DIR, 1 << 4   @ bitWidth 1 (Direction)  
        .equ TIM14_CR1_OPM, 1 << 3   @ bitWidth 1 (One-pulse mode)  
        .equ TIM14_CR1_URS, 1 << 2   @ bitWidth 1 (Update request source)  
        .equ TIM14_CR1_UDIS, 1 << 1   @ bitWidth 1 (Update disable)  
        .equ TIM14_CR1_CEN, 1 << 0   @ bitWidth 1 (Counter enable)  
 
    .equ TIM14_CR2, TIM14_BASE + 0x4 @ (control register 2) 
        .equ TIM14_CR2_TI1S, 1 << 7   @ bitWidth 1 (TI1 selection)  
        .equ TIM14_CR2_MMS_Shift, 4   @ bitWidth 3 (Master mode selection)  
        .equ TIM14_CR2_CCDS, 1 << 3   @ bitWidth 1 (Capture/compare DMA  selection)  
 
    .equ TIM14_SMCR, TIM14_BASE + 0x8 @ (slave mode control register) 
        .equ TIM14_SMCR_TS_4_3_Shift, 20   @ bitWidth 2 (Trigger selection)  
        .equ TIM14_SMCR_SMS_3, 1 << 16   @ bitWidth 1 (Slave mode selection - bit  3)  
        .equ TIM14_SMCR_ETP, 1 << 15   @ bitWidth 1 (External trigger polarity)  
        .equ TIM14_SMCR_ECE, 1 << 14   @ bitWidth 1 (External clock enable)  
        .equ TIM14_SMCR_ETPS_Shift, 12   @ bitWidth 2 (External trigger prescaler)  
        .equ TIM14_SMCR_ETF_Shift, 8   @ bitWidth 4 (External trigger filter)  
        .equ TIM14_SMCR_MSM, 1 << 7   @ bitWidth 1 (Master/Slave mode)  
        .equ TIM14_SMCR_TS_Shift, 4   @ bitWidth 3 (Trigger selection)  
        .equ TIM14_SMCR_SMS_Shift, 0   @ bitWidth 3 (Slave mode selection)  
 
    .equ TIM14_DIER, TIM14_BASE + 0xC @ (DMA/Interrupt enable register) 
        .equ TIM14_DIER_TDE, 1 << 14   @ bitWidth 1 (Trigger DMA request enable)  
        .equ TIM14_DIER_CC4DE, 1 << 12   @ bitWidth 1 (Capture/Compare 4 DMA request  enable)  
        .equ TIM14_DIER_CC3DE, 1 << 11   @ bitWidth 1 (Capture/Compare 3 DMA request  enable)  
        .equ TIM14_DIER_CC2DE, 1 << 10   @ bitWidth 1 (Capture/Compare 2 DMA request  enable)  
        .equ TIM14_DIER_CC1DE, 1 << 9   @ bitWidth 1 (Capture/Compare 1 DMA request  enable)  
        .equ TIM14_DIER_UDE, 1 << 8   @ bitWidth 1 (Update DMA request enable)  
        .equ TIM14_DIER_TIE, 1 << 6   @ bitWidth 1 (Trigger interrupt enable)  
        .equ TIM14_DIER_CC4IE, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  enable)  
        .equ TIM14_DIER_CC3IE, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  enable)  
        .equ TIM14_DIER_CC2IE, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  enable)  
        .equ TIM14_DIER_CC1IE, 1 << 1   @ bitWidth 1 (Capture/Compare 1 interrupt  enable)  
        .equ TIM14_DIER_UIE, 1 << 0   @ bitWidth 1 (Update interrupt enable)  
 
    .equ TIM14_SR, TIM14_BASE + 0x10 @ (status register) 
        .equ TIM14_SR_CC4OF, 1 << 12   @ bitWidth 1 (Capture/Compare 4 overcapture  flag)  
        .equ TIM14_SR_CC3OF, 1 << 11   @ bitWidth 1 (Capture/Compare 3 overcapture  flag)  
        .equ TIM14_SR_CC2OF, 1 << 10   @ bitWidth 1 (Capture/compare 2 overcapture  flag)  
        .equ TIM14_SR_CC1OF, 1 << 9   @ bitWidth 1 (Capture/Compare 1 overcapture  flag)  
        .equ TIM14_SR_TIF, 1 << 6   @ bitWidth 1 (Trigger interrupt flag)  
        .equ TIM14_SR_CC4IF, 1 << 4   @ bitWidth 1 (Capture/Compare 4 interrupt  flag)  
        .equ TIM14_SR_CC3IF, 1 << 3   @ bitWidth 1 (Capture/Compare 3 interrupt  flag)  
        .equ TIM14_SR_CC2IF, 1 << 2   @ bitWidth 1 (Capture/Compare 2 interrupt  flag)  
        .equ TIM14_SR_CC1IF, 1 << 1   @ bitWidth 1 (Capture/compare 1 interrupt  flag)  
        .equ TIM14_SR_UIF, 1 << 0   @ bitWidth 1 (Update interrupt flag)  
 
    .equ TIM14_EGR, TIM14_BASE + 0x14 @ (event generation register) 
        .equ TIM14_EGR_TG, 1 << 6   @ bitWidth 1 (Trigger generation)  
        .equ TIM14_EGR_CC4G, 1 << 4   @ bitWidth 1 (Capture/compare 4  generation)  
        .equ TIM14_EGR_CC3G, 1 << 3   @ bitWidth 1 (Capture/compare 3  generation)  
        .equ TIM14_EGR_CC2G, 1 << 2   @ bitWidth 1 (Capture/compare 2  generation)  
        .equ TIM14_EGR_CC1G, 1 << 1   @ bitWidth 1 (Capture/compare 1  generation)  
        .equ TIM14_EGR_UG, 1 << 0   @ bitWidth 1 (Update generation)  
 
    .equ TIM14_CCMR1_Output, TIM14_BASE + 0x18 @ (capture/compare mode register 1 output  mode) 
        .equ TIM14_CCMR1_Output_CC1S_Shift, 0   @ bitWidth 2 (CC1S)  
        .equ TIM14_CCMR1_Output_OC1FE, 1 << 2   @ bitWidth 1 (OC1FE)  
        .equ TIM14_CCMR1_Output_OC1PE, 1 << 3   @ bitWidth 1 (OC1PE)  
        .equ TIM14_CCMR1_Output_OC1M_Shift, 4   @ bitWidth 3 (OC1M)  
        .equ TIM14_CCMR1_Output_OC1CE, 1 << 7   @ bitWidth 1 (OC1CE)  
        .equ TIM14_CCMR1_Output_CC2S_Shift, 8   @ bitWidth 2 (CC2S)  
        .equ TIM14_CCMR1_Output_OC2FE, 1 << 10   @ bitWidth 1 (OC2FE)  
        .equ TIM14_CCMR1_Output_OC2PE, 1 << 11   @ bitWidth 1 (OC2PE)  
        .equ TIM14_CCMR1_Output_OC2M_Shift, 12   @ bitWidth 3 (OC2M)  
        .equ TIM14_CCMR1_Output_OC2CE, 1 << 15   @ bitWidth 1 (OC2CE)  
        .equ TIM14_CCMR1_Output_OC1M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode - bit  3)  
        .equ TIM14_CCMR1_Output_OC2M_3, 1 << 24   @ bitWidth 1 (Output Compare 2 mode - bit  3)  
 
    .equ TIM14_CCMR1_Input, TIM14_BASE + 0x18 @ (capture/compare mode register 1 input  mode) 
        .equ TIM14_CCMR1_Input_IC2F_Shift, 12   @ bitWidth 4 (Input capture 2 filter)  
        .equ TIM14_CCMR1_Input_IC2PCS_Shift, 10   @ bitWidth 2 (Input capture 2 prescaler)  
        .equ TIM14_CCMR1_Input_CC2S_Shift, 8   @ bitWidth 2 (Capture/Compare 2  selection)  
        .equ TIM14_CCMR1_Input_IC1F_Shift, 4   @ bitWidth 4 (Input capture 1 filter)  
        .equ TIM14_CCMR1_Input_ICPCS_Shift, 2   @ bitWidth 2 (Input capture 1 prescaler)  
        .equ TIM14_CCMR1_Input_CC1S_Shift, 0   @ bitWidth 2 (Capture/Compare 1  selection)  
 
    .equ TIM14_CCMR2_Output, TIM14_BASE + 0x1C @ (capture/compare mode register 2 output  mode) 
        .equ TIM14_CCMR2_Output_OC4M_3, 1 << 24   @ bitWidth 1 (Output Compare 2 mode - bit  3)  
        .equ TIM14_CCMR2_Output_OC3M_3, 1 << 16   @ bitWidth 1 (Output Compare 1 mode - bit  3)  
        .equ TIM14_CCMR2_Output_O24CE, 1 << 15   @ bitWidth 1 (O24CE)  
        .equ TIM14_CCMR2_Output_OC4M_Shift, 12   @ bitWidth 3 (OC4M)  
        .equ TIM14_CCMR2_Output_OC4PE, 1 << 11   @ bitWidth 1 (OC4PE)  
        .equ TIM14_CCMR2_Output_OC4FE, 1 << 10   @ bitWidth 1 (OC4FE)  
        .equ TIM14_CCMR2_Output_CC4S_Shift, 8   @ bitWidth 2 (CC4S)  
        .equ TIM14_CCMR2_Output_OC3CE, 1 << 7   @ bitWidth 1 (OC3CE)  
        .equ TIM14_CCMR2_Output_OC3M_Shift, 4   @ bitWidth 3 (OC3M)  
        .equ TIM14_CCMR2_Output_OC3PE, 1 << 3   @ bitWidth 1 (OC3PE)  
        .equ TIM14_CCMR2_Output_OC3FE, 1 << 2   @ bitWidth 1 (OC3FE)  
        .equ TIM14_CCMR2_Output_CC3S_Shift, 0   @ bitWidth 2 (CC3S)  
 
    .equ TIM14_CCMR2_Input, TIM14_BASE + 0x1C @ (capture/compare mode register 2 input  mode) 
        .equ TIM14_CCMR2_Input_IC4F_Shift, 12   @ bitWidth 4 (Input capture 4 filter)  
        .equ TIM14_CCMR2_Input_IC4PSC_Shift, 10   @ bitWidth 2 (Input capture 4 prescaler)  
        .equ TIM14_CCMR2_Input_CC4S_Shift, 8   @ bitWidth 2 (Capture/Compare 4  selection)  
        .equ TIM14_CCMR2_Input_IC3F_Shift, 4   @ bitWidth 4 (Input capture 3 filter)  
        .equ TIM14_CCMR2_Input_IC3PSC_Shift, 2   @ bitWidth 2 (Input capture 3 prescaler)  
        .equ TIM14_CCMR2_Input_CC3S_Shift, 0   @ bitWidth 2 (Capture/compare 3  selection)  
 
    .equ TIM14_CCER, TIM14_BASE + 0x20 @ (capture/compare enable  register) 
        .equ TIM14_CCER_CC4NP, 1 << 15   @ bitWidth 1 (Capture/Compare 4 output  Polarity)  
        .equ TIM14_CCER_CC4P, 1 << 13   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM14_CCER_CC4E, 1 << 12   @ bitWidth 1 (Capture/Compare 4 output  enable)  
        .equ TIM14_CCER_CC3NP, 1 << 11   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM14_CCER_CC3P, 1 << 9   @ bitWidth 1 (Capture/Compare 3 output  Polarity)  
        .equ TIM14_CCER_CC3E, 1 << 8   @ bitWidth 1 (Capture/Compare 3 output  enable)  
        .equ TIM14_CCER_CC2NP, 1 << 7   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM14_CCER_CC2P, 1 << 5   @ bitWidth 1 (Capture/Compare 2 output  Polarity)  
        .equ TIM14_CCER_CC2E, 1 << 4   @ bitWidth 1 (Capture/Compare 2 output  enable)  
        .equ TIM14_CCER_CC1NP, 1 << 3   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM14_CCER_CC1P, 1 << 1   @ bitWidth 1 (Capture/Compare 1 output  Polarity)  
        .equ TIM14_CCER_CC1E, 1 << 0   @ bitWidth 1 (Capture/Compare 1 output  enable)  
 
    .equ TIM14_CNT, TIM14_BASE + 0x24 @ (counter) 
        .equ TIM14_CNT_CNT_L_Shift, 0   @ bitWidth 16 (low counter value)  
        .equ TIM14_CNT_CNT_H_Shift, 16   @ bitWidth 16 (High counter value)  
 
    .equ TIM14_PSC, TIM14_BASE + 0x28 @ (prescaler) 
        .equ TIM14_PSC_PSC_Shift, 0   @ bitWidth 16 (Prescaler value)  
 
    .equ TIM14_ARR, TIM14_BASE + 0x2C @ (auto-reload register) 
        .equ TIM14_ARR_ARR_H_Shift, 16   @ bitWidth 16 (High Auto-reload value)  
        .equ TIM14_ARR_ARR_L_Shift, 0   @ bitWidth 16 (Low Auto-reload value)  
 
    .equ TIM14_CCR1, TIM14_BASE + 0x34 @ (capture/compare register 1) 
        .equ TIM14_CCR1_CCR1_H_Shift, 16   @ bitWidth 16 (High Capture/Compare 1  value)  
        .equ TIM14_CCR1_CCR1_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare 1  value)  
 
    .equ TIM14_CCR2, TIM14_BASE + 0x38 @ (capture/compare register 2) 
        .equ TIM14_CCR2_CCR2_H_Shift, 16   @ bitWidth 16 (High Capture/Compare 2  value)  
        .equ TIM14_CCR2_CCR2_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare 2  value)  
 
    .equ TIM14_CCR3, TIM14_BASE + 0x3C @ (capture/compare register 3) 
        .equ TIM14_CCR3_CCR3_H_Shift, 16   @ bitWidth 16 (High Capture/Compare value)  
        .equ TIM14_CCR3_CCR3_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare value)  
 
    .equ TIM14_CCR4, TIM14_BASE + 0x40 @ (capture/compare register 4) 
        .equ TIM14_CCR4_CCR4_H_Shift, 16   @ bitWidth 16 (High Capture/Compare value)  
        .equ TIM14_CCR4_CCR4_L_Shift, 0   @ bitWidth 16 (Low Capture/Compare value)  
 
    .equ TIM14_DCR, TIM14_BASE + 0x48 @ (DMA control register) 
        .equ TIM14_DCR_DBL_Shift, 8   @ bitWidth 5 (DMA burst length)  
        .equ TIM14_DCR_DBA_Shift, 0   @ bitWidth 5 (DMA base address)  
 
    .equ TIM14_DMAR, TIM14_BASE + 0x4C @ (DMA address for full transfer) 
        .equ TIM14_DMAR_DMAB_Shift, 0   @ bitWidth 16 (DMA register for burst  accesses)  
 
    .equ TIM14_AF1, TIM14_BASE + 0x60 @ (TIM alternate function option register  1) 
        .equ TIM14_AF1_ETRSEL_Shift, 14   @ bitWidth 4 (ETR source selection)  
 
    .equ TIM14_TISEL, TIM14_BASE + 0x68 @ (TIM timer input selection  register) 
        .equ TIM14_TISEL_TI1SEL_Shift, 0   @ bitWidth 4 (TI1[0] to TI1[15] input  selection)  
        .equ TIM14_TISEL_TI2SEL_Shift, 8   @ bitWidth 4 (TI2[0] to TI2[15] input  selection)  
        .equ TIM14_TISEL_TI3SEL_Shift, 16   @ bitWidth 4 (TI3[0] to TI3[15] input  selection)  
        .equ TIM14_TISEL_TI4SEL_Shift, 24   @ bitWidth 4 (TI4[0] to TI4[15] input  selection)  
 

@=========================== TIM6 ===========================@
.equ TIM6_BASE, 0x40001000 @ (Basic timers) 
    .equ TIM6_CR1, TIM6_BASE + 0x0 @ (control register 1) 
        .equ TIM6_CR1_UIFREMAP, 1 << 11   @ bitWidth 1 (UIF status bit remapping)  
        .equ TIM6_CR1_ARPE, 1 << 7   @ bitWidth 1 (Auto-reload preload enable)  
        .equ TIM6_CR1_OPM, 1 << 3   @ bitWidth 1 (One-pulse mode)  
        .equ TIM6_CR1_URS, 1 << 2   @ bitWidth 1 (Update request source)  
        .equ TIM6_CR1_UDIS, 1 << 1   @ bitWidth 1 (Update disable)  
        .equ TIM6_CR1_CEN, 1 << 0   @ bitWidth 1 (Counter enable)  
 
    .equ TIM6_CR2, TIM6_BASE + 0x4 @ (control register 2) 
        .equ TIM6_CR2_MMS_Shift, 4   @ bitWidth 3 (Master mode selection)  
 
    .equ TIM6_DIER, TIM6_BASE + 0xC @ (DMA/Interrupt enable register) 
        .equ TIM6_DIER_UDE, 1 << 8   @ bitWidth 1 (Update DMA request enable)  
        .equ TIM6_DIER_UIE, 1 << 0   @ bitWidth 1 (Update interrupt enable)  
 
    .equ TIM6_SR, TIM6_BASE + 0x10 @ (status register) 
        .equ TIM6_SR_UIF, 1 << 0   @ bitWidth 1 (Update interrupt flag)  
 
    .equ TIM6_EGR, TIM6_BASE + 0x14 @ (event generation register) 
        .equ TIM6_EGR_UG, 1 << 0   @ bitWidth 1 (Update generation)  
 
    .equ TIM6_CNT, TIM6_BASE + 0x24 @ (counter) 
        .equ TIM6_CNT_CNT_Shift, 0   @ bitWidth 16 (Low counter value)  
        .equ TIM6_CNT_UIFCPY, 1 << 31   @ bitWidth 1 (UIF Copy)  
 
    .equ TIM6_PSC, TIM6_BASE + 0x28 @ (prescaler) 
        .equ TIM6_PSC_PSC_Shift, 0   @ bitWidth 16 (Prescaler value)  
 
    .equ TIM6_ARR, TIM6_BASE + 0x2C @ (auto-reload register) 
        .equ TIM6_ARR_ARR_Shift, 0   @ bitWidth 16 (Low Auto-reload value)  
 

@=========================== TIM7 ===========================@
.equ TIM7_BASE, 0x40001400 @ (Basic timers) 
    .equ TIM7_CR1, TIM7_BASE + 0x0 @ (control register 1) 
        .equ TIM7_CR1_UIFREMAP, 1 << 11   @ bitWidth 1 (UIF status bit remapping)  
        .equ TIM7_CR1_ARPE, 1 << 7   @ bitWidth 1 (Auto-reload preload enable)  
        .equ TIM7_CR1_OPM, 1 << 3   @ bitWidth 1 (One-pulse mode)  
        .equ TIM7_CR1_URS, 1 << 2   @ bitWidth 1 (Update request source)  
        .equ TIM7_CR1_UDIS, 1 << 1   @ bitWidth 1 (Update disable)  
        .equ TIM7_CR1_CEN, 1 << 0   @ bitWidth 1 (Counter enable)  
 
    .equ TIM7_CR2, TIM7_BASE + 0x4 @ (control register 2) 
        .equ TIM7_CR2_MMS_Shift, 4   @ bitWidth 3 (Master mode selection)  
 
    .equ TIM7_DIER, TIM7_BASE + 0xC @ (DMA/Interrupt enable register) 
        .equ TIM7_DIER_UDE, 1 << 8   @ bitWidth 1 (Update DMA request enable)  
        .equ TIM7_DIER_UIE, 1 << 0   @ bitWidth 1 (Update interrupt enable)  
 
    .equ TIM7_SR, TIM7_BASE + 0x10 @ (status register) 
        .equ TIM7_SR_UIF, 1 << 0   @ bitWidth 1 (Update interrupt flag)  
 
    .equ TIM7_EGR, TIM7_BASE + 0x14 @ (event generation register) 
        .equ TIM7_EGR_UG, 1 << 0   @ bitWidth 1 (Update generation)  
 
    .equ TIM7_CNT, TIM7_BASE + 0x24 @ (counter) 
        .equ TIM7_CNT_CNT_Shift, 0   @ bitWidth 16 (Low counter value)  
        .equ TIM7_CNT_UIFCPY, 1 << 31   @ bitWidth 1 (UIF Copy)  
 
    .equ TIM7_PSC, TIM7_BASE + 0x28 @ (prescaler) 
        .equ TIM7_PSC_PSC_Shift, 0   @ bitWidth 16 (Prescaler value)  
 
    .equ TIM7_ARR, TIM7_BASE + 0x2C @ (auto-reload register) 
        .equ TIM7_ARR_ARR_Shift, 0   @ bitWidth 16 (Low Auto-reload value)  
 

@=========================== NVIC ===========================@
.equ NVIC_BASE, 0xE000E100 @ (Nested Vectored Interrupt  Controller) 
    .equ NVIC_ISER0, NVIC_BASE + 0x0 @ (Interrupt Set-Enable Register) 
        .equ NVIC_ISER0_SETENA_Shift, 0   @ bitWidth 32 (SETENA)  
 
    .equ NVIC_ISER1, NVIC_BASE + 0x4 @ (Interrupt Set-Enable Register) 
        .equ NVIC_ISER1_SETENA_Shift, 0   @ bitWidth 32 (SETENA)  
 
    .equ NVIC_ISER2, NVIC_BASE + 0x8 @ (Interrupt Set-Enable Register) 
        .equ NVIC_ISER2_SETENA_Shift, 0   @ bitWidth 32 (SETENA)  
 
    .equ NVIC_ICER0, NVIC_BASE + 0x80 @ (Interrupt Clear-Enable  Register) 
        .equ NVIC_ICER0_CLRENA_Shift, 0   @ bitWidth 32 (CLRENA)  
 
    .equ NVIC_ICER1, NVIC_BASE + 0x84 @ (Interrupt Clear-Enable  Register) 
        .equ NVIC_ICER1_CLRENA_Shift, 0   @ bitWidth 32 (CLRENA)  
 
    .equ NVIC_ICER2, NVIC_BASE + 0x88 @ (Interrupt Clear-Enable  Register) 
        .equ NVIC_ICER2_CLRENA_Shift, 0   @ bitWidth 32 (CLRENA)  
 
    .equ NVIC_ISPR0, NVIC_BASE + 0x100 @ (Interrupt Set-Pending Register) 
        .equ NVIC_ISPR0_SETPEND_Shift, 0   @ bitWidth 32 (SETPEND)  
 
    .equ NVIC_ISPR1, NVIC_BASE + 0x104 @ (Interrupt Set-Pending Register) 
        .equ NVIC_ISPR1_SETPEND_Shift, 0   @ bitWidth 32 (SETPEND)  
 
    .equ NVIC_ISPR2, NVIC_BASE + 0x108 @ (Interrupt Set-Pending Register) 
        .equ NVIC_ISPR2_SETPEND_Shift, 0   @ bitWidth 32 (SETPEND)  
 
    .equ NVIC_ICPR0, NVIC_BASE + 0x180 @ (Interrupt Clear-Pending  Register) 
        .equ NVIC_ICPR0_CLRPEND_Shift, 0   @ bitWidth 32 (CLRPEND)  
 
    .equ NVIC_ICPR1, NVIC_BASE + 0x184 @ (Interrupt Clear-Pending  Register) 
        .equ NVIC_ICPR1_CLRPEND_Shift, 0   @ bitWidth 32 (CLRPEND)  
 
    .equ NVIC_ICPR2, NVIC_BASE + 0x188 @ (Interrupt Clear-Pending  Register) 
        .equ NVIC_ICPR2_CLRPEND_Shift, 0   @ bitWidth 32 (CLRPEND)  
 
    .equ NVIC_IABR0, NVIC_BASE + 0x200 @ (Interrupt Active Bit Register) 
        .equ NVIC_IABR0_ACTIVE_Shift, 0   @ bitWidth 32 (ACTIVE)  
 
    .equ NVIC_IABR1, NVIC_BASE + 0x204 @ (Interrupt Active Bit Register) 
        .equ NVIC_IABR1_ACTIVE_Shift, 0   @ bitWidth 32 (ACTIVE)  
 
    .equ NVIC_IABR2, NVIC_BASE + 0x208 @ (Interrupt Active Bit Register) 
        .equ NVIC_IABR2_ACTIVE_Shift, 0   @ bitWidth 32 (ACTIVE)  
 
    .equ NVIC_IPR0, NVIC_BASE + 0x300 @ (Interrupt Priority Register) 
        .equ NVIC_IPR0_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR0_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR0_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR0_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR1, NVIC_BASE + 0x304 @ (Interrupt Priority Register) 
        .equ NVIC_IPR1_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR1_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR1_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR1_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR2, NVIC_BASE + 0x308 @ (Interrupt Priority Register) 
        .equ NVIC_IPR2_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR2_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR2_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR2_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR3, NVIC_BASE + 0x30C @ (Interrupt Priority Register) 
        .equ NVIC_IPR3_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR3_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR3_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR3_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR4, NVIC_BASE + 0x310 @ (Interrupt Priority Register) 
        .equ NVIC_IPR4_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR4_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR4_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR4_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR5, NVIC_BASE + 0x314 @ (Interrupt Priority Register) 
        .equ NVIC_IPR5_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR5_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR5_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR5_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR6, NVIC_BASE + 0x318 @ (Interrupt Priority Register) 
        .equ NVIC_IPR6_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR6_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR6_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR6_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR7, NVIC_BASE + 0x31C @ (Interrupt Priority Register) 
        .equ NVIC_IPR7_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR7_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR7_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR7_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR8, NVIC_BASE + 0x320 @ (Interrupt Priority Register) 
        .equ NVIC_IPR8_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR8_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR8_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR8_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR9, NVIC_BASE + 0x324 @ (Interrupt Priority Register) 
        .equ NVIC_IPR9_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR9_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR9_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR9_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR10, NVIC_BASE + 0x328 @ (Interrupt Priority Register) 
        .equ NVIC_IPR10_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR10_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR10_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR10_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR11, NVIC_BASE + 0x32C @ (Interrupt Priority Register) 
        .equ NVIC_IPR11_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR11_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR11_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR11_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR12, NVIC_BASE + 0x330 @ (Interrupt Priority Register) 
        .equ NVIC_IPR12_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR12_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR12_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR12_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR13, NVIC_BASE + 0x334 @ (Interrupt Priority Register) 
        .equ NVIC_IPR13_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR13_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR13_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR13_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR14, NVIC_BASE + 0x338 @ (Interrupt Priority Register) 
        .equ NVIC_IPR14_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR14_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR14_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR14_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR15, NVIC_BASE + 0x33C @ (Interrupt Priority Register) 
        .equ NVIC_IPR15_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR15_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR15_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR15_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR16, NVIC_BASE + 0x340 @ (Interrupt Priority Register) 
        .equ NVIC_IPR16_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR16_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR16_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR16_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR17, NVIC_BASE + 0x344 @ (Interrupt Priority Register) 
        .equ NVIC_IPR17_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR17_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR17_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR17_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR18, NVIC_BASE + 0x348 @ (Interrupt Priority Register) 
        .equ NVIC_IPR18_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR18_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR18_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR18_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR19, NVIC_BASE + 0x34C @ (Interrupt Priority Register) 
        .equ NVIC_IPR19_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR19_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR19_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR19_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR20, NVIC_BASE + 0x350 @ (Interrupt Priority Register) 
        .equ NVIC_IPR20_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR20_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR20_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR20_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR21, NVIC_BASE + 0x354 @ (Interrupt Priority Register) 
        .equ NVIC_IPR21_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR21_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR21_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR21_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR22, NVIC_BASE + 0x358 @ (Interrupt Priority Register) 
        .equ NVIC_IPR22_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR22_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR22_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR22_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR23, NVIC_BASE + 0x35C @ (Interrupt Priority Register) 
        .equ NVIC_IPR23_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR23_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR23_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR23_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR24, NVIC_BASE + 0x360 @ (Interrupt Priority Register) 
        .equ NVIC_IPR24_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR24_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR24_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR24_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR25, NVIC_BASE + 0x364 @ (Interrupt Priority Register) 
        .equ NVIC_IPR25_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR25_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR25_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR25_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR26, NVIC_BASE + 0x368 @ (Interrupt Priority Register) 
        .equ NVIC_IPR26_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR26_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR26_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR26_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR27, NVIC_BASE + 0x36C @ (Interrupt Priority Register) 
        .equ NVIC_IPR27_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR27_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR27_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR27_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR28, NVIC_BASE + 0x370 @ (Interrupt Priority Register) 
        .equ NVIC_IPR28_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR28_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR28_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR28_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR29, NVIC_BASE + 0x374 @ (Interrupt Priority Register) 
        .equ NVIC_IPR29_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR29_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR29_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR29_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR30, NVIC_BASE + 0x378 @ (Interrupt Priority Register) 
        .equ NVIC_IPR30_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR30_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR30_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR30_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR31, NVIC_BASE + 0x37C @ (Interrupt Priority Register) 
        .equ NVIC_IPR31_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR31_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR31_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR31_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR32, NVIC_BASE + 0x380 @ (Interrupt Priority Register) 
        .equ NVIC_IPR32_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR32_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR32_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR32_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR33, NVIC_BASE + 0x384 @ (Interrupt Priority Register) 
        .equ NVIC_IPR33_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR33_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR33_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR33_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR34, NVIC_BASE + 0x388 @ (Interrupt Priority Register) 
        .equ NVIC_IPR34_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR34_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR34_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR34_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR35, NVIC_BASE + 0x38C @ (Interrupt Priority Register) 
        .equ NVIC_IPR35_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR35_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR35_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR35_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR36, NVIC_BASE + 0x390 @ (Interrupt Priority Register) 
        .equ NVIC_IPR36_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR36_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR36_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR36_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR37, NVIC_BASE + 0x394 @ (Interrupt Priority Register) 
        .equ NVIC_IPR37_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR37_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR37_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR37_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR38, NVIC_BASE + 0x398 @ (Interrupt Priority Register) 
        .equ NVIC_IPR38_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR38_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR38_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR38_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_IPR39, NVIC_BASE + 0x39C @ (Interrupt Priority Register) 
        .equ NVIC_IPR39_IPR_N0_Shift, 0   @ bitWidth 8 (IPR_N0)  
        .equ NVIC_IPR39_IPR_N1_Shift, 8   @ bitWidth 8 (IPR_N1)  
        .equ NVIC_IPR39_IPR_N2_Shift, 16   @ bitWidth 8 (IPR_N2)  
        .equ NVIC_IPR39_IPR_N3_Shift, 24   @ bitWidth 8 (IPR_N3)  
 
    .equ NVIC_ISER3, NVIC_BASE + 0xC @ (Interrupt Set-Enable Register) 
 
    .equ NVIC_ISER4, NVIC_BASE + 0x10 @ (Interrupt Set-Enable Register) 
 
    .equ NVIC_ICER3, NVIC_BASE + 0x8C @ (Interrupt Clear-Enable  Register) 
 
    .equ NVIC_ICER4, NVIC_BASE + 0x90 @ (Interrupt Clear-Enable  Register) 
 
    .equ NVIC_ISPR3, NVIC_BASE + 0x10C @ (Interrupt Set-Pending Register) 
 
    .equ NVIC_ISPR4, NVIC_BASE + 0x110 @ (Interrupt Set-Pending Register) 
 
    .equ NVIC_ICPR3, NVIC_BASE + 0x1C0 @ (Interrupt Clear-Pending  Register) 
 
    .equ NVIC_ICPR4, NVIC_BASE + 0x1C4 @ (Interrupt Clear-Pending  Register) 
 
    .equ NVIC_IABR3, NVIC_BASE + 0x20C @ (Interrupt Active Bit Register) 
 
    .equ NVIC_IABR4, NVIC_BASE + 0x210 @ (Interrupt Active Bit Register) 
 

@=========================== MPU ===========================@
.equ MPU_BASE, 0xE000ED90 @ (Memory protection unit) 
    .equ MPU_MPU_TYPER, MPU_BASE + 0x0 @ (MPU type register) 
        .equ MPU_MPU_TYPER_SEPARATE, 1 << 0   @ bitWidth 1 (Separate flag)  
        .equ MPU_MPU_TYPER_DREGION_Shift, 8   @ bitWidth 8 (Number of MPU data regions)  
        .equ MPU_MPU_TYPER_IREGION_Shift, 16   @ bitWidth 8 (Number of MPU instruction  regions)  
 
    .equ MPU_MPU_CTRL, MPU_BASE + 0x4 @ (MPU control register) 
        .equ MPU_MPU_CTRL_ENABLE, 1 << 0   @ bitWidth 1 (Enables the MPU)  
        .equ MPU_MPU_CTRL_HFNMIENA, 1 << 1   @ bitWidth 1 (Enables the operation of MPU during hard  fault)  
        .equ MPU_MPU_CTRL_PRIVDEFENA, 1 << 2   @ bitWidth 1 (Enable priviliged software access to  default memory map)  
 
    .equ MPU_MPU_RNR, MPU_BASE + 0x8 @ (MPU region number register) 
        .equ MPU_MPU_RNR_REGION_Shift, 0   @ bitWidth 8 (MPU region)  
 
    .equ MPU_MPU_RBAR, MPU_BASE + 0xC @ (MPU region base address  register) 
        .equ MPU_MPU_RBAR_REGION_Shift, 0   @ bitWidth 4 (MPU region field)  
        .equ MPU_MPU_RBAR_VALID, 1 << 4   @ bitWidth 1 (MPU region number valid)  
        .equ MPU_MPU_RBAR_ADDR_Shift, 5   @ bitWidth 27 (Region base address field)  
 
    .equ MPU_MPU_RASR, MPU_BASE + 0x10 @ (MPU region attribute and size  register) 
        .equ MPU_MPU_RASR_ENABLE, 1 << 0   @ bitWidth 1 (Region enable bit.)  
        .equ MPU_MPU_RASR_SIZE_Shift, 1   @ bitWidth 5 (Size of the MPU protection  region)  
        .equ MPU_MPU_RASR_SRD_Shift, 8   @ bitWidth 8 (Subregion disable bits)  
        .equ MPU_MPU_RASR_B, 1 << 16   @ bitWidth 1 (memory attribute)  
        .equ MPU_MPU_RASR_C, 1 << 17   @ bitWidth 1 (memory attribute)  
        .equ MPU_MPU_RASR_S, 1 << 18   @ bitWidth 1 (Shareable memory attribute)  
        .equ MPU_MPU_RASR_TEX_Shift, 19   @ bitWidth 3 (memory attribute)  
        .equ MPU_MPU_RASR_AP_Shift, 24   @ bitWidth 3 (Access permission)  
        .equ MPU_MPU_RASR_XN, 1 << 28   @ bitWidth 1 (Instruction access disable  bit)  
 

@=========================== STK ===========================@
.equ STK_BASE, 0xE000E010 @ (SysTick timer) 
    .equ STK_CSR, STK_BASE + 0x0 @ (SysTick control and status  register) 
        .equ STK_CSR_ENABLE, 1 << 0   @ bitWidth 1 (Counter enable)  
        .equ STK_CSR_TICKINT, 1 << 1   @ bitWidth 1 (SysTick exception request  enable)  
        .equ STK_CSR_CLKSOURCE, 1 << 2   @ bitWidth 1 (Clock source selection)  
        .equ STK_CSR_COUNTFLAG, 1 << 16   @ bitWidth 1 (COUNTFLAG)  
 
    .equ STK_RVR, STK_BASE + 0x4 @ (SysTick reload value register) 
        .equ STK_RVR_RELOAD_Shift, 0   @ bitWidth 24 (RELOAD value)  
 
    .equ STK_CVR, STK_BASE + 0x8 @ (SysTick current value register) 
        .equ STK_CVR_CURRENT_Shift, 0   @ bitWidth 24 (Current counter value)  
 
    .equ STK_CALIB, STK_BASE + 0xC @ (SysTick calibration value  register) 
        .equ STK_CALIB_TENMS_Shift, 0   @ bitWidth 24 (Calibration value)  
        .equ STK_CALIB_SKEW, 1 << 30   @ bitWidth 1 (SKEW flag: Indicates whether the TENMS  value is exact)  
        .equ STK_CALIB_NOREF, 1 << 31   @ bitWidth 1 (NOREF flag. Reads as zero)  
 

@=========================== NVIC_STIR ===========================@
.equ NVIC_STIR_BASE, 0xE000EF00 @ (Nested vectored interrupt  controller) 
    .equ NVIC_STIR_STIR, NVIC_STIR_BASE + 0x0 @ (Software trigger interrupt  register) 
        .equ NVIC_STIR_STIR_INTID_Shift, 0   @ bitWidth 9 (Software generated interrupt  ID)  
 

@=========================== FPU_CPACR ===========================@
.equ FPU_CPACR_BASE, 0xE000ED88 @ (Floating point unit CPACR) 
    .equ FPU_CPACR_CPACR, FPU_CPACR_BASE + 0x0 @ (Coprocessor access control  register) 
        .equ FPU_CPACR_CPACR_CP_Shift, 20   @ bitWidth 4 (CP)  
 

@=========================== SCB_ACTRL ===========================@
.equ SCB_ACTRL_BASE, 0xE000E008 @ (System control block ACTLR) 
    .equ SCB_ACTRL_ACTRL, SCB_ACTRL_BASE + 0x0 @ (Auxiliary control register) 
        .equ SCB_ACTRL_ACTRL_DISFOLD, 1 << 2   @ bitWidth 1 (DISFOLD)  
        .equ SCB_ACTRL_ACTRL_FPEXCODIS, 1 << 10   @ bitWidth 1 (FPEXCODIS)  
        .equ SCB_ACTRL_ACTRL_DISRAMODE, 1 << 11   @ bitWidth 1 (DISRAMODE)  
        .equ SCB_ACTRL_ACTRL_DISITMATBFLUSH, 1 << 12   @ bitWidth 1 (DISITMATBFLUSH)  
 

@=========================== FPU ===========================@
.equ FPU_BASE, 0xE000EF34 @ (Floting point unit) 
    .equ FPU_FPCCR, FPU_BASE + 0x0 @ (Floating-point context control  register) 
        .equ FPU_FPCCR_LSPACT, 1 << 0   @ bitWidth 1 (LSPACT)  
        .equ FPU_FPCCR_USER, 1 << 1   @ bitWidth 1 (USER)  
        .equ FPU_FPCCR_THREAD, 1 << 3   @ bitWidth 1 (THREAD)  
        .equ FPU_FPCCR_HFRDY, 1 << 4   @ bitWidth 1 (HFRDY)  
        .equ FPU_FPCCR_MMRDY, 1 << 5   @ bitWidth 1 (MMRDY)  
        .equ FPU_FPCCR_BFRDY, 1 << 6   @ bitWidth 1 (BFRDY)  
        .equ FPU_FPCCR_MONRDY, 1 << 8   @ bitWidth 1 (MONRDY)  
        .equ FPU_FPCCR_LSPEN, 1 << 30   @ bitWidth 1 (LSPEN)  
        .equ FPU_FPCCR_ASPEN, 1 << 31   @ bitWidth 1 (ASPEN)  
 
    .equ FPU_FPCAR, FPU_BASE + 0x4 @ (Floating-point context address  register) 
        .equ FPU_FPCAR_ADDRESS_Shift, 3   @ bitWidth 29 (Location of unpopulated  floating-point)  
 
    .equ FPU_FPSCR, FPU_BASE + 0x8 @ (Floating-point status control  register) 
        .equ FPU_FPSCR_IOC, 1 << 0   @ bitWidth 1 (Invalid operation cumulative exception  bit)  
        .equ FPU_FPSCR_DZC, 1 << 1   @ bitWidth 1 (Division by zero cumulative exception  bit.)  
        .equ FPU_FPSCR_OFC, 1 << 2   @ bitWidth 1 (Overflow cumulative exception  bit)  
        .equ FPU_FPSCR_UFC, 1 << 3   @ bitWidth 1 (Underflow cumulative exception  bit)  
        .equ FPU_FPSCR_IXC, 1 << 4   @ bitWidth 1 (Inexact cumulative exception  bit)  
        .equ FPU_FPSCR_IDC, 1 << 7   @ bitWidth 1 (Input denormal cumulative exception  bit.)  
        .equ FPU_FPSCR_RMode_Shift, 22   @ bitWidth 2 (Rounding Mode control  field)  
        .equ FPU_FPSCR_FZ, 1 << 24   @ bitWidth 1 (Flush-to-zero mode control  bit:)  
        .equ FPU_FPSCR_DN, 1 << 25   @ bitWidth 1 (Default NaN mode control  bit)  
        .equ FPU_FPSCR_AHP, 1 << 26   @ bitWidth 1 (Alternative half-precision control  bit)  
        .equ FPU_FPSCR_V, 1 << 28   @ bitWidth 1 (Overflow condition code  flag)  
        .equ FPU_FPSCR_C, 1 << 29   @ bitWidth 1 (Carry condition code flag)  
        .equ FPU_FPSCR_Z, 1 << 30   @ bitWidth 1 (Zero condition code flag)  
        .equ FPU_FPSCR_N, 1 << 31   @ bitWidth 1 (Negative condition code  flag)  
 

@=========================== SCB ===========================@
.equ SCB_BASE, 0xE000ED00 @ (System control block) 
    .equ SCB_CPUID, SCB_BASE + 0x0 @ (CPUID base register) 
        .equ SCB_CPUID_Revision_Shift, 0   @ bitWidth 4 (Revision number)  
        .equ SCB_CPUID_PartNo_Shift, 4   @ bitWidth 12 (Part number of the  processor)  
        .equ SCB_CPUID_Constant_Shift, 16   @ bitWidth 4 (Reads as 0xF)  
        .equ SCB_CPUID_Variant_Shift, 20   @ bitWidth 4 (Variant number)  
        .equ SCB_CPUID_Implementer_Shift, 24   @ bitWidth 8 (Implementer code)  
 
    .equ SCB_ICSR, SCB_BASE + 0x4 @ (Interrupt control and state  register) 
        .equ SCB_ICSR_VECTACTIVE_Shift, 0   @ bitWidth 9 (Active vector)  
        .equ SCB_ICSR_RETTOBASE, 1 << 11   @ bitWidth 1 (Return to base level)  
        .equ SCB_ICSR_VECTPENDING_Shift, 12   @ bitWidth 7 (Pending vector)  
        .equ SCB_ICSR_ISRPENDING, 1 << 22   @ bitWidth 1 (Interrupt pending flag)  
        .equ SCB_ICSR_PENDSTCLR, 1 << 25   @ bitWidth 1 (SysTick exception clear-pending  bit)  
        .equ SCB_ICSR_PENDSTSET, 1 << 26   @ bitWidth 1 (SysTick exception set-pending  bit)  
        .equ SCB_ICSR_PENDSVCLR, 1 << 27   @ bitWidth 1 (PendSV clear-pending bit)  
        .equ SCB_ICSR_PENDSVSET, 1 << 28   @ bitWidth 1 (PendSV set-pending bit)  
        .equ SCB_ICSR_NMIPENDSET, 1 << 31   @ bitWidth 1 (NMI set-pending bit.)  
 
    .equ SCB_VTOR, SCB_BASE + 0x8 @ (Vector table offset register) 
        .equ SCB_VTOR_TBLOFF_Shift, 9   @ bitWidth 21 (Vector table base offset  field)  
 
    .equ SCB_AIRCR, SCB_BASE + 0xC @ (Application interrupt and reset control  register) 
        .equ SCB_AIRCR_VECTRESET, 1 << 0   @ bitWidth 1 (VECTRESET)  
        .equ SCB_AIRCR_VECTCLRACTIVE, 1 << 1   @ bitWidth 1 (VECTCLRACTIVE)  
        .equ SCB_AIRCR_SYSRESETREQ, 1 << 2   @ bitWidth 1 (SYSRESETREQ)  
        .equ SCB_AIRCR_PRIGROUP_Shift, 8   @ bitWidth 3 (PRIGROUP)  
        .equ SCB_AIRCR_ENDIANESS, 1 << 15   @ bitWidth 1 (ENDIANESS)  
        .equ SCB_AIRCR_VECTKEYSTAT_Shift, 16   @ bitWidth 16 (Register key)  
 
    .equ SCB_SCR, SCB_BASE + 0x10 @ (System control register) 
        .equ SCB_SCR_SLEEPONEXIT, 1 << 1   @ bitWidth 1 (SLEEPONEXIT)  
        .equ SCB_SCR_SLEEPDEEP, 1 << 2   @ bitWidth 1 (SLEEPDEEP)  
        .equ SCB_SCR_SEVEONPEND, 1 << 4   @ bitWidth 1 (Send Event on Pending bit)  
 
    .equ SCB_CCR, SCB_BASE + 0x14 @ (Configuration and control  register) 
        .equ SCB_CCR_NONBASETHRDENA, 1 << 0   @ bitWidth 1 (Configures how the processor enters  Thread mode)  
        .equ SCB_CCR_USERSETMPEND, 1 << 1   @ bitWidth 1 (USERSETMPEND)  
        .equ SCB_CCR_UNALIGN__TRP, 1 << 3   @ bitWidth 1 (UNALIGN_ TRP)  
        .equ SCB_CCR_DIV_0_TRP, 1 << 4   @ bitWidth 1 (DIV_0_TRP)  
        .equ SCB_CCR_BFHFNMIGN, 1 << 8   @ bitWidth 1 (BFHFNMIGN)  
        .equ SCB_CCR_STKALIGN, 1 << 9   @ bitWidth 1 (STKALIGN)  
        .equ SCB_CCR_DC, 1 << 16   @ bitWidth 1 (DC)  
        .equ SCB_CCR_IC, 1 << 17   @ bitWidth 1 (IC)  
        .equ SCB_CCR_BP, 1 << 18   @ bitWidth 1 (BP)  
 
    .equ SCB_SHPR1, SCB_BASE + 0x18 @ (System handler priority  registers) 
        .equ SCB_SHPR1_PRI_4_Shift, 0   @ bitWidth 8 (Priority of system handler  4)  
        .equ SCB_SHPR1_PRI_5_Shift, 8   @ bitWidth 8 (Priority of system handler  5)  
        .equ SCB_SHPR1_PRI_6_Shift, 16   @ bitWidth 8 (Priority of system handler  6)  
 
    .equ SCB_SHPR2, SCB_BASE + 0x1C @ (System handler priority  registers) 
        .equ SCB_SHPR2_PRI_11_Shift, 24   @ bitWidth 8 (Priority of system handler  11)  
 
    .equ SCB_SHPR3, SCB_BASE + 0x20 @ (System handler priority  registers) 
        .equ SCB_SHPR3_PRI_14_Shift, 16   @ bitWidth 8 (Priority of system handler  14)  
        .equ SCB_SHPR3_PRI_15_Shift, 24   @ bitWidth 8 (Priority of system handler  15)  
 
    .equ SCB_SHCRS, SCB_BASE + 0x24 @ (System handler control and state  register) 
        .equ SCB_SHCRS_MEMFAULTACT, 1 << 0   @ bitWidth 1 (Memory management fault exception active  bit)  
        .equ SCB_SHCRS_BUSFAULTACT, 1 << 1   @ bitWidth 1 (Bus fault exception active  bit)  
        .equ SCB_SHCRS_USGFAULTACT, 1 << 3   @ bitWidth 1 (Usage fault exception active  bit)  
        .equ SCB_SHCRS_SVCALLACT, 1 << 7   @ bitWidth 1 (SVC call active bit)  
        .equ SCB_SHCRS_MONITORACT, 1 << 8   @ bitWidth 1 (Debug monitor active bit)  
        .equ SCB_SHCRS_PENDSVACT, 1 << 10   @ bitWidth 1 (PendSV exception active  bit)  
        .equ SCB_SHCRS_SYSTICKACT, 1 << 11   @ bitWidth 1 (SysTick exception active  bit)  
        .equ SCB_SHCRS_USGFAULTPENDED, 1 << 12   @ bitWidth 1 (Usage fault exception pending  bit)  
        .equ SCB_SHCRS_MEMFAULTPENDED, 1 << 13   @ bitWidth 1 (Memory management fault exception  pending bit)  
        .equ SCB_SHCRS_BUSFAULTPENDED, 1 << 14   @ bitWidth 1 (Bus fault exception pending  bit)  
        .equ SCB_SHCRS_SVCALLPENDED, 1 << 15   @ bitWidth 1 (SVC call pending bit)  
        .equ SCB_SHCRS_MEMFAULTENA, 1 << 16   @ bitWidth 1 (Memory management fault enable  bit)  
        .equ SCB_SHCRS_BUSFAULTENA, 1 << 17   @ bitWidth 1 (Bus fault enable bit)  
        .equ SCB_SHCRS_USGFAULTENA, 1 << 18   @ bitWidth 1 (Usage fault enable bit)  
 
    .equ SCB_CFSR_UFSR_BFSR_MMFSR, SCB_BASE + 0x28 @ (Configurable fault status  register) 
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL, 1 << 0   @ bitWidth 1 (IACCVIOL)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_DACCVIOL, 1 << 1   @ bitWidth 1 (DACCVIOL)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR, 1 << 3   @ bitWidth 1 (MUNSTKERR)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR, 1 << 4   @ bitWidth 1 (MSTKERR)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR, 1 << 5   @ bitWidth 1 (MLSPERR)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID, 1 << 7   @ bitWidth 1 (MMARVALID)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR, 1 << 8   @ bitWidth 1 (Instruction bus error)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR, 1 << 9   @ bitWidth 1 (Precise data bus error)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR, 1 << 10   @ bitWidth 1 (Imprecise data bus error)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR, 1 << 11   @ bitWidth 1 (Bus fault on unstacking for a return  from exception)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_STKERR, 1 << 12   @ bitWidth 1 (Bus fault on stacking for exception  entry)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR, 1 << 13   @ bitWidth 1 (Bus fault on floating-point lazy state  preservation)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID, 1 << 15   @ bitWidth 1 (Bus Fault Address Register BFAR valid  flag)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR, 1 << 16   @ bitWidth 1 (Undefined instruction usage  fault)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE, 1 << 17   @ bitWidth 1 (Invalid state usage fault)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_INVPC, 1 << 18   @ bitWidth 1 (Invalid PC load usage  fault)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_NOCP, 1 << 19   @ bitWidth 1 (No coprocessor usage  fault.)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED, 1 << 24   @ bitWidth 1 (Unaligned access usage  fault)  
        .equ SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO, 1 << 25   @ bitWidth 1 (Divide by zero usage fault)  
 
    .equ SCB_HFSR, SCB_BASE + 0x2C @ (Hard fault status register) 
        .equ SCB_HFSR_VECTTBL, 1 << 1   @ bitWidth 1 (Vector table hard fault)  
        .equ SCB_HFSR_FORCED, 1 << 30   @ bitWidth 1 (Forced hard fault)  
        .equ SCB_HFSR_DEBUG_VT, 1 << 31   @ bitWidth 1 (Reserved for Debug use)  
 
    .equ SCB_MMFAR, SCB_BASE + 0x34 @ (Memory management fault address  register) 
        .equ SCB_MMFAR_ADDRESS_Shift, 0   @ bitWidth 32 (Memory management fault  address)  
 
    .equ SCB_BFAR, SCB_BASE + 0x38 @ (Bus fault address register) 
        .equ SCB_BFAR_ADDRESS_Shift, 0   @ bitWidth 32 (Bus fault address)  
 

@=========================== PF ===========================@
.equ PF_BASE, 0xE000ED78 @ (Processor features) 
    .equ PF_CLIDR, PF_BASE + 0x0 @ (Cache Level ID register) 
        .equ PF_CLIDR_CL1_Shift, 0   @ bitWidth 3 (CL1)  
        .equ PF_CLIDR_CL2_Shift, 3   @ bitWidth 3 (CL2)  
        .equ PF_CLIDR_CL3_Shift, 6   @ bitWidth 3 (CL3)  
        .equ PF_CLIDR_CL4_Shift, 9   @ bitWidth 3 (CL4)  
        .equ PF_CLIDR_CL5_Shift, 12   @ bitWidth 3 (CL5)  
        .equ PF_CLIDR_CL6_Shift, 15   @ bitWidth 3 (CL6)  
        .equ PF_CLIDR_CL7_Shift, 18   @ bitWidth 3 (CL7)  
        .equ PF_CLIDR_LoUIS_Shift, 21   @ bitWidth 3 (LoUIS)  
        .equ PF_CLIDR_LoC_Shift, 24   @ bitWidth 3 (LoC)  
        .equ PF_CLIDR_LoU_Shift, 27   @ bitWidth 3 (LoU)  
 
    .equ PF_CTR, PF_BASE + 0x4 @ (Cache Type register) 
        .equ PF_CTR__IminLine_Shift, 0   @ bitWidth 4 (IminLine)  
        .equ PF_CTR_DMinLine_Shift, 16   @ bitWidth 4 (DMinLine)  
        .equ PF_CTR_ERG_Shift, 20   @ bitWidth 4 (ERG)  
        .equ PF_CTR_CWG_Shift, 24   @ bitWidth 4 (CWG)  
        .equ PF_CTR_Format_Shift, 29   @ bitWidth 3 (Format)  
 
    .equ PF_CCSIDR, PF_BASE + 0x8 @ (Cache Size ID register) 
        .equ PF_CCSIDR_LineSize_Shift, 0   @ bitWidth 3 (LineSize)  
        .equ PF_CCSIDR_Associativity_Shift, 3   @ bitWidth 10 (Associativity)  
        .equ PF_CCSIDR_NumSets_Shift, 13   @ bitWidth 15 (NumSets)  
        .equ PF_CCSIDR_WA, 1 << 28   @ bitWidth 1 (WA)  
        .equ PF_CCSIDR_RA, 1 << 29   @ bitWidth 1 (RA)  
        .equ PF_CCSIDR_WB, 1 << 30   @ bitWidth 1 (WB)  
        .equ PF_CCSIDR_WT, 1 << 31   @ bitWidth 1 (WT)  
 

@=========================== AC ===========================@
.equ AC_BASE, 0xE000EF90 @ (Access control) 
    .equ AC_ITCMCR, AC_BASE + 0x0 @ (Instruction and Data Tightly-Coupled Memory  Control Registers) 
        .equ AC_ITCMCR_EN, 1 << 0   @ bitWidth 1 (EN)  
        .equ AC_ITCMCR_RMW, 1 << 1   @ bitWidth 1 (RMW)  
        .equ AC_ITCMCR_RETEN, 1 << 2   @ bitWidth 1 (RETEN)  
        .equ AC_ITCMCR_SZ_Shift, 3   @ bitWidth 4 (SZ)  
 
    .equ AC_DTCMCR, AC_BASE + 0x4 @ (Instruction and Data Tightly-Coupled Memory  Control Registers) 
        .equ AC_DTCMCR_EN, 1 << 0   @ bitWidth 1 (EN)  
        .equ AC_DTCMCR_RMW, 1 << 1   @ bitWidth 1 (RMW)  
        .equ AC_DTCMCR_RETEN, 1 << 2   @ bitWidth 1 (RETEN)  
        .equ AC_DTCMCR_SZ_Shift, 3   @ bitWidth 4 (SZ)  
 
    .equ AC_AHBPCR, AC_BASE + 0x8 @ (AHBP Control register) 
        .equ AC_AHBPCR_EN, 1 << 0   @ bitWidth 1 (EN)  
        .equ AC_AHBPCR_SZ_Shift, 1   @ bitWidth 3 (SZ)  
 
    .equ AC_CACR, AC_BASE + 0xC @ (Auxiliary Cache Control  register) 
        .equ AC_CACR_SIWT, 1 << 0   @ bitWidth 1 (SIWT)  
        .equ AC_CACR_ECCEN, 1 << 1   @ bitWidth 1 (ECCEN)  
        .equ AC_CACR_FORCEWT, 1 << 2   @ bitWidth 1 (FORCEWT)  
 
    .equ AC_AHBSCR, AC_BASE + 0x10 @ (AHB Slave Control register) 
        .equ AC_AHBSCR_CTL_Shift, 0   @ bitWidth 2 (CTL)  
        .equ AC_AHBSCR_TPRI_Shift, 2   @ bitWidth 9 (TPRI)  
        .equ AC_AHBSCR_INITCOUNT_Shift, 11   @ bitWidth 5 (INITCOUNT)  
 
    .equ AC_ABFSR, AC_BASE + 0x18 @ (Auxiliary Bus Fault Status  register) 
        .equ AC_ABFSR_ITCM, 1 << 0   @ bitWidth 1 (ITCM)  
        .equ AC_ABFSR_DTCM, 1 << 1   @ bitWidth 1 (DTCM)  
        .equ AC_ABFSR_AHBP, 1 << 2   @ bitWidth 1 (AHBP)  
        .equ AC_ABFSR_AXIM, 1 << 3   @ bitWidth 1 (AXIM)  
        .equ AC_ABFSR_EPPB, 1 << 4   @ bitWidth 1 (EPPB)  
        .equ AC_ABFSR_AXIMTYPE_Shift, 8   @ bitWidth 2 (AXIMTYPE)  
 
